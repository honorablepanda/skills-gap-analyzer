File name: code-backups\code-bundle-6.txt

Code:
File name: node_modules\@babel\parser\package.json

Code:
{
  "name": "@babel/parser",
  "version": "7.27.7",
  "description": "A JavaScript parser",
  "author": "The Babel Team (https://babel.dev/team)",
  "homepage": "https://babel.dev/docs/en/next/babel-parser",
  "bugs": "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A+parser+%28babylon%29%22+is%3Aopen",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "keywords": [
    "babel",
    "javascript",
    "parser",
    "tc39",
    "ecmascript",
    "@babel/parser"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-parser"
  },
  "main": "./lib/index.js",
  "types": "./typings/babel-parser.d.ts",
  "files": [
    "bin",
    "lib",
    "typings/babel-parser.d.ts",
    "index.cjs"
  ],
  "engines": {
    "node": ">=6.0.0"
  },
  "# dependencies": "This package doesn't actually have runtime dependencies. @babel/types is only needed for type definitions.",
  "dependencies": {
    "@babel/types": "^7.27.7"
  },
  "devDependencies": {
    "@babel/code-frame": "^7.27.1",
    "@babel/helper-check-duplicate-nodes": "^7.27.1",
    "@babel/helper-fixtures": "^7.27.1",
    "@babel/helper-string-parser": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1",
    "charcodes": "^0.2.0"
  },
  "bin": "./bin/babel-parser.js",
  "type": "commonjs"
}

---

File name: node_modules\@babel\parser\README.md

Code:
# @babel/parser

> A JavaScript parser

See our website [@babel/parser](https://babeljs.io/docs/babel-parser) for more information or the [issues](https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20parser%22+is%3Aopen) associated with this package.

## Install

Using npm:

```sh
npm install --save-dev @babel/parser
```

or using yarn:

```sh
yarn add @babel/parser --dev
```


---

File name: node_modules\@babel\parser\typings\babel-parser.d.ts

Code:
// This file is auto-generated! Do not modify it directly.
// Run `yarn gulp bundle-dts` to re-generate it.
/* eslint-disable @typescript-eslint/consistent-type-imports, @typescript-eslint/no-redundant-type-constituents */
import { File, Expression } from '@babel/types';

type BABEL_8_BREAKING = false;
type IF_BABEL_7<V> = false extends BABEL_8_BREAKING ? V : never;

type Plugin$1 =
  | "asyncDoExpressions"
  | IF_BABEL_7<"asyncGenerators">
  | IF_BABEL_7<"bigInt">
  | IF_BABEL_7<"classPrivateMethods">
  | IF_BABEL_7<"classPrivateProperties">
  | IF_BABEL_7<"classProperties">
  | IF_BABEL_7<"classStaticBlock">
  | IF_BABEL_7<"decimal">
  | "decorators-legacy"
  | "deferredImportEvaluation"
  | "decoratorAutoAccessors"
  | "destructuringPrivate"
  | "deprecatedImportAssert"
  | "doExpressions"
  | IF_BABEL_7<"dynamicImport">
  | "explicitResourceManagement"
  | "exportDefaultFrom"
  | IF_BABEL_7<"exportNamespaceFrom">
  | "flow"
  | "flowComments"
  | "functionBind"
  | "functionSent"
  | "importMeta"
  | "jsx"
  | IF_BABEL_7<"jsonStrings">
  | IF_BABEL_7<"logicalAssignment">
  | IF_BABEL_7<"importAssertions">
  | IF_BABEL_7<"importReflection">
  | "moduleBlocks"
  | IF_BABEL_7<"moduleStringNames">
  | IF_BABEL_7<"nullishCoalescingOperator">
  | IF_BABEL_7<"numericSeparator">
  | IF_BABEL_7<"objectRestSpread">
  | IF_BABEL_7<"optionalCatchBinding">
  | IF_BABEL_7<"optionalChaining">
  | "partialApplication"
  | "placeholders"
  | IF_BABEL_7<"privateIn">
  | IF_BABEL_7<"regexpUnicodeSets">
  | "sourcePhaseImports"
  | "throwExpressions"
  | IF_BABEL_7<"topLevelAwait">
  | "v8intrinsic"
  | ParserPluginWithOptions[0];

type ParserPluginWithOptions =
  | ["decorators", DecoratorsPluginOptions]
  | ["estree", { classFeatures?: boolean }]
  | IF_BABEL_7<["importAttributes", { deprecatedAssertSyntax: boolean }]>
  | IF_BABEL_7<["moduleAttributes", { version: "may-2020" }]>
  | ["optionalChainingAssign", { version: "2023-07" }]
  | ["pipelineOperator", PipelineOperatorPluginOptions]
  | ["recordAndTuple", RecordAndTuplePluginOptions]
  | ["flow", FlowPluginOptions]
  | ["typescript", TypeScriptPluginOptions];

type PluginConfig = Plugin$1 | ParserPluginWithOptions;

interface DecoratorsPluginOptions {
  decoratorsBeforeExport?: boolean;
  allowCallParenthesized?: boolean;
}

interface PipelineOperatorPluginOptions {
  proposal: BABEL_8_BREAKING extends false
    ? "minimal" | "fsharp" | "hack" | "smart"
    : "fsharp" | "hack";
  topicToken?: "%" | "#" | "@@" | "^^" | "^";
}

interface RecordAndTuplePluginOptions {
  syntaxType: "bar" | "hash";
}

type FlowPluginOptions = BABEL_8_BREAKING extends true
  ? {
      all?: boolean;
      enums?: boolean;
    }
  : {
      all?: boolean;
    };

interface TypeScriptPluginOptions {
  dts?: boolean;
  disallowAmbiguousJSXLike?: boolean;
}

type Plugin = PluginConfig;

interface Options {
    /**
     * By default, import and export declarations can only appear at a program's top level.
     * Setting this option to true allows them anywhere where a statement is allowed.
     */
    allowImportExportEverywhere?: boolean;
    /**
     * By default, await use is not allowed outside of an async function.
     * Set this to true to accept such code.
     */
    allowAwaitOutsideFunction?: boolean;
    /**
     * By default, a return statement at the top level raises an error.
     * Set this to true to accept such code.
     */
    allowReturnOutsideFunction?: boolean;
    /**
     * By default, new.target use is not allowed outside of a function or class.
     * Set this to true to accept such code.
     */
    allowNewTargetOutsideFunction?: boolean;
    allowSuperOutsideMethod?: boolean;
    /**
     * By default, exported identifiers must refer to a declared variable.
     * Set this to true to allow export statements to reference undeclared variables.
     */
    allowUndeclaredExports?: boolean;
    /**
     * By default, yield use is not allowed outside of a generator function.
     * Set this to true to accept such code.
     */
    allowYieldOutsideFunction?: boolean;
    /**
     * By default, Babel parser JavaScript code according to Annex B syntax.
     * Set this to `false` to disable such behavior.
     */
    annexB?: boolean;
    /**
     * By default, Babel attaches comments to adjacent AST nodes.
     * When this option is set to false, comments are not attached.
     * It can provide up to 30% performance improvement when the input code has many comments.
     * @babel/eslint-parser will set it for you.
     * It is not recommended to use attachComment: false with Babel transform,
     * as doing so removes all the comments in output code, and renders annotations such as
     * /* istanbul ignore next *\/ nonfunctional.
     */
    attachComment?: boolean;
    /**
     * By default, Babel always throws an error when it finds some invalid code.
     * When this option is set to true, it will store the parsing error and
     * try to continue parsing the invalid input file.
     */
    errorRecovery?: boolean;
    /**
     * Indicate the mode the code should be parsed in.
     * Can be one of "script", "module", or "unambiguous". Defaults to "script".
     * "unambiguous" will make @babel/parser attempt to guess, based on the presence
     * of ES6 import or export statements.
     * Files with ES6 imports and exports are considered "module" and are otherwise "script".
     */
    sourceType?: "script" | "module" | "unambiguous";
    /**
     * Correlate output AST nodes with their source filename.
     * Useful when generating code and source maps from the ASTs of multiple input files.
     */
    sourceFilename?: string;
    /**
     * By default, all source indexes start from 0.
     * You can provide a start index to alternatively start with.
     * Useful for integration with other source tools.
     */
    startIndex?: number;
    /**
     * By default, the first line of code parsed is treated as line 1.
     * You can provide a line number to alternatively start with.
     * Useful for integration with other source tools.
     */
    startLine?: number;
    /**
     * By default, the parsed code is treated as if it starts from line 1, column 0.
     * You can provide a column number to alternatively start with.
     * Useful for integration with other source tools.
     */
    startColumn?: number;
    /**
     * Array containing the plugins that you want to enable.
     */
    plugins?: Plugin[];
    /**
     * Should the parser work in strict mode.
     * Defaults to true if sourceType === 'module'. Otherwise, false.
     */
    strictMode?: boolean;
    /**
     * Adds a ranges property to each node: [node.start, node.end]
     */
    ranges?: boolean;
    /**
     * Adds all parsed tokens to a tokens property on the File node.
     */
    tokens?: boolean;
    /**
     * By default, the parser adds information about parentheses by setting
     * `extra.parenthesized` to `true` as needed.
     * When this option is `true` the parser creates `ParenthesizedExpression`
     * AST nodes instead of using the `extra` property.
     */
    createParenthesizedExpressions?: boolean;
    /**
     * The default is false in Babel 7 and true in Babel 8
     * Set this to true to parse it as an `ImportExpression` node.
     * Otherwise `import(foo)` is parsed as `CallExpression(Import, [Identifier(foo)])`.
     */
    createImportExpressions?: boolean;
}

type ParserOptions = Partial<Options>;
interface ParseError {
    code: string;
    reasonCode: string;
}
type ParseResult<Result extends File | Expression = File> = Result & {
    errors: null | ParseError[];
};
/**
 * Parse the provided code as an entire ECMAScript program.
 */
declare function parse(input: string, options?: ParserOptions): ParseResult<File>;
declare function parseExpression(input: string, options?: ParserOptions): ParseResult<Expression>;

declare const tokTypes: {
  // todo(flow->ts) real token type
  [name: string]: any;
};

export { DecoratorsPluginOptions, FlowPluginOptions, ParseError, ParseResult, ParserOptions, PluginConfig as ParserPlugin, ParserPluginWithOptions, PipelineOperatorPluginOptions, RecordAndTuplePluginOptions, TypeScriptPluginOptions, parse, parseExpression, tokTypes };


---

File name: node_modules\@babel\plugin-bugfix-firefox-class-in-computed-class-key\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _traverse = require("@babel/traverse");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(({
  types: t,
  assertVersion
}) => {
  assertVersion(7);
  const containsClassExpressionVisitor = {
    ClassExpression(path, state) {
      state.found = true;
      path.stop();
    },
    Function(path) {
      path.skip();
    }
  };
  const containsYieldOrAwaitVisitor = _traverse.visitors.environmentVisitor({
    YieldExpression(path, state) {
      state.yield = true;
      if (state.await) path.stop();
    },
    AwaitExpression(path, state) {
      state.await = true;
      if (state.yield) path.stop();
    }
  });
  function containsClassExpression(path) {
    if (t.isClassExpression(path.node)) return true;
    if (t.isFunction(path.node)) return false;
    const state = {
      found: false
    };
    path.traverse(containsClassExpressionVisitor, state);
    return state.found;
  }
  function wrap(path) {
    const context = {
      yield: t.isYieldExpression(path.node),
      await: t.isAwaitExpression(path.node)
    };
    path.traverse(containsYieldOrAwaitVisitor, context);
    let replacement;
    if (context.yield) {
      const fn = t.functionExpression(null, [], t.blockStatement([t.returnStatement(path.node)]), true, context.await);
      replacement = t.yieldExpression(t.callExpression(t.memberExpression(fn, t.identifier("call")), [t.thisExpression(), t.identifier("arguments")]), true);
    } else {
      const fn = t.arrowFunctionExpression([], path.node, context.await);
      replacement = t.callExpression(fn, []);
      if (context.await) replacement = t.awaitExpression(replacement);
    }
    path.replaceWith(replacement);
  }
  return {
    name: "bugfix-firefox-class-in-computed-class-key",
    visitor: {
      Class(path) {
        const hasPrivateElement = path.node.body.body.some(node => t.isPrivate(node));
        if (!hasPrivateElement) return;
        for (const elem of path.get("body.body")) {
          if ("computed" in elem.node && elem.node.computed && containsClassExpression(elem.get("key"))) {
            wrap(elem.get("key"));
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-bugfix-firefox-class-in-computed-class-key\package.json

Code:
{
  "name": "@babel/plugin-bugfix-firefox-class-in-computed-class-key",
  "version": "7.27.1",
  "description": "Wraps classes defined in computed keys of other classes affected by https://bugzilla.mozilla.org/show_bug.cgi?id=1887677",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-firefox-class-in-computed-class-key"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-firefox-class-in-computed-class-key",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-bugfix-firefox-class-in-computed-class-key\README.md

Code:
# @babel/plugin-bugfix-firefox-class-in-computed-class-key

> Wraps classes defined in computed keys of other classes affected by https://bugzilla.mozilla.org/show_bug.cgi?id=1887677

See our website [@babel/plugin-bugfix-firefox-class-in-computed-class-key](https://babeljs.io/docs/babel-plugin-bugfix-firefox-class-in-computed-class-key) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-bugfix-firefox-class-in-computed-class-key
```

or using yarn:

```sh
yarn add @babel/plugin-bugfix-firefox-class-in-computed-class-key --dev
```


---

File name: node_modules\@babel\plugin-bugfix-safari-class-field-initializer-scope\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');
var core = require('@babel/core');

function needsWrapping(node) {
  if (core.types.isLiteral(node) && !core.types.isTemplateLiteral(node)) {
    return false;
  }
  if (core.types.isCallExpression(node) || core.types.isOptionalCallExpression(node) || core.types.isNewExpression(node)) {
    return needsWrapping(node.callee) || node.arguments.some(needsWrapping);
  }
  if (core.types.isTemplateLiteral(node)) {
    return node.expressions.some(needsWrapping);
  }
  if (core.types.isTaggedTemplateExpression(node)) {
    return needsWrapping(node.tag) || needsWrapping(node.quasi);
  }
  if (core.types.isArrayExpression(node)) {
    return node.elements.some(needsWrapping);
  }
  if (core.types.isObjectExpression(node)) {
    return node.properties.some(prop => {
      if (core.types.isObjectProperty(prop)) {
        return needsWrapping(prop.value) || prop.computed && needsWrapping(prop.key);
      }
      if (core.types.isObjectMethod(prop)) {
        return false;
      }
      return false;
    });
  }
  if (core.types.isMemberExpression(node) || core.types.isOptionalMemberExpression(node)) {
    return needsWrapping(node.object) || node.computed && needsWrapping(node.property);
  }
  if (core.types.isFunctionExpression(node) || core.types.isArrowFunctionExpression(node) || core.types.isClassExpression(node)) {
    return false;
  }
  if (core.types.isThisExpression(node)) {
    return false;
  }
  if (core.types.isSequenceExpression(node)) {
    return node.expressions.some(needsWrapping);
  }
  return true;
}
function wrapInitializer(path) {
  const {
    value
  } = path.node;
  if (value && needsWrapping(value)) {
    path.node.value = core.types.callExpression(core.types.arrowFunctionExpression([], value), []);
  }
}
var index = helperPluginUtils.declare(api => {
  api.assertVersion("^7.16.0");
  return {
    name: "plugin-bugfix-safari-class-field-initializer-scope",
    visitor: {
      ClassProperty(path) {
        wrapInitializer(path);
      },
      ClassPrivateProperty(path) {
        wrapInitializer(path);
      }
    }
  };
});

exports.default = index;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-bugfix-safari-class-field-initializer-scope\package.json

Code:
{
  "name": "@babel/plugin-bugfix-safari-class-field-initializer-scope",
  "version": "7.27.1",
  "description": "Wrap class field initializers with IIFE to workaround https://webkit.org/b/236843",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-safari-class-field-initializer-scope"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-safari-class-field-initializer-scope",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-bugfix-safari-class-field-initializer-scope\README.md

Code:
# @babel/plugin-bugfix-safari-class-field-initializer-scope

> Wrap class field initializers with IIFE to workaround https://webkit.org/b/236843

See our website [@babel/plugin-bugfix-safari-class-field-initializer-scope](https://babeljs.io/docs/babel-plugin-bugfix-safari-class-field-initializer-scope) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-bugfix-safari-class-field-initializer-scope
```

or using yarn:

```sh
yarn add @babel/plugin-bugfix-safari-class-field-initializer-scope --dev
```


---

File name: node_modules\@babel\plugin-bugfix-safari-id-destructuring-collision-in-function-expression\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');

function shouldTransform(path) {
  const {
    node
  } = path;
  const functionId = node.id;
  if (!functionId) return false;
  const name = functionId.name;
  const paramNameBinding = path.scope.getOwnBinding(name);
  if (paramNameBinding === undefined) {
    return false;
  }
  if (paramNameBinding.kind !== "param") {
    return false;
  }
  if (paramNameBinding.identifier === paramNameBinding.path.node) {
    return false;
  }
  return name;
}

var index = helperPluginUtils.declare(api => {
  api.assertVersion("^7.16.0");
  return {
    name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
    visitor: {
      FunctionExpression(path) {
        const name = shouldTransform(path);
        if (name) {
          const {
            scope
          } = path;
          const newParamName = scope.generateUid(name);
          scope.rename(name, newParamName);
        }
      }
    }
  };
});

exports.default = index;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-bugfix-safari-id-destructuring-collision-in-function-expression\package.json

Code:
{
  "name": "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
  "version": "7.27.1",
  "description": "Rename destructuring parameter to workaround https://bugs.webkit.org/show_bug.cgi?id=220517",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-safari-id-destructuring-collision-in-function-expression"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-bugfix-safari-id-destructuring-collision-in-function-expression\README.md

Code:
# @babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression

> Rename destructuring parameter to workaround https://bugs.webkit.org/show_bug.cgi?id=220517

See our website [@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression](https://babeljs.io/docs/babel-plugin-bugfix-safari-id-destructuring-collision-in-function-expression) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression
```

or using yarn:

```sh
yarn add @babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression --dev
```


---

File name: node_modules\@babel\plugin-bugfix-v8-spread-parameters-in-optional-chaining\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');
var pluginTransformOptionalChaining = require('@babel/plugin-transform-optional-chaining');
var helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');
var core = require('@babel/core');

function matchAffectedArguments(argumentNodes) {
  const spreadIndex = argumentNodes.findIndex(node => core.types.isSpreadElement(node));
  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
}
function shouldTransform(path) {
  let optionalPath = path;
  const chains = [];
  for (;;) {
    if (optionalPath.isOptionalMemberExpression()) {
      chains.push(optionalPath.node);
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
    } else if (optionalPath.isOptionalCallExpression()) {
      chains.push(optionalPath.node);
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
    } else {
      break;
    }
  }
  for (let i = 0; i < chains.length; i++) {
    const node = chains[i];
    if (core.types.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {
      if (node.optional) {
        return true;
      }
      const callee = chains[i + 1];
      if (core.types.isOptionalMemberExpression(callee, {
        optional: true
      })) {
        return true;
      }
    }
  }
  return false;
}

var index = helperPluginUtils.declare(api => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : false;
  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : false;
  return {
    name: "bugfix-v8-spread-parameters-in-optional-chaining",
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        if (shouldTransform(path)) {
          pluginTransformOptionalChaining.transform(path, {
            noDocumentAll,
            pureGetters
          });
        }
      }
    }
  };
});

exports.default = index;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-bugfix-v8-spread-parameters-in-optional-chaining\package.json

Code:
{
  "name": "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining",
  "version": "7.27.1",
  "description": "Transform optional chaining operators to workaround https://crbug.com/v8/11558",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-v8-spread-parameters-in-optional-chaining"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-v8-spread-parameters-in-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1",
    "@babel/plugin-transform-optional-chaining": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.13.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-bugfix-v8-spread-parameters-in-optional-chaining\README.md

Code:
# @babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining

> Transform optional chaining operators to workaround https://crbug.com/v8/11558

See our website [@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining](https://babeljs.io/docs/babel-plugin-bugfix-v8-spread-parameters-in-optional-chaining) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining
```

or using yarn:

```sh
yarn add @babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining --dev
```


---

File name: node_modules\@babel\plugin-bugfix-v8-static-class-fields-redefine-readonly\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@babel/core');
var helperPluginUtils = require('@babel/helper-plugin-utils');

function isNameOrLength(key) {
  if (core.types.isIdentifier(key)) {
    return key.name === "name" || key.name === "length";
  }
  if (core.types.isStringLiteral(key)) {
    return key.value === "name" || key.value === "length";
  }
  return false;
}
function isStaticFieldWithValue(node) {
  return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;
}
const hasReferenceVisitor = {
  ReferencedIdentifier(path, state) {
    if (path.node.name === state.name) {
      state.ref();
      path.stop();
    }
  },
  Scope(path, {
    name
  }) {
    if (path.scope.hasOwnBinding(name)) {
      path.skip();
    }
  }
};
function isReferenceOrThis(node, name) {
  return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {
    name
  });
}
const hasReferenceOrThisVisitor = {
  "ThisExpression|ReferencedIdentifier"(path, state) {
    if (isReferenceOrThis(path.node, state.name)) {
      state.ref();
      path.stop();
    }
  },
  FunctionParent(path, state) {
    if (path.isArrowFunctionExpression()) return;
    if (state.name && !path.scope.hasOwnBinding(state.name)) {
      path.traverse(hasReferenceVisitor, state);
    }
    path.skip();
    if (path.isMethod()) {
      if (path.requeueComputedKeyAndDecorators) {
        path.requeueComputedKeyAndDecorators();
      } else {
        require("@babel/traverse").NodePath.prototype.requeueComputedKeyAndDecorators.call(path);
      }
    }
  }
};
function getPotentiallyBuggyFieldsIndexes(path) {
  var _path$node$id;
  const buggyPublicStaticFieldsIndexes = [];
  let classReferenced = false;
  const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
  const hasReferenceState = {
    name: className,
    ref: () => classReferenced = true
  };
  if (className) {
    for (const el of path.get("body.body")) {
      if (el.node.computed) {
        el.get("key").traverse(hasReferenceVisitor, hasReferenceState);
        if (classReferenced) break;
      }
    }
  }
  let nextPotentiallyBuggy = false;
  const {
    body
  } = path.node.body;
  for (let i = 0; i < body.length; i++) {
    const node = body[i];
    if (!nextPotentiallyBuggy) {
      if (core.types.isStaticBlock(node)) {
        classReferenced = true;
        nextPotentiallyBuggy = true;
      } else if (isStaticFieldWithValue(node)) {
        if (!classReferenced) {
          if (isReferenceOrThis(node.value, className)) {
            classReferenced = true;
          } else {
            path.get(`body.body.${i}.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);
          }
        }
        if (classReferenced) {
          nextPotentiallyBuggy = !path.scope.isPure(node.value);
        }
      }
    }
    if (core.types.isClassProperty(node, {
      static: true
    }) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {
      buggyPublicStaticFieldsIndexes.push(i);
    }
  }
  return buggyPublicStaticFieldsIndexes;
}
function getNameOrLengthStaticFieldsIndexes(path) {
  const indexes = [];
  const {
    body
  } = path.node.body;
  for (let i = 0; i < body.length; i++) {
    const node = body[i];
    if (core.types.isClassProperty(node, {
      static: true,
      computed: false
    }) && isNameOrLength(node.key)) {
      indexes.push(i);
    }
  }
  return indexes;
}
function toRanges(nums) {
  const ranges = [];
  if (nums.length === 0) return ranges;
  let start = nums[0];
  let end = start + 1;
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] <= nums[i - 1]) {
      throw new Error("Internal Babel error: nums must be in ascending order");
    }
    if (nums[i] === end) {
      end++;
    } else {
      ranges.push([start, end]);
      start = nums[i];
      end = start + 1;
    }
  }
  ranges.push([start, end]);
  return ranges;
}

function buildFieldsReplacement(fields, scope, file) {
  return core.types.staticBlock(fields.map(field => {
    const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);
    return core.types.expressionStatement(core.types.callExpression(file.addHelper("defineProperty"), [core.types.thisExpression(), key, field.value || scope.buildUndefinedNode()]));
  }));
}
var index = helperPluginUtils.declare(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const setPublicClassFields = api.assumption("setPublicClassFields");
  return {
    name: "bugfix-v8-static-class-fields-redefine-readonly",
    visitor: {
      Class(path) {
        const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));
        for (let i = ranges.length - 1; i >= 0; i--) {
          const [start, end] = ranges[i];
          const startPath = path.get("body.body")[start];
          startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));
          for (let j = end - 1; j > start; j--) {
            path.get("body.body")[j].remove();
          }
        }
      }
    }
  };
});

exports.default = index;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-bugfix-v8-static-class-fields-redefine-readonly\package.json

Code:
{
  "name": "@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly",
  "version": "7.27.1",
  "description": "Transform static class fields assignments that are affected by https://crbug.com/v8/12421",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-bugfix-v8-static-class-fields-redefine-readonly"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-bugfix-v8-static-class-fields-redefine-readonly",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin",
    "bugfix"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-bugfix-v8-static-class-fields-redefine-readonly\README.md

Code:
# @babel/plugin-bugfix-v8-static-class-fields-redefine-readonly

> Transform static class fields assignments that are affected by https://crbug.com/v8/12421

See our website [@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly](https://babeljs.io/docs/babel-plugin-bugfix-v8-static-class-fields-redefine-readonly) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-bugfix-v8-static-class-fields-redefine-readonly
```

or using yarn:

```sh
yarn add @babel/plugin-bugfix-v8-static-class-fields-redefine-readonly --dev
```


---

File name: node_modules\@babel\plugin-proposal-private-property-in-object\lib\index.js

Code:
maybeWarn: try {
  var stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  var stack = new Error().stack;
  Error.stackTraceLimit = stackTraceLimit;
  if (!stack.includes("babel-preset-react-app")) break maybeWarn;

  // Try this as a fallback, in case it's available in node_modules
  module.exports = require("@babel/plugin-transform-private-property-in-object");

  setTimeout(console.warn, 2500, `\
\x1B[0;33mOne of your dependencies, babel-preset-react-app, is importing the
"@babel/plugin-proposal-private-property-in-object" package without
declaring it in its dependencies. This is currently working because
"@babel/plugin-proposal-private-property-in-object" is already in your
node_modules folder for unrelated reasons, but it \x1B[1mmay break at any time\x1B[0;33m.

babel-preset-react-app is part of the create-react-app project, \x1B[1mwhich
is not maintianed anymore\x1B[0;33m. It is thus unlikely that this bug will
ever be fixed. Add "@babel/plugin-proposal-private-property-in-object" to
your devDependencies to work around this error. This will make this message
go away.\x1B[0m
  `);

  return;
} catch (e) {}

throw new Error(`\
--- PLACEHOLDER PACKAGE ---
This @babel/plugin-proposal-private-property-in-object version is not meant to
be imported. Something is importing
@babel/plugin-proposal-private-property-in-object without declaring it in its
dependencies (or devDependencies) in the package.json file.
Add "@babel/plugin-proposal-private-property-in-object" to your devDependencies
to work around this error. This will make this message go away.
`);


---

File name: node_modules\@babel\plugin-proposal-private-property-in-object\package.json

Code:
{
  "name": "@babel/plugin-proposal-private-property-in-object",
  "version": "7.21.0-placeholder-for-preset-env.2",
  "description": "This plugin transforms checks for a private property in an object",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel-plugin-proposal-private-property-in-object.git"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-proposal-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {},
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}


---

File name: node_modules\@babel\plugin-proposal-private-property-in-object\README.md

Code:
# @babel/plugin-proposal-private-property-in-object

> ⚠️ This version of the package (`v7.21.0-placeholder-for-preset-env.1`) is not meant to
> be imported. Use any other version of this plugin or, even better, the
> [@babel/plugin-transform-private-property-in-object](https://babeljs.io/docs/en/babel-plugin-transform-private-property-in-object) package.

> This plugin transforms checks for a private property in an object

See our website [@babel/plugin-proposal-private-property-in-object](https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-proposal-private-property-in-object
```

or using yarn:

```sh
yarn add @babel/plugin-proposal-private-property-in-object --dev
```


---

File name: node_modules\@babel\plugin-syntax-async-generators\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-async-generators",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("asyncGenerators");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-async-generators\package.json

Code:
{
  "name": "@babel/plugin-syntax-async-generators",
  "version": "7.8.4",
  "description": "Allow parsing of async generator functions",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-async-generators",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-async-generators\README.md

Code:
# @babel/plugin-syntax-async-generators

> Allow parsing of async generator functions

See our website [@babel/plugin-syntax-async-generators](https://babeljs.io/docs/en/next/babel-plugin-syntax-async-generators.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-async-generators
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-async-generators --dev
```


---

File name: node_modules\@babel\plugin-syntax-bigint\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-bigint",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("bigInt");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-bigint\package.json

Code:
{
  "name": "@babel/plugin-syntax-bigint",
  "version": "7.8.3",
  "description": "Allow parsing of BigInt literals",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-bigint",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-bigint\README.md

Code:
# @babel/plugin-syntax-bigint

> Allow parsing of BigInt literals

See our website [@babel/plugin-syntax-bigint](https://babeljs.io/docs/en/next/babel-plugin-syntax-bigint.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-bigint
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-bigint --dev
```


---

File name: node_modules\@babel\plugin-syntax-class-properties\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-class-properties",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-class-properties\package.json

Code:
{
  "name": "@babel/plugin-syntax-class-properties",
  "version": "7.12.13",
  "description": "Allow parsing of class properties",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-class-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-class-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.12.13"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "7.12.13"
  }
}

---

File name: node_modules\@babel\plugin-syntax-class-properties\README.md

Code:
# @babel/plugin-syntax-class-properties

> Allow parsing of class properties

See our website [@babel/plugin-syntax-class-properties](https://babeljs.io/docs/en/babel-plugin-syntax-class-properties) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-class-properties
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-class-properties --dev
```


---

File name: node_modules\@babel\plugin-syntax-class-static-block\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-class-static-block",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classStaticBlock");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-class-static-block\package.json

Code:
{
  "name": "@babel/plugin-syntax-class-static-block",
  "version": "7.14.5",
  "description": "Allow parsing of class static blocks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-class-static-block"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-class-static-block",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

---

File name: node_modules\@babel\plugin-syntax-class-static-block\README.md

Code:
# @babel/plugin-syntax-class-static-block

> Allow parsing of class static blocks

See our website [@babel/plugin-syntax-class-static-block](https://babeljs.io/docs/en/babel-plugin-syntax-class-static-block) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-class-static-block
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-class-static-block --dev
```


---

File name: node_modules\@babel\plugin-syntax-import-assertions\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const isPlugin = (plugin, name) => name === "plugin" || Array.isArray(plugin) && plugin[0] === "plugin";
  const options = plugin => Array.isArray(plugin) && plugin.length > 1 ? plugin[1] : {};
  return {
    name: "syntax-import-assertions",
    manipulateOptions(opts, {
      plugins
    }) {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (isPlugin(plugin, "deprecatedImportAssert")) return;
        if (isPlugin(plugin, "importAttributes")) {
          plugins.splice(i, 1, "deprecatedImportAssert", ["importAttributes", Object.assign({}, options(plugin), {
            deprecatedAssertSyntax: true
          })]);
          return;
        }
      }
      plugins.push("importAssertions");
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-syntax-import-assertions\package.json

Code:
{
  "name": "@babel/plugin-syntax-import-assertions",
  "version": "7.27.1",
  "description": "Allow parsing of the module assertion attributes in the import statement",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-assertions"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-syntax-import-assertions\README.md

Code:
# @babel/plugin-syntax-import-assertions

> Allow parsing of the module assertion attributes in the import statement

See our website [@babel/plugin-syntax-import-assertions](https://babeljs.io/docs/babel-plugin-syntax-import-assertions) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-import-assertions
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-import-assertions --dev
```


---

File name: node_modules\@babel\plugin-syntax-import-attributes\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, {
  deprecatedAssertSyntax
}) => {
  api.assertVersion("^7.22.0 || >8.0.0-alpha <8.0.0-beta");
  if (deprecatedAssertSyntax != null && typeof deprecatedAssertSyntax !== "boolean") {
    throw new Error("'deprecatedAssertSyntax' must be a boolean, if specified.");
  }
  return {
    name: "syntax-import-attributes",
    manipulateOptions({
      parserOpts,
      generatorOpts
    }) {
      var _generatorOpts$import;
      (_generatorOpts$import = generatorOpts.importAttributesKeyword) != null ? _generatorOpts$import : generatorOpts.importAttributesKeyword = "with";
      const importAssertionsPluginIndex = parserOpts.plugins.indexOf("importAssertions");
      if (importAssertionsPluginIndex !== -1) {
        parserOpts.plugins.splice(importAssertionsPluginIndex, 1);
        deprecatedAssertSyntax = true;
      }
      if (deprecatedAssertSyntax) {
        parserOpts.plugins.push("deprecatedImportAssert", ["importAttributes", {
          deprecatedAssertSyntax: true
        }]);
      } else {
        parserOpts.plugins.push("importAttributes");
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-syntax-import-attributes\package.json

Code:
{
  "name": "@babel/plugin-syntax-import-attributes",
  "version": "7.27.1",
  "description": "Allow parsing of the module attributes in the import statement",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-attributes"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-syntax-import-attributes\README.md

Code:
# @babel/plugin-syntax-import-attributes

> Allow parsing of the module attributes in the import statement

See our website [@babel/plugin-syntax-import-attributes](https://babeljs.io/docs/babel-plugin-syntax-import-attributes) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-import-attributes
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-import-attributes --dev
```


---

File name: node_modules\@babel\plugin-syntax-import-meta\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-import-meta",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("importMeta");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-import-meta\package.json

Code:
{
  "name": "@babel/plugin-syntax-import-meta",
  "version": "7.10.4",
  "description": "Allow parsing of import.meta",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-import-meta"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}


---

File name: node_modules\@babel\plugin-syntax-import-meta\README.md

Code:
# @babel/plugin-syntax-import-meta

> Allow parsing of import.meta

See our website [@babel/plugin-syntax-import-meta](https://babeljs.io/docs/en/next/babel-plugin-syntax-import-meta.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-import-meta
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-import-meta --dev
```


---

File name: node_modules\@babel\plugin-syntax-json-strings\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-json-strings",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsonStrings");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-json-strings\package.json

Code:
{
  "name": "@babel/plugin-syntax-json-strings",
  "version": "7.8.3",
  "description": "Allow parsing of the U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-json-strings",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-json-strings\README.md

Code:
# @babel/plugin-syntax-json-strings

> Allow parsing of the U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings

See our website [@babel/plugin-syntax-json-strings](https://babeljs.io/docs/en/next/babel-plugin-syntax-json-strings.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-json-strings
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-json-strings --dev
```


---

File name: node_modules\@babel\plugin-syntax-jsx\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-jsx",
    manipulateOptions(opts, parserOpts) {
      {
        if (parserOpts.plugins.some(p => (Array.isArray(p) ? p[0] : p) === "typescript")) {
          return;
        }
      }
      parserOpts.plugins.push("jsx");
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-syntax-jsx\package.json

Code:
{
  "name": "@babel/plugin-syntax-jsx",
  "version": "7.27.1",
  "description": "Allow parsing of jsx",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-jsx"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-jsx",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-syntax-jsx\README.md

Code:
# @babel/plugin-syntax-jsx

> Allow parsing of jsx

See our website [@babel/plugin-syntax-jsx](https://babeljs.io/docs/babel-plugin-syntax-jsx) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-jsx
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-jsx --dev
```


---

File name: node_modules\@babel\plugin-syntax-logical-assignment-operators\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-logical-assignment-operators",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("logicalAssignment");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-logical-assignment-operators\package.json

Code:
{
  "name": "@babel/plugin-syntax-logical-assignment-operators",
  "version": "7.10.4",
  "description": "Allow parsing of the logical assignment operators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-logical-assignment-operators"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}


---

File name: node_modules\@babel\plugin-syntax-logical-assignment-operators\README.md

Code:
# @babel/plugin-syntax-logical-assignment-operators

> Allow parsing of the logical assignment operators

See our website [@babel/plugin-syntax-logical-assignment-operators](https://babeljs.io/docs/en/next/babel-plugin-syntax-logical-assignment-operators.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-logical-assignment-operators
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-logical-assignment-operators --dev
```


---

File name: node_modules\@babel\plugin-syntax-nullish-coalescing-operator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-nullish-coalescing-operator",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("nullishCoalescingOperator");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-nullish-coalescing-operator\package.json

Code:
{
  "name": "@babel/plugin-syntax-nullish-coalescing-operator",
  "version": "7.8.3",
  "description": "Allow parsing of the nullish-coalescing operator",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-nullish-coalescing-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-nullish-coalescing-operator\README.md

Code:
# @babel/plugin-syntax-nullish-coalescing-operator

> Allow parsing of the nullish-coalescing operator

See our website [@babel/plugin-syntax-nullish-coalescing-operator](https://babeljs.io/docs/en/next/babel-plugin-syntax-nullish-coalescing-operator.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-nullish-coalescing-operator
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-nullish-coalescing-operator --dev
```


---

File name: node_modules\@babel\plugin-syntax-numeric-separator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-numeric-separator",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("numericSeparator");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-numeric-separator\package.json

Code:
{
  "name": "@babel/plugin-syntax-numeric-separator",
  "version": "7.10.4",
  "description": "Allow parsing of Decimal, Binary, Hex and Octal literals that contain a Numeric Literal Separator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-numeric-separator"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.10.4"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4"
  },
  "gitHead": "7fd40d86a0d03ff0e9c3ea16b29689945433d4df"
}


---

File name: node_modules\@babel\plugin-syntax-numeric-separator\README.md

Code:
# @babel/plugin-syntax-numeric-separator

> Allow parsing of Decimal, Binary, Hex and Octal literals that contain a Numeric Literal Separator

See our website [@babel/plugin-syntax-numeric-separator](https://babeljs.io/docs/en/next/babel-plugin-syntax-numeric-separator.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-numeric-separator
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-numeric-separator --dev
```


---

File name: node_modules\@babel\plugin-syntax-object-rest-spread\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-object-rest-spread",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("objectRestSpread");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-object-rest-spread\package.json

Code:
{
  "name": "@babel/plugin-syntax-object-rest-spread",
  "version": "7.8.3",
  "description": "Allow parsing of object rest/spread",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-object-rest-spread",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-object-rest-spread\README.md

Code:
# @babel/plugin-syntax-object-rest-spread

> Allow parsing of object rest/spread

See our website [@babel/plugin-syntax-object-rest-spread](https://babeljs.io/docs/en/next/babel-plugin-syntax-object-rest-spread.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-object-rest-spread
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-object-rest-spread --dev
```


---

File name: node_modules\@babel\plugin-syntax-optional-catch-binding\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-optional-catch-binding",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalCatchBinding");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-optional-catch-binding\package.json

Code:
{
  "name": "@babel/plugin-syntax-optional-catch-binding",
  "version": "7.8.3",
  "description": "Allow parsing of optional catch bindings",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-optional-catch-binding",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-optional-catch-binding\README.md

Code:
# @babel/plugin-syntax-optional-catch-binding

> Allow parsing of optional catch bindings

See our website [@babel/plugin-syntax-optional-catch-binding](https://babeljs.io/docs/en/next/babel-plugin-syntax-optional-catch-binding.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-optional-catch-binding
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-optional-catch-binding --dev
```


---

File name: node_modules\@babel\plugin-syntax-optional-chaining\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-optional-chaining",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalChaining");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-optional-chaining\package.json

Code:
{
  "name": "@babel/plugin-syntax-optional-chaining",
  "version": "7.8.3",
  "description": "Allow parsing of optional properties",
  "repository": "https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.8.0"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.8.0"
  }
}


---

File name: node_modules\@babel\plugin-syntax-optional-chaining\README.md

Code:
# @babel/plugin-syntax-optional-chaining

> Allow parsing of optional properties

See our website [@babel/plugin-syntax-optional-chaining](https://babeljs.io/docs/en/next/babel-plugin-syntax-optional-chaining.html) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-optional-chaining
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-optional-chaining --dev
```


---

File name: node_modules\@babel\plugin-syntax-private-property-in-object\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-private-property-in-object",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("privateIn");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-private-property-in-object\package.json

Code:
{
  "name": "@babel/plugin-syntax-private-property-in-object",
  "version": "7.14.5",
  "description": "Allow parsing of '#foo in obj' brand checks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-private-property-in-object"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

---

File name: node_modules\@babel\plugin-syntax-private-property-in-object\README.md

Code:
# @babel/plugin-syntax-private-property-in-object

> Allow parsing of '#foo in obj' brand checks

See our website [@babel/plugin-syntax-private-property-in-object](https://babeljs.io/docs/en/babel-plugin-syntax-private-property-in-object) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-private-property-in-object
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-private-property-in-object --dev
```


---

File name: node_modules\@babel\plugin-syntax-top-level-await\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "syntax-top-level-await",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("topLevelAwait");
    }

  };
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-top-level-await\package.json

Code:
{
  "name": "@babel/plugin-syntax-top-level-await",
  "version": "7.14.5",
  "description": "Allow parsing of top-level await in modules",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-top-level-await"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-top-level-await",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.14.5"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "7.14.5"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)"
}

---

File name: node_modules\@babel\plugin-syntax-top-level-await\README.md

Code:
# @babel/plugin-syntax-top-level-await

> Allow parsing of top-level await in modules

See our website [@babel/plugin-syntax-top-level-await](https://babeljs.io/docs/en/babel-plugin-syntax-top-level-await) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-top-level-await
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-top-level-await --dev
```


---

File name: node_modules\@babel\plugin-syntax-typescript\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
{
  var removePlugin = function (plugins, name) {
    const indices = [];
    plugins.forEach((plugin, i) => {
      const n = Array.isArray(plugin) ? plugin[0] : plugin;
      if (n === name) {
        indices.unshift(i);
      }
    });
    for (const i of indices) {
      plugins.splice(i, 1);
    }
  };
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
  api.assertVersion(7);
  const {
    disallowAmbiguousJSXLike,
    dts
  } = opts;
  {
    var {
      isTSX
    } = opts;
  }
  return {
    name: "syntax-typescript",
    manipulateOptions(opts, parserOpts) {
      {
        const {
          plugins
        } = parserOpts;
        removePlugin(plugins, "flow");
        removePlugin(plugins, "jsx");
        {
          plugins.push("objectRestSpread", "classProperties");
        }
        if (isTSX) {
          plugins.push("jsx");
        }
      }
      parserOpts.plugins.push(["typescript", {
        disallowAmbiguousJSXLike,
        dts
      }]);
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-syntax-typescript\package.json

Code:
{
  "name": "@babel/plugin-syntax-typescript",
  "version": "7.27.1",
  "description": "Allow parsing of TypeScript syntax",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-typescript"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-typescript",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "typescript"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-syntax-typescript\README.md

Code:
# @babel/plugin-syntax-typescript

> Allow parsing of TypeScript syntax

See our website [@babel/plugin-syntax-typescript](https://babeljs.io/docs/babel-plugin-syntax-typescript) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-typescript
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-typescript --dev
```


---

File name: node_modules\@babel\plugin-syntax-unicode-sets-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "syntax-unicode-sets-regex",
    feature: "unicodeSetsFlag_syntax",

    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("regexpUnicodeSets");
    }

  });
});

exports.default = _default;

---

File name: node_modules\@babel\plugin-syntax-unicode-sets-regex\package.json

Code:
{
  "name": "@babel/plugin-syntax-unicode-sets-regex",
  "version": "7.18.6",
  "description": "Parse regular expressions' unicodeSets (v) flag.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-syntax-unicode-sets-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "unicode",
    "sets",
    "properties",
    "property",
    "string",
    "strings",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-syntax-unicode-sets-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.18.6",
    "@babel/helper-plugin-utils": "^7.18.6"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.18.6",
    "@babel/helper-plugin-test-runner": "^7.18.6"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": "./lib/index.js",
    "./package.json": "./package.json"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-syntax-unicode-sets-regex\README.md

Code:
# @babel/plugin-syntax-unicode-sets-regex

> Parse regular expressions' unicodeSets (v) flag.

See our website [@babel/plugin-syntax-unicode-sets-regex](https://babeljs.io/docs/en/babel-plugin-syntax-unicode-sets-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-syntax-unicode-sets-regex
```

or using yarn:

```sh
yarn add @babel/plugin-syntax-unicode-sets-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-arrow-functions\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression(path) {
        if (!path.isArrowFunctionExpression()) return;
        {
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            noNewArrows,
            specCompliant: !noNewArrows
          });
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-arrow-functions\package.json

Code:
{
  "name": "@babel/plugin-transform-arrow-functions",
  "version": "7.27.1",
  "description": "Compile ES2015 arrow functions to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-arrow-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-arrow-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-arrow-functions\README.md

Code:
# @babel/plugin-transform-arrow-functions

> Compile ES2015 arrow functions to ES5

See our website [@babel/plugin-transform-arrow-functions](https://babeljs.io/docs/babel-plugin-transform-arrow-functions) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-arrow-functions
```

or using yarn:

```sh
yarn add @babel/plugin-transform-arrow-functions --dev
```


---

File name: node_modules\@babel\plugin-transform-async-generator-functions\lib\for-await.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _core = require("@babel/core");
const buildForAwait = (0, _core.template)(`
  async function wrapper() {
    var ITERATOR_ABRUPT_COMPLETION = false;
    var ITERATOR_HAD_ERROR_KEY = false;
    var ITERATOR_ERROR_KEY;
    try {
      for (
        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;
        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;
        ITERATOR_ABRUPT_COMPLETION = false
      ) {
      }
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {
          await ITERATOR_KEY.return();
        }
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) {
          throw ITERATOR_ERROR_KEY;
        }
      }
    }
  }
`);
function _default(path, {
  getAsyncIterator
}) {
  const {
    node,
    scope,
    parent
  } = path;
  const stepKey = scope.generateUidIdentifier("step");
  const stepValue = _core.types.memberExpression(stepKey, _core.types.identifier("value"));
  const left = node.left;
  let declar;
  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
  } else if (_core.types.isVariableDeclaration(left)) {
    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
  }
  let template = buildForAwait({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    GET_ITERATOR: getAsyncIterator,
    OBJECT: node.right,
    STEP_KEY: _core.types.cloneNode(stepKey)
  });
  template = template.body.body;
  const isLabeledParent = _core.types.isLabeledStatement(parent);
  const tryBody = template[3].block.body;
  const loop = tryBody[0];
  if (isLabeledParent) {
    tryBody[0] = _core.types.labeledStatement(parent.label, loop);
  }
  return {
    replaceParent: isLabeledParent,
    node: template,
    declar,
    loop
  };
}

//# sourceMappingURL=for-await.js.map


---

File name: node_modules\@babel\plugin-transform-async-generator-functions\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperRemapAsyncToGenerator = require("@babel/helper-remap-async-to-generator");
var _core = require("@babel/core");
var _traverse = require("@babel/traverse");
var _forAwait = require("./for-await.js");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const yieldStarVisitor = _traverse.visitors.environmentVisitor({
    ArrowFunctionExpression(path) {
      path.skip();
    },
    YieldExpression({
      node
    }, state) {
      if (!node.delegate) return;
      const asyncIter = _core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]);
      node.argument = _core.types.callExpression(state.addHelper("asyncGeneratorDelegate"), [asyncIter, state.addHelper("awaitAsyncGenerator")]);
    }
  });
  const forAwaitVisitor = _traverse.visitors.environmentVisitor({
    ArrowFunctionExpression(path) {
      path.skip();
    },
    ForOfStatement(path, {
      file
    }) {
      const {
        node
      } = path;
      if (!node.await) return;
      const build = (0, _forAwait.default)(path, {
        getAsyncIterator: file.addHelper("asyncIterator")
      });
      const {
        declar,
        loop
      } = build;
      const block = loop.body;
      path.ensureBlock();
      if (declar) {
        block.body.push(declar);
        if (path.node.body.body.length) {
          block.body.push(_core.types.blockStatement(path.node.body.body));
        }
      } else {
        block.body.push(...path.node.body.body);
      }
      _core.types.inherits(loop, node);
      _core.types.inherits(loop.body, node.body);
      const p = build.replaceParent ? path.parentPath : path;
      p.replaceWithMultiple(build.node);
      p.scope.parent.crawl();
    }
  });
  const visitor = {
    Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
      path.setData("@babel/plugin-transform-async-generator-functions/async_generator_function", true);
      (0, _helperRemapAsyncToGenerator.default)(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator")
      });
    }
  };
  return {
    name: "transform-async-generator-functions",
    manipulateOptions: (_, parser) => parser.plugins.push("asyncGenerators"),
    visitor: {
      Program(path, state) {
        path.traverse(visitor, state);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-async-generator-functions\package.json

Code:
{
  "name": "@babel/plugin-transform-async-generator-functions",
  "version": "7.27.1",
  "description": "Turn async generator functions into ES2015 generators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-async-generator-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-async-generator-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-remap-async-to-generator": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "babel-plugin-polyfill-corejs3": "^0.11.0",
    "core-js-pure": "^3.30.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-async-generator-functions\README.md

Code:
# @babel/plugin-transform-async-generator-functions

> Turn async generator functions into ES2015 generators

See our website [@babel/plugin-transform-async-generator-functions](https://babeljs.io/docs/babel-plugin-transform-async-generator-functions) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-async-generator-functions
```

or using yarn:

```sh
yarn add @babel/plugin-transform-async-generator-functions --dev
```


---

File name: node_modules\@babel\plugin-transform-async-to-generator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperRemapAsyncToGenerator = require("@babel/helper-remap-async-to-generator");
var _helperModuleImports = require("@babel/helper-module-imports");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    method,
    module
  } = options;
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : true;
  const ignoreFunctionLength = (_api$assumption2 = api.assumption("ignoreFunctionLength")) != null ? _api$assumption2 : false;
  if (method && module) {
    return {
      name: "transform-async-to-generator",
      visitor: {
        Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          let wrapAsync = state.methodWrapper;
          if (wrapAsync) {
            wrapAsync = _core.types.cloneNode(wrapAsync);
          } else {
            wrapAsync = state.methodWrapper = (0, _helperModuleImports.addNamed)(path, method, module);
          }
          (0, _helperRemapAsyncToGenerator.default)(path, {
            wrapAsync
          }, noNewArrows, ignoreFunctionLength);
        }
      }
    };
  }
  return {
    name: "transform-async-to-generator",
    visitor: {
      Function(path, state) {
        if (!path.node.async || path.node.generator) return;
        (0, _helperRemapAsyncToGenerator.default)(path, {
          wrapAsync: state.addHelper("asyncToGenerator")
        }, noNewArrows, ignoreFunctionLength);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-async-to-generator\package.json

Code:
{
  "name": "@babel/plugin-transform-async-to-generator",
  "version": "7.27.1",
  "description": "Turn async functions into ES2015 generators",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-async-to-generator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-async-to-generator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-module-imports": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-remap-async-to-generator": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-async-to-generator\README.md

Code:
# @babel/plugin-transform-async-to-generator

> Turn async functions into ES2015 generators

See our website [@babel/plugin-transform-async-to-generator](https://babeljs.io/docs/babel-plugin-transform-async-to-generator) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-async-to-generator
```

or using yarn:

```sh
yarn add @babel/plugin-transform-async-to-generator --dev
```


---

File name: node_modules\@babel\plugin-transform-block-scoped-functions\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  function transformStatementList(parentPath, paths) {
    ;
    for (const path of paths) {
      if (!path.isFunctionDeclaration()) continue;
      ;
      const func = path.node;
      const declar = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(func.id, _core.types.toExpression(func))]);
      declar._blockHoist = 2;
      func.id = null;
      path.replaceWith(declar);
    }
  }
  return {
    name: "transform-block-scoped-functions",
    visitor: {
      BlockStatement(path) {
        const {
          node,
          parent
        } = path;
        if (_core.types.isFunction(parent, {
          body: node
        }) || _core.types.isExportDeclaration(parent)) {
          return;
        }
        transformStatementList(path, path.get("body"));
      },
      SwitchCase(path) {
        transformStatementList(path, path.get("consequent"));
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-block-scoped-functions\package.json

Code:
{
  "name": "@babel/plugin-transform-block-scoped-functions",
  "version": "7.27.1",
  "description": "Babel plugin to ensure function declarations at the block level are block scoped",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-block-scoped-functions"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-block-scoped-functions",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-block-scoped-functions\README.md

Code:
# @babel/plugin-transform-block-scoped-functions

> Babel plugin to ensure function declarations at the block level are block scoped

See our website [@babel/plugin-transform-block-scoped-functions](https://babeljs.io/docs/babel-plugin-transform-block-scoped-functions) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-block-scoped-functions
```

or using yarn:

```sh
yarn add @babel/plugin-transform-block-scoped-functions --dev
```


---

File name: node_modules\@babel\plugin-transform-block-scoping\lib\annex-B_3_3.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.annexB33FunctionsVisitor = void 0;
exports.isVarScope = isVarScope;
var _core = require("@babel/core");
const annexB33FunctionsVisitor = exports.annexB33FunctionsVisitor = Object.assign({
  VariableDeclaration(path) {
    if (isStrict(path)) return;
    if (path.node.kind !== "var") return;
    const varScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
    varScope.path.traverse(functionsToVarVisitor, {
      names: Object.keys(path.getBindingIdentifiers())
    });
  }
}, {
  BlockStatement(path) {
    if (isStrict(path)) return;
    if (_core.types.isFunction(path.parent, {
      body: path.node
    })) return;
    transformStatementList(path.get("body"));
  },
  SwitchCase(path) {
    if (isStrict(path)) return;
    transformStatementList(path.get("consequent"));
  }
});
function transformStatementList(paths) {
  outer: for (const path of paths) {
    if (!path.isFunctionDeclaration()) continue;
    if (path.node.async || path.node.generator) return;
    const {
      scope
    } = path.parentPath;
    if (isVarScope(scope)) return;
    const {
      name
    } = path.node.id;
    let currScope = scope;
    do {
      if (currScope.parent.hasOwnBinding(name)) continue outer;
      currScope = currScope.parent;
    } while (!isVarScope(currScope));
    maybeTransformBlockScopedFunction(path);
  }
}
function maybeTransformBlockScopedFunction(path) {
  const {
    node,
    parentPath: {
      scope
    }
  } = path;
  const {
    id
  } = node;
  scope.removeOwnBinding(id.name);
  node.id = null;
  const varNode = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(id, _core.types.toExpression(node))]);
  varNode._blockHoist = 2;
  const [varPath] = path.replaceWith(varNode);
  scope.registerDeclaration(varPath);
}
const functionsToVarVisitor = {
  Scope(path, {
    names
  }) {
    for (const name of names) {
      const binding = path.scope.getOwnBinding(name);
      if (binding && binding.kind === "hoisted") {
        maybeTransformBlockScopedFunction(binding.path);
      }
    }
  },
  "Expression|Declaration"(path) {
    path.skip();
  }
};
function isVarScope(scope) {
  return scope.path.isFunctionParent() || scope.path.isProgram();
}
function isStrict(path) {
  return !!path.find(({
    node
  }) => {
    var _node$directives;
    if (_core.types.isProgram(node)) {
      if (node.sourceType === "module") return true;
    } else if (_core.types.isClass(node)) {
      return true;
    } else if (!_core.types.isBlockStatement(node)) {
      return false;
    }
    return (_node$directives = node.directives) == null ? void 0 : _node$directives.some(directive => directive.value.value === "use strict");
  });
}

//# sourceMappingURL=annex-B_3_3.js.map


---

File name: node_modules\@babel\plugin-transform-block-scoping\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _loop = require("./loop.js");
var _validation = require("./validation.js");
var _annexB_3_ = require("./annex-B_3_3.js");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
  api.assertVersion(7);
  const {
    throwIfClosureRequired = false,
    tdz: tdzEnabled = false
  } = opts;
  if (typeof throwIfClosureRequired !== "boolean") {
    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);
  }
  if (typeof tdzEnabled !== "boolean") {
    throw new Error(`.tdz must be a boolean, or undefined`);
  }
  return {
    name: "transform-block-scoping",
    visitor: _core.traverse.visitors.merge([_annexB_3_.annexB33FunctionsVisitor, {
      Loop(path, state) {
        const isForStatement = path.isForStatement();
        const headPath = isForStatement ? path.get("init") : path.isForXStatement() ? path.get("left") : null;
        let needsBodyWrap = false;
        const markNeedsBodyWrap = () => {
          if (throwIfClosureRequired) {
            throw path.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
          }
          needsBodyWrap = true;
        };
        const body = path.get("body");
        let bodyScope;
        if (body.isBlockStatement()) {
          bodyScope = body.scope;
        }
        const bindings = (0, _loop.getLoopBodyBindings)(path);
        for (const binding of bindings) {
          const {
            capturedInClosure
          } = (0, _loop.getUsageInBody)(binding, path);
          if (capturedInClosure) markNeedsBodyWrap();
        }
        const captured = [];
        const updatedBindingsUsages = new Map();
        if (headPath && isBlockScoped(headPath)) {
          const names = Object.keys(headPath.getBindingIdentifiers());
          const headScope = headPath.scope;
          for (let name of names) {
            var _bodyScope;
            if ((_bodyScope = bodyScope) != null && _bodyScope.hasOwnBinding(name)) continue;
            let binding = headScope.getOwnBinding(name);
            if (!binding) {
              headScope.crawl();
              binding = headScope.getOwnBinding(name);
            }
            const {
              usages,
              capturedInClosure,
              hasConstantViolations
            } = (0, _loop.getUsageInBody)(binding, path);
            if (headScope.parent.hasBinding(name) || headScope.parent.hasGlobal(name)) {
              const newName = headScope.generateUid(name);
              headScope.rename(name, newName);
              name = newName;
            }
            if (capturedInClosure) {
              markNeedsBodyWrap();
              captured.push(name);
            }
            if (isForStatement && hasConstantViolations) {
              updatedBindingsUsages.set(name, usages);
            }
          }
        }
        if (needsBodyWrap) {
          const varPath = (0, _loop.wrapLoopBody)(path, captured, updatedBindingsUsages);
          if (headPath != null && headPath.isVariableDeclaration()) {
            transformBlockScopedVariable(headPath, state, tdzEnabled);
          }
          varPath.get("declarations.0.init").unwrapFunctionEnvironment();
        }
      },
      VariableDeclaration(path, state) {
        transformBlockScopedVariable(path, state, tdzEnabled);
      },
      ClassDeclaration(path) {
        const {
          id
        } = path.node;
        if (!id) return;
        const {
          scope
        } = path.parentPath;
        if (!(0, _annexB_3_.isVarScope)(scope) && scope.parent.hasBinding(id.name, {
          noUids: true
        })) {
          path.scope.rename(id.name);
        }
      }
    }])
  };
});
const conflictingFunctionsVisitor = {
  Scope(path, {
    names
  }) {
    for (const name of names) {
      const binding = path.scope.getOwnBinding(name);
      if (binding && binding.kind === "hoisted") {
        path.scope.rename(name);
      }
    }
  },
  "Expression|Declaration"(path) {
    path.skip();
  }
};
function transformBlockScopedVariable(path, state, tdzEnabled) {
  if (!isBlockScoped(path)) return;
  const dynamicTDZNames = (0, _validation.validateUsage)(path, state, tdzEnabled);
  path.node.kind = "var";
  const bindingNames = Object.keys(path.getBindingIdentifiers());
  for (const name of bindingNames) {
    const binding = path.scope.getOwnBinding(name);
    if (!binding) continue;
    binding.kind = "var";
  }
  if (isInLoop(path) && !(0, _loop.isVarInLoopHead)(path) || dynamicTDZNames.length > 0) {
    for (const decl of path.node.declarations) {
      var _decl$init;
      (_decl$init = decl.init) != null ? _decl$init : decl.init = path.scope.buildUndefinedNode();
    }
  }
  const blockScope = path.scope;
  const varScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
  if (varScope !== blockScope) {
    for (const name of bindingNames) {
      let newName = name;
      if (blockScope.parent.hasBinding(name, {
        noUids: true
      }) || blockScope.parent.hasGlobal(name)) {
        newName = blockScope.generateUid(name);
        blockScope.rename(name, newName);
      }
      blockScope.moveBindingTo(newName, varScope);
    }
  }
  blockScope.path.traverse(conflictingFunctionsVisitor, {
    names: bindingNames
  });
  for (const name of dynamicTDZNames) {
    path.scope.push({
      id: _core.types.identifier(name),
      init: state.addHelper("temporalUndefined")
    });
  }
}
function isLetOrConst(kind) {
  return kind === "let" || kind === "const";
}
function isInLoop(path) {
  if (!path.parentPath) return false;
  if (path.parentPath.isLoop()) return true;
  if (path.parentPath.isFunctionParent()) return false;
  return isInLoop(path.parentPath);
}
function isBlockScoped(path) {
  const {
    node
  } = path;
  if (!_core.types.isVariableDeclaration(node)) return false;
  const {
    kind
  } = node;
  if (kind === "using" || kind === "await using") {
    throw path.buildCodeFrameError(`The ${kind} declaration should be first transformed by \`@babel/plugin-transform-explicit-resource-management\`.`);
  } else if (!isLetOrConst(kind)) {
    return false;
  }
  return true;
}

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-block-scoping\lib\loop.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoopBodyBindings = getLoopBodyBindings;
exports.getUsageInBody = getUsageInBody;
exports.isVarInLoopHead = isVarInLoopHead;
exports.wrapLoopBody = wrapLoopBody;
var _core = require("@babel/core");
const collectLoopBodyBindingsVisitor = {
  "Expression|Declaration|Loop"(path) {
    path.skip();
  },
  Scope(path, state) {
    if (path.isFunctionParent()) path.skip();
    const {
      bindings
    } = path.scope;
    for (const name of Object.keys(bindings)) {
      const binding = bindings[name];
      if (binding.kind === "let" || binding.kind === "const" || binding.kind === "hoisted") {
        state.blockScoped.push(binding);
      }
    }
  }
};
function getLoopBodyBindings(loopPath) {
  const state = {
    blockScoped: []
  };
  loopPath.traverse(collectLoopBodyBindingsVisitor, state);
  return state.blockScoped;
}
function getUsageInBody(binding, loopPath) {
  const seen = new WeakSet();
  let capturedInClosure = false;
  const constantViolations = filterMap(binding.constantViolations, path => {
    const {
      inBody,
      inClosure
    } = relativeLoopLocation(path, loopPath);
    if (!inBody) return null;
    capturedInClosure || (capturedInClosure = inClosure);
    const id = path.isUpdateExpression() ? path.get("argument") : path.isAssignmentExpression() ? path.get("left") : null;
    if (id) seen.add(id.node);
    return id;
  });
  const references = filterMap(binding.referencePaths, path => {
    if (seen.has(path.node)) return null;
    const {
      inBody,
      inClosure
    } = relativeLoopLocation(path, loopPath);
    if (!inBody) return null;
    capturedInClosure || (capturedInClosure = inClosure);
    return path;
  });
  return {
    capturedInClosure,
    hasConstantViolations: constantViolations.length > 0,
    usages: references.concat(constantViolations)
  };
}
function relativeLoopLocation(path, loopPath) {
  const bodyPath = loopPath.get("body");
  let inClosure = false;
  for (let currPath = path; currPath; currPath = currPath.parentPath) {
    if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {
      inClosure = true;
    }
    if (currPath === bodyPath) {
      return {
        inBody: true,
        inClosure
      };
    } else if (currPath === loopPath) {
      return {
        inBody: false,
        inClosure
      };
    }
  }
  throw new Error("Internal Babel error: path is not in loop. Please report this as a bug.");
}
const collectCompletionsAndVarsVisitor = {
  Function(path) {
    path.skip();
  },
  LabeledStatement: {
    enter({
      node
    }, state) {
      state.labelsStack.push(node.label.name);
    },
    exit({
      node
    }, state) {
      const popped = state.labelsStack.pop();
      if (popped !== node.label.name) {
        throw new Error("Assertion failure. Please report this bug to Babel.");
      }
    }
  },
  Loop: {
    enter(_, state) {
      state.labellessContinueTargets++;
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessContinueTargets--;
      state.labellessBreakTargets--;
    }
  },
  SwitchStatement: {
    enter(_, state) {
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessBreakTargets--;
    }
  },
  "BreakStatement|ContinueStatement"(path, state) {
    const {
      label
    } = path.node;
    if (label) {
      if (state.labelsStack.includes(label.name)) return;
    } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0) {
      return;
    }
    state.breaksContinues.push(path);
  },
  ReturnStatement(path, state) {
    state.returns.push(path);
  },
  VariableDeclaration(path, state) {
    if (path.parent === state.loopNode && isVarInLoopHead(path)) return;
    if (path.node.kind === "var") state.vars.push(path);
  }
};
function wrapLoopBody(loopPath, captured, updatedBindingsUsages) {
  const loopNode = loopPath.node;
  const state = {
    breaksContinues: [],
    returns: [],
    labelsStack: [],
    labellessBreakTargets: 0,
    labellessContinueTargets: 0,
    vars: [],
    loopNode
  };
  loopPath.traverse(collectCompletionsAndVarsVisitor, state);
  const callArgs = [];
  const closureParams = [];
  const updater = [];
  for (const [name, updatedUsage] of updatedBindingsUsages) {
    callArgs.push(_core.types.identifier(name));
    const innerName = loopPath.scope.generateUid(name);
    closureParams.push(_core.types.identifier(innerName));
    updater.push(_core.types.assignmentExpression("=", _core.types.identifier(name), _core.types.identifier(innerName)));
    for (const path of updatedUsage) path.replaceWith(_core.types.identifier(innerName));
  }
  for (const name of captured) {
    if (updatedBindingsUsages.has(name)) continue;
    callArgs.push(_core.types.identifier(name));
    closureParams.push(_core.types.identifier(name));
  }
  const id = loopPath.scope.generateUid("loop");
  const fn = _core.types.functionExpression(null, closureParams, _core.types.toBlock(loopNode.body));
  let call = _core.types.callExpression(_core.types.identifier(id), callArgs);
  const fnParent = loopPath.findParent(p => p.isFunction());
  if (fnParent) {
    const {
      async,
      generator
    } = fnParent.node;
    fn.async = async;
    fn.generator = generator;
    if (generator) call = _core.types.yieldExpression(call, true);else if (async) call = _core.types.awaitExpression(call);
  }
  const updaterNode = updater.length > 0 ? _core.types.expressionStatement(_core.types.sequenceExpression(updater)) : null;
  if (updaterNode) fn.body.body.push(updaterNode);
  const [varPath] = loopPath.insertBefore(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(id), fn)]));
  const bodyStmts = [];
  const varNames = [];
  for (const varPath of state.vars) {
    const assign = [];
    for (const decl of varPath.node.declarations) {
      varNames.push(...Object.keys(_core.types.getBindingIdentifiers(decl.id)));
      if (decl.init) {
        assign.push(_core.types.assignmentExpression("=", decl.id, decl.init));
      } else if (_core.types.isForXStatement(varPath.parent, {
        left: varPath.node
      })) {
        assign.push(decl.id);
      }
    }
    if (assign.length > 0) {
      const replacement = assign.length === 1 ? assign[0] : _core.types.sequenceExpression(assign);
      varPath.replaceWith(replacement);
    } else {
      varPath.remove();
    }
  }
  if (varNames.length) {
    varPath.pushContainer("declarations", varNames.map(name => _core.types.variableDeclarator(_core.types.identifier(name))));
  }
  const labelNum = state.breaksContinues.length;
  const returnNum = state.returns.length;
  if (labelNum + returnNum === 0) {
    bodyStmts.push(_core.types.expressionStatement(call));
  } else if (labelNum === 1 && returnNum === 0) {
    for (const path of state.breaksContinues) {
      const {
        node
      } = path;
      const {
        type,
        label
      } = node;
      let name = type === "BreakStatement" ? "break" : "continue";
      if (label) name += " " + label.name;
      path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(1)), "trailing", " " + name, true));
      if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
      bodyStmts.push(_core.template.statement.ast`
        if (${call}) ${node}
      `);
    }
  } else {
    const completionId = loopPath.scope.generateUid("ret");
    if (varPath.isVariableDeclaration()) {
      varPath.pushContainer("declarations", [_core.types.variableDeclarator(_core.types.identifier(completionId))]);
      bodyStmts.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(completionId), call)));
    } else {
      bodyStmts.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(completionId), call)]));
    }
    const injected = [];
    for (const path of state.breaksContinues) {
      const {
        node
      } = path;
      const {
        type,
        label
      } = node;
      let name = type === "BreakStatement" ? "break" : "continue";
      if (label) name += " " + label.name;
      let i = injected.indexOf(name);
      const hasInjected = i !== -1;
      if (!hasInjected) {
        injected.push(name);
        i = injected.length - 1;
      }
      path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(i)), "trailing", " " + name, true));
      if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
      if (hasInjected) continue;
      bodyStmts.push(_core.template.statement.ast`
        if (${_core.types.identifier(completionId)} === ${_core.types.numericLiteral(i)}) ${node}
      `);
    }
    if (returnNum) {
      for (const path of state.returns) {
        const arg = path.node.argument || path.scope.buildUndefinedNode();
        path.replaceWith(_core.template.statement.ast`
          return { v: ${arg} };
        `);
      }
      bodyStmts.push(_core.template.statement.ast`
          if (${_core.types.identifier(completionId)}) return ${_core.types.identifier(completionId)}.v;
        `);
    }
  }
  loopNode.body = _core.types.blockStatement(bodyStmts);
  return varPath;
}
function isVarInLoopHead(path) {
  if (_core.types.isForStatement(path.parent)) return path.key === "init";
  if (_core.types.isForXStatement(path.parent)) return path.key === "left";
  return false;
}
function filterMap(list, fn) {
  const result = [];
  for (const item of list) {
    const mapped = fn(item);
    if (mapped) result.push(mapped);
  }
  return result;
}

//# sourceMappingURL=loop.js.map


---

File name: node_modules\@babel\plugin-transform-block-scoping\lib\validation.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateUsage = validateUsage;
var _core = require("@babel/core");
function validateUsage(path, state, tdzEnabled) {
  const dynamicTDZNames = [];
  for (const name of Object.keys(path.getBindingIdentifiers())) {
    const binding = path.scope.getBinding(name);
    if (!binding) continue;
    if (tdzEnabled) {
      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);
    }
    if (path.node.kind === "const") {
      disallowConstantViolations(name, binding, state);
    }
  }
  return dynamicTDZNames;
}
function disallowConstantViolations(name, binding, state) {
  for (const violation of binding.constantViolations) {
    const readOnlyError = state.addHelper("readOnlyError");
    const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);
    if (violation.isAssignmentExpression()) {
      const {
        operator,
        left,
        right
      } = violation.node;
      if (operator === "=") {
        const exprs = [right];
        exprs.push(throwNode);
        violation.replaceWith(_core.types.sequenceExpression(exprs));
      } else if (["&&=", "||=", "??="].includes(operator)) {
        violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), left, _core.types.sequenceExpression([right, throwNode])));
      } else {
        violation.replaceWith(_core.types.sequenceExpression([_core.types.binaryExpression(operator.slice(0, -1), left, right), throwNode]));
      }
    } else if (violation.isUpdateExpression()) {
      violation.replaceWith(_core.types.sequenceExpression([_core.types.unaryExpression("+", violation.get("argument").node), throwNode]));
    } else if (violation.isForXStatement()) {
      violation.ensureBlock();
      violation.get("left").replaceWith(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))]));
      violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));
    }
  }
}
function getTDZStatus(refPath, bindingPath) {
  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
  if (executionStatus === "before") {
    return "outside";
  } else if (executionStatus === "after") {
    return "inside";
  } else {
    return "maybe";
  }
}
const skipTDZChecks = new WeakSet();
function buildTDZAssert(status, node, state) {
  if (status === "maybe") {
    const clone = _core.types.cloneNode(node);
    skipTDZChecks.add(clone);
    return _core.types.callExpression(state.addHelper("temporalRef"), [clone, _core.types.stringLiteral(node.name)]);
  } else {
    return _core.types.callExpression(state.addHelper("tdz"), [_core.types.stringLiteral(node.name)]);
  }
}
function getTDZReplacement(path, state, id = path.node) {
  var _path$scope$getBindin;
  if (skipTDZChecks.has(id)) return;
  skipTDZChecks.add(id);
  const bindingPath = (_path$scope$getBindin = path.scope.getBinding(id.name)) == null ? void 0 : _path$scope$getBindin.path;
  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;
  const status = getTDZStatus(path, bindingPath);
  if (status === "outside") return;
  if (status === "maybe") {
    bindingPath.parent._tdzThis = true;
  }
  return {
    status,
    node: buildTDZAssert(status, id, state)
  };
}
function injectTDZChecks(binding, state) {
  const allUsages = new Set(binding.referencePaths);
  binding.constantViolations.forEach(allUsages.add, allUsages);
  let dynamicTdz = false;
  for (const path of binding.constantViolations) {
    const {
      node
    } = path;
    if (skipTDZChecks.has(node)) continue;
    skipTDZChecks.add(node);
    if (path.isUpdateExpression()) {
      const arg = path.get("argument");
      const replacement = getTDZReplacement(path, state, arg.node);
      if (!replacement) continue;
      if (replacement.status === "maybe") {
        dynamicTdz = true;
        path.insertBefore(replacement.node);
      } else {
        path.replaceWith(replacement.node);
      }
    } else if (path.isAssignmentExpression()) {
      const nodes = [];
      const ids = path.getBindingIdentifiers();
      for (const name of Object.keys(ids)) {
        const replacement = getTDZReplacement(path, state, ids[name]);
        if (replacement) {
          nodes.push(_core.types.expressionStatement(replacement.node));
          if (replacement.status === "inside") break;
          if (replacement.status === "maybe") dynamicTdz = true;
        }
      }
      if (nodes.length > 0) path.insertBefore(nodes);
    }
  }
  for (const path of binding.referencePaths) {
    if (path.parentPath.isUpdateExpression()) continue;
    if (path.parentPath.isFor({
      left: path.node
    })) continue;
    const replacement = getTDZReplacement(path, state);
    if (!replacement) continue;
    if (replacement.status === "maybe") dynamicTdz = true;
    path.replaceWith(replacement.node);
  }
  return dynamicTdz;
}

//# sourceMappingURL=validation.js.map


---

File name: node_modules\@babel\plugin-transform-block-scoping\package.json

Code:
{
  "name": "@babel/plugin-transform-block-scoping",
  "version": "7.27.5",
  "description": "Compile ES2015 block scoping (const and let) to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-block-scoping"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-block-scoping",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.4",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.4"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-block-scoping\README.md

Code:
# @babel/plugin-transform-block-scoping

> Compile ES2015 block scoping (const and let) to ES5

See our website [@babel/plugin-transform-block-scoping](https://babeljs.io/docs/babel-plugin-transform-block-scoping) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-block-scoping
```

or using yarn:

```sh
yarn add @babel/plugin-transform-block-scoping --dev
```


---

File name: node_modules\@babel\plugin-transform-class-properties\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
    name: "transform-class-properties",
    api,
    feature: _helperCreateClassFeaturesPlugin.FEATURES.fields,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      {
        parserOpts.plugins.push("classProperties", "classPrivateProperties");
      }
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-class-properties\package.json

Code:
{
  "name": "@babel/plugin-transform-class-properties",
  "version": "7.27.1",
  "description": "This plugin transforms static class properties as well as properties declared with the property initializer syntax",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-class-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-class-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-class-properties\README.md

Code:
# @babel/plugin-transform-class-properties

> This plugin transforms static class properties as well as properties declared with the property initializer syntax

See our website [@babel/plugin-transform-class-properties](https://babeljs.io/docs/babel-plugin-transform-class-properties) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-class-properties
```

or using yarn:

```sh
yarn add @babel/plugin-transform-class-properties --dev
```


---

File name: node_modules\@babel\plugin-transform-class-static-block\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");
function generateUid(scope, denyList) {
  const name = "";
  let uid;
  let i = 1;
  do {
    uid = `_${name}`;
    if (i > 1) uid += i;
    i++;
  } while (denyList.has(uid));
  return uid;
}
var _default = exports.default = (0, _helperPluginUtils.declare)(({
  types: t,
  template,
  assertVersion
}) => {
  assertVersion("^7.12.0 || >8.0.0-alpha <8.0.0-beta");
  return {
    name: "transform-class-static-block",
    manipulateOptions: (_, parser) => parser.plugins.push("classStaticBlock"),
    pre() {
      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);
    },
    visitor: {
      ClassBody(classBody) {
        const {
          scope
        } = classBody;
        const privateNames = new Set();
        const body = classBody.get("body");
        for (const path of body) {
          if (path.isPrivate()) {
            privateNames.add(path.get("key.id").node.name);
          }
        }
        for (const path of body) {
          if (!path.isStaticBlock()) continue;
          const staticBlockPrivateId = generateUid(scope, privateNames);
          privateNames.add(staticBlockPrivateId);
          const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));
          let replacement;
          const blockBody = path.node.body;
          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {
            replacement = t.inheritsComments(blockBody[0].expression, blockBody[0]);
          } else {
            replacement = template.expression.ast`(() => { ${blockBody} })()`;
          }
          path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-class-static-block\package.json

Code:
{
  "name": "@babel/plugin-transform-class-static-block",
  "version": "7.27.1",
  "description": "Transform class static blocks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-class-static-block"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.12.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1",
    "@babel/plugin-transform-class-properties": "^7.27.1",
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-class-static-block",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-class-static-block\README.md

Code:
# @babel/plugin-transform-class-static-block

> Transform class static blocks

See our website [@babel/plugin-transform-class-static-block](https://babeljs.io/docs/babel-plugin-transform-class-static-block) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-class-static-block
```

or using yarn:

```sh
yarn add @babel/plugin-transform-class-static-block --dev
```


---

File name: node_modules\@babel\plugin-transform-classes\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCompilationTargets = require("@babel/helper-compilation-targets");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
var _core = require("@babel/core");
var _globals = require("globals");
var _transformClass = require("./transformClass.js");
const getBuiltinClasses = category => Object.keys(_globals[category]).filter(name => /^[A-Z]/.test(name));
const builtinClasses = new Set([...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser")]);
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
  api.assertVersion(7);
  const {
    loose = false
  } = options;
  const setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : loose;
  const constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : loose;
  const superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : loose;
  const noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : loose;
  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
  const VISITED = new WeakSet();
  return {
    name: "transform-classes",
    visitor: {
      ExportDefaultDeclaration(path) {
        if (!path.get("declaration").isClassDeclaration()) return;
        {
          var _path$splitExportDecl;
          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require("@babel/traverse").NodePath.prototype.splitExportDeclaration;
        }
        path.splitExportDeclaration();
      },
      ClassDeclaration(path) {
        const {
          node
        } = path;
        const ref = node.id ? _core.types.cloneNode(node.id) : path.scope.generateUidIdentifier("class");
        path.replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));
      },
      ClassExpression(path, state) {
        const {
          node
        } = path;
        if (VISITED.has(node)) return;
        {
          var _path$ensureFunctionN;
          (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require("@babel/traverse").NodePath.prototype.ensureFunctionName;
        }
        const replacement = path.ensureFunctionName(supportUnicodeId);
        if (replacement && replacement.node !== node) return;
        VISITED.add(node);
        const [replacedPath] = path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {
          setClassMethods,
          constantSuper,
          superIsCallableConstructor,
          noClassCalls
        }, supportUnicodeId));
        if (replacedPath.isCallExpression()) {
          (0, _helperAnnotateAsPure.default)(replacedPath);
          const callee = replacedPath.get("callee");
          if (callee.isArrowFunctionExpression()) {
            callee.arrowFunctionToExpression();
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-classes\lib\inline-callSuper-helpers.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addCallSuperHelper;
var _core = require("@babel/core");
const helper = _core.template.statement`
  function CALL_SUPER(
    _this,
    derived,
    args,
  ) {
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;

      // core-js@3
      if (Reflect.construct.sham) return false;

      // Proxy can't be polyfilled. Every browser implemented
      // proxies before or at the same time as Reflect.construct,
      // so if they support Proxy they also support Reflect.construct.
      if (typeof Proxy === "function") return true;

      // Since Reflect.construct can't be properly polyfilled, some
      // implementations (e.g. core-js@2) don't set the correct internal slots.
      // Those polyfills don't allow us to subclass built-ins, so we need to
      // use our fallback implementation.
      try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}),);
      } catch (e) {
        return false;
      }
    }

    // Super
    derived = GET_PROTOTYPE_OF(derived);
    return POSSIBLE_CONSTRUCTOR_RETURN(
      _this,
      isNativeReflectConstruct()
        ? // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          Reflect.construct(
            derived,
            args || [],
            GET_PROTOTYPE_OF(_this).constructor,
          )
        : derived.apply(_this, args),
    );
  }
`;
const helperIDs = new WeakMap();
function addCallSuperHelper(file) {
  if (helperIDs.has(file)) {
    return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));
  }
  try {
    return file.addHelper("callSuper");
  } catch (_unused) {}
  const id = file.scope.generateUidIdentifier("callSuper");
  helperIDs.set(file, id);
  const fn = helper({
    CALL_SUPER: id,
    GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
  });
  file.path.unshiftContainer("body", [fn]);
  file.scope.registerDeclaration(file.path.get("body.0"));
  return _core.types.cloneNode(id);
}

//# sourceMappingURL=inline-callSuper-helpers.js.map


---

File name: node_modules\@babel\plugin-transform-classes\lib\transformClass.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformClass;
var _helperReplaceSupers = require("@babel/helper-replace-supers");
var _core = require("@babel/core");
var _traverse = require("@babel/traverse");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
var _inlineCallSuperHelpers = require("./inline-callSuper-helpers.js");
function buildConstructor(classRef, constructorBody, node) {
  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);
  _core.types.inherits(func, node);
  return func;
}
function transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {
  const classState = {
    parent: undefined,
    scope: undefined,
    node: undefined,
    path: undefined,
    file: undefined,
    classId: undefined,
    classRef: undefined,
    superName: null,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: undefined,
    constructorBody: undefined,
    userConstructor: undefined,
    userConstructorPath: undefined,
    hasConstructor: false,
    body: [],
    superThises: [],
    pushedInherits: false,
    pushedCreateClass: false,
    protoAlias: null,
    isLoose: false,
    dynamicKeys: new Map(),
    methods: {
      instance: {
        hasComputed: false,
        list: [],
        map: new Map()
      },
      static: {
        hasComputed: false,
        list: [],
        map: new Map()
      }
    }
  };
  const setState = newState => {
    Object.assign(classState, newState);
  };
  const findThisesVisitor = _traverse.visitors.environmentVisitor({
    ThisExpression(path) {
      classState.superThises.push(path);
    }
  });
  function createClassHelper(args) {
    return _core.types.callExpression(classState.file.addHelper("createClass"), args);
  }
  function maybeCreateConstructor() {
    const classBodyPath = classState.path.get("body");
    for (const path of classBodyPath.get("body")) {
      if (path.isClassMethod({
        kind: "constructor"
      })) return;
    }
    const params = [];
    let body;
    if (classState.isDerived) {
      body = _core.template.statement.ast`{
          super(...arguments);
        }`;
    } else {
      body = _core.types.blockStatement([]);
    }
    classBodyPath.unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
  }
  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();
    if (classState.userConstructor) {
      const {
        constructorBody,
        userConstructor,
        construct
      } = classState;
      constructorBody.body.push(...userConstructor.body.body);
      _core.types.inherits(construct, userConstructor);
      _core.types.inherits(constructorBody, userConstructor.body);
    }
    pushDescriptors();
  }
  function pushBody() {
    const classBodyPaths = classState.path.get("body.body");
    for (const path of classBodyPaths) {
      const node = path.node;
      if (path.isClassProperty() || path.isClassPrivateProperty()) {
        throw path.buildCodeFrameError("Missing class properties transform.");
      }
      if (node.decorators) {
        throw path.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
      }
      if (_core.types.isClassMethod(node)) {
        const isConstructor = node.kind === "constructor";
        const replaceSupers = new _helperReplaceSupers.default({
          methodPath: path,
          objectRef: classState.classRef,
          superRef: classState.superName,
          constantSuper: assumptions.constantSuper,
          file: classState.file,
          refToPreserve: classState.classRef
        });
        replaceSupers.replace();
        const superReturns = [];
        path.traverse(_traverse.visitors.environmentVisitor({
          ReturnStatement(path) {
            if (!path.getFunctionParent().isArrowFunctionExpression()) {
              superReturns.push(path);
            }
          }
        }));
        if (isConstructor) {
          pushConstructor(superReturns, node, path);
        } else {
          {
            var _path$ensureFunctionN;
            (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require("@babel/traverse").NodePath.prototype.ensureFunctionName;
          }
          path.ensureFunctionName(supportUnicodeId);
          let wrapped;
          if (node !== path.node) {
            wrapped = path.node;
            path.replaceWith(node);
          }
          pushMethod(node, wrapped);
        }
      }
    }
  }
  function pushDescriptors() {
    pushInheritsToBody();
    const {
      body
    } = classState;
    const props = {
      instance: null,
      static: null
    };
    for (const placement of ["static", "instance"]) {
      if (classState.methods[placement].list.length) {
        props[placement] = classState.methods[placement].list.map(desc => {
          const obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("key"), desc.key)]);
          for (const kind of ["get", "set", "value"]) {
            if (desc[kind] != null) {
              obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));
            }
          }
          return obj;
        });
      }
    }
    if (props.instance || props.static) {
      let args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()];
      let lastNonNullIndex = 0;
      for (let i = 0; i < args.length; i++) {
        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;
      }
      args = args.slice(0, lastNonNullIndex + 1);
      body.push(_core.types.returnStatement(createClassHelper(args)));
      classState.pushedCreateClass = true;
    }
  }
  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    const bareSuperNode = bareSuper.node;
    let call;
    if (assumptions.superIsCallableConstructor) {
      bareSuperNode.arguments.unshift(_core.types.thisExpression());
      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
        name: "arguments"
      })) {
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"));
      } else {
        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call"));
      }
      call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression());
    } else {
      var _bareSuperNode$argume;
      const args = [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)];
      if ((_bareSuperNode$argume = bareSuperNode.arguments) != null && _bareSuperNode$argume.length) {
        const bareSuperNodeArguments = bareSuperNode.arguments;
        if (bareSuperNodeArguments.length === 1 && _core.types.isSpreadElement(bareSuperNodeArguments[0]) && _core.types.isIdentifier(bareSuperNodeArguments[0].argument, {
          name: "arguments"
        })) {
          args.push(bareSuperNodeArguments[0].argument);
        } else {
          args.push(_core.types.arrayExpression(bareSuperNodeArguments));
        }
      }
      call = _core.types.callExpression((0, _inlineCallSuperHelpers.default)(classState.file), args);
    }
    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
      if (classState.superThises.length) {
        call = _core.types.assignmentExpression("=", thisRef(), call);
      }
      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));
    } else {
      bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
    }
  }
  function verifyConstructor() {
    if (!classState.isDerived) return;
    const path = classState.userConstructorPath;
    const body = path.get("body");
    const constructorBody = path.get("body");
    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;
    path.traverse(findThisesVisitor);
    let thisRef = function () {
      const ref = path.scope.generateDeclaredUidIdentifier("this");
      maxGuaranteedSuperBeforeIndex++;
      thisRef = () => _core.types.cloneNode(ref);
      return ref;
    };
    const buildAssertThisInitialized = function () {
      return _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]);
    };
    const bareSupers = [];
    path.traverse(_traverse.visitors.environmentVisitor({
      Super(path) {
        const {
          node,
          parentPath
        } = path;
        if (parentPath.isCallExpression({
          callee: node
        })) {
          bareSupers.unshift(parentPath);
        }
      }
    }));
    for (const bareSuper of bareSupers) {
      wrapSuperCall(bareSuper, classState.superName, thisRef, body);
      if (maxGuaranteedSuperBeforeIndex >= 0) {
        let lastParentPath;
        bareSuper.find(function (parentPath) {
          if (parentPath === constructorBody) {
            maxGuaranteedSuperBeforeIndex = Math.min(maxGuaranteedSuperBeforeIndex, lastParentPath.key);
            return true;
          }
          const {
            type
          } = parentPath;
          switch (type) {
            case "ExpressionStatement":
            case "SequenceExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "MemberExpression":
            case "CallExpression":
            case "NewExpression":
            case "VariableDeclarator":
            case "VariableDeclaration":
            case "BlockStatement":
            case "ArrayExpression":
            case "ObjectExpression":
            case "ObjectProperty":
            case "TemplateLiteral":
              lastParentPath = parentPath;
              return false;
            default:
              if (type === "LogicalExpression" && parentPath.node.left === lastParentPath.node || parentPath.isConditional() && parentPath.node.test === lastParentPath.node || type === "OptionalCallExpression" && parentPath.node.callee === lastParentPath.node || type === "OptionalMemberExpression" && parentPath.node.object === lastParentPath.node) {
                lastParentPath = parentPath;
                return false;
              }
          }
          maxGuaranteedSuperBeforeIndex = -1;
          return true;
        });
      }
    }
    const guaranteedCalls = new Set();
    for (const thisPath of classState.superThises) {
      const {
        node,
        parentPath
      } = thisPath;
      if (parentPath.isMemberExpression({
        object: node
      })) {
        thisPath.replaceWith(thisRef());
        continue;
      }
      let thisIndex;
      thisPath.find(function (parentPath) {
        if (parentPath.parentPath === constructorBody) {
          thisIndex = parentPath.key;
          return true;
        }
      });
      let exprPath = thisPath.parentPath.isSequenceExpression() ? thisPath.parentPath : thisPath;
      if (exprPath.listKey === "arguments" && (exprPath.parentPath.isCallExpression() || exprPath.parentPath.isOptionalCallExpression())) {
        exprPath = exprPath.parentPath;
      } else {
        exprPath = null;
      }
      if (maxGuaranteedSuperBeforeIndex !== -1 && thisIndex > maxGuaranteedSuperBeforeIndex || guaranteedCalls.has(exprPath)) {
        thisPath.replaceWith(thisRef());
      } else {
        if (exprPath) {
          guaranteedCalls.add(exprPath);
        }
        thisPath.replaceWith(buildAssertThisInitialized());
      }
    }
    let wrapReturn;
    if (classState.isLoose) {
      wrapReturn = returnArg => {
        const thisExpr = buildAssertThisInitialized();
        return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
      };
    } else {
      wrapReturn = returnArg => {
        const returnParams = [thisRef()];
        if (returnArg != null) {
          returnParams.push(returnArg);
        }
        return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), returnParams);
      };
    }
    const bodyPaths = body.get("body");
    const guaranteedSuperBeforeFinish = maxGuaranteedSuperBeforeIndex !== -1 && maxGuaranteedSuperBeforeIndex < bodyPaths.length;
    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
      body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : buildAssertThisInitialized()));
    }
    for (const returnPath of classState.superReturns) {
      returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
    }
  }
  function pushMethod(node, wrapped) {
    if (node.kind === "method") {
      if (processMethod(node)) return;
    }
    const placement = node.static ? "static" : "instance";
    const methods = classState.methods[placement];
    const descKey = node.kind === "method" ? "value" : node.kind;
    const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);
    methods.hasComputed = !_core.types.isStringLiteral(key);
    const fn = wrapped != null ? wrapped : _core.types.toExpression(node);
    let descriptor;
    if (!methods.hasComputed && methods.map.has(key.value)) {
      descriptor = methods.map.get(key.value);
      descriptor[descKey] = fn;
      if (descKey === "value") {
        descriptor.get = null;
        descriptor.set = null;
      } else {
        descriptor.value = null;
      }
    } else {
      descriptor = {
        key: key,
        [descKey]: fn
      };
      methods.list.push(descriptor);
      if (!methods.hasComputed) {
        methods.map.set(key.value, descriptor);
      }
    }
  }
  function processMethod(node) {
    if (assumptions.setClassMethods && !node.decorators) {
      let {
        classRef
      } = classState;
      if (!node.static) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }
      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));
      const func = _core.types.functionExpression(node.id, node.params, node.body, node.generator, node.async);
      _core.types.inherits(func, node);
      const expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));
      _core.types.inheritsComments(expr, node);
      classState.body.push(expr);
      return true;
    }
    return false;
  }
  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({
        protoAlias: classState.scope.generateUidIdentifier("proto")
      });
      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype"));
      const protoDeclaration = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);
      classState.body.push(protoDeclaration);
    }
  }
  function pushConstructor(superReturns, method, path) {
    setState({
      userConstructorPath: path,
      userConstructor: method,
      hasConstructor: true,
      superReturns
    });
    const {
      construct
    } = classState;
    _core.types.inheritsComments(construct, method);
    construct.params = method.params;
    _core.types.inherits(construct.body, method.body);
    construct.body.directives = method.body.directives;
    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
      pushDescriptors();
    }
    pushInheritsToBody();
  }
  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    classState.pushedInherits = true;
    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));
  }
  function extractDynamicKeys() {
    const {
      dynamicKeys,
      node,
      scope
    } = classState;
    for (const elem of node.body.body) {
      if (!_core.types.isClassMethod(elem) || !elem.computed) continue;
      if (scope.isPure(elem.key, true)) continue;
      const id = scope.generateUidIdentifierBasedOnNode(elem.key);
      dynamicKeys.set(id.name, elem.key);
      elem.key = id;
    }
  }
  function setupClosureParamsArgs() {
    const {
      superName,
      dynamicKeys
    } = classState;
    const closureParams = [];
    const closureArgs = [];
    if (classState.isDerived) {
      let arg = _core.types.cloneNode(superName);
      if (classState.extendsNative) {
        arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
        (0, _helperAnnotateAsPure.default)(arg);
      }
      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
      closureParams.push(param);
      closureArgs.push(arg);
      setState({
        superName: _core.types.cloneNode(param)
      });
    }
    for (const [name, value] of dynamicKeys) {
      closureParams.push(_core.types.identifier(name));
      closureArgs.push(value);
    }
    return {
      closureParams,
      closureArgs
    };
  }
  function classTransformer(path, file, builtinClasses, isLoose) {
    setState({
      parent: path.parent,
      scope: path.scope,
      node: path.node,
      path,
      file,
      isLoose
    });
    setState({
      classId: classState.node.id,
      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: _core.types.blockStatement([])
    });
    setState({
      extendsNative: _core.types.isIdentifier(classState.superName) && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
    });
    const {
      classRef,
      node,
      constructorBody
    } = classState;
    setState({
      construct: buildConstructor(classRef, constructorBody, node)
    });
    extractDynamicKeys();
    const {
      body
    } = classState;
    const {
      closureParams,
      closureArgs
    } = setupClosureParamsArgs();
    buildBody();
    if (!assumptions.noClassCalls) {
      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));
    }
    const isStrict = path.isInStrictMode();
    let constructorOnly = body.length === 0;
    if (constructorOnly && !isStrict) {
      for (const param of classState.construct.params) {
        if (!_core.types.isIdentifier(param)) {
          constructorOnly = false;
          break;
        }
      }
    }
    const directives = constructorOnly ? classState.construct.body.directives : [];
    if (!isStrict) {
      directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
    }
    if (constructorOnly) {
      const expr = _core.types.toExpression(classState.construct);
      return classState.isLoose ? expr : createClassHelper([expr]);
    }
    if (!classState.pushedCreateClass) {
      body.push(_core.types.returnStatement(classState.isLoose ? _core.types.cloneNode(classState.classRef) : createClassHelper([_core.types.cloneNode(classState.classRef)])));
    }
    body.unshift(classState.construct);
    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));
    return _core.types.callExpression(container, closureArgs);
  }
  return classTransformer(path, file, builtinClasses, isLoose);
}

//# sourceMappingURL=transformClass.js.map


---

File name: node_modules\@babel\plugin-transform-classes\package.json

Code:
{
  "name": "@babel/plugin-transform-classes",
  "version": "7.27.7",
  "description": "Compile ES2015 classes to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-classes"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-classes",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.3",
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-replace-supers": "^7.27.1",
    "@babel/traverse": "^7.27.7",
    "globals": "^11.1.0"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-classes\README.md

Code:
# @babel/plugin-transform-classes

> Compile ES2015 classes to ES5

See our website [@babel/plugin-transform-classes](https://babeljs.io/docs/babel-plugin-transform-classes) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-classes
```

or using yarn:

```sh
yarn add @babel/plugin-transform-classes --dev
```


---

File name: node_modules\@babel\plugin-transform-computed-properties\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@babel/core");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _template = require("@babel/template");
{
  var DefineAccessorHelper = _template.default.expression.ast`
    function (type, obj, key, fn) {
      var desc = { configurable: true, enumerable: true };
      desc[type] = fn;
      return Object.defineProperty(obj, key, desc);
    }
  `;
  DefineAccessorHelper._compact = true;
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const setComputedProperties = (_api$assumption = api.assumption("setComputedProperties")) != null ? _api$assumption : options.loose;
  const pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;
  function buildDefineAccessor(state, obj, prop) {
    const type = prop.kind;
    const key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;
    const fn = getValue(prop);
    {
      let helper;
      if (state.availableHelper("defineAccessor")) {
        helper = state.addHelper("defineAccessor");
      } else {
        const file = state.file;
        helper = file.get("fallbackDefineAccessorHelper");
        if (!helper) {
          const id = file.scope.generateUidIdentifier("defineAccessor");
          file.scope.push({
            id,
            init: DefineAccessorHelper
          });
          file.set("fallbackDefineAccessorHelper", helper = id);
        }
        helper = _core.types.cloneNode(helper);
      }
      return _core.types.callExpression(helper, [_core.types.stringLiteral(type), obj, key, fn]);
    }
  }
  function getValue(prop) {
    if (_core.types.isObjectProperty(prop)) {
      return prop.value;
    } else if (_core.types.isObjectMethod(prop)) {
      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
    }
  }
  function pushAssign(objId, prop, body) {
    body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));
  }
  function pushComputedPropsLoose(info) {
    const {
      computedProps,
      state,
      initPropExpression,
      objId,
      body
    } = info;
    for (const prop of computedProps) {
      if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
        if (computedProps.length === 1) {
          return buildDefineAccessor(state, initPropExpression, prop);
        } else {
          body.push(_core.types.expressionStatement(buildDefineAccessor(state, _core.types.cloneNode(objId), prop)));
        }
      } else {
        pushAssign(_core.types.cloneNode(objId), prop, body);
      }
    }
  }
  function pushComputedPropsSpec(info) {
    const {
      objId,
      body,
      computedProps,
      state
    } = info;
    const CHUNK_LENGTH_CAP = 10;
    let currentChunk = null;
    const computedPropsChunks = [];
    for (const prop of computedProps) {
      if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {
        currentChunk = [];
        computedPropsChunks.push(currentChunk);
      }
      currentChunk.push(prop);
    }
    for (const chunk of computedPropsChunks) {
      const single = computedPropsChunks.length === 1;
      let node = single ? info.initPropExpression : _core.types.cloneNode(objId);
      for (const prop of chunk) {
        if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
          node = buildDefineAccessor(info.state, node, prop);
        } else {
          node = _core.types.callExpression(state.addHelper("defineProperty"), [node, _core.types.toComputedKey(prop), getValue(prop)]);
        }
      }
      if (single) return node;
      body.push(_core.types.expressionStatement(node));
    }
  }
  return {
    name: "transform-computed-properties",
    visitor: {
      ObjectExpression: {
        exit(path, state) {
          const {
            node,
            parent,
            scope
          } = path;
          let hasComputed = false;
          for (const prop of node.properties) {
            hasComputed = prop.computed === true;
            if (hasComputed) break;
          }
          if (!hasComputed) return;
          const initProps = [];
          const computedProps = [];
          let foundComputed = false;
          for (const prop of node.properties) {
            if (_core.types.isSpreadElement(prop)) {
              continue;
            }
            if (prop.computed) {
              foundComputed = true;
            }
            if (foundComputed) {
              computedProps.push(prop);
            } else {
              initProps.push(prop);
            }
          }
          const objId = scope.generateUidIdentifierBasedOnNode(parent);
          const initPropExpression = _core.types.objectExpression(initProps);
          const body = [];
          body.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(objId, initPropExpression)]));
          const single = pushComputedProps({
            scope,
            objId,
            body,
            computedProps,
            initPropExpression,
            state
          });
          if (single) {
            path.replaceWith(single);
          } else {
            if (setComputedProperties) {
              body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));
            }
            path.replaceWithMultiple(body);
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-computed-properties\package.json

Code:
{
  "name": "@babel/plugin-transform-computed-properties",
  "version": "7.27.1",
  "description": "Compile ES2015 computed properties to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-computed-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-computed-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/template": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-computed-properties\README.md

Code:
# @babel/plugin-transform-computed-properties

> Compile ES2015 computed properties to ES5

See our website [@babel/plugin-transform-computed-properties](https://babeljs.io/docs/babel-plugin-transform-computed-properties) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-computed-properties
```

or using yarn:

```sh
yarn add @babel/plugin-transform-computed-properties --dev
```


---

File name: node_modules\@babel\plugin-transform-destructuring\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');
var core = require('@babel/core');

function isPureVoid(node) {
  return core.types.isUnaryExpression(node) && node.operator === "void" && core.types.isPureish(node.argument);
}
function unshiftForXStatementBody(statementPath, newStatements) {
  statementPath.ensureBlock();
  const {
    scope,
    node
  } = statementPath;
  const bodyScopeBindings = statementPath.get("body").scope.bindings;
  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(name => scope.hasBinding(name));
  if (hasShadowedBlockScopedBindings) {
    node.body = core.types.blockStatement([...newStatements, node.body]);
  } else {
    node.body.body.unshift(...newStatements);
  }
}
function hasArrayRest(pattern) {
  return pattern.elements.some(elem => core.types.isRestElement(elem));
}
function hasObjectRest(pattern) {
  return pattern.properties.some(prop => core.types.isRestElement(prop));
}
const STOP_TRAVERSAL = {};
const arrayUnpackVisitor = (node, ancestors, state) => {
  if (!ancestors.length) {
    return;
  }
  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {
    state.deopt = true;
    throw STOP_TRAVERSAL;
  }
};
class DestructuringTransformer {
  constructor(opts) {
    this.blockHoist = void 0;
    this.operator = void 0;
    this.arrayRefSet = void 0;
    this.nodes = void 0;
    this.scope = void 0;
    this.kind = void 0;
    this.iterableIsArray = void 0;
    this.arrayLikeIsIterable = void 0;
    this.objectRestNoSymbols = void 0;
    this.useBuiltIns = void 0;
    this.addHelper = void 0;
    this.blockHoist = opts.blockHoist;
    this.operator = opts.operator;
    this.arrayRefSet = new Set();
    this.nodes = opts.nodes || [];
    this.scope = opts.scope;
    this.kind = opts.kind;
    this.iterableIsArray = opts.iterableIsArray;
    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
    this.objectRestNoSymbols = opts.objectRestNoSymbols;
    this.useBuiltIns = opts.useBuiltIns;
    this.addHelper = opts.addHelper;
  }
  getExtendsHelper() {
    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : this.addHelper("extends");
  }
  buildVariableAssignment(id, init) {
    let op = this.operator;
    if (core.types.isMemberExpression(id) || core.types.isOptionalMemberExpression(id)) op = "=";
    let node;
    if (op) {
      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
    } else {
      let nodeInit;
      if (this.kind === "const" && init === null) {
        nodeInit = this.scope.buildUndefinedNode();
      } else {
        nodeInit = core.types.cloneNode(init);
      }
      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);
    }
    node._blockHoist = this.blockHoist;
    return node;
  }
  buildVariableDeclaration(id, init) {
    const declar = core.types.variableDeclaration("var", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);
    declar._blockHoist = this.blockHoist;
    return declar;
  }
  push(id, _init) {
    const init = core.types.cloneNode(_init);
    if (core.types.isObjectPattern(id)) {
      this.pushObjectPattern(id, init);
    } else if (core.types.isArrayPattern(id)) {
      this.pushArrayPattern(id, init);
    } else if (core.types.isAssignmentPattern(id)) {
      this.pushAssignmentPattern(id, init);
    } else {
      this.nodes.push(this.buildVariableAssignment(id, init));
    }
  }
  toArray(node, count) {
    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {
      return node;
    } else {
      const {
        scope,
        arrayLikeIsIterable
      } = this;
      if (core.types.isIdentifier(node)) {
        const binding = scope.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }
      if (core.types.isArrayExpression(node)) {
        return node;
      }
      if (core.types.isIdentifier(node, {
        name: "arguments"
      })) {
        return core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
      }
      let helperName;
      const args = [node];
      if (typeof count === "number") {
        args.push(core.types.numericLiteral(count));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(scope.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return core.types.callExpression(scope.path.hub.addHelper(helperName), args);
    }
  }
  pushAssignmentPattern({
    left,
    right
  }, valueRef) {
    if (isPureVoid(valueRef)) {
      this.push(left, right);
      return;
    }
    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression("===", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));
    if (core.types.isPattern(left)) {
      let patternId;
      let node;
      if (this.kind === "const" || this.kind === "let") {
        patternId = this.scope.generateUidIdentifier(tempId.name);
        node = this.buildVariableDeclaration(patternId, tempConditional);
      } else {
        patternId = tempId;
        node = core.types.expressionStatement(core.types.assignmentExpression("=", core.types.cloneNode(tempId), tempConditional));
      }
      this.nodes.push(node);
      this.push(left, patternId);
    } else {
      this.nodes.push(this.buildVariableAssignment(left, tempConditional));
    }
  }
  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);
    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
  }
  pushObjectProperty(prop, propRef) {
    if (core.types.isLiteral(prop.key)) prop.computed = true;
    const pattern = prop.value;
    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);
    if (core.types.isPattern(pattern)) {
      this.push(pattern, objRef);
    } else {
      this.nodes.push(this.buildVariableAssignment(pattern, objRef));
    }
  }
  pushObjectPattern(pattern, objRef) {
    if (!pattern.properties.length) {
      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), isPureVoid(objRef) ? [] : [objRef])));
      return;
    }
    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
      objRef = temp;
    }
    if (hasObjectRest(pattern)) {
      let copiedPattern;
      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (core.types.isRestElement(prop)) {
          break;
        }
        const key = prop.key;
        if (prop.computed && !this.scope.isPure(key)) {
          const name = this.scope.generateUidIdentifierBasedOnNode(key);
          this.nodes.push(this.buildVariableDeclaration(name, key));
          if (!copiedPattern) {
            copiedPattern = pattern = Object.assign({}, pattern, {
              properties: pattern.properties.slice()
            });
          }
          copiedPattern.properties[i] = Object.assign({}, prop, {
            key: name
          });
        }
      }
    }
    for (let i = 0; i < pattern.properties.length; i++) {
      const prop = pattern.properties[i];
      if (core.types.isRestElement(prop)) {
        this.pushObjectRest(pattern, objRef, prop, i);
      } else {
        this.pushObjectProperty(prop, objRef);
      }
    }
  }
  canUnpackArrayPattern(pattern, arr) {
    if (!core.types.isArrayExpression(arr)) return false;
    if (pattern.elements.length > arr.elements.length) return;
    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {
      return false;
    }
    for (const elem of pattern.elements) {
      if (!elem) return false;
      if (core.types.isMemberExpression(elem)) return false;
    }
    for (const elem of arr.elements) {
      if (core.types.isSpreadElement(elem)) return false;
      if (core.types.isCallExpression(elem)) return false;
      if (core.types.isMemberExpression(elem)) return false;
    }
    const bindings = core.types.getBindingIdentifiers(pattern);
    const state = {
      deopt: false,
      bindings
    };
    try {
      core.types.traverse(arr, arrayUnpackVisitor, state);
    } catch (e) {
      if (e !== STOP_TRAVERSAL) throw e;
    }
    return !state.deopt;
  }
  pushUnpackedArrayPattern(pattern, arr) {
    const holeToUndefined = el => el != null ? el : this.scope.buildUndefinedNode();
    for (let i = 0; i < pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      if (core.types.isRestElement(elem)) {
        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));
      } else {
        this.push(elem, holeToUndefined(arr.elements[i]));
      }
    }
  }
  pushArrayPattern(pattern, arrayRef) {
    if (arrayRef === null) {
      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [])));
      return;
    }
    if (!pattern.elements) return;
    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
      this.pushUnpackedArrayPattern(pattern, arrayRef);
      return;
    }
    const count = !hasArrayRest(pattern) && pattern.elements.length;
    const toArray = this.toArray(arrayRef, count);
    if (core.types.isIdentifier(toArray)) {
      arrayRef = toArray;
    } else {
      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
      this.arrayRefSet.add(arrayRef.name);
      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
    }
    for (let i = 0; i < pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      if (!elem) continue;
      let elemRef;
      if (core.types.isRestElement(elem)) {
        elemRef = this.toArray(arrayRef);
        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier("slice")), [core.types.numericLiteral(i)]);
        this.push(elem.argument, elemRef);
      } else {
        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);
        this.push(elem, elemRef);
      }
    }
  }
  init(pattern, ref) {
    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {
      const memo = this.scope.maybeGenerateMemoised(ref, true);
      if (memo) {
        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));
        ref = memo;
      }
    }
    this.push(pattern, ref);
    return this.nodes;
  }
}
function buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
  const keys = [];
  let allLiteral = true;
  let hasTemplateLiteral = false;
  for (let i = 0; i < excludedKeys.length; i++) {
    const prop = excludedKeys[i];
    const key = prop.key;
    if (core.types.isIdentifier(key) && !prop.computed) {
      keys.push(core.types.stringLiteral(key.name));
    } else if (core.types.isTemplateLiteral(key)) {
      keys.push(core.types.cloneNode(key));
      hasTemplateLiteral = true;
    } else if (core.types.isLiteral(key)) {
      keys.push(core.types.stringLiteral(String(key.value)));
    } else if (core.types.isPrivateName(key)) ; else {
      keys.push(core.types.cloneNode(key));
      allLiteral = false;
    }
  }
  let value;
  if (keys.length === 0) {
    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : addHelper("extends");
    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(addHelper("objectDestructuringEmpty"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])]);
  } else {
    let keyExpression = core.types.arrayExpression(keys);
    if (!allLiteral) {
      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier("map")), [addHelper("toPropertyKey")]);
    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {
      const programScope = scope.getProgramParent();
      const id = programScope.generateUidIdentifier("excluded");
      programScope.push({
        id,
        init: keyExpression,
        kind: "const"
      });
      keyExpression = core.types.cloneNode(id);
    }
    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [core.types.cloneNode(objRef), keyExpression]);
  }
  return value;
}
function convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
  const {
    node,
    scope
  } = path;
  const nodeKind = node.kind;
  const nodeLoc = node.loc;
  const nodes = [];
  for (let i = 0; i < node.declarations.length; i++) {
    const declar = node.declarations[i];
    const patternId = declar.init;
    const pattern = declar.id;
    const destructuring = new DestructuringTransformer({
      blockHoist: node._blockHoist,
      nodes: nodes,
      scope: scope,
      kind: node.kind,
      iterableIsArray,
      arrayLikeIsIterable,
      useBuiltIns,
      objectRestNoSymbols,
      addHelper
    });
    if (core.types.isPattern(pattern)) {
      destructuring.init(pattern, patternId);
      if (+i !== node.declarations.length - 1) {
        core.types.inherits(nodes[nodes.length - 1], declar);
      }
    } else {
      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
    }
  }
  let tail = null;
  let nodesOut = [];
  for (const node of nodes) {
    if (core.types.isVariableDeclaration(node)) {
      if (tail !== null) {
        tail.declarations.push(...node.declarations);
        continue;
      } else {
        node.kind = nodeKind;
        tail = node;
      }
    } else {
      tail = null;
    }
    if (!node.loc) {
      node.loc = nodeLoc;
    }
    nodesOut.push(node);
  }
  if (nodesOut.length === 2 && core.types.isVariableDeclaration(nodesOut[0]) && core.types.isExpressionStatement(nodesOut[1]) && core.types.isCallExpression(nodesOut[1].expression) && nodesOut[0].declarations.length === 1) {
    const expr = nodesOut[1].expression;
    expr.arguments = [nodesOut[0].declarations[0].init];
    nodesOut = [expr];
  } else {
    if (core.types.isForStatement(path.parent, {
      init: node
    }) && !nodesOut.some(v => core.types.isVariableDeclaration(v))) {
      for (let i = 0; i < nodesOut.length; i++) {
        const node = nodesOut[i];
        if (core.types.isExpressionStatement(node)) {
          nodesOut[i] = node.expression;
        }
      }
    }
  }
  if (nodesOut.length === 1) {
    path.replaceWith(nodesOut[0]);
  } else {
    path.replaceWithMultiple(nodesOut);
  }
  scope.crawl();
}
function convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
  const {
    node,
    scope,
    parentPath
  } = path;
  const nodes = [];
  const destructuring = new DestructuringTransformer({
    operator: node.operator,
    scope: scope,
    nodes: nodes,
    arrayLikeIsIterable,
    iterableIsArray,
    objectRestNoSymbols,
    useBuiltIns,
    addHelper
  });
  let ref;
  if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {
    ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
    nodes.push(core.types.variableDeclaration("var", [core.types.variableDeclarator(ref, node.right)]));
    if (core.types.isArrayExpression(node.right)) {
      destructuring.arrayRefSet.add(ref.name);
    }
  }
  destructuring.init(node.left, ref || node.right);
  if (ref) {
    if (parentPath.isArrowFunctionExpression()) {
      path.replaceWith(core.types.blockStatement([]));
      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));
    } else {
      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));
    }
  }
  path.replaceWithMultiple(nodes);
  scope.crawl();
}

function variableDeclarationHasPattern(node) {
  for (const declar of node.declarations) {
    if (core.types.isPattern(declar.id)) {
      return true;
    }
  }
  return false;
}
var index = helperPluginUtils.declare((api, options) => {
  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;
  api.assertVersion(7);
  const {
    useBuiltIns = false
  } = options;
  const iterableIsArray = (_ref = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose) != null ? _ref : false;
  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable")) != null ? _ref2 : false;
  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;
  return {
    name: "transform-destructuring",
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasPattern(declaration.node)) return;
        {
          var _path$splitExportDecl;
          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require("@babel/traverse").NodePath.prototype.splitExportDeclaration;
        }
        path.splitExportDeclaration();
      },
      ForXStatement(path) {
        const {
          node,
          scope
        } = path;
        const left = node.left;
        if (core.types.isPattern(left)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = core.types.variableDeclaration("var", [core.types.variableDeclarator(temp)]);
          path.ensureBlock();
          const statementBody = path.node.body.body;
          const nodes = [];
          if (statementBody.length === 0 && path.isCompletionRecord()) {
            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
          }
          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, core.types.cloneNode(temp))));
          unshiftForXStatementBody(path, nodes);
          scope.crawl();
          return;
        }
        if (!core.types.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!core.types.isPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: left.kind,
          scope: scope,
          nodes: nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name => this.addHelper(name)
        });
        destructuring.init(pattern, key);
        unshiftForXStatementBody(path, nodes);
        scope.crawl();
      },
      CatchClause({
        node,
        scope
      }) {
        const pattern = node.param;
        if (!core.types.isPattern(pattern)) return;
        const ref = scope.generateUidIdentifier("ref");
        node.param = ref;
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: "let",
          scope: scope,
          nodes: nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name => this.addHelper(name)
        });
        destructuring.init(pattern, ref);
        node.body.body = [...nodes, ...node.body.body];
        scope.crawl();
      },
      AssignmentExpression(path, state) {
        if (!core.types.isPattern(path.node.left)) return;
        convertAssignmentExpression(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
      },
      VariableDeclaration(path, state) {
        const {
          node,
          parent
        } = path;
        if (core.types.isForXStatement(parent)) return;
        if (!parent || !path.container) return;
        if (!variableDeclarationHasPattern(node)) return;
        convertVariableDeclaration(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
      }
    }
  };
});

exports.buildObjectExcludingKeys = buildObjectExcludingKeys;
exports.default = index;
exports.unshiftForXStatementBody = unshiftForXStatementBody;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-destructuring\package.json

Code:
{
  "name": "@babel/plugin-transform-destructuring",
  "version": "7.27.7",
  "description": "Compile ES2015 destructuring to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-destructuring"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-destructuring",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.7"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-destructuring\README.md

Code:
# @babel/plugin-transform-destructuring

> Compile ES2015 destructuring to ES5

See our website [@babel/plugin-transform-destructuring](https://babeljs.io/docs/babel-plugin-transform-destructuring) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-destructuring
```

or using yarn:

```sh
yarn add @babel/plugin-transform-destructuring --dev
```


---

File name: node_modules\@babel\plugin-transform-dotall-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-dotall-regex",
    feature: "dotAllFlag"
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-dotall-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-dotall-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using the `s` (`dotAll`) flag to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-dotall-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions",
    "dotall"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-dotall-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-dotall-regex\README.md

Code:
# @babel/plugin-transform-dotall-regex

> Compile regular expressions using the `s` (`dotAll`) flag to ES5.

See our website [@babel/plugin-transform-dotall-regex](https://babeljs.io/docs/babel-plugin-transform-dotall-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-dotall-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-dotall-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-duplicate-keys\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
function getName(key) {
  if (_core.types.isIdentifier(key)) {
    return key.name;
  }
  return key.value.toString();
}
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-duplicate-keys",
    visitor: {
      ObjectExpression(path) {
        const {
          node
        } = path;
        const plainProps = node.properties.filter(prop => !_core.types.isSpreadElement(prop) && !prop.computed);
        const alreadySeenData = Object.create(null);
        const alreadySeenGetters = Object.create(null);
        const alreadySeenSetters = Object.create(null);
        for (const prop of plainProps) {
          const name = getName(prop.key);
          let isDuplicate = false;
          switch (prop.kind) {
            case "get":
              if (alreadySeenData[name] || alreadySeenGetters[name]) {
                isDuplicate = true;
              }
              alreadySeenGetters[name] = true;
              break;
            case "set":
              if (alreadySeenData[name] || alreadySeenSetters[name]) {
                isDuplicate = true;
              }
              alreadySeenSetters[name] = true;
              break;
            default:
              if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                isDuplicate = true;
              }
              alreadySeenData[name] = true;
          }
          if (isDuplicate) {
            prop.computed = true;
            prop.key = _core.types.stringLiteral(name);
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-duplicate-keys\package.json

Code:
{
  "name": "@babel/plugin-transform-duplicate-keys",
  "version": "7.27.1",
  "description": "Compile objects with duplicate keys to valid strict ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-duplicate-keys"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-duplicate-keys",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-duplicate-keys\README.md

Code:
# @babel/plugin-transform-duplicate-keys

> Compile objects with duplicate keys to valid strict ES5

See our website [@babel/plugin-transform-duplicate-keys](https://babeljs.io/docs/babel-plugin-transform-duplicate-keys) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-duplicate-keys
```

or using yarn:

```sh
yarn add @babel/plugin-transform-duplicate-keys --dev
```


---

File name: node_modules\@babel\plugin-transform-duplicate-named-capturing-groups-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
  const {
    runtime
  } = options;
  if (runtime !== undefined && typeof runtime !== "boolean") {
    throw new Error("The 'runtime' option must be boolean");
  }
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-duplicate-named-capturing-groups-regex",
    feature: "duplicateNamedCaptureGroups",
    options: {
      runtime
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-duplicate-named-capturing-groups-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-duplicate-named-capturing-groups-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using duplicate named groups to index-based groups.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-duplicate-named-capturing-groups-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-duplicate-named-capturing-groups-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "core-js": "^3.30.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-duplicate-named-capturing-groups-regex\README.md

Code:
# @babel/plugin-transform-duplicate-named-capturing-groups-regex

> Compile regular expressions using duplicate named groups to index-based groups.

See our website [@babel/plugin-transform-duplicate-named-capturing-groups-regex](https://babeljs.io/docs/babel-plugin-transform-duplicate-named-capturing-groups-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-duplicate-named-capturing-groups-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-duplicate-named-capturing-groups-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-dynamic-import\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
const SUPPORTED_MODULES = new Set(["commonjs", "amd", "systemjs"]);
const MODULES_NOT_FOUND = `\
@babel/plugin-transform-dynamic-import depends on a modules
transform plugin. Supported plugins are:
 - @babel/plugin-transform-modules-commonjs ^7.4.0
 - @babel/plugin-transform-modules-amd ^7.4.0
 - @babel/plugin-transform-modules-systemjs ^7.4.0

If you are using Webpack or Rollup and thus don't want
Babel to transpile your imports and exports, you can use
the @babel/plugin-syntax-dynamic-import plugin and let your
bundler handle dynamic imports.
`;
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-dynamic-import",
    manipulateOptions: (_, parser) => parser.plugins.push("dynamicImport"),
    pre() {
      this.file.set("@babel/plugin-proposal-dynamic-import", "7.27.1");
    },
    visitor: {
      Program() {
        const modules = this.file.get("@babel/plugin-transform-modules-*");
        if (!SUPPORTED_MODULES.has(modules)) {
          throw new Error(MODULES_NOT_FOUND);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-dynamic-import\package.json

Code:
{
  "name": "@babel/plugin-transform-dynamic-import",
  "version": "7.27.1",
  "description": "Transform import() expressions",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-dynamic-import"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-dynamic-import\README.md

Code:
# @babel/plugin-transform-dynamic-import

> Transform import() expressions

See our website [@babel/plugin-transform-dynamic-import](https://babeljs.io/docs/babel-plugin-transform-dynamic-import) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-dynamic-import
```

or using yarn:

```sh
yarn add @babel/plugin-transform-dynamic-import --dev
```


---

File name: node_modules\@babel\plugin-transform-exponentiation-operator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    types: t,
    template
  } = api;
  function build(left, right) {
    return t.callExpression(t.memberExpression(t.identifier("Math"), t.identifier("pow")), [left, right]);
  }
  function maybeMemoize(node, scope) {
    if (scope.isStatic(node)) {
      return {
        assign: node,
        ref: t.cloneNode(node)
      };
    }
    if (scope.path.isPattern()) {
      return null;
    }
    const id = scope.generateUidIdentifierBasedOnNode(node);
    scope.push({
      id
    });
    return {
      assign: t.assignmentExpression("=", t.cloneNode(id), node),
      ref: t.cloneNode(id)
    };
  }
  return {
    name: "transform-exponentiation-operator",
    visitor: {
      AssignmentExpression(path) {
        const {
          node,
          scope
        } = path;
        if (node.operator !== "**=") return;
        if (t.isMemberExpression(node.left)) {
          let member1;
          let member2;
          const object = maybeMemoize(node.left.object, scope);
          if (!object) {
            path.replaceWith(template.expression.ast`(() => ${path.node})()`);
            return;
          }
          const {
            property,
            computed
          } = node.left;
          if (computed) {
            const prop = maybeMemoize(property, scope);
            member1 = t.memberExpression(object.assign, prop.assign, true);
            member2 = t.memberExpression(object.ref, prop.ref, true);
          } else {
            member1 = t.memberExpression(object.assign, property, false);
            member2 = t.memberExpression(object.ref, t.cloneNode(property), false);
          }
          path.replaceWith(t.assignmentExpression("=", member1, build(member2, node.right)));
        } else {
          path.replaceWith(t.assignmentExpression("=", node.left, build(t.cloneNode(node.left), node.right)));
        }
      },
      BinaryExpression(path) {
        const {
          node
        } = path;
        if (node.operator === "**") {
          path.replaceWith(build(node.left, node.right));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-exponentiation-operator\package.json

Code:
{
  "name": "@babel/plugin-transform-exponentiation-operator",
  "version": "7.27.1",
  "description": "Compile exponentiation operator to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-exponentiation-operator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-exponentiation-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-exponentiation-operator\README.md

Code:
# @babel/plugin-transform-exponentiation-operator

> Compile exponentiation operator to ES5

See our website [@babel/plugin-transform-exponentiation-operator](https://babeljs.io/docs/babel-plugin-transform-exponentiation-operator) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-exponentiation-operator
```

or using yarn:

```sh
yarn add @babel/plugin-transform-exponentiation-operator --dev
```


---

File name: node_modules\@babel\plugin-transform-export-namespace-from\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-export-namespace-from",
    manipulateOptions: (_, parser) => parser.plugins.push("exportNamespaceFrom"),
    visitor: {
      ExportNamedDeclaration(path) {
        var _exported$name;
        const {
          node,
          scope
        } = path;
        const {
          specifiers
        } = node;
        const index = _core.types.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
        if (!_core.types.isExportNamespaceSpecifier(specifiers[index])) return;
        const nodes = [];
        if (index === 1) {
          nodes.push(_core.types.exportNamedDeclaration(null, [specifiers.shift()], node.source));
        }
        const specifier = specifiers.shift();
        const {
          exported
        } = specifier;
        const uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
        nodes.push(_core.types.importDeclaration([_core.types.importNamespaceSpecifier(uid)], _core.types.cloneNode(node.source)), _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(uid), exported)]));
        if (node.specifiers.length >= 1) {
          nodes.push(node);
        }
        const [importDeclaration] = path.replaceWithMultiple(nodes);
        path.scope.registerDeclaration(importDeclaration);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-export-namespace-from\package.json

Code:
{
  "name": "@babel/plugin-transform-export-namespace-from",
  "version": "7.27.1",
  "description": "Compile export namespace to ES2015",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-export-namespace-from"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-export-namespace-from",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-export-namespace-from\README.md

Code:
# @babel/plugin-transform-export-namespace-from

> Compile export namespace to ES2015

See our website [@babel/plugin-transform-export-namespace-from](https://babeljs.io/docs/babel-plugin-transform-export-namespace-from) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-export-namespace-from
```

or using yarn:

```sh
yarn add @babel/plugin-transform-export-namespace-from --dev
```


---

File name: node_modules\@babel\plugin-transform-for-of\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _noHelperImplementation = require("./no-helper-implementation.js");
var _helperSkipTransparentExpressionWrappers = require("@babel/helper-skip-transparent-expression-wrappers");
function buildLoopBody(path, declar, newBody) {
  let block;
  const bodyPath = path.get("body");
  const body = newBody != null ? newBody : bodyPath.node;
  if (_core.types.isBlockStatement(body) && Object.keys(path.getBindingIdentifiers()).some(id => bodyPath.scope.hasOwnBinding(id))) {
    block = _core.types.blockStatement([declar, body]);
  } else {
    block = _core.types.toBlock(body);
    block.body.unshift(declar);
  }
  return block;
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _options$assumeArray, _options$allowArrayLi, _api$assumption;
  api.assertVersion(7);
  {
    const {
      assumeArray,
      allowArrayLike,
      loose
    } = options;
    if (loose === true && assumeArray === true) {
      throw new Error(`The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`);
    }
    if (assumeArray === true && allowArrayLike === true) {
      throw new Error(`The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of`);
    }
    {
      if (allowArrayLike && /^7\.\d\./.test(api.version)) {
        throw new Error(`The allowArrayLike is only supported when using @babel/core@^7.10.0`);
      }
    }
  }
  const iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
  const skipIteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;
  if (iterableIsArray && arrayLikeIsIterable) {
    throw new Error(`The "iterableIsArray" and "arrayLikeIsIterable" assumptions are not compatible.`);
  }
  if (iterableIsArray) {
    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement(path) {
          const {
            scope
          } = path;
          const {
            left,
            await: isAwait
          } = path.node;
          if (isAwait) {
            return;
          }
          const right = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(path.node.right);
          const i = scope.generateUidIdentifier("i");
          let array = scope.maybeGenerateMemoised(right, true);
          if (!array && _core.types.isIdentifier(right) && path.get("body").scope.hasOwnBinding(right.name)) {
            array = scope.generateUidIdentifier("arr");
          }
          const inits = [_core.types.variableDeclarator(i, _core.types.numericLiteral(0))];
          if (array) {
            inits.push(_core.types.variableDeclarator(array, right));
          } else {
            array = right;
          }
          const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), true);
          let assignment;
          if (_core.types.isVariableDeclaration(left)) {
            assignment = left;
            assignment.declarations[0].init = item;
          } else {
            assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
          }
          path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), buildLoopBody(path, assignment)));
        }
      }
    };
  }
  const buildForOfArray = (0, _core.template)`
    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;
  `;
  const buildForOfNoIteratorClosing = _core.template.statements`
    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;
  `;
  const buildForOf = _core.template.statements`
    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
    try {
      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;
    } catch (err) {
      ITERATOR_HELPER.e(err);
    } finally {
      ITERATOR_HELPER.f();
    }
  `;
  const builder = skipIteratorClosing ? {
    build: buildForOfNoIteratorClosing,
    helper: "createForOfIteratorHelperLoose",
    getContainer: nodes => nodes
  } : {
    build: buildForOf,
    helper: "createForOfIteratorHelper",
    getContainer: nodes => nodes[1].block.body
  };
  function _ForOfStatementArray(path) {
    const {
      node,
      scope
    } = path;
    const right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
    const iterationKey = scope.generateUidIdentifier("i");
    const loop = buildForOfArray({
      BODY: node.body,
      KEY: iterationKey,
      NAME: right,
      ARR: node.right
    });
    _core.types.inherits(loop, node);
    const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), true);
    let declar;
    const left = node.left;
    if (_core.types.isVariableDeclaration(left)) {
      left.declarations[0].init = iterationValue;
      declar = left;
    } else {
      declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue));
    }
    loop.body = buildLoopBody(path, declar, loop.body);
    return loop;
  }
  return {
    name: "transform-for-of",
    visitor: {
      ForOfStatement(path, state) {
        const right = path.get("right");
        if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) {
          path.replaceWith(_ForOfStatementArray(path));
          return;
        }
        {
          if (!state.availableHelper(builder.helper)) {
            (0, _noHelperImplementation.default)(skipIteratorClosing, path, state);
            return;
          }
        }
        const {
          node,
          parent,
          scope
        } = path;
        const left = node.left;
        let declar;
        const stepKey = scope.generateUid("step");
        const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
        if (_core.types.isVariableDeclaration(left)) {
          declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
        } else {
          declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
        }
        const nodes = builder.build({
          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
          ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? _core.types.booleanLiteral(true) : null,
          STEP_KEY: _core.types.identifier(stepKey),
          OBJECT: node.right,
          BODY: buildLoopBody(path, declar)
        });
        const container = builder.getContainer(nodes);
        _core.types.inherits(container[0], node);
        _core.types.inherits(container[0].body, node.body);
        if (_core.types.isLabeledStatement(parent)) {
          container[0] = _core.types.labeledStatement(parent.label, container[0]);
          path.parentPath.replaceWithMultiple(nodes);
          path.skip();
        } else {
          path.replaceWithMultiple(nodes);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-for-of\lib\no-helper-implementation.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformWithoutHelper;
var _core = require("@babel/core");
;
function transformWithoutHelper(loose, path, state) {
  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
  const {
    node
  } = path;
  const build = pushComputedProps(path, state);
  const declar = build.declar;
  const loop = build.loop;
  const block = loop.body;
  path.ensureBlock();
  if (declar) {
    block.body.push(declar);
  }
  block.body.push(...node.body.body);
  _core.types.inherits(loop, node);
  _core.types.inherits(loop.body, node.body);
  if (build.replaceParent) {
    path.parentPath.replaceWithMultiple(build.node);
    path.remove();
  } else {
    path.replaceWithMultiple(build.node);
  }
}
const buildForOfLoose = _core.template.statement(`
  for (var LOOP_OBJECT = OBJECT,
          IS_ARRAY = Array.isArray(LOOP_OBJECT),
          INDEX = 0,
          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {
    INTERMEDIATE;
    if (IS_ARRAY) {
      if (INDEX >= LOOP_OBJECT.length) break;
      ID = LOOP_OBJECT[INDEX++];
    } else {
      INDEX = LOOP_OBJECT.next();
      if (INDEX.done) break;
      ID = INDEX.value;
    }
  }
`);
const buildForOf = _core.template.statements(`
  var ITERATOR_COMPLETION = true;
  var ITERATOR_HAD_ERROR_KEY = false;
  var ITERATOR_ERROR_KEY = undefined;
  try {
    for (
      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;
      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);
      ITERATOR_COMPLETION = true
    ) {}
  } catch (err) {
    ITERATOR_HAD_ERROR_KEY = true;
    ITERATOR_ERROR_KEY = err;
  } finally {
    try {
      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {
        ITERATOR_KEY.return();
      }
    } finally {
      if (ITERATOR_HAD_ERROR_KEY) {
        throw ITERATOR_ERROR_KEY;
      }
    }
  }
`);
function pushComputedPropsLoose(path, state) {
  const {
    node,
    scope,
    parent
  } = path;
  const {
    left
  } = node;
  let declar, id, intermediate;
  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
    id = left;
    intermediate = null;
  } else if (_core.types.isVariableDeclaration(left)) {
    id = scope.generateUidIdentifier("ref");
    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name))]);
    intermediate = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(id.name))]);
  } else {
    throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
  }
  const iteratorKey = scope.generateUidIdentifier("iterator");
  const isArrayKey = scope.generateUidIdentifier("isArray");
  const loop = buildForOfLoose({
    LOOP_OBJECT: iteratorKey,
    IS_ARRAY: isArrayKey,
    OBJECT: node.right,
    INDEX: scope.generateUidIdentifier("i"),
    ID: id,
    INTERMEDIATE: intermediate
  });
  const isLabeledParent = _core.types.isLabeledStatement(parent);
  let labeled;
  if (isLabeledParent) {
    labeled = _core.types.labeledStatement(parent.label, loop);
  }
  return {
    replaceParent: isLabeledParent,
    declar: declar,
    node: labeled || loop,
    loop: loop
  };
}
function pushComputedPropsSpec(path, state) {
  const {
    node,
    scope,
    parent
  } = path;
  const left = node.left;
  let declar;
  const stepKey = scope.generateUid("step");
  const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
  } else if (_core.types.isVariableDeclaration(left)) {
    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
  } else {
    throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
  }
  const template = buildForOf({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    STEP_KEY: _core.types.identifier(stepKey),
    OBJECT: node.right
  });
  const isLabeledParent = _core.types.isLabeledStatement(parent);
  const tryBody = template[3].block.body;
  const loop = tryBody[0];
  if (isLabeledParent) {
    tryBody[0] = _core.types.labeledStatement(parent.label, loop);
  }
  return {
    replaceParent: isLabeledParent,
    declar: declar,
    loop: loop,
    node: template
  };
}

//# sourceMappingURL=no-helper-implementation.js.map


---

File name: node_modules\@babel\plugin-transform-for-of\package.json

Code:
{
  "name": "@babel/plugin-transform-for-of",
  "version": "7.27.1",
  "description": "Compile ES2015 for...of to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-for-of"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-for-of",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-for-of\README.md

Code:
# @babel/plugin-transform-for-of

> Compile ES2015 for...of to ES5

See our website [@babel/plugin-transform-for-of](https://babeljs.io/docs/babel-plugin-transform-for-of) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-for-of
```

or using yarn:

```sh
yarn add @babel/plugin-transform-for-of --dev
```


---

File name: node_modules\@babel\plugin-transform-function-name\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCompilationTargets = require("@babel/helper-compilation-targets");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
  return {
    name: "transform-function-name",
    visitor: {
      FunctionExpression: {
        exit(path) {
          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
            {
              var _path$ensureFunctionN;
              (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require("@babel/traverse").NodePath.prototype.ensureFunctionName;
            }
            path.ensureFunctionName(supportUnicodeId);
          }
        }
      },
      ObjectProperty(path) {
        const value = path.get("value");
        if (value.isFunction()) {
          {
            var _value$ensureFunction;
            (_value$ensureFunction = value.ensureFunctionName) != null ? _value$ensureFunction : value.ensureFunctionName = require("@babel/traverse").NodePath.prototype.ensureFunctionName;
          }
          value.ensureFunctionName(supportUnicodeId);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-function-name\package.json

Code:
{
  "name": "@babel/plugin-transform-function-name",
  "version": "7.27.1",
  "description": "Apply ES2015 function.name semantics to all functions",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-function-name"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-function-name",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-compilation-targets": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-function-name\README.md

Code:
# @babel/plugin-transform-function-name

> Apply ES2015 function.name semantics to all functions

See our website [@babel/plugin-transform-function-name](https://babeljs.io/docs/babel-plugin-transform-function-name) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-function-name
```

or using yarn:

```sh
yarn add @babel/plugin-transform-function-name --dev
```


---

File name: node_modules\@babel\plugin-transform-json-strings\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const regex = /(\\*)([\u2028\u2029])/g;
  function replace(match, escapes, separator) {
    const isEscaped = escapes.length % 2 === 1;
    if (isEscaped) return match;
    return `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
  }
  return {
    name: "transform-json-strings",
    manipulateOptions: (_, parser) => parser.plugins.push("jsonStrings"),
    visitor: {
      "DirectiveLiteral|StringLiteral"({
        node
      }) {
        const {
          extra
        } = node;
        if (!(extra != null && extra.raw)) return;
        extra.raw = extra.raw.replace(regex, replace);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-json-strings\package.json

Code:
{
  "name": "@babel/plugin-transform-json-strings",
  "version": "7.27.1",
  "description": "Escape U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-json-strings"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-json-strings",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-json-strings\README.md

Code:
# @babel/plugin-transform-json-strings

> Escape U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR in JS strings

See our website [@babel/plugin-transform-json-strings](https://babeljs.io/docs/babel-plugin-transform-json-strings) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-json-strings
```

or using yarn:

```sh
yarn add @babel/plugin-transform-json-strings --dev
```


---

File name: node_modules\@babel\plugin-transform-literals\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-literals",
    visitor: {
      NumericLiteral({
        node
      }) {
        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
          node.extra = undefined;
        }
      },
      StringLiteral({
        node
      }) {
        if (node.extra && /\\u/i.test(node.extra.raw)) {
          node.extra = undefined;
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-literals\package.json

Code:
{
  "name": "@babel/plugin-transform-literals",
  "version": "7.27.1",
  "description": "Compile ES2015 unicode string and number literals to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-literals\README.md

Code:
# @babel/plugin-transform-literals

> Compile ES2015 unicode string and number literals to ES5

See our website [@babel/plugin-transform-literals](https://babeljs.io/docs/babel-plugin-transform-literals) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-literals
```

or using yarn:

```sh
yarn add @babel/plugin-transform-literals --dev
```


---

File name: node_modules\@babel\plugin-transform-logical-assignment-operators\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return {
    name: "transform-logical-assignment-operators",
    manipulateOptions: (_, parser) => parser.plugins.push("logicalAssignment"),
    visitor: {
      AssignmentExpression(path) {
        const {
          node,
          scope
        } = path;
        const {
          operator,
          left,
          right
        } = node;
        const operatorTrunc = operator.slice(0, -1);
        if (!_core.types.LOGICAL_OPERATORS.includes(operatorTrunc)) {
          return;
        }
        const lhs = _core.types.cloneNode(left);
        if (_core.types.isMemberExpression(left)) {
          const {
            object,
            property,
            computed
          } = left;
          const memo = scope.maybeGenerateMemoised(object);
          if (memo) {
            left.object = memo;
            lhs.object = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), object);
          }
          if (computed) {
            const memo = scope.maybeGenerateMemoised(property);
            if (memo) {
              left.property = memo;
              lhs.property = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), property);
            }
          }
        }
        path.replaceWith(_core.types.logicalExpression(operatorTrunc, lhs, _core.types.assignmentExpression("=", left, right)));
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-logical-assignment-operators\package.json

Code:
{
  "name": "@babel/plugin-transform-logical-assignment-operators",
  "version": "7.27.1",
  "description": "Transforms logical assignment operators into short-circuited assignments",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-logical-assignment-operators"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-nullish-coalescing-operator": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-logical-assignment-operators",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-logical-assignment-operators\README.md

Code:
# @babel/plugin-transform-logical-assignment-operators

> Transforms logical assignment operators into short-circuited assignments

See our website [@babel/plugin-transform-logical-assignment-operators](https://babeljs.io/docs/babel-plugin-transform-logical-assignment-operators) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-logical-assignment-operators
```

or using yarn:

```sh
yarn add @babel/plugin-transform-logical-assignment-operators --dev
```


---

File name: node_modules\@babel\plugin-transform-member-expression-literals\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-member-expression-literals",
    visitor: {
      MemberExpression: {
        exit({
          node
        }) {
          const prop = node.property;
          if (!node.computed && _core.types.isIdentifier(prop) && !_core.types.isValidES3Identifier(prop.name)) {
            node.property = _core.types.stringLiteral(prop.name);
            node.computed = true;
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-member-expression-literals\package.json

Code:
{
  "name": "@babel/plugin-transform-member-expression-literals",
  "version": "7.27.1",
  "description": "Ensure that reserved words are quoted in property accesses",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-member-expression-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-member-expression-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-member-expression-literals\README.md

Code:
# @babel/plugin-transform-member-expression-literals

> Ensure that reserved words are quoted in property accesses

See our website [@babel/plugin-transform-member-expression-literals](https://babeljs.io/docs/babel-plugin-transform-member-expression-literals) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-member-expression-literals
```

or using yarn:

```sh
yarn add @babel/plugin-transform-member-expression-literals --dev
```


---

File name: node_modules\@babel\plugin-transform-modules-amd\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
var _core = require("@babel/core");
const buildWrapper = _core.template.statement(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);
const buildAnonymousWrapper = _core.template.statement(`
  define(["require"], function(REQUIRE) {
  })
`);
function injectWrapper(path, wrapper) {
  const {
    body,
    directives
  } = path.node;
  path.node.directives = [];
  path.node.body = [];
  const amdFactoryCall = path.pushContainer("body", wrapper)[0].get("expression");
  const amdFactoryCallArgs = amdFactoryCall.get("arguments");
  const amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get("body");
  amdFactory.pushContainer("directives", directives);
  amdFactory.pushContainer("body", body);
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const {
    allowTopLevelThis,
    strict,
    strictMode,
    importInterop,
    noInterop
  } = options;
  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
  return {
    name: "transform-modules-amd",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "amd");
    },
    visitor: {
      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path, state) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (path.isCallExpression() && !path.get("callee").isImport()) return;
        let {
          requireId,
          resolveId,
          rejectId
        } = state;
        if (!requireId) {
          requireId = path.scope.generateUidIdentifier("require");
          state.requireId = requireId;
        }
        if (!resolveId || !rejectId) {
          resolveId = path.scope.generateUidIdentifier("resolve");
          rejectId = path.scope.generateUidIdentifier("reject");
          state.resolveId = resolveId;
          state.rejectId = rejectId;
        }
        let result = _core.types.identifier("imported");
        if (!noInterop) {
          result = (0, _helperModuleTransforms.wrapInterop)(this.file.path, result, "namespace");
        }
        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, false, specifier => _core.template.expression.ast`
              new Promise((${resolveId}, ${rejectId}) =>
                ${requireId}(
                  [${specifier}],
                  imported => ${_core.types.cloneNode(resolveId)}(${result}),
                  ${_core.types.cloneNode(rejectId)}
                )
              )
            `));
      },
      Program: {
        exit(path, {
          requireId
        }) {
          if (!(0, _helperModuleTransforms.isModule)(path)) {
            if (requireId) {
              injectWrapper(path, buildAnonymousWrapper({
                REQUIRE: _core.types.cloneNode(requireId)
              }));
            }
            return;
          }
          const amdArgs = [];
          const importNames = [];
          if (requireId) {
            amdArgs.push(_core.types.stringLiteral("require"));
            importNames.push(_core.types.cloneNode(requireId));
          }
          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          const {
            meta,
            headers
          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
            enumerableModuleMeta,
            constantReexports,
            strict,
            strictMode,
            allowTopLevelThis,
            importInterop,
            noInterop,
            filename: this.file.opts.filename
          });
          if ((0, _helperModuleTransforms.hasExports)(meta)) {
            amdArgs.push(_core.types.stringLiteral("exports"));
            importNames.push(_core.types.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(_core.types.stringLiteral(source));
            importNames.push(_core.types.identifier(metadata.name));
            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
              if (interop) {
                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                header.loc = metadata.loc;
                headers.push(header);
              }
            }
            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
          }
          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
          injectWrapper(path, buildWrapper({
            MODULE_NAME: moduleName,
            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
            IMPORT_NAMES: importNames
          }));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-modules-amd\package.json

Code:
{
  "name": "@babel/plugin-transform-modules-amd",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to AMD",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-amd"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-amd",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-modules-amd\README.md

Code:
# @babel/plugin-transform-modules-amd

> This plugin transforms ES2015 modules to AMD

See our website [@babel/plugin-transform-modules-amd](https://babeljs.io/docs/babel-plugin-transform-modules-amd) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-modules-amd
```

or using yarn:

```sh
yarn add @babel/plugin-transform-modules-amd --dev
```


---

File name: node_modules\@babel\plugin-transform-modules-commonjs\lib\dynamic-import.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformDynamicImport = transformDynamicImport;
var _core = require("@babel/core");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
const requireNoInterop = source => _core.template.expression.ast`require(${source})`;
const requireInterop = (source, file) => _core.types.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
function transformDynamicImport(path, noInterop, file) {
  const buildRequire = noInterop ? requireNoInterop : requireInterop;
  path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, true, false, specifier => buildRequire(specifier, file)));
}

//# sourceMappingURL=dynamic-import.js.map


---

File name: node_modules\@babel\plugin-transform-modules-commonjs\lib\hooks.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineCommonJSHook = defineCommonJSHook;
exports.makeInvokers = makeInvokers;
const commonJSHooksKey = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
function defineCommonJSHook(file, hook) {
  let hooks = file.get(commonJSHooksKey);
  if (!hooks) file.set(commonJSHooksKey, hooks = []);
  hooks.push(hook);
}
function findMap(arr, cb) {
  if (arr) {
    for (const el of arr) {
      const res = cb(el);
      if (res != null) return res;
    }
  }
}
function makeInvokers(file) {
  const hooks = file.get(commonJSHooksKey);
  return {
    getWrapperPayload(...args) {
      return findMap(hooks, hook => hook.getWrapperPayload == null ? void 0 : hook.getWrapperPayload(...args));
    },
    wrapReference(...args) {
      return findMap(hooks, hook => hook.wrapReference == null ? void 0 : hook.wrapReference(...args));
    },
    buildRequireWrapper(...args) {
      return findMap(hooks, hook => hook.buildRequireWrapper == null ? void 0 : hook.buildRequireWrapper(...args));
    }
  };
}

//# sourceMappingURL=hooks.js.map


---

File name: node_modules\@babel\plugin-transform-modules-commonjs\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
Object.defineProperty(exports, "defineCommonJSHook", {
  enumerable: true,
  get: function () {
    return _hooks.defineCommonJSHook;
  }
});
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
var _core = require("@babel/core");
var _dynamicImport = require("./dynamic-import.js");
var _lazy = require("./lazy.js");
var _hooks = require("./hooks.js");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2, _api$assumption3;
  api.assertVersion(7);
  const {
    strictNamespace = false,
    mjsStrictNamespace = strictNamespace,
    allowTopLevelThis,
    strict,
    strictMode,
    noInterop,
    importInterop,
    lazy = false,
    allowCommonJSExports = true,
    loose = false
  } = options;
  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose;
  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose;
  const noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : false;
  if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(item => typeof item === "string"))) {
    throw new Error(`.lazy must be a boolean, array of strings, or a function`);
  }
  if (typeof strictNamespace !== "boolean") {
    throw new Error(`.strictNamespace must be a boolean, or undefined`);
  }
  if (typeof mjsStrictNamespace !== "boolean") {
    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
  }
  const getAssertion = localName => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
  const moduleExportsVisitor = {
    ReferencedIdentifier(path) {
      const localName = path.node.name;
      if (localName !== "module" && localName !== "exports") return;
      const localBinding = path.scope.getBinding(localName);
      const rootBinding = this.scope.getBinding(localName);
      if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
        value: path.node
      }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
        left: path.node
      }) || path.isAssignmentExpression({
        left: path.node
      })) {
        return;
      }
      path.replaceWith(getAssertion(localName));
    },
    UpdateExpression(path) {
      const arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      const localName = arg.node.name;
      if (localName !== "module" && localName !== "exports") return;
      const localBinding = path.scope.getBinding(localName);
      const rootBinding = this.scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
    },
    AssignmentExpression(path) {
      const left = path.get("left");
      if (left.isIdentifier()) {
        const localName = left.node.name;
        if (localName !== "module" && localName !== "exports") return;
        const localBinding = path.scope.getBinding(localName);
        const rootBinding = this.scope.getBinding(localName);
        if (rootBinding !== localBinding) return;
        const right = path.get("right");
        right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
      } else if (left.isPattern()) {
        const ids = left.getOuterBindingIdentifiers();
        const localName = Object.keys(ids).find(localName => {
          if (localName !== "module" && localName !== "exports") return false;
          return this.scope.getBinding(localName) === path.scope.getBinding(localName);
        });
        if (localName) {
          const right = path.get("right");
          right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
        }
      }
    }
  };
  return {
    name: "transform-modules-commonjs",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "commonjs");
      if (lazy) (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));
    },
    visitor: {
      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
        let {
          scope
        } = path;
        do {
          scope.rename("require");
        } while (scope = scope.parent);
        (0, _dynamicImport.transformDynamicImport)(path, noInterop, this.file);
      },
      Program: {
        exit(path, state) {
          if (!(0, _helperModuleTransforms.isModule)(path)) return;
          path.scope.rename("exports");
          path.scope.rename("module");
          path.scope.rename("require");
          path.scope.rename("__filename");
          path.scope.rename("__dirname");
          if (!allowCommonJSExports) {
            path.traverse(moduleExportsVisitor, {
              scope: path.scope
            });
          }
          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          const hooks = (0, _hooks.makeInvokers)(this.file);
          const {
            meta,
            headers
          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
            exportName: "exports",
            constantReexports,
            enumerableModuleMeta,
            strict,
            strictMode,
            allowTopLevelThis,
            noInterop,
            importInterop,
            wrapReference: hooks.wrapReference,
            getWrapperPayload: hooks.getWrapperPayload,
            esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
            noIncompleteNsImportDetection,
            filename: this.file.opts.filename
          });
          for (const [source, metadata] of meta.source) {
            const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);
            let header;
            if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
              if (lazy && metadata.wrap === "function") {
                throw new Error("Assertion failure");
              }
              header = _core.types.expressionStatement(loadExpr);
            } else {
              const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
              if (metadata.wrap) {
                const res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);
                if (res === false) continue;else header = res;
              }
              header != null ? header : header = _core.template.statement.ast`
                var ${metadata.name} = ${init};
              `;
            }
            header.loc = metadata.loc;
            headers.push(header);
            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));
          }
          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
          path.get("body").forEach(path => {
            if (!headers.includes(path.node)) return;
            if (path.isVariableDeclaration()) {
              path.scope.registerDeclaration(path);
            }
          });
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-modules-commonjs\lib\lazy.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lazyImportsHook = void 0;
var _core = require("@babel/core");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
const lazyImportsHook = lazy => ({
  name: `${"@babel/plugin-transform-modules-commonjs"}/lazy`,
  version: "7.27.1",
  getWrapperPayload(source, metadata) {
    if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll) {
      return null;
    }
    if (lazy === true) {
      return source.includes(".") ? null : "lazy/function";
    }
    if (Array.isArray(lazy)) {
      return !lazy.includes(source) ? null : "lazy/function";
    }
    if (typeof lazy === "function") {
      return lazy(source) ? "lazy/function" : null;
    }
  },
  buildRequireWrapper(name, init, payload, referenced) {
    if (payload === "lazy/function") {
      if (!referenced) return false;
      return _core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `;
    }
  },
  wrapReference(ref, payload) {
    if (payload === "lazy/function") return _core.types.callExpression(ref, []);
  }
});
exports.lazyImportsHook = lazyImportsHook;

//# sourceMappingURL=lazy.js.map


---

File name: node_modules\@babel\plugin-transform-modules-commonjs\package.json

Code:
{
  "name": "@babel/plugin-transform-modules-commonjs",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to CommonJS",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-commonjs"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-commonjs",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-modules-commonjs\README.md

Code:
# @babel/plugin-transform-modules-commonjs

> This plugin transforms ES2015 modules to CommonJS

See our website [@babel/plugin-transform-modules-commonjs](https://babeljs.io/docs/babel-plugin-transform-modules-commonjs) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-modules-commonjs
```

or using yarn:

```sh
yarn add @babel/plugin-transform-modules-commonjs --dev
```


---

File name: node_modules\@babel\plugin-transform-modules-systemjs\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getExportSpecifierName = getExportSpecifierName;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
const buildTemplate = _core.template.statement(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: EXECUTE,
    };
  });
`);
const buildExportAll = _core.template.statement(`
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
const MISSING_PLUGIN_WARNING = `\
WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-transform-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;
const MISSING_PLUGIN_ERROR = `\
ERROR: Dynamic import() transformation must be enabled using the
       @babel/plugin-transform-dynamic-import plugin. Babel 8
       no longer transforms import() without using that plugin.
`;
function getExportSpecifierName(node, stringSpecifiers) {
  if (node.type === "Identifier") {
    return node.name;
  } else if (node.type === "StringLiteral") {
    const stringValue = node.value;
    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
      stringSpecifiers.add(stringValue);
    }
    return stringValue;
  } else {
    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);
  }
}
function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
  const statements = [];
  if (!exportStarTarget) {
    if (exportNames.length === 1) {
      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
    } else {
      const objectProperties = [];
      for (let i = 0; i < exportNames.length; i++) {
        const exportName = exportNames[i];
        const exportValue = exportValues[i];
        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));
      }
      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
    }
  } else {
    const exportObj = path.scope.generateUid("exportObj");
    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: _core.types.identifier(exportObj),
      TARGET: exportStarTarget
    }));
    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
    }
    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
  }
  return statements;
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  const {
    systemGlobal = "System",
    allowTopLevelThis = false
  } = options;
  const reassignmentVisited = new WeakSet();
  const reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression"(path) {
      if (reassignmentVisited.has(path.node)) return;
      reassignmentVisited.add(path.node);
      const arg = path.isAssignmentExpression() ? path.get("left") : path.get("argument");
      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        const exprs = [path.node];
        for (const name of Object.keys(arg.getBindingIdentifiers())) {
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {
            return;
          }
          const exportedNames = this.exports[name];
          if (!exportedNames) continue;
          for (const exportedName of exportedNames) {
            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
          }
        }
        path.replaceWith(_core.types.sequenceExpression(exprs));
        return;
      }
      if (!arg.isIdentifier()) return;
      const name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      const exportedNames = this.exports[name];
      if (!exportedNames) return;
      let node = path.node;
      const isPostUpdateExpression = _core.types.isUpdateExpression(node, {
        prefix: false
      });
      if (isPostUpdateExpression) {
        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
      }
      for (const exportedName of exportedNames) {
        node = this.buildCall(exportedName, node).expression;
      }
      if (isPostUpdateExpression) {
        node = _core.types.sequenceExpression([node, path.node]);
      }
      path.replaceWith(node);
    }
  };
  return {
    name: "transform-modules-systemjs",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },
    visitor: {
      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path, state) {
        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
        if (path.isCallExpression()) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            {
              console.warn(MISSING_PLUGIN_WARNING);
            }
          }
        } else {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            throw new Error(MISSING_PLUGIN_ERROR);
          }
        }
        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, true, specifier => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [specifier])));
      },
      MetaProperty(path, state) {
        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
        }
      },
      ReferencedIdentifier(path, state) {
        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
        }
      },
      Program: {
        enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
          state.stringSpecifiers = new Set();
          if (!allowTopLevelThis) {
            (0, _helperModuleTransforms.rewriteThis)(path);
          }
        },
        exit(path, state) {
          const scope = path.scope;
          const exportIdent = scope.generateUid("export");
          const {
            contextIdent,
            stringSpecifiers
          } = state;
          const exportMap = Object.create(null);
          const modules = [];
          const beforeBody = [];
          const setters = [];
          const sources = [];
          const variableIds = [];
          const removedPaths = [];
          function addExportName(key, val) {
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
          }
          function pushModule(source, key, specifiers) {
            let module;
            modules.forEach(function (m) {
              if (m.key === source) {
                module = m;
              }
            });
            if (!module) {
              modules.push(module = {
                key: source,
                imports: [],
                exports: []
              });
            }
            module[key] = module[key].concat(specifiers);
          }
          function buildExportCall(name, val) {
            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
          }
          const exportNames = [];
          const exportValues = [];
          const body = path.get("body");
          for (const path of body) {
            if (path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
            } else if (path.isClassDeclaration()) {
              variableIds.push(_core.types.cloneNode(path.node.id));
              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));
            } else if (path.isVariableDeclaration()) {
              path.node.kind = "var";
            } else if (path.isImportDeclaration()) {
              const source = path.node.source.value;
              pushModule(source, "imports", path.node.specifiers);
              for (const name of Object.keys(path.getBindingIdentifiers())) {
                scope.removeBinding(name);
                variableIds.push(_core.types.identifier(name));
              }
              path.remove();
            } else if (path.isExportAllDeclaration()) {
              pushModule(path.node.source.value, "exports", path.node);
              path.remove();
            } else if (path.isExportDefaultDeclaration()) {
              const declar = path.node.declaration;
              if (_core.types.isClassDeclaration(declar)) {
                const id = declar.id;
                if (id) {
                  exportNames.push("default");
                  exportValues.push(scope.buildUndefinedNode());
                  variableIds.push(_core.types.cloneNode(id));
                  addExportName(id.name, "default");
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar))));
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar));
                  removedPaths.push(path);
                }
              } else if (_core.types.isFunctionDeclaration(declar)) {
                const id = declar.id;
                if (id) {
                  beforeBody.push(declar);
                  exportNames.push("default");
                  exportValues.push(_core.types.cloneNode(id));
                  addExportName(id.name, "default");
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar));
                }
                removedPaths.push(path);
              } else {
                path.replaceWith(buildExportCall("default", declar));
              }
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.node.declaration;
              if (declar) {
                path.replaceWith(declar);
                if (_core.types.isFunction(declar)) {
                  const name = declar.id.name;
                  addExportName(name, name);
                  beforeBody.push(declar);
                  exportNames.push(name);
                  exportValues.push(_core.types.cloneNode(declar.id));
                  removedPaths.push(path);
                } else if (_core.types.isClass(declar)) {
                  const name = declar.id.name;
                  exportNames.push(name);
                  exportValues.push(scope.buildUndefinedNode());
                  variableIds.push(_core.types.cloneNode(declar.id));
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));
                  addExportName(name, name);
                } else {
                  if (_core.types.isVariableDeclaration(declar)) {
                    declar.kind = "var";
                  }
                  for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))) {
                    addExportName(name, name);
                  }
                }
              } else {
                const specifiers = path.node.specifiers;
                if (specifiers != null && specifiers.length) {
                  if (path.node.source) {
                    pushModule(path.node.source.value, "exports", specifiers);
                    path.remove();
                  } else {
                    const nodes = [];
                    for (const specifier of specifiers) {
                      const {
                        local,
                        exported
                      } = specifier;
                      const binding = scope.getBinding(local.name);
                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);
                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                        exportNames.push(exportedName);
                        exportValues.push(_core.types.cloneNode(local));
                      } else if (!binding) {
                        nodes.push(buildExportCall(exportedName, local));
                      }
                      addExportName(local.name, exportedName);
                    }
                    path.replaceWithMultiple(nodes);
                  }
                } else {
                  path.remove();
                }
              }
            }
          }
          modules.forEach(function (specifiers) {
            const setterBody = [];
            const target = scope.generateUid(specifiers.key);
            for (let specifier of specifiers.imports) {
              if (_core.types.isImportNamespaceSpecifier(specifier)) {
                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
              } else if (_core.types.isImportDefaultSpecifier(specifier)) {
                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
              }
              if (_core.types.isImportSpecifier(specifier)) {
                const {
                  imported
                } = specifier;
                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === "StringLiteral"))));
              }
            }
            if (specifiers.exports.length) {
              const exportNames = [];
              const exportValues = [];
              let hasExportStar = false;
              for (const node of specifiers.exports) {
                if (_core.types.isExportAllDeclaration(node)) {
                  hasExportStar = true;
                } else if (_core.types.isExportSpecifier(node)) {
                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);
                  exportNames.push(exportedName);
                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));
                } else {}
              }
              setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));
            }
            sources.push(_core.types.stringLiteral(specifiers.key));
            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));
          });
          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          {
            var _path$scope, _path$scope$hoistVari;
            (_path$scope$hoistVari = (_path$scope = path.scope).hoistVariables) != null ? _path$scope$hoistVari : _path$scope.hoistVariables = require("@babel/traverse").Scope.prototype.hoistVariables;
          }
          path.scope.hoistVariables((id, hasInit) => {
            variableIds.push(id);
            if (!hasInit && id.name in exportMap) {
              for (const exported of exportMap[id.name]) {
                exportNames.push(exported);
                exportValues.push(_core.types.buildUndefinedNode());
              }
            }
          });
          if (variableIds.length) {
            beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map(id => _core.types.variableDeclarator(id))));
          }
          if (exportNames.length) {
            beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
          }
          path.traverse(reassignmentVisitor, {
            exports: exportMap,
            buildCall: buildExportCall,
            scope
          });
          for (const path of removedPaths) {
            path.remove();
          }
          let hasTLA = false;
          path.traverse({
            AwaitExpression(path) {
              hasTLA = true;
              path.stop();
            },
            Function(path) {
              path.skip();
            },
            noScope: true
          });
          path.node.body = [buildTemplate({
            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: _core.types.arrayExpression(setters),
            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),
            SOURCES: _core.types.arrayExpression(sources),
            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
          })];
          path.requeue(path.get("body.0"));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-modules-systemjs\package.json

Code:
{
  "name": "@babel/plugin-transform-modules-systemjs",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to SystemJS",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-systemjs"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-validator-identifier": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/helper-transform-fixture-test-runner": "^7.27.1",
    "core-js": "^3.35.0"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-systemjs",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-modules-systemjs\README.md

Code:
# @babel/plugin-transform-modules-systemjs

> This plugin transforms ES2015 modules to SystemJS

See our website [@babel/plugin-transform-modules-systemjs](https://babeljs.io/docs/babel-plugin-transform-modules-systemjs) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-modules-systemjs
```

or using yarn:

```sh
yarn add @babel/plugin-transform-modules-systemjs --dev
```


---

File name: node_modules\@babel\plugin-transform-modules-umd\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _path = require("path");
var _helperModuleTransforms = require("@babel/helper-module-transforms");
var _core = require("@babel/core");
const buildPrerequisiteAssignment = (0, _core.template)(`
  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}
`);
const buildWrapper = (0, _core.template)(`
  (function (global, factory) {
    if (typeof define === "function" && define.amd) {
      define(MODULE_NAME, AMD_ARGUMENTS, factory);
    } else if (typeof exports !== "undefined") {
      factory(COMMONJS_ARGUMENTS);
    } else {
      var mod = { exports: {} };
      factory(BROWSER_ARGUMENTS);

      GLOBAL_TO_ASSIGN;
    }
  })(
    typeof globalThis !== "undefined" ? globalThis
      : typeof self !== "undefined" ? self
      : this,
    function(IMPORT_NAMES) {
  })
`);
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const {
    globals,
    exactGlobals,
    allowTopLevelThis,
    strict,
    strictMode,
    noInterop,
    importInterop
  } = options;
  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
  function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
    const moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, _path.extname)(filename));
    let globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename)));
    let initAssignments = [];
    if (exactGlobals) {
      const globalName = browserGlobals[moduleNameOrBasename];
      if (globalName) {
        initAssignments = [];
        const members = globalName.split(".");
        globalToAssign = members.slice(1).reduce((accum, curr) => {
          initAssignments.push(buildPrerequisiteAssignment({
            GLOBAL_REFERENCE: _core.types.cloneNode(accum)
          }));
          return _core.types.memberExpression(accum, _core.types.identifier(curr));
        }, _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
      }
    }
    initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")))));
    return initAssignments;
  }
  function buildBrowserArg(browserGlobals, exactGlobals, source) {
    let memberExpression;
    if (exactGlobals) {
      const globalRef = browserGlobals[source];
      if (globalRef) {
        memberExpression = globalRef.split(".").reduce((accum, curr) => _core.types.memberExpression(accum, _core.types.identifier(curr)), _core.types.identifier("global"));
      } else {
        memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
      }
    } else {
      const requireName = (0, _path.basename)(source, (0, _path.extname)(source));
      const globalName = browserGlobals[requireName] || requireName;
      memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
    }
    return memberExpression;
  }
  return {
    name: "transform-modules-umd",
    visitor: {
      Program: {
        exit(path) {
          if (!(0, _helperModuleTransforms.isModule)(path)) return;
          const browserGlobals = globals || {};
          const moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
          let moduleNameLiteral;
          if (moduleName) moduleNameLiteral = _core.types.stringLiteral(moduleName);
          const {
            meta,
            headers
          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
            constantReexports,
            enumerableModuleMeta,
            strict,
            strictMode,
            allowTopLevelThis,
            noInterop,
            importInterop,
            filename: this.file.opts.filename
          });
          const amdArgs = [];
          const commonjsArgs = [];
          const browserArgs = [];
          const importNames = [];
          if ((0, _helperModuleTransforms.hasExports)(meta)) {
            amdArgs.push(_core.types.stringLiteral("exports"));
            commonjsArgs.push(_core.types.identifier("exports"));
            browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")));
            importNames.push(_core.types.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(_core.types.stringLiteral(source));
            commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]));
            browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
            importNames.push(_core.types.identifier(metadata.name));
            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
              if (interop) {
                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                header.loc = meta.loc;
                headers.push(header);
              }
            }
            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
          }
          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
          path.unshiftContainer("body", headers);
          const {
            body,
            directives
          } = path.node;
          path.node.directives = [];
          path.node.body = [];
          const umdWrapper = path.pushContainer("body", [buildWrapper({
            MODULE_NAME: moduleNameLiteral,
            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
            COMMONJS_ARGUMENTS: commonjsArgs,
            BROWSER_ARGUMENTS: browserArgs,
            IMPORT_NAMES: importNames,
            GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleNameLiteral)
          })])[0];
          const umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
          umdFactory.pushContainer("directives", directives);
          umdFactory.pushContainer("body", body);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-modules-umd\package.json

Code:
{
  "name": "@babel/plugin-transform-modules-umd",
  "version": "7.27.1",
  "description": "This plugin transforms ES2015 modules to UMD",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-modules-umd"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-modules-umd",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-module-transforms": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-external-helpers": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-modules-umd\README.md

Code:
# @babel/plugin-transform-modules-umd

> This plugin transforms ES2015 modules to UMD

See our website [@babel/plugin-transform-modules-umd](https://babeljs.io/docs/babel-plugin-transform-modules-umd) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-modules-umd
```

or using yarn:

```sh
yarn add @babel/plugin-transform-modules-umd --dev
```


---

File name: node_modules\@babel\plugin-transform-named-capturing-groups-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  const {
    runtime
  } = options;
  if (runtime !== undefined && typeof runtime !== "boolean") {
    throw new Error("The 'runtime' option must be boolean");
  }
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-named-capturing-groups-regex",
    feature: "namedCaptureGroups",
    options: {
      runtime
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-named-capturing-groups-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-named-capturing-groups-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions using named groups to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-named-capturing-groups-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-named-capturing-groups-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "core-js": "^3.30.2"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-named-capturing-groups-regex\README.md

Code:
# @babel/plugin-transform-named-capturing-groups-regex

> Compile regular expressions using named groups to ES5.

See our website [@babel/plugin-transform-named-capturing-groups-regex](https://babeljs.io/docs/babel-plugin-transform-named-capturing-groups-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-named-capturing-groups-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-named-capturing-groups-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-new-target\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-new-target",
    visitor: {
      MetaProperty(path) {
        const meta = path.get("meta");
        const property = path.get("property");
        const {
          scope
        } = path;
        if (meta.isIdentifier({
          name: "new"
        }) && property.isIdentifier({
          name: "target"
        })) {
          const func = path.findParent(path => {
            if (path.isClass()) return true;
            if (path.isFunction() && !path.isArrowFunctionExpression()) {
              if (path.isClassMethod({
                kind: "constructor"
              })) {
                return false;
              }
              return true;
            }
            return false;
          });
          if (!func) {
            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
          }
          const {
            node
          } = func;
          if (_core.types.isMethod(node)) {
            path.replaceWith(scope.buildUndefinedNode());
            return;
          }
          const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
          if (func.isClass()) {
            path.replaceWith(constructor);
            return;
          }
          if (!node.id) {
            node.id = scope.generateUidIdentifier("target");
          } else {
            let scope = path.scope;
            const name = node.id.name;
            while (scope !== func.parentPath.scope) {
              if (scope.hasOwnBinding(name) && !scope.bindingIdentifierEquals(name, node.id)) {
                scope.rename(name);
              }
              scope = scope.parent;
            }
          }
          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-new-target\package.json

Code:
{
  "name": "@babel/plugin-transform-new-target",
  "version": "7.27.1",
  "description": "Transforms new.target meta property",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-new-target"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-new-target",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-arrow-functions": "^7.27.1",
    "@babel/plugin-transform-class-properties": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-new-target\README.md

Code:
# @babel/plugin-transform-new-target

> Transforms new.target meta property

See our website [@babel/plugin-transform-new-target](https://babeljs.io/docs/babel-plugin-transform-new-target) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-new-target
```

or using yarn:

```sh
yarn add @babel/plugin-transform-new-target --dev
```


---

File name: node_modules\@babel\plugin-transform-nullish-coalescing-operator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, {
  loose = false
}) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : false;
  return {
    name: "transform-nullish-coalescing-operator",
    manipulateOptions: (_, parser) => parser.plugins.push("nullishCoalescingOperator"),
    visitor: {
      LogicalExpression(path) {
        const {
          node,
          scope
        } = path;
        if (node.operator !== "??") {
          return;
        }
        let ref;
        let assignment;
        if (pureGetters && scope.path.isPattern() && _core.types.isMemberExpression(node.left) && !node.left.computed && _core.types.isIdentifier(node.left.object) && _core.types.isIdentifier(node.left.property) || _core.types.isIdentifier(node.left) && (pureGetters || scope.hasBinding(node.left.name))) {
          ref = node.left;
          assignment = _core.types.cloneNode(node.left);
        } else if (scope.path.isPattern()) {
          path.replaceWith(_core.template.statement.ast`(() => ${path.node})()`);
          return;
        } else {
          ref = scope.generateUidIdentifierBasedOnNode(node.left);
          scope.push({
            id: _core.types.cloneNode(ref)
          });
          assignment = _core.types.assignmentExpression("=", ref, node.left);
        }
        path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-nullish-coalescing-operator\package.json

Code:
{
  "name": "@babel/plugin-transform-nullish-coalescing-operator",
  "version": "7.27.1",
  "description": "Remove nullish coalescing operator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-nullish-coalescing-operator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-nullish-coalescing-operator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-nullish-coalescing-operator\README.md

Code:
# @babel/plugin-transform-nullish-coalescing-operator

> Remove nullish coalescing operator

See our website [@babel/plugin-transform-nullish-coalescing-operator](https://babeljs.io/docs/babel-plugin-transform-nullish-coalescing-operator) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-nullish-coalescing-operator
```

or using yarn:

```sh
yarn add @babel/plugin-transform-nullish-coalescing-operator --dev
```


---

File name: node_modules\@babel\plugin-transform-numeric-separator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
function remover({
  node
}) {
  var _extra$raw;
  const {
    extra
  } = node;
  if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_")) {
    extra.raw = extra.raw.replace(/_/g, "");
  }
}
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return {
    name: "transform-numeric-separator",
    manipulateOptions: (_, parser) => parser.plugins.push("numericSeparator"),
    visitor: {
      NumericLiteral: remover,
      BigIntLiteral: remover
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-numeric-separator\package.json

Code:
{
  "name": "@babel/plugin-transform-numeric-separator",
  "version": "7.27.1",
  "description": "Remove numeric separators from Decimal, Binary, Hex and Octal literals",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-numeric-separator"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-numeric-separator",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-numeric-separator\README.md

Code:
# @babel/plugin-transform-numeric-separator

> Remove numeric separators from Decimal, Binary, Hex and Octal literals

See our website [@babel/plugin-transform-numeric-separator](https://babeljs.io/docs/babel-plugin-transform-numeric-separator) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-numeric-separator
```

or using yarn:

```sh
yarn add @babel/plugin-transform-numeric-separator --dev
```


---

File name: node_modules\@babel\plugin-transform-object-rest-spread\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');
var core = require('@babel/core');
var pluginTransformParameters = require('@babel/plugin-transform-parameters');
var helperCompilationTargets = require('@babel/helper-compilation-targets');
var pluginTransformDestructuring = require('@babel/plugin-transform-destructuring');

function shouldStoreRHSInTemporaryVariable(node) {
  if (!node) return false;
  if (node.type === "ArrayPattern") {
    const nonNullElements = node.elements.filter(element => element !== null);
    if (nonNullElements.length > 1) return true;else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
  } else if (node.type === "ObjectPattern") {
    const {
      properties
    } = node;
    if (properties.length > 1) return true;else if (properties.length === 0) return false;else {
      const firstProperty = properties[0];
      if (firstProperty.type === "ObjectProperty") {
        return shouldStoreRHSInTemporaryVariable(firstProperty.value);
      } else {
        return shouldStoreRHSInTemporaryVariable(firstProperty);
      }
    }
  } else if (node.type === "AssignmentPattern") {
    return shouldStoreRHSInTemporaryVariable(node.left);
  } else if (node.type === "RestElement") {
    if (node.argument.type === "Identifier") return true;
    return shouldStoreRHSInTemporaryVariable(node.argument);
  } else {
    return false;
  }
}

var compatData = {
  "Object.assign": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "36",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  }
};

{
  const node = core.types.identifier("a");
  const property = core.types.objectProperty(core.types.identifier("key"), node);
  const pattern = core.types.objectPattern([property]);
  var ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;
}
var index = helperPluginUtils.declare((api, opts) => {
  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const targets = api.targets();
  const supportsObjectAssign = !helperCompilationTargets.isRequired("Object.assign", targets, {
    compatData
  });
  const {
    useBuiltIns = supportsObjectAssign,
    loose = false
  } = opts;
  if (typeof loose !== "boolean") {
    throw new Error(".loose must be a boolean, or undefined");
  }
  const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose;
  const objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose;
  const pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose;
  const setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;
  function getExtendsHelper(file) {
    return useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : file.addHelper("extends");
  }
  function* iterateObjectRestElement(path) {
    switch (path.type) {
      case "ArrayPattern":
        for (const elementPath of path.get("elements")) {
          if (elementPath.isRestElement()) {
            yield* iterateObjectRestElement(elementPath.get("argument"));
          } else {
            yield* iterateObjectRestElement(elementPath);
          }
        }
        break;
      case "ObjectPattern":
        for (const propertyPath of path.get("properties")) {
          if (propertyPath.isRestElement()) {
            yield propertyPath;
          } else {
            yield* iterateObjectRestElement(propertyPath.get("value"));
          }
        }
        break;
      case "AssignmentPattern":
        yield* iterateObjectRestElement(path.get("left"));
        break;
    }
  }
  function hasObjectRestElement(path) {
    const objectRestPatternIterator = iterateObjectRestElement(path);
    return !objectRestPatternIterator.next().done;
  }
  function visitObjectRestElements(path, visitor) {
    for (const restElementPath of iterateObjectRestElement(path)) {
      visitor(restElementPath);
    }
  }
  function hasSpread(node) {
    for (const prop of node.properties) {
      if (core.types.isSpreadElement(prop)) {
        return true;
      }
    }
    return false;
  }
  function extractNormalizedKeys(node) {
    const props = node.properties;
    const keys = [];
    let allPrimitives = true;
    let hasTemplateLiteral = false;
    for (const prop of props) {
      const {
        key
      } = prop;
      if (core.types.isIdentifier(key) && !prop.computed) {
        keys.push(core.types.stringLiteral(key.name));
      } else if (core.types.isTemplateLiteral(key)) {
        keys.push(core.types.cloneNode(key));
        hasTemplateLiteral = true;
      } else if (core.types.isLiteral(key)) {
        keys.push(core.types.stringLiteral(String(key.value)));
      } else {
        keys.push(core.types.cloneNode(key));
        if (core.types.isMemberExpression(key, {
          computed: false
        }) && core.types.isIdentifier(key.object, {
          name: "Symbol"
        }) || core.types.isCallExpression(key) && core.types.matchesPattern(key.callee, "Symbol.for")) ; else {
          allPrimitives = false;
        }
      }
    }
    return {
      keys,
      allPrimitives,
      hasTemplateLiteral
    };
  }
  function replaceImpureComputedKeys(properties, scope) {
    const impureComputedPropertyDeclarators = [];
    for (const propPath of properties) {
      const key = propPath.get("key");
      if (propPath.node.computed && !key.isPure()) {
        const name = scope.generateUidBasedOnNode(key.node);
        const declarator = core.types.variableDeclarator(core.types.identifier(name), key.node);
        impureComputedPropertyDeclarators.push(declarator);
        key.replaceWith(core.types.identifier(name));
      }
    }
    return impureComputedPropertyDeclarators;
  }
  function removeUnusedExcludedKeys(path) {
    const bindings = path.getOuterBindingIdentifierPaths();
    Object.keys(bindings).forEach(bindingName => {
      const bindingParentPath = bindings[bindingName].parentPath;
      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
        return;
      }
      bindingParentPath.remove();
    });
  }
  function createObjectRest(path, file, objRef) {
    const props = path.get("properties");
    const last = props[props.length - 1];
    core.types.assertRestElement(last.node);
    const restElement = core.types.cloneNode(last.node);
    last.remove();
    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);
    const {
      keys,
      allPrimitives,
      hasTemplateLiteral
    } = extractNormalizedKeys(path.node);
    if (keys.length === 0) {
      return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(getExtendsHelper(file), [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(file.addHelper("objectDestructuringEmpty"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])])];
    }
    let keyExpression;
    if (!allPrimitives) {
      keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier("map")), [file.addHelper("toPropertyKey")]);
    } else {
      keyExpression = core.types.arrayExpression(keys);
      if (!hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {
        const program = path.findParent(path => path.isProgram());
        const id = path.scope.generateUidIdentifier("excluded");
        program.scope.push({
          id,
          init: keyExpression,
          kind: "const"
        });
        keyExpression = core.types.cloneNode(id);
      }
    }
    return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [core.types.cloneNode(objRef), keyExpression])];
  }
  function replaceRestElement(parentPath, paramPath, container) {
    if (paramPath.isAssignmentPattern()) {
      replaceRestElement(parentPath, paramPath.get("left"), container);
      return;
    }
    if (paramPath.isArrayPattern() && hasObjectRestElement(paramPath)) {
      const elements = paramPath.get("elements");
      for (let i = 0; i < elements.length; i++) {
        replaceRestElement(parentPath, elements[i], container);
      }
    }
    if (paramPath.isObjectPattern() && hasObjectRestElement(paramPath)) {
      const uid = parentPath.scope.generateUidIdentifier("ref");
      const declar = core.types.variableDeclaration("let", [core.types.variableDeclarator(paramPath.node, uid)]);
      if (container) {
        container.push(declar);
      } else {
        parentPath.ensureBlock();
        parentPath.get("body").unshiftContainer("body", declar);
      }
      paramPath.replaceWith(core.types.cloneNode(uid));
    }
  }
  return {
    name: "transform-object-rest-spread",
    manipulateOptions: (_, parser) => parser.plugins.push("objectRestSpread"),
    visitor: {
      Function(path) {
        const params = path.get("params");
        const paramsWithRestElement = new Set();
        const idsInRestParams = new Set();
        for (let i = 0; i < params.length; ++i) {
          const param = params[i];
          if (hasObjectRestElement(param)) {
            paramsWithRestElement.add(i);
            for (const name of Object.keys(param.getBindingIdentifiers())) {
              idsInRestParams.add(name);
            }
          }
        }
        let idInRest = false;
        const IdentifierHandler = function (path, functionScope) {
          const name = path.node.name;
          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
            idInRest = true;
            path.stop();
          }
        };
        let i;
        for (i = 0; i < params.length && !idInRest; ++i) {
          const param = params[i];
          if (!paramsWithRestElement.has(i)) {
            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {
              IdentifierHandler(param, path.scope);
            } else {
              param.traverse({
                "Scope|TypeAnnotation|TSTypeAnnotation": path => path.skip(),
                "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
              }, path.scope);
            }
          }
        }
        if (!idInRest) {
          for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            if (paramsWithRestElement.has(i)) {
              replaceRestElement(path, param);
            }
          }
        } else {
          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);
          pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
        }
      },
      VariableDeclarator(path, file) {
        if (!path.get("id").isObjectPattern()) {
          return;
        }
        let insertionPath = path;
        const originalPath = path;
        visitObjectRestElements(path.get("id"), path => {
          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {
            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
            originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init));
            originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));
            return;
          }
          let ref = originalPath.node.init;
          const refPropertyPath = [];
          let kind;
          path.findParent(path => {
            if (path.isObjectProperty()) {
              refPropertyPath.unshift(path);
            } else if (path.isVariableDeclarator()) {
              kind = path.parentPath.node.kind;
              return true;
            }
          });
          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
          refPropertyPath.forEach(prop => {
            const {
              node
            } = prop;
            ref = core.types.memberExpression(ref, core.types.cloneNode(node.key), node.computed || core.types.isLiteral(node.key));
          });
          const objectPatternPath = path.parentPath;
          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);
          if (pureGetters) {
            removeUnusedExcludedKeys(objectPatternPath);
          }
          core.types.assertIdentifier(argument);
          insertionPath.insertBefore(impureComputedPropertyDeclarators);
          insertionPath.insertBefore(impureObjRefComputedDeclarators);
          insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0];
          path.scope.registerBinding(kind, insertionPath);
          if (objectPatternPath.node.properties.length === 0) {
            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();
          }
        });
      },
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        const hasRest = declaration.get("declarations").some(path => hasObjectRestElement(path.get("id")));
        if (!hasRest) return;
        {
          var _path$splitExportDecl;
          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require("@babel/traverse").NodePath.prototype.splitExportDeclaration;
        }
        path.splitExportDeclaration();
      },
      CatchClause(path) {
        const paramPath = path.get("param");
        replaceRestElement(path, paramPath);
      },
      AssignmentExpression(path, file) {
        const leftPath = path.get("left");
        if (leftPath.isObjectPattern() && hasObjectRestElement(leftPath)) {
          const nodes = [];
          const refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
          nodes.push(core.types.variableDeclaration("var", [core.types.variableDeclarator(core.types.identifier(refName), path.node.right)]));
          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));
          if (impureComputedPropertyDeclarators.length > 0) {
            nodes.push(core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
          }
          const nodeWithoutSpread = core.types.cloneNode(path.node);
          nodeWithoutSpread.right = core.types.identifier(refName);
          nodes.push(core.types.expressionStatement(nodeWithoutSpread));
          nodes.push(core.types.expressionStatement(core.types.assignmentExpression("=", argument, callExpression)));
          nodes.push(core.types.expressionStatement(core.types.identifier(refName)));
          path.replaceWithMultiple(nodes);
        }
      },
      ForXStatement(path) {
        const {
          node,
          scope
        } = path;
        const leftPath = path.get("left");
        if (!leftPath.isVariableDeclaration()) {
          if (!hasObjectRestElement(leftPath)) {
            return;
          }
          const temp = scope.generateUidIdentifier("ref");
          node.left = core.types.variableDeclaration("var", [core.types.variableDeclarator(temp)]);
          path.ensureBlock();
          const statementBody = path.node.body.body;
          const nodes = [];
          if (statementBody.length === 0 && path.isCompletionRecord()) {
            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
          }
          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", leftPath.node, core.types.cloneNode(temp))));
          pluginTransformDestructuring.unshiftForXStatementBody(path, nodes);
          scope.crawl();
          return;
        } else {
          const patternPath = leftPath.get("declarations")[0].get("id");
          if (!hasObjectRestElement(patternPath)) {
            return;
          }
          const left = leftPath.node;
          const pattern = patternPath.node;
          const key = scope.generateUidIdentifier("ref");
          node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);
          path.ensureBlock();
          pluginTransformDestructuring.unshiftForXStatementBody(path, [core.types.variableDeclaration(node.left.kind, [core.types.variableDeclarator(pattern, core.types.cloneNode(key))])]);
          scope.crawl();
          return;
        }
      },
      ArrayPattern(path) {
        const objectPatterns = [];
        const {
          scope
        } = path;
        const uidIdentifiers = [];
        visitObjectRestElements(path, path => {
          const objectPattern = path.parentPath;
          const uid = scope.generateUidIdentifier("ref");
          objectPatterns.push({
            left: objectPattern.node,
            right: uid
          });
          uidIdentifiers.push(uid);
          objectPattern.replaceWith(core.types.cloneNode(uid));
          path.skip();
        });
        if (objectPatterns.length > 0) {
          const patternParentPath = path.findParent(path => !(path.isPattern() || path.isObjectProperty()));
          const patternParent = patternParentPath.node;
          switch (patternParent.type) {
            case "VariableDeclarator":
              patternParentPath.insertAfter(objectPatterns.map(({
                left,
                right
              }) => core.types.variableDeclarator(left, right)));
              break;
            case "AssignmentExpression":
              {
                for (const uidIdentifier of uidIdentifiers) {
                  scope.push({
                    id: core.types.cloneNode(uidIdentifier)
                  });
                }
                patternParentPath.insertAfter(objectPatterns.map(({
                  left,
                  right
                }) => core.types.assignmentExpression("=", left, right)));
              }
              break;
            default:
              throw new Error(`Unexpected pattern parent type: ${patternParent.type}`);
          }
        }
      },
      ObjectExpression(path, file) {
        if (!hasSpread(path.node)) return;
        let helper;
        if (setSpreadProperties) {
          helper = getExtendsHelper(file);
        } else {
          {
            try {
              helper = file.addHelper("objectSpread2");
            } catch (_unused) {
              this.file.declarations.objectSpread2 = null;
              helper = file.addHelper("objectSpread");
            }
          }
        }
        let exp = null;
        let props = [];
        function make() {
          const hadProps = props.length > 0;
          const obj = core.types.objectExpression(props);
          props = [];
          if (!exp) {
            exp = core.types.callExpression(helper, [obj]);
            return;
          }
          if (pureGetters) {
            if (hadProps) {
              exp.arguments.push(obj);
            }
            return;
          }
          exp = core.types.callExpression(core.types.cloneNode(helper), [exp, ...(hadProps ? [core.types.objectExpression([]), obj] : [])]);
        }
        for (const prop of path.node.properties) {
          if (core.types.isSpreadElement(prop)) {
            make();
            exp.arguments.push(prop.argument);
          } else {
            props.push(prop);
          }
        }
        if (props.length) make();
        path.replaceWith(exp);
      }
    }
  };
});

exports.default = index;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-object-rest-spread\package.json

Code:
{
  "name": "@babel/plugin-transform-object-rest-spread",
  "version": "7.27.7",
  "description": "Compile object rest and spread to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-object-rest-spread"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-object-rest-spread",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-compilation-targets": "^7.27.2",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/plugin-transform-destructuring": "^7.27.7",
    "@babel/plugin-transform-parameters": "^7.27.7",
    "@babel/traverse": "^7.27.7"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/parser": "^7.27.7"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-object-rest-spread\README.md

Code:
# @babel/plugin-transform-object-rest-spread

> Compile object rest and spread to ES5

See our website [@babel/plugin-transform-object-rest-spread](https://babeljs.io/docs/babel-plugin-transform-object-rest-spread) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-object-rest-spread
```

or using yarn:

```sh
yarn add @babel/plugin-transform-object-rest-spread --dev
```


---

File name: node_modules\@babel\plugin-transform-object-super\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperReplaceSupers = require("@babel/helper-replace-supers");
var _core = require("@babel/core");
function replacePropertySuper(path, getObjectRef, file) {
  const replaceSupers = new _helperReplaceSupers.default({
    getObjectRef: getObjectRef,
    methodPath: path,
    file: file
  });
  replaceSupers.replace();
}
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const newLets = new Set();
  return {
    name: "transform-object-super",
    visitor: {
      Loop: {
        exit(path) {
          newLets.forEach(v => {
            if (v.scopePath === path) {
              path.scope.push({
                id: v.id,
                kind: "let"
              });
              path.scope.crawl();
              path.requeue();
              newLets.delete(v);
            }
          });
        }
      },
      ObjectExpression(path, state) {
        let objectRef;
        const getObjectRef = () => objectRef = objectRef || path.scope.generateUidIdentifier("obj");
        path.get("properties").forEach(propPath => {
          if (!propPath.isMethod()) return;
          replacePropertySuper(propPath, getObjectRef, state.file);
        });
        if (objectRef) {
          const scopePath = path.findParent(p => p.isFunction() || p.isProgram() || p.isLoop());
          const useLet = scopePath.isLoop();
          if (useLet) {
            newLets.add({
              scopePath,
              id: _core.types.cloneNode(objectRef)
            });
          } else {
            path.scope.push({
              id: _core.types.cloneNode(objectRef),
              kind: "var"
            });
          }
          path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(objectRef), path.node));
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-object-super\package.json

Code:
{
  "name": "@babel/plugin-transform-object-super",
  "version": "7.27.1",
  "description": "Compile ES2015 object super to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-object-super"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-object-super",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-replace-supers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-object-super\README.md

Code:
# @babel/plugin-transform-object-super

> Compile ES2015 object super to ES5

See our website [@babel/plugin-transform-object-super](https://babeljs.io/docs/babel-plugin-transform-object-super) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-object-super
```

or using yarn:

```sh
yarn add @babel/plugin-transform-object-super --dev
```


---

File name: node_modules\@babel\plugin-transform-optional-catch-binding\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return {
    name: "transform-optional-catch-binding",
    manipulateOptions: (_, parser) => parser.plugins.push("optionalCatchBinding"),
    visitor: {
      CatchClause(path) {
        if (!path.node.param) {
          const uid = path.scope.generateUidIdentifier("unused");
          const paramPath = path.get("param");
          paramPath.replaceWith(uid);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-optional-catch-binding\package.json

Code:
{
  "name": "@babel/plugin-transform-optional-catch-binding",
  "version": "7.27.1",
  "description": "Compile optional catch bindings",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-optional-catch-binding"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-optional-catch-binding",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-optional-catch-binding\README.md

Code:
# @babel/plugin-transform-optional-catch-binding

> Compile optional catch bindings

See our website [@babel/plugin-transform-optional-catch-binding](https://babeljs.io/docs/babel-plugin-transform-optional-catch-binding) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-optional-catch-binding
```

or using yarn:

```sh
yarn add @babel/plugin-transform-optional-catch-binding --dev
```


---

File name: node_modules\@babel\plugin-transform-optional-chaining\lib\index.js

Code:
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helperPluginUtils = require('@babel/helper-plugin-utils');
var core = require('@babel/core');
var helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');

function willPathCastToBoolean(path) {
  const maybeWrapped = findOutermostTransparentParent(path);
  const {
    node,
    parentPath
  } = maybeWrapped;
  if (parentPath.isLogicalExpression()) {
    const {
      operator,
      right
    } = parentPath.node;
    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
      return willPathCastToBoolean(parentPath);
    }
  }
  if (parentPath.isSequenceExpression()) {
    const {
      expressions
    } = parentPath.node;
    if (expressions[expressions.length - 1] === node) {
      return willPathCastToBoolean(parentPath);
    } else {
      return true;
    }
  }
  return parentPath.isConditional({
    test: node
  }) || parentPath.isUnaryExpression({
    operator: "!"
  }) || parentPath.isLoop({
    test: node
  });
}
function findOutermostTransparentParent(path) {
  let maybeWrapped = path;
  path.findParent(p => {
    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;
    maybeWrapped = p;
  });
  return maybeWrapped;
}

const last = arr => arr[arr.length - 1];
function isSimpleMemberExpression(expression) {
  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);
  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
}
function needsMemoize(path) {
  let optionalPath = path;
  const {
    scope
  } = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const {
      node
    } = optionalPath;
    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get("object") : optionalPath.get("callee"));
    if (node.optional) {
      return !scope.isStatic(childPath.node);
    }
    optionalPath = childPath;
  }
}
const NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);
const NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);
const NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);
const NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);
function transformOptionalChain(path, {
  pureGetters,
  noDocumentAll
}, replacementPath, ifNullish, wrapLast) {
  const {
    scope
  } = path;
  if (scope.path.isPattern() && needsMemoize(path)) {
    replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node})()`);
    return;
  }
  const optionals = [];
  let optionalPath = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const {
      node
    } = optionalPath;
    if (node.optional) {
      optionals.push(node);
    }
    if (optionalPath.isOptionalMemberExpression()) {
      optionalPath.node.type = "MemberExpression";
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
    } else if (optionalPath.isOptionalCallExpression()) {
      optionalPath.node.type = "CallExpression";
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
    }
  }
  if (optionals.length === 0) {
    return;
  }
  const checks = [];
  let tmpVar;
  for (let i = optionals.length - 1; i >= 0; i--) {
    const node = optionals[i];
    const isCall = core.types.isCallExpression(node);
    const chainWithTypes = isCall ? node.callee : node.object;
    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
    let ref;
    let check;
    if (isCall && core.types.isIdentifier(chain, {
      name: "eval"
    })) {
      check = ref = chain;
      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);
    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
      check = ref = node.callee;
    } else if (scope.isStatic(chain)) {
      check = ref = chainWithTypes;
    } else {
      if (!tmpVar || isCall) {
        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);
        scope.push({
          id: core.types.cloneNode(tmpVar)
        });
      }
      ref = tmpVar;
      check = core.types.assignmentExpression("=", core.types.cloneNode(tmpVar), chainWithTypes);
      if (isCall) {
        node.callee = ref;
      } else {
        node.object = ref;
      }
    }
    if (isCall && core.types.isMemberExpression(chain)) {
      if (pureGetters && isSimpleMemberExpression(chain)) {
        node.callee = chainWithTypes;
      } else {
        const {
          object
        } = chain;
        let context;
        if (core.types.isSuper(object)) {
          context = core.types.thisExpression();
        } else {
          const memoized = scope.maybeGenerateMemoised(object);
          if (memoized) {
            context = memoized;
            chain.object = core.types.assignmentExpression("=", memoized, object);
          } else {
            context = object;
          }
        }
        node.arguments.unshift(core.types.cloneNode(context));
        node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
      }
    }
    const data = {
      check: core.types.cloneNode(check),
      ref: core.types.cloneNode(ref)
    };
    Object.defineProperty(data, "ref", {
      enumerable: false
    });
    checks.push(data);
  }
  let result = replacementPath.node;
  if (wrapLast) result = wrapLast(result);
  const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);
  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;
  const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {
    operator: "void"
  });
  const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;
  const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;
  const logicalOp = ifNullishFalse ? "&&" : "||";
  const check = checks.map(tpl).reduce((expr, check) => core.types.logicalExpression(logicalOp, expr, check));
  replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));
}
function transform(path, assumptions) {
  const {
    scope
  } = path;
  const maybeWrapped = findOutermostTransparentParent(path);
  const {
    parentPath
  } = maybeWrapped;
  if (parentPath.isUnaryExpression({
    operator: "delete"
  })) {
    transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));
  } else {
    let wrapLast;
    if (parentPath.isCallExpression({
      callee: maybeWrapped.node
    }) && path.isOptionalMemberExpression()) {
      wrapLast = replacement => {
        const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
        let baseRef;
        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {
          baseRef = scope.maybeGenerateMemoised(object);
          if (baseRef) {
            replacement.object = core.types.assignmentExpression("=", baseRef, object);
          }
        }
        return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [core.types.cloneNode(baseRef != null ? baseRef : object)]);
      };
    }
    transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);
  }
}

var index = helperPluginUtils.declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    loose = false
  } = options;
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
  return {
    name: "transform-optional-chaining",
    manipulateOptions: (_, parser) => parser.plugins.push("optionalChaining"),
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        transform(path, {
          noDocumentAll,
          pureGetters
        });
      }
    }
  };
});

exports.default = index;
exports.transform = transform;
exports.transformOptionalChain = transformOptionalChain;
//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-optional-chaining\package.json

Code:
{
  "name": "@babel/plugin-transform-optional-chaining",
  "version": "7.27.1",
  "description": "Transform optional chaining operators into a series of nil checks",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-optional-chaining"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-optional-chaining",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-transform-block-scoping": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-optional-chaining\README.md

Code:
# @babel/plugin-transform-optional-chaining

> Transform optional chaining operators into a series of nil checks

See our website [@babel/plugin-transform-optional-chaining](https://babeljs.io/docs/babel-plugin-transform-optional-chaining) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-optional-chaining
```

or using yarn:

```sh
yarn add @babel/plugin-transform-optional-chaining --dev
```


---

File name: node_modules\@babel\plugin-transform-parameters\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "convertFunctionParams", {
  enumerable: true,
  get: function () {
    return _params.default;
  }
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _params = require("./params.js");
var _rest = require("./rest.js");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose;
  const noNewArrows = (_api$assumption2 = api.assumption("noNewArrows")) != null ? _api$assumption2 : true;
  return {
    name: "transform-parameters",
    visitor: {
      Function(path) {
        if (path.isArrowFunctionExpression() && path.get("params").some(param => param.isRestElement() || param.isAssignmentPattern())) {
          path.arrowFunctionToExpression({
            allowInsertArrowWithRest: false,
            noNewArrows
          });
          if (!path.isFunctionExpression()) return;
        }
        const convertedRest = (0, _rest.default)(path);
        const convertedParams = (0, _params.default)(path, ignoreFunctionLength);
        if (convertedRest || convertedParams) {
          path.scope.crawl();
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-parameters\lib\params.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convertFunctionParams;
var _core = require("@babel/core");
var _shadowUtils = require("./shadow-utils.js");
const buildDefaultParam = _core.template.statement(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?
      arguments[ARGUMENT_KEY]
    :
      DEFAULT_VALUE;
`);
const buildLooseDefaultParam = _core.template.statement(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {
    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
  }
`);
const buildLooseDestructuredDefaultParam = _core.template.statement(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;
`);
const buildSafeArgumentsAccess = _core.template.statement(`
  let $0 = arguments.length > $1 ? arguments[$1] : undefined;
`);
function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
  const params = path.get("params");
  const isSimpleParameterList = params.every(param => param.isIdentifier());
  if (isSimpleParameterList) return false;
  const {
    node,
    scope
  } = path;
  const body = [];
  const shadowedParams = new Set();
  for (const param of params) {
    (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);
  }
  const state = {
    needsOuterBinding: false,
    scope
  };
  if (shadowedParams.size === 0) {
    for (const param of params) {
      if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);
      if (state.needsOuterBinding) break;
    }
  }
  let firstOptionalIndex = null;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    if (shouldTransformParam && !shouldTransformParam(i)) {
      continue;
    }
    const transformedRestNodes = [];
    if (replaceRestElement) {
      replaceRestElement(path, param, transformedRestNodes);
    }
    const paramIsAssignmentPattern = param.isAssignmentPattern();
    if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {
      kind: "set"
    }))) {
      const left = param.get("left");
      const right = param.get("right");
      const undefinedNode = scope.buildUndefinedNode();
      if (left.isIdentifier()) {
        body.push(buildLooseDefaultParam({
          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
          DEFAULT_VALUE: right.node,
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(left.node);
      } else if (left.isObjectPattern() || left.isArrayPattern()) {
        const paramName = scope.generateUidIdentifier();
        body.push(buildLooseDestructuredDefaultParam({
          ASSIGNMENT_IDENTIFIER: left.node,
          DEFAULT_VALUE: right.node,
          PARAMETER_NAME: _core.types.cloneNode(paramName),
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(paramName);
      }
    } else if (paramIsAssignmentPattern) {
      if (firstOptionalIndex === null) firstOptionalIndex = i;
      const left = param.get("left");
      const right = param.get("right");
      const defNode = buildDefaultParam({
        VARIABLE_NAME: left.node,
        DEFAULT_VALUE: right.node,
        ARGUMENT_KEY: _core.types.numericLiteral(i)
      });
      body.push(defNode);
    } else if (firstOptionalIndex !== null) {
      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);
      body.push(defNode);
    } else if (param.isObjectPattern() || param.isArrayPattern()) {
      const uid = path.scope.generateUidIdentifier("ref");
      uid.typeAnnotation = param.node.typeAnnotation;
      const defNode = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(param.node, uid)]);
      body.push(defNode);
      param.replaceWith(_core.types.cloneNode(uid));
    }
    if (transformedRestNodes) {
      for (const transformedNode of transformedRestNodes) {
        body.push(transformedNode);
      }
    }
  }
  if (firstOptionalIndex !== null) {
    node.params = node.params.slice(0, firstOptionalIndex);
  }
  path.ensureBlock();
  const path2 = path;
  const {
    async,
    generator
  } = node;
  if (generator || state.needsOuterBinding || shadowedParams.size > 0) {
    body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path2.node.body));
    path.set("body", _core.types.blockStatement(body));
    const bodyPath = path2.get("body.body");
    const arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
    arrowPath.arrowFunctionToExpression();
    arrowPath.node.generator = generator;
    arrowPath.node.async = async;
    node.generator = false;
    node.async = false;
    if (async && !generator) {
      path2.node.body = _core.template.statement.ast`{
        try {
          ${path2.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`;
    }
  } else {
    path2.get("body").unshiftContainer("body", body);
  }
  return true;
}

//# sourceMappingURL=params.js.map


---

File name: node_modules\@babel\plugin-transform-parameters\lib\rest.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convertFunctionRest;
var _core = require("@babel/core");
var _shadowUtils = require("./shadow-utils.js");
const buildRest = _core.template.statement(`
  for (var LEN = ARGUMENTS.length,
           ARRAY = new Array(ARRAY_LEN),
           KEY = START;
       KEY < LEN;
       KEY++) {
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
  }
`);
const restIndex = _core.template.expression(`
  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]
`);
const restIndexImpure = _core.template.expression(`
  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]
`);
const restLength = _core.template.expression(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`);
function referencesRest(path, state) {
  if (path.node.name === state.name) {
    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
  }
  return false;
}
const memberExpressionOptimisationVisitor = {
  Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
      path.skip();
    }
  },
  Flow(path) {
    if (path.isTypeCastExpression()) return;
    path.skip();
  },
  Function(path, state) {
    const oldNoOptimise = state.noOptimise;
    state.noOptimise = true;
    path.traverse(memberExpressionOptimisationVisitor, state);
    state.noOptimise = oldNoOptimise;
    path.skip();
  },
  ReferencedIdentifier(path, state) {
    const {
      node
    } = path;
    if (node.name === "arguments") {
      state.deopted = true;
    }
    if (!referencesRest(path, state)) return;
    if (state.noOptimise) {
      state.deopted = true;
    } else {
      const {
        parentPath
      } = path;
      if (parentPath.listKey === "params" && parentPath.key < state.offset) {
        return;
      }
      if (parentPath.isMemberExpression({
        object: node
      })) {
        const grandparentPath = parentPath.parentPath;
        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
          operator: "delete"
        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);
        if (argsOptEligible) {
          if (parentPath.node.computed) {
            if (parentPath.get("property").isBaseType("number")) {
              state.candidates.push({
                cause: "indexGetter",
                path
              });
              return;
            }
          } else if (parentPath.node.property.name === "length") {
            state.candidates.push({
              cause: "lengthGetter",
              path
            });
            return;
          }
        }
      }
      if (state.offset === 0 && parentPath.isSpreadElement()) {
        const call = parentPath.parentPath;
        if (call.isCallExpression() && call.node.arguments.length === 1) {
          state.candidates.push({
            cause: "argSpread",
            path
          });
          return;
        }
      }
      state.references.push(path);
    }
  },
  BindingIdentifier(path, state) {
    if (referencesRest(path, state)) {
      state.deopted = true;
    }
  }
};
function getParamsCount(node) {
  let count = node.params.length;
  if (count > 0 && _core.types.isIdentifier(node.params[0], {
    name: "this"
  })) {
    count -= 1;
  }
  return count;
}
function hasRest(node) {
  const length = node.params.length;
  return length > 0 && _core.types.isRestElement(node.params[length - 1]);
}
function optimiseIndexGetter(path, argsId, offset) {
  const offsetLiteral = _core.types.numericLiteral(offset);
  let index;
  const parent = path.parent;
  if (_core.types.isNumericLiteral(parent.property)) {
    index = _core.types.numericLiteral(parent.property.value + offset);
  } else if (offset === 0) {
    index = parent.property;
  } else {
    index = _core.types.binaryExpression("+", parent.property, _core.types.cloneNode(offsetLiteral));
  }
  const {
    scope,
    parentPath
  } = path;
  if (!scope.isPure(index)) {
    const temp = scope.generateUidIdentifierBasedOnNode(index);
    scope.push({
      id: temp,
      kind: "var"
    });
    parentPath.replaceWith(restIndexImpure({
      ARGUMENTS: argsId,
      OFFSET: offsetLiteral,
      INDEX: index,
      REF: _core.types.cloneNode(temp)
    }));
  } else {
    parentPath.replaceWith(restIndex({
      ARGUMENTS: argsId,
      OFFSET: offsetLiteral,
      INDEX: index
    }));
    const replacedParentPath = parentPath;
    const offsetTestPath = replacedParentPath.get("test");
    const valRes = offsetTestPath.get("left").evaluate();
    if (valRes.confident) {
      if (valRes.value === true) {
        replacedParentPath.replaceWith(scope.buildUndefinedNode());
      } else {
        offsetTestPath.replaceWith(offsetTestPath.get("right"));
      }
    }
  }
}
function optimiseLengthGetter(path, argsId, offset) {
  if (offset) {
    path.parentPath.replaceWith(restLength({
      ARGUMENTS: argsId,
      OFFSET: _core.types.numericLiteral(offset)
    }));
  } else {
    path.replaceWith(argsId);
  }
}
function convertFunctionRest(path) {
  const {
    node,
    scope
  } = path;
  if (!hasRest(node)) return false;
  const restPath = path.get(`params.${node.params.length - 1}.argument`);
  if (!restPath.isIdentifier()) {
    const shadowedParams = new Set();
    (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);
    let needsIIFE = shadowedParams.size > 0;
    if (!needsIIFE) {
      const state = {
        needsOuterBinding: false,
        scope
      };
      restPath.traverse(_shadowUtils.iifeVisitor, state);
      needsIIFE = state.needsOuterBinding;
    }
    if (needsIIFE) {
      path.ensureBlock();
      path.set("body", _core.types.blockStatement([(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)]));
    }
  }
  let rest = restPath.node;
  node.params.pop();
  if (_core.types.isPattern(rest)) {
    const pattern = rest;
    rest = scope.generateUidIdentifier("ref");
    const declar = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(pattern, rest)]);
    path.ensureBlock();
    node.body.body.unshift(declar);
  } else if (rest.name === "arguments") {
    scope.rename(rest.name);
  }
  const argsId = _core.types.identifier("arguments");
  const paramsCount = getParamsCount(node);
  const state = {
    references: [],
    offset: paramsCount,
    argumentsNode: argsId,
    outerBinding: scope.getBindingIdentifier(rest.name),
    candidates: [],
    name: rest.name,
    deopted: false
  };
  path.traverse(memberExpressionOptimisationVisitor, state);
  if (!state.deopted && !state.references.length) {
    for (const {
      path,
      cause
    } of state.candidates) {
      const clonedArgsId = _core.types.cloneNode(argsId);
      switch (cause) {
        case "indexGetter":
          optimiseIndexGetter(path, clonedArgsId, state.offset);
          break;
        case "lengthGetter":
          optimiseLengthGetter(path, clonedArgsId, state.offset);
          break;
        default:
          path.replaceWith(clonedArgsId);
      }
    }
    return true;
  }
  state.references.push(...state.candidates.map(({
    path
  }) => path));
  const start = _core.types.numericLiteral(paramsCount);
  const key = scope.generateUidIdentifier("key");
  const len = scope.generateUidIdentifier("len");
  let arrKey, arrLen;
  if (paramsCount) {
    arrKey = _core.types.binaryExpression("-", _core.types.cloneNode(key), _core.types.cloneNode(start));
    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(">", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression("-", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));
  } else {
    arrKey = _core.types.identifier(key.name);
    arrLen = _core.types.identifier(len.name);
  }
  const loop = buildRest({
    ARGUMENTS: argsId,
    ARRAY_KEY: arrKey,
    ARRAY_LEN: arrLen,
    START: start,
    ARRAY: rest,
    KEY: key,
    LEN: len
  });
  if (state.deopted) {
    node.body.body.unshift(loop);
  } else {
    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
    target.findParent(path => {
      if (path.isLoop()) {
        target = path;
      } else {
        return path.isFunction();
      }
    });
    target.insertBefore(loop);
  }
  return true;
}

//# sourceMappingURL=rest.js.map


---

File name: node_modules\@babel\plugin-transform-parameters\lib\shadow-utils.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildScopeIIFE = buildScopeIIFE;
exports.collectShadowedParamsNames = collectShadowedParamsNames;
exports.iifeVisitor = void 0;
var _core = require("@babel/core");
const iifeVisitor = exports.iifeVisitor = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    const {
      scope,
      node
    } = path;
    const {
      name
    } = node;
    if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
      state.needsOuterBinding = true;
      path.stop();
    }
  },
  "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": path => path.skip()
};
function collectShadowedParamsNames(param, functionScope, shadowedParams) {
  for (const name of Object.keys(param.getBindingIdentifiers())) {
    var _functionScope$bindin;
    const constantViolations = (_functionScope$bindin = functionScope.bindings[name]) == null ? void 0 : _functionScope$bindin.constantViolations;
    if (constantViolations) {
      for (const redeclarator of constantViolations) {
        const node = redeclarator.node;
        switch (node.type) {
          case "VariableDeclarator":
            {
              if (node.init === null) {
                const declaration = redeclarator.parentPath;
                if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                  redeclarator.remove();
                  break;
                }
              }
              shadowedParams.add(name);
              break;
            }
          case "FunctionDeclaration":
            shadowedParams.add(name);
            break;
        }
      }
    }
  }
}
function buildScopeIIFE(shadowedParams, body) {
  const args = [];
  const params = [];
  for (const name of shadowedParams) {
    args.push(_core.types.identifier(name));
    params.push(_core.types.identifier(name));
  }
  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));
}

//# sourceMappingURL=shadow-utils.js.map


---

File name: node_modules\@babel\plugin-transform-parameters\package.json

Code:
{
  "name": "@babel/plugin-transform-parameters",
  "version": "7.27.7",
  "description": "Compile ES2015 default and rest parameters to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-parameters"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-parameters",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.7",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-parameters\README.md

Code:
# @babel/plugin-transform-parameters

> Compile ES2015 default and rest parameters to ES5

See our website [@babel/plugin-transform-parameters](https://babeljs.io/docs/babel-plugin-transform-parameters) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-parameters
```

or using yarn:

```sh
yarn add @babel/plugin-transform-parameters --dev
```


---

File name: node_modules\@babel\plugin-transform-private-methods\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
    name: "transform-private-methods",
    api,
    feature: _helperCreateClassFeaturesPlugin.FEATURES.privateMethods,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      {
        parserOpts.plugins.push("classPrivateMethods");
      }
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-private-methods\package.json

Code:
{
  "name": "@babel/plugin-transform-private-methods",
  "version": "7.27.1",
  "description": "This plugin transforms private class methods",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-private-methods"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-private-methods",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-private-methods\README.md

Code:
# @babel/plugin-transform-private-methods

> This plugin transforms private class methods

See our website [@babel/plugin-transform-private-methods](https://babeljs.io/docs/babel-plugin-transform-private-methods) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-private-methods
```

or using yarn:

```sh
yarn add @babel/plugin-transform-private-methods --dev
```


---

File name: node_modules\@babel\plugin-transform-private-property-in-object\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opt) => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    types: t,
    template
  } = api;
  const {
    loose
  } = opt;
  const classWeakSets = new WeakMap();
  const fieldsWeakSets = new WeakMap();
  function unshadow(name, targetScope, scope) {
    while (scope !== targetScope) {
      if (scope.hasOwnBinding(name)) scope.rename(name);
      scope = scope.parent;
    }
  }
  function injectToFieldInit(fieldPath, expr, before = false) {
    if (fieldPath.node.value) {
      const value = fieldPath.get("value");
      if (before) {
        value.insertBefore(expr);
      } else {
        value.insertAfter(expr);
      }
    } else {
      fieldPath.set("value", t.unaryExpression("void", expr));
    }
  }
  function injectInitialization(classPath, init) {
    let firstFieldPath;
    let constructorPath;
    for (const el of classPath.get("body.body")) {
      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {
        firstFieldPath = el;
        break;
      }
      if (!constructorPath && el.isClassMethod({
        kind: "constructor"
      })) {
        constructorPath = el;
      }
    }
    if (firstFieldPath) {
      injectToFieldInit(firstFieldPath, init, true);
    } else {
      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);
    }
  }
  function getWeakSetId(weakSets, outerClass, reference, name = "", inject) {
    let id = weakSets.get(reference.node);
    if (!id) {
      id = outerClass.scope.generateUidIdentifier(`${name || ""} brandCheck`);
      weakSets.set(reference.node, id);
      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);
      const newExpr = t.newExpression(t.identifier("WeakSet"), []);
      (0, _helperAnnotateAsPure.default)(newExpr);
      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);
    }
    return t.cloneNode(id);
  }
  return {
    name: "transform-private-property-in-object",
    manipulateOptions: (_, parser) => parser.plugins.push("privateIn"),
    pre() {
      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);
    },
    visitor: {
      BinaryExpression(path, state) {
        const {
          node
        } = path;
        const {
          file
        } = state;
        if (node.operator !== "in") return;
        if (!t.isPrivateName(node.left)) return;
        const {
          name
        } = node.left.id;
        let privateElement;
        const outerClass = path.findParent(path => {
          if (!path.isClass()) return false;
          privateElement = path.get("body.body").find(({
            node
          }) => t.isPrivate(node) && node.key.id.name === name);
          return !!privateElement;
        });
        if (outerClass.parentPath.scope.path.isPattern()) {
          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);
          return;
        }
        if (privateElement.node.type === "ClassPrivateMethod") {
          if (privateElement.node.static) {
            if (outerClass.node.id) {
              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);
            } else {
              outerClass.set("id", path.scope.generateUidIdentifier("class"));
            }
            path.replaceWith(template.expression.ast`
                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}
              `);
          } else {
            var _outerClass$node$id;
            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);
            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
          }
        } else {
          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);
          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-private-property-in-object\package.json

Code:
{
  "name": "@babel/plugin-transform-private-property-in-object",
  "version": "7.27.1",
  "description": "This plugin transforms checks for a private property in an object",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-private-property-in-object"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-private-property-in-object",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-create-class-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-private-property-in-object\README.md

Code:
# @babel/plugin-transform-private-property-in-object

> This plugin transforms checks for a private property in an object

See our website [@babel/plugin-transform-private-property-in-object](https://babeljs.io/docs/babel-plugin-transform-private-property-in-object) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-private-property-in-object
```

or using yarn:

```sh
yarn add @babel/plugin-transform-private-property-in-object --dev
```


---

File name: node_modules\@babel\plugin-transform-property-literals\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-property-literals",
    visitor: {
      ObjectProperty: {
        exit({
          node
        }) {
          const key = node.key;
          if (!node.computed && _core.types.isIdentifier(key) && !_core.types.isValidES3Identifier(key.name)) {
            node.key = _core.types.stringLiteral(key.name);
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-property-literals\package.json

Code:
{
  "name": "@babel/plugin-transform-property-literals",
  "version": "7.27.1",
  "description": "Ensure that reserved words are quoted in object property keys",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-property-literals"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-property-literals",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-property-literals\README.md

Code:
# @babel/plugin-transform-property-literals

> Ensure that reserved words are quoted in object property keys

See our website [@babel/plugin-transform-property-literals](https://babeljs.io/docs/babel-plugin-transform-property-literals) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-property-literals
```

or using yarn:

```sh
yarn add @babel/plugin-transform-property-literals --dev
```


---

File name: node_modules\@babel\plugin-transform-react-display-name\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _path = require("path");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  function addDisplayName(id, call) {
    const props = call.arguments[0].properties;
    let safe = true;
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (_core.types.isSpreadElement(prop)) {
        continue;
      }
      const key = _core.types.toComputedKey(prop);
      if (_core.types.isStringLiteral(key, {
        value: "displayName"
      })) {
        safe = false;
        break;
      }
    }
    if (safe) {
      props.unshift(_core.types.objectProperty(_core.types.identifier("displayName"), _core.types.stringLiteral(id)));
    }
  }
  const isCreateClassCallExpression = _core.types.buildMatchMemberExpression("React.createClass");
  const isCreateClassAddon = callee => _core.types.isIdentifier(callee, {
    name: "createReactClass"
  });
  function isCreateClass(node) {
    if (!node || !_core.types.isCallExpression(node)) return false;
    if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
      return false;
    }
    const args = node.arguments;
    if (args.length !== 1) return false;
    const first = args[0];
    if (!_core.types.isObjectExpression(first)) return false;
    return true;
  }
  return {
    name: "transform-react-display-name",
    visitor: {
      ExportDefaultDeclaration({
        node
      }, state) {
        if (isCreateClass(node.declaration)) {
          const filename = state.filename || "unknown";
          let displayName = _path.basename(filename, _path.extname(filename));
          if (displayName === "index") {
            displayName = _path.basename(_path.dirname(filename));
          }
          addDisplayName(displayName, node.declaration);
        }
      },
      CallExpression(path) {
        const {
          node
        } = path;
        if (!isCreateClass(node)) return;
        let id;
        path.find(function (path) {
          if (path.isAssignmentExpression()) {
            id = path.node.left;
          } else if (path.isObjectProperty()) {
            id = path.node.key;
          } else if (path.isVariableDeclarator()) {
            id = path.node.id;
          } else if (path.isStatement()) {
            return true;
          }
          if (id) return true;
        });
        if (!id) return;
        if (_core.types.isMemberExpression(id)) {
          id = id.property;
        }
        if (_core.types.isIdentifier(id)) {
          addDisplayName(id.name, node);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-react-display-name\package.json

Code:
{
  "name": "@babel/plugin-transform-react-display-name",
  "version": "7.27.1",
  "description": "Add displayName to React.createClass calls",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-display-name"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-display-name",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-react-display-name\README.md

Code:
# @babel/plugin-transform-react-display-name

> Add displayName to React.createClass calls

See our website [@babel/plugin-transform-react-display-name](https://babeljs.io/docs/babel-plugin-transform-react-display-name) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-react-display-name
```

or using yarn:

```sh
yarn add @babel/plugin-transform-react-display-name --dev
```


---

File name: node_modules\@babel\plugin-transform-react-jsx\lib\create-plugin.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPlugin;
var _pluginSyntaxJsx = require("@babel/plugin-syntax-jsx");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _helperModuleImports = require("@babel/helper-module-imports");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
const DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};
const JSX_SOURCE_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxImportSource\s+(\S+)\s*$/m;
const JSX_RUNTIME_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxRuntime\s+(\S+)\s*$/m;
const JSX_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsx\s+(\S+)\s*$/m;
const JSX_FRAG_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxFrag\s+(\S+)\s*$/m;
const get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);
const set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);
function hasProto(node) {
  return node.properties.some(value => _core.types.isObjectProperty(value, {
    computed: false,
    shorthand: false
  }) && (_core.types.isIdentifier(value.key, {
    name: "__proto__"
  }) || _core.types.isStringLiteral(value.key, {
    value: "__proto__"
  })));
}
function createPlugin({
  name,
  development
}) {
  return (0, _helperPluginUtils.declare)((_, options) => {
    const {
      pure: PURE_ANNOTATION,
      throwIfNamespace = true,
      filter,
      runtime: RUNTIME_DEFAULT = development ? "automatic" : "classic",
      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,
      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,
      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag
    } = options;
    {
      var {
        useSpread = false,
        useBuiltIns = false
      } = options;
      if (RUNTIME_DEFAULT === "classic") {
        if (typeof useSpread !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
        }
        if (typeof useBuiltIns !== "boolean") {
          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
        }
        if (useSpread && useBuiltIns) {
          throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
        }
      }
    }
    const injectMetaPropertiesVisitor = {
      JSXOpeningElement(path, state) {
        const attributes = [];
        if (isThisAllowed(path.scope)) {
          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__self"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));
        }
        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__source"), _core.types.jsxExpressionContainer(makeSource(path, state))));
        path.pushContainer("attributes", attributes);
      }
    };
    return {
      name,
      inherits: _pluginSyntaxJsx.default,
      visitor: {
        JSXNamespacedName(path) {
          if (throwIfNamespace) {
            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \
You can set \`throwIfNamespace: false\` to bypass this warning.`);
          }
        },
        JSXSpreadChild(path) {
          throw path.buildCodeFrameError("Spread children are not supported in React.");
        },
        Program: {
          enter(path, state) {
            const {
              file
            } = state;
            let runtime = RUNTIME_DEFAULT;
            let source = IMPORT_SOURCE_DEFAULT;
            let pragma = PRAGMA_DEFAULT;
            let pragmaFrag = PRAGMA_FRAG_DEFAULT;
            let sourceSet = !!options.importSource;
            let pragmaSet = !!options.pragma;
            let pragmaFragSet = !!options.pragmaFrag;
            if (file.ast.comments) {
              for (const comment of file.ast.comments) {
                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);
                if (sourceMatches) {
                  source = sourceMatches[1];
                  sourceSet = true;
                }
                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);
                if (runtimeMatches) {
                  runtime = runtimeMatches[1];
                }
                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);
                if (jsxMatches) {
                  pragma = jsxMatches[1];
                  pragmaSet = true;
                }
                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);
                if (jsxFragMatches) {
                  pragmaFrag = jsxFragMatches[1];
                  pragmaFragSet = true;
                }
              }
            }
            set(state, "runtime", runtime);
            if (runtime === "classic") {
              if (sourceSet) {
                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);
              }
              const createElement = toMemberExpression(pragma);
              const fragment = toMemberExpression(pragmaFrag);
              set(state, "id/createElement", () => _core.types.cloneNode(createElement));
              set(state, "id/fragment", () => _core.types.cloneNode(fragment));
              set(state, "defaultPure", pragma === DEFAULT.pragma);
            } else if (runtime === "automatic") {
              if (pragmaSet || pragmaFragSet) {
                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);
              }
              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));
              define("id/jsx", development ? "jsxDEV" : "jsx");
              define("id/jsxs", development ? "jsxDEV" : "jsxs");
              define("id/createElement", "createElement");
              define("id/fragment", "Fragment");
              set(state, "defaultPure", source === DEFAULT.importSource);
            } else {
              throw path.buildCodeFrameError(`Runtime must be either "classic" or "automatic".`);
            }
            if (development) {
              path.traverse(injectMetaPropertiesVisitor, state);
            }
          }
        },
        JSXFragment: {
          exit(path, file) {
            let callExpr;
            if (get(file, "runtime") === "classic") {
              callExpr = buildCreateElementFragmentCall(path, file);
            } else {
              callExpr = buildJSXFragmentCall(path, file);
            }
            path.replaceWith(_core.types.inherits(callExpr, path.node));
          }
        },
        JSXElement: {
          exit(path, file) {
            let callExpr;
            if (get(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
              callExpr = buildCreateElementCall(path, file);
            } else {
              callExpr = buildJSXElementCall(path, file);
            }
            path.replaceWith(_core.types.inherits(callExpr, path.node));
          }
        },
        JSXAttribute(path) {
          if (_core.types.isJSXElement(path.node.value)) {
            path.node.value = _core.types.jsxExpressionContainer(path.node.value);
          }
        }
      }
    };
    function isDerivedClass(classPath) {
      return classPath.node.superClass !== null;
    }
    function isThisAllowed(scope) {
      do {
        const {
          path
        } = scope;
        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {
          if (!path.isMethod()) {
            return true;
          }
          if (path.node.kind !== "constructor") {
            return true;
          }
          return !isDerivedClass(path.parentPath.parentPath);
        }
        if (path.isTSModuleBlock()) {
          return false;
        }
      } while (scope = scope.parent);
      return true;
    }
    function call(pass, name, args) {
      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);
      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) (0, _helperAnnotateAsPure.default)(node);
      return node;
    }
    function shouldUseCreateElement(path) {
      const openingPath = path.get("openingElement");
      const attributes = openingPath.node.attributes;
      let seenPropsSpread = false;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes[i];
        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === "key") {
          return true;
        } else if (_core.types.isJSXSpreadAttribute(attr)) {
          seenPropsSpread = true;
        }
      }
      return false;
    }
    function convertJSXIdentifier(node, parent) {
      if (_core.types.isJSXIdentifier(node)) {
        if (node.name === "this" && _core.types.isReferenced(node, parent)) {
          return _core.types.thisExpression();
        } else if (_core.types.isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
          return node;
        } else {
          return _core.types.stringLiteral(node.name);
        }
      } else if (_core.types.isJSXMemberExpression(node)) {
        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (_core.types.isJSXNamespacedName(node)) {
        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);
      }
      return node;
    }
    function convertAttributeValue(node) {
      if (_core.types.isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }
    function accumulateAttribute(array, attribute) {
      if (_core.types.isJSXSpreadAttribute(attribute.node)) {
        const arg = attribute.node.argument;
        if (_core.types.isObjectExpression(arg) && !hasProto(arg)) {
          array.push(...arg.properties);
        } else {
          array.push(_core.types.spreadElement(arg));
        }
        return array;
      }
      const value = convertAttributeValue(attribute.node.name.name !== "key" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);
      if (attribute.node.name.name === "key" && value === null) {
        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
      }
      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {
        var _value$extra;
        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null || delete _value$extra.raw;
      }
      if (_core.types.isJSXNamespacedName(attribute.node.name)) {
        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + ":" + attribute.node.name.name.name);
      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {
        attribute.node.name.type = "Identifier";
      } else {
        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);
      }
      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));
      return array;
    }
    function buildChildrenProperty(children) {
      let childrenNode;
      if (children.length === 1) {
        childrenNode = children[0];
      } else if (children.length > 1) {
        childrenNode = _core.types.arrayExpression(children);
      } else {
        return undefined;
      }
      return _core.types.objectProperty(_core.types.identifier("children"), childrenNode);
    }
    function buildJSXElementCall(path, file) {
      const openingPath = path.get("openingElement");
      const args = [getTag(openingPath)];
      const attribsArray = [];
      const extracted = Object.create(null);
      for (const attr of openingPath.get("attributes")) {
        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {
          const {
            name
          } = attr.node.name;
          switch (name) {
            case "__source":
            case "__self":
              if (extracted[name]) throw sourceSelfError(path, name);
            case "key":
              {
                const keyValue = convertAttributeValue(attr.node.value);
                if (keyValue === null) {
                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
                }
                extracted[name] = keyValue;
                break;
              }
            default:
              attribsArray.push(attr);
          }
        } else {
          attribsArray.push(attr);
        }
      }
      const children = _core.types.react.buildChildren(path.node);
      let attribs;
      if (attribsArray.length || children.length) {
        attribs = buildJSXOpeningElementAttributes(attribsArray, children);
      } else {
        attribs = _core.types.objectExpression([]);
      }
      args.push(attribs);
      if (development) {
        var _extracted$key;
        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));
        if (extracted.__source) {
          args.push(extracted.__source);
          if (extracted.__self) args.push(extracted.__self);
        } else if (extracted.__self) {
          args.push(path.scope.buildUndefinedNode(), extracted.__self);
        }
      } else if (extracted.key !== undefined) {
        args.push(extracted.key);
      }
      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }
    function buildJSXOpeningElementAttributes(attribs, children) {
      const props = attribs.reduce(accumulateAttribute, []);
      if ((children == null ? void 0 : children.length) > 0) {
        props.push(buildChildrenProperty(children));
      }
      return _core.types.objectExpression(props);
    }
    function buildJSXFragmentCall(path, file) {
      const args = [get(file, "id/fragment")()];
      const children = _core.types.react.buildChildren(path.node);
      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));
      if (development) {
        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));
      }
      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }
    function buildCreateElementFragmentCall(path, file) {
      if (filter && !filter(path.node, file)) return;
      return call(file, "createElement", [get(file, "id/fragment")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);
    }
    function buildCreateElementCall(path, file) {
      const openingPath = path.get("openingElement");
      return call(file, "createElement", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes")), ..._core.types.react.buildChildren(path.node)]);
    }
    function getTag(openingPath) {
      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      let tagName;
      if (_core.types.isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (_core.types.isStringLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }
      if (_core.types.react.isCompatTag(tagName)) {
        return _core.types.stringLiteral(tagName);
      } else {
        return tagExpr;
      }
    }
    function buildCreateElementOpeningElementAttributes(file, path, attribs) {
      const runtime = get(file, "runtime");
      {
        if (runtime !== "automatic") {
          const objs = [];
          const props = attribs.reduce(accumulateAttribute, []);
          if (!useSpread) {
            let start = 0;
            props.forEach((prop, i) => {
              if (_core.types.isSpreadElement(prop)) {
                if (i > start) {
                  objs.push(_core.types.objectExpression(props.slice(start, i)));
                }
                objs.push(prop.argument);
                start = i + 1;
              }
            });
            if (props.length > start) {
              objs.push(_core.types.objectExpression(props.slice(start)));
            }
          } else if (props.length) {
            objs.push(_core.types.objectExpression(props));
          }
          if (!objs.length) {
            return _core.types.nullLiteral();
          }
          if (objs.length === 1) {
            if (!(_core.types.isSpreadElement(props[0]) && _core.types.isObjectExpression(props[0].argument))) {
              return objs[0];
            }
          }
          if (!_core.types.isObjectExpression(objs[0])) {
            objs.unshift(_core.types.objectExpression([]));
          }
          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
          return _core.types.callExpression(helper, objs);
        }
      }
      const props = [];
      const found = Object.create(null);
      for (const attr of attribs) {
        const {
          node
        } = attr;
        const name = _core.types.isJSXAttribute(node) && _core.types.isJSXIdentifier(node.name) && node.name.name;
        if (runtime === "automatic" && (name === "__source" || name === "__self")) {
          if (found[name]) throw sourceSelfError(path, name);
          found[name] = true;
        }
        accumulateAttribute(props, attr);
      }
      return props.length === 1 && _core.types.isSpreadElement(props[0]) && !_core.types.isObjectExpression(props[0].argument) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();
    }
  });
  function getSource(source, importName) {
    switch (importName) {
      case "Fragment":
        return `${source}/${development ? "jsx-dev-runtime" : "jsx-runtime"}`;
      case "jsxDEV":
        return `${source}/jsx-dev-runtime`;
      case "jsx":
      case "jsxs":
        return `${source}/jsx-runtime`;
      case "createElement":
        return source;
    }
  }
  function createImportLazily(pass, path, importName, source) {
    return () => {
      const actualSource = getSource(source, importName);
      if ((0, _helperModuleImports.isModule)(path)) {
        let reference = get(pass, `imports/${importName}`);
        if (reference) return _core.types.cloneNode(reference);
        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {
          importedInterop: "uncompiled",
          importPosition: "after"
        });
        set(pass, `imports/${importName}`, reference);
        return reference;
      } else {
        let reference = get(pass, `requires/${actualSource}`);
        if (reference) {
          reference = _core.types.cloneNode(reference);
        } else {
          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {
            importedInterop: "uncompiled"
          });
          set(pass, `requires/${actualSource}`, reference);
        }
        return _core.types.memberExpression(reference, _core.types.identifier(importName));
      }
    };
  }
}
function toMemberExpression(id) {
  return id.split(".").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));
}
function makeSource(path, state) {
  const location = path.node.loc;
  if (!location) {
    return path.scope.buildUndefinedNode();
  }
  if (!state.fileNameIdentifier) {
    const {
      filename = ""
    } = state;
    const fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
    path.scope.getProgramParent().push({
      id: fileNameIdentifier,
      init: _core.types.stringLiteral(filename)
    });
    state.fileNameIdentifier = fileNameIdentifier;
  }
  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
}
function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();
  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();
  return _core.template.expression.ast`{
    fileName: ${fileNameIdentifier},
    lineNumber: ${fileLineLiteral},
    columnNumber: ${fileColumnLiteral},
  }`;
}
function sourceSelfError(path, name) {
  const pluginName = `transform-react-jsx-${name.slice(2)}`;
  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);
}

//# sourceMappingURL=create-plugin.js.map


---

File name: node_modules\@babel\plugin-transform-react-jsx\lib\development.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _createPlugin = require("./create-plugin.js");
var _default = exports.default = (0, _createPlugin.default)({
  name: "transform-react-jsx/development",
  development: true
});

//# sourceMappingURL=development.js.map


---

File name: node_modules\@babel\plugin-transform-react-jsx\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _createPlugin = require("./create-plugin.js");
var _default = exports.default = (0, _createPlugin.default)({
  name: "transform-react-jsx",
  development: false
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-react-jsx\package.json

Code:
{
  "name": "@babel/plugin-transform-react-jsx",
  "version": "7.27.1",
  "description": "Turn JSX into React function calls",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-react-jsx",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-module-imports": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/plugin-syntax-jsx": "^7.27.1",
    "@babel/types": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/traverse": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-react-jsx\README.md

Code:
# @babel/plugin-transform-react-jsx

> Turn JSX into React function calls

See our website [@babel/plugin-transform-react-jsx](https://babeljs.io/docs/babel-plugin-transform-react-jsx) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-react-jsx
```

or using yarn:

```sh
yarn add @babel/plugin-transform-react-jsx --dev
```


---

File name: node_modules\@babel\plugin-transform-react-jsx-development\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _development = require("@babel/plugin-transform-react-jsx/lib/development");
var _default = exports.default = _development.default;

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-react-jsx-development\package.json

Code:
{
  "name": "@babel/plugin-transform-react-jsx-development",
  "version": "7.27.1",
  "description": "Turn JSX into React function calls in development",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-jsx-development"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/plugin-transform-react-jsx": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-react-jsx-development\README.md

Code:
# @babel/plugin-transform-react-jsx-development

> Turn JSX into React function calls in development

See our website [@babel/plugin-transform-react-jsx-development](https://babeljs.io/docs/babel-plugin-transform-react-jsx-development) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-react-jsx-development
```

or using yarn:

```sh
yarn add @babel/plugin-transform-react-jsx-development --dev
```


---

File name: node_modules\@babel\plugin-transform-react-pure-annotations\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
var _core = require("@babel/core");
const PURE_CALLS = [["react", new Set(["cloneElement", "createContext", "createElement", "createFactory", "createRef", "forwardRef", "isValidElement", "memo", "lazy"])], ["react-dom", new Set(["createPortal"])]];
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-react-pure-annotations",
    visitor: {
      CallExpression(path) {
        if (isReactCall(path)) {
          (0, _helperAnnotateAsPure.default)(path);
        }
      }
    }
  };
});
function isReactCall(path) {
  const calleePath = path.get("callee");
  if (!calleePath.isMemberExpression()) {
    for (const [module, methods] of PURE_CALLS) {
      for (const method of methods) {
        if (calleePath.referencesImport(module, method)) {
          return true;
        }
      }
    }
    return false;
  }
  const object = calleePath.get("object");
  const callee = calleePath.node;
  if (!callee.computed && _core.types.isIdentifier(callee.property)) {
    const propertyName = callee.property.name;
    for (const [module, methods] of PURE_CALLS) {
      if (object.referencesImport(module, "default") || object.referencesImport(module, "*")) {
        return methods.has(propertyName);
      }
    }
  }
  return false;
}

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-react-pure-annotations\package.json

Code:
{
  "name": "@babel/plugin-transform-react-pure-annotations",
  "version": "7.27.1",
  "description": "Mark top-level React method calls as pure for tree shaking",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-react-pure-annotations"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-annotate-as-pure": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-react-pure-annotations\README.md

Code:
# @babel/plugin-transform-react-pure-annotations

> Mark top-level React method calls as pure for tree shaking

See our website [@babel/plugin-transform-react-pure-annotations](https://babeljs.io/docs/babel-plugin-transform-react-pure-annotations) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-react-pure-annotations
```

or using yarn:

```sh
yarn add @babel/plugin-transform-react-pure-annotations --dev
```


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _visit = require("./regenerator/visit.js");
var _default = exports.default = (0, _helperPluginUtils.declare)(({
  types: t,
  traverse,
  assertVersion
}) => {
  assertVersion(7);
  return {
    name: "transform-regenerator",
    visitor: traverse.visitors.merge([(0, _visit.getVisitor)(t), {
      CallExpression(path) {
        var _this$availableHelper;
        if (!((_this$availableHelper = this.availableHelper) != null && _this$availableHelper.call(this, "regeneratorRuntime"))) {
          return;
        }
        const callee = path.get("callee");
        if (!callee.isMemberExpression()) return;
        const obj = callee.get("object");
        if (obj.isIdentifier({
          name: "regeneratorRuntime"
        })) {
          const helper = this.addHelper("regeneratorRuntime");
          if (t.isArrowFunctionExpression(helper)) {
            obj.replaceWith(helper.body);
            return;
          }
          obj.replaceWith(t.callExpression(helper, []));
        }
      }
    }])
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\emit.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = void 0;
var _assert = require("assert");
var leap = require("./leap.js");
var meta = require("./meta.js");
var util = require("./util.js");
var _core = require("@babel/core");
const PENDING_LOCATION = Number.MAX_VALUE;
function getDeclError(node) {
  return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
}
const catchParamVisitor = {
  Identifier: function (path, state) {
    if (path.node.name === state.catchParamName && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.getSafeParam());
    }
  },
  Scope: function (path, state) {
    if (path.scope.hasOwnBinding(state.catchParamName)) {
      path.skip();
    }
  }
};
class Emitter {
  constructor(contextId, scope, vars, pluginPass) {
    this.nextTempId = void 0;
    this.contextId = void 0;
    this.index = void 0;
    this.indexMap = void 0;
    this.listing = void 0;
    this.returns = void 0;
    this.lastReferenceIndex = 0;
    this.marked = void 0;
    this.insertedLocs = void 0;
    this.finalLoc = void 0;
    this.tryEntries = void 0;
    this.leapManager = void 0;
    this.scope = void 0;
    this.vars = void 0;
    this.pluginPass = void 0;
    this.pluginPass = pluginPass;
    this.scope = scope;
    this.vars = vars;
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.index = 0;
    this.indexMap = new Map([[0, 0]]);
    this.returns = new Set();
    this.lastReferenceIndex = 0;
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap.LeapManager(this);
  }
  loc() {
    const l = _core.types.numericLiteral(PENDING_LOCATION);
    this.insertedLocs.add(l);
    return l;
  }
  getInsertedLocs() {
    return this.insertedLocs;
  }
  getContextId() {
    return _core.types.cloneNode(this.contextId);
  }
  getIndex() {
    if (!this.indexMap.has(this.listing.length)) {
      this.indexMap.set(this.listing.length, ++this.index);
    }
    return this.index;
  }
  mark(loc) {
    if (loc.value === PENDING_LOCATION) {
      loc.value = this.getIndex();
    } else {
      _assert.strictEqual(loc.value, this.index);
    }
    this.marked[this.listing.length] = true;
    if (loc.value > this.lastReferenceIndex) {
      this.lastReferenceIndex = loc.value;
    }
    return loc;
  }
  emit(node) {
    if (_core.types.isExpression(node)) {
      node = _core.types.expressionStatement(node);
    }
    _core.types.assertStatement(node);
    this.listing.push(node);
  }
  emitAssign(lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  }
  assign(lhs, rhs) {
    return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(lhs), rhs));
  }
  contextProperty(name) {
    const computed = name === "catch";
    return _core.types.memberExpression(this.getContextId(), computed ? _core.types.stringLiteral(name) : _core.types.identifier(name), !!computed);
  }
  clearPendingException(tryLoc, assignee) {
    const catchCall = _core.types.callExpression(this.contextProperty("catch"), [_core.types.cloneNode(tryLoc)]);
    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  }
  jump(toLoc) {
    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc);
    this.emit(_core.types.breakStatement());
  }
  jumpIf(test, toLoc) {
    this.emit(_core.types.ifStatement(test, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
  }
  jumpIfNot(test, toLoc) {
    let negatedTest;
    if (_core.types.isUnaryExpression(test) && test.operator === "!") {
      negatedTest = test.argument;
    } else {
      negatedTest = _core.types.unaryExpression("!", test);
    }
    this.emit(_core.types.ifStatement(negatedTest, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
  }
  makeContextTempVar() {
    return this.contextProperty("t" + this.nextTempId++);
  }
  makeTempVar() {
    const id = this.scope.generateUidIdentifier("t");
    this.vars.push(_core.types.variableDeclarator(id));
    return _core.types.cloneNode(id);
  }
  getContextFunction() {
    return _core.types.functionExpression(null, [this.getContextId()], _core.types.blockStatement([this.getDispatchLoop()]), false, false);
  }
  getDispatchLoop() {
    const self = this;
    const cases = [];
    let current;
    let alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked[i]) {
        cases.push(_core.types.switchCase(_core.types.numericLiteral(self.indexMap.get(i)), current = []));
        alreadyEnded = false;
      }
      if (!alreadyEnded) {
        current.push(stmt);
        if (_core.types.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.getIndex();
    if (util.newHelpersAvailable(this.pluginPass)) {
      if (this.lastReferenceIndex === this.index || !this.returns.has(this.listing.length)) {
        cases.push(_core.types.switchCase(this.finalLoc, [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("a"), [_core.types.numericLiteral(2)]))]));
      }
    } else {
      cases.push(_core.types.switchCase(this.finalLoc, []), _core.types.switchCase(_core.types.stringLiteral("end"), [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("stop"), []))]));
    }
    return _core.types.whileStatement(_core.types.numericLiteral(1), _core.types.switchStatement(util.newHelpersAvailable(this.pluginPass) ? this.contextProperty("n") : _core.types.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  }
  getTryLocsList() {
    if (this.tryEntries.length === 0) {
      return null;
    }
    let lastLocValue = 0;
    const arrayExpression = _core.types.arrayExpression(this.tryEntries.map(function (tryEntry) {
      const thisLocValue = tryEntry.firstLoc.value;
      _assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
      lastLocValue = thisLocValue;
      const ce = tryEntry.catchEntry;
      const fe = tryEntry.finallyEntry;
      const locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];
      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }
      return _core.types.arrayExpression(locs.map(loc => loc && _core.types.cloneNode(loc)));
    }));
    if (util.newHelpersAvailable(this.pluginPass)) {
      arrayExpression.elements.reverse();
    }
    return arrayExpression;
  }
  explode(path, ignoreResult) {
    const node = path.node;
    const self = this;
    if (_core.types.isDeclaration(node)) throw getDeclError(node);
    if (path.isStatement()) return self.explodeStatement(path);
    if (path.isExpression()) return self.explodeExpression(path, ignoreResult);
    switch (node.type) {
      case "VariableDeclarator":
        throw getDeclError(node);
      case "ObjectProperty":
      case "SwitchCase":
      case "CatchClause":
        throw new Error(node.type + " nodes should be handled by their parents");
      default:
        throw new Error("unknown Node of type " + JSON.stringify(node.type));
    }
  }
  explodeStatement(path, labelId = null) {
    const stmt = path.node;
    const self = this;
    let before, after, head;
    if (path.isBlockStatement()) {
      path.get("body").forEach(function (path) {
        self.explodeStatement(path);
      });
      return;
    }
    if (!meta.containsLeap(stmt)) {
      self.emit(stmt);
      return;
    }
    switch (path.type) {
      case "ExpressionStatement":
        self.explodeExpression(path.get("expression"), true);
        break;
      case "LabeledStatement":
        after = this.loc();
        self.leapManager.withEntry(new leap.LabeledEntry(after, path.node.label), function () {
          self.explodeStatement(path.get("body"), path.node.label);
        });
        self.mark(after);
        break;
      case "WhileStatement":
        before = this.loc();
        after = this.loc();
        self.mark(before);
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(before);
        self.mark(after);
        break;
      case "DoWhileStatement":
        const first = this.loc();
        const test = this.loc();
        after = this.loc();
        self.mark(first);
        self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
          self.explode(path.get("body"));
        });
        self.mark(test);
        self.jumpIf(self.explodeExpression(path.get("test")), first);
        self.mark(after);
        break;
      case "ForStatement":
        head = this.loc();
        const update = this.loc();
        after = this.loc();
        if (path.node.init) {
          self.explode(path.get("init"), true);
        }
        self.mark(head);
        if (path.node.test) {
          self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        } else {}
        self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.mark(update);
        if (path.node.update) {
          self.explode(path.get("update"), true);
        }
        self.jump(head);
        self.mark(after);
        break;
      case "TypeCastExpression":
        return self.explodeExpression(path.get("expression"));
      case "ForInStatement":
        head = this.loc();
        after = this.loc();
        const keyIterNextFn = self.makeTempVar();
        const helper = util.newHelpersAvailable(this.pluginPass) ? this.pluginPass.addHelper("regeneratorKeys") : util.runtimeProperty(this.pluginPass, "keys");
        self.emitAssign(keyIterNextFn, _core.types.callExpression(helper, [self.explodeExpression(path.get("right"))]));
        self.mark(head);
        const keyInfoTmpVar = self.makeTempVar();
        self.jumpIf(_core.types.memberExpression(_core.types.assignmentExpression("=", keyInfoTmpVar, _core.types.callExpression(_core.types.cloneNode(keyIterNextFn), [])), _core.types.identifier("done"), false), after);
        self.emitAssign(path.node.left, _core.types.memberExpression(_core.types.cloneNode(keyInfoTmpVar), _core.types.identifier("value"), false));
        self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(head);
        self.mark(after);
        break;
      case "BreakStatement":
        self.emitAbruptCompletion({
          type: 3,
          target: self.leapManager.getBreakLoc(path.node.label)
        });
        break;
      case "ContinueStatement":
        self.emitAbruptCompletion({
          type: 3,
          target: self.leapManager.getContinueLoc(path.node.label)
        });
        break;
      case "SwitchStatement":
        const disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
        after = this.loc();
        const defaultLoc = this.loc();
        let condition = defaultLoc;
        const caseLocs = [];
        const cases = path.node.cases || [];
        for (let i = cases.length - 1; i >= 0; --i) {
          const c = cases[i];
          if (c.test) {
            condition = _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.cloneNode(disc), c.test), caseLocs[i] = this.loc(), condition);
          } else {
            caseLocs[i] = defaultLoc;
          }
        }
        const discriminant = path.get("discriminant");
        util.replaceWithOrRemove(discriminant, condition);
        self.jump(self.explodeExpression(discriminant));
        self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
          path.get("cases").forEach(function (casePath) {
            const i = casePath.key;
            self.mark(caseLocs[i]);
            casePath.get("consequent").forEach(function (path) {
              self.explodeStatement(path);
            });
          });
        });
        self.mark(after);
        if (defaultLoc.value === PENDING_LOCATION) {
          self.mark(defaultLoc);
          _assert.strictEqual(after.value, defaultLoc.value);
        }
        break;
      case "IfStatement":
        const elseLoc = path.node.alternate && this.loc();
        after = this.loc();
        self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
        self.explodeStatement(path.get("consequent"));
        if (elseLoc) {
          self.jump(after);
          self.mark(elseLoc);
          self.explodeStatement(path.get("alternate"));
        }
        self.mark(after);
        break;
      case "ReturnStatement":
        self.emitAbruptCompletion({
          type: 2,
          value: self.explodeExpression(path.get("argument"))
        });
        break;
      case "WithStatement":
        throw new Error("WithStatement not supported in generator functions.");
      case "TryStatement":
        after = this.loc();
        const handler = path.node.handler;
        const catchLoc = handler && this.loc();
        const catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
        const finallyLoc = path.node.finalizer && this.loc();
        const finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
        const tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
        self.tryEntries.push(tryEntry);
        self.updateContextPrevLoc(tryEntry.firstLoc);
        self.leapManager.withEntry(tryEntry, () => {
          self.explodeStatement(path.get("block"));
          if (catchLoc) {
            const body = path.node.block.body;
            if (finallyLoc) {
              self.jump(finallyLoc);
            } else if (body.length && body[body.length - 1].type === "ReturnStatement") {
              after = null;
            } else {
              self.jump(after);
            }
            self.updateContextPrevLoc(self.mark(catchLoc));
            const bodyPath = path.get("handler.body");
            const safeParam = self.makeTempVar();
            if (util.newHelpersAvailable(this.pluginPass)) {
              this.emitAssign(safeParam, self.contextProperty("v"));
            } else {
              self.clearPendingException(tryEntry.firstLoc, safeParam);
            }
            bodyPath.traverse(catchParamVisitor, {
              getSafeParam: () => _core.types.cloneNode(safeParam),
              catchParamName: handler.param.name
            });
            self.leapManager.withEntry(catchEntry, function () {
              self.explodeStatement(bodyPath);
            });
          }
          if (finallyLoc) {
            self.updateContextPrevLoc(self.mark(finallyLoc));
            self.leapManager.withEntry(finallyEntry, function () {
              self.explodeStatement(path.get("finalizer"));
            });
            self.emit(_core.types.returnStatement(_core.types.callExpression(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "f" : "finish"), [finallyEntry.firstLoc])));
          }
        });
        if (after) self.mark(after);
        break;
      case "ThrowStatement":
        self.emit(_core.types.throwStatement(self.explodeExpression(path.get("argument"))));
        break;
      case "ClassDeclaration":
        self.emit(self.explodeClass(path));
        break;
      default:
        throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
    }
  }
  emitAbruptCompletion(record) {
    const abruptArgs = [util.newHelpersAvailable(this.pluginPass) ? _core.types.numericLiteral(record.type) : _core.types.stringLiteral(record.type === 3 ? "continue" : "return")];
    if (record.type === 3) {
      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : _core.types.cloneNode(record.target);
    } else if (record.type === 2) {
      if (record.value) {
        abruptArgs[1] = _core.types.cloneNode(record.value);
      }
    }
    this.emit(_core.types.returnStatement(_core.types.callExpression(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "a" : "abrupt"), abruptArgs)));
    if (record.type === 2) {
      this.returns.add(this.listing.length);
    }
  }
  getUnmarkedCurrentLoc() {
    return _core.types.numericLiteral(this.getIndex());
  }
  updateContextPrevLoc(loc) {
    if (loc) {
      if (loc.value === PENDING_LOCATION) {
        loc.value = this.getIndex();
      } else {
        _assert.strictEqual(loc.value, this.index);
      }
    } else {
      loc = this.getUnmarkedCurrentLoc();
    }
    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "p" : "prev"), loc);
  }
  explodeViaTempVar(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
    _assert.ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");
    let result = this.explodeExpression(childPath, ignoreChildResult);
    if (ignoreChildResult) {} else if (tempVar || hasLeapingChildren && !_core.types.isLiteral(result)) {
      result = this.emitAssign(tempVar || this.makeTempVar(), result);
    }
    return result;
  }
  explodeExpression(path, ignoreResult) {
    const expr = path.node;
    if (!expr) {
      return expr;
    }
    const self = this;
    let result;
    let after;
    function finish(expr) {
      if (ignoreResult) {
        self.emit(expr);
      }
      return expr;
    }
    if (!meta.containsLeap(expr)) {
      return finish(expr);
    }
    const hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
    switch (path.type) {
      case "MemberExpression":
        return finish(_core.types.memberExpression(self.explodeExpression(path.get("object")), path.node.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : path.node.property, path.node.computed));
      case "CallExpression":
        const calleePath = path.get("callee");
        const argsPath = path.get("arguments");
        let newCallee;
        let newArgs;
        const hasLeapingArgs = argsPath.some(argPath => meta.containsLeap(argPath.node));
        let injectFirstArg = null;
        if (_core.types.isMemberExpression(calleePath.node)) {
          if (hasLeapingArgs) {
            const newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get("object"), hasLeapingChildren);
            const newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren) : calleePath.node.property;
            injectFirstArg = newObject;
            newCallee = _core.types.memberExpression(_core.types.memberExpression(_core.types.cloneNode(newObject), newProperty, calleePath.node.computed), _core.types.identifier("call"), false);
          } else {
            newCallee = self.explodeExpression(calleePath);
          }
        } else {
          newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);
          if (_core.types.isMemberExpression(newCallee)) {
            newCallee = _core.types.sequenceExpression([_core.types.numericLiteral(0), _core.types.cloneNode(newCallee)]);
          }
        }
        if (hasLeapingArgs) {
          newArgs = argsPath.map(argPath => self.explodeViaTempVar(null, argPath, hasLeapingChildren));
          if (injectFirstArg) newArgs.unshift(injectFirstArg);
          newArgs = newArgs.map(arg => _core.types.cloneNode(arg));
        } else {
          newArgs = path.node.arguments;
        }
        return finish(_core.types.callExpression(newCallee, newArgs));
      case "NewExpression":
        return finish(_core.types.newExpression(self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren), path.get("arguments").map(function (argPath) {
          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
        })));
      case "ObjectExpression":
        return finish(_core.types.objectExpression(path.get("properties").map(function (propPath) {
          if (propPath.isObjectProperty()) {
            return _core.types.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed);
          } else {
            return propPath.node;
          }
        })));
      case "ArrayExpression":
        return finish(_core.types.arrayExpression(path.get("elements").map(function (elemPath) {
          if (!elemPath.node) {
            return null;
          }
          if (elemPath.isSpreadElement()) {
            return _core.types.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren));
          } else {
            return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
          }
        })));
      case "SequenceExpression":
        const lastIndex = path.node.expressions.length - 1;
        path.get("expressions").forEach(function (exprPath) {
          if (exprPath.key === lastIndex) {
            result = self.explodeExpression(exprPath, ignoreResult);
          } else {
            self.explodeExpression(exprPath, true);
          }
        });
        return result;
      case "LogicalExpression":
        after = this.loc();
        if (!ignoreResult) {
          result = self.makeTempVar();
        }
        const left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren);
        if (path.node.operator === "&&") {
          self.jumpIfNot(left, after);
        } else {
          _assert.strictEqual(path.node.operator, "||");
          self.jumpIf(left, after);
        }
        self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult);
        self.mark(after);
        return result;
      case "ConditionalExpression":
        const elseLoc = this.loc();
        after = this.loc();
        const test = self.explodeExpression(path.get("test"));
        self.jumpIfNot(test, elseLoc);
        if (!ignoreResult) {
          result = self.makeTempVar();
        }
        self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult);
        self.jump(after);
        self.mark(elseLoc);
        self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult);
        self.mark(after);
        return result;
      case "UnaryExpression":
        return finish(_core.types.unaryExpression(path.node.operator, self.explodeExpression(path.get("argument")), !!path.node.prefix));
      case "BinaryExpression":
        return finish(_core.types.binaryExpression(path.node.operator, self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren), self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)));
      case "AssignmentExpression":
        if (path.node.operator === "=") {
          return finish(_core.types.assignmentExpression(path.node.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
        }
        const lhs = self.explodeExpression(path.get("left"));
        const temp = self.emitAssign(self.makeTempVar(), lhs);
        return finish(_core.types.assignmentExpression("=", _core.types.cloneNode(lhs), _core.types.assignmentExpression(path.node.operator, _core.types.cloneNode(temp), self.explodeExpression(path.get("right")))));
      case "UpdateExpression":
        return finish(_core.types.updateExpression(path.node.operator, self.explodeExpression(path.get("argument")), path.node.prefix));
      case "YieldExpression":
        after = this.loc();
        const arg = path.node.argument && self.explodeExpression(path.get("argument"));
        if (arg && path.node.delegate) {
          if (util.newHelpersAvailable(this.pluginPass)) {
            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty("d"), [_core.types.callExpression(this.pluginPass.addHelper("regeneratorValues"), [arg]), after]));
            ret.loc = expr.loc;
            self.emit(ret);
            self.mark(after);
            return self.contextProperty("v");
          } else {
            const result = self.makeContextTempVar();
            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty("delegateYield"), [arg, _core.types.stringLiteral(result.property.name), after]));
            ret.loc = expr.loc;
            self.emit(ret);
            self.mark(after);
            return result;
          }
        }
        self.emitAssign(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), after);
        const ret = _core.types.returnStatement(_core.types.cloneNode(arg) || null);
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return self.contextProperty(util.newHelpersAvailable(self.pluginPass) ? "v" : "sent");
      case "ClassExpression":
        return finish(self.explodeClass(path));
      default:
        throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
    }
  }
  explodeClass(path) {
    const explodingChildren = [];
    if (path.node.superClass) {
      explodingChildren.push(path.get("superClass"));
    }
    path.get("body.body").forEach(member => {
      if (member.node.computed) {
        explodingChildren.push(member.get("key"));
      }
    });
    const hasLeapingChildren = explodingChildren.some(child => meta.containsLeap(child));
    for (let i = 0; i < explodingChildren.length; i++) {
      const child = explodingChildren[i];
      const isLast = i === explodingChildren.length - 1;
      if (isLast) {
        child.replaceWith(this.explodeExpression(child));
      } else {
        child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
      }
    }
    return path.node;
  }
}
exports.Emitter = Emitter;

//# sourceMappingURL=emit.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\hoist.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hoist = hoist;
var util = require("./util.js");
const hasOwn = Object.prototype.hasOwnProperty;
function hoist(funPath) {
  const t = util.getTypes();
  t.assertFunction(funPath.node);
  const vars = {};
  function varDeclToExpr({
    node: vdec,
    scope
  }, includeIdentifiers) {
    t.assertVariableDeclaration(vdec);
    const exprs = [];
    vdec.declarations.forEach(function (dec) {
      vars[dec.id.name] = t.identifier(dec.id.name);
      scope.removeBinding(dec.id.name);
      if (dec.init) {
        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });
    if (exprs.length === 0) return null;
    if (exprs.length === 1) return exprs[0];
    return t.sequenceExpression(exprs);
  }
  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function (path) {
        const expr = varDeclToExpr(path, false);
        if (expr === null) {
          path.remove();
        } else {
          util.replaceWithOrRemove(path, t.expressionStatement(expr));
        }
        path.skip();
      }
    },
    ForStatement: function (path) {
      const init = path.get("init");
      if (init.isVariableDeclaration()) {
        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
      }
    },
    ForXStatement: function (path) {
      const left = path.get("left");
      if (left.isVariableDeclaration()) {
        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
      }
    },
    FunctionDeclaration: function (path) {
      const node = path.node;
      vars[node.id.name] = node.id;
      const assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
      if (path.parentPath.isBlockStatement()) {
        path.parentPath.unshiftContainer("body", assignment);
        path.remove();
      } else {
        util.replaceWithOrRemove(path, assignment);
      }
      path.scope.removeBinding(node.id.name);
      path.skip();
    },
    FunctionExpression: function (path) {
      path.skip();
    },
    ArrowFunctionExpression: function (path) {
      path.skip();
    }
  });
  const paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    const param = paramPath.node;
    if (t.isIdentifier(param)) {
      paramNames[param.name] = param;
    } else {}
  });
  const declarations = [];
  Object.keys(vars).forEach(function (name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(t.variableDeclarator(vars[name], null));
    }
  });
  return declarations;
}

//# sourceMappingURL=hoist.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\leap.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TryEntry = exports.SwitchEntry = exports.LoopEntry = exports.LeapManager = exports.LabeledEntry = exports.FunctionEntry = exports.FinallyEntry = exports.Entry = exports.CatchEntry = void 0;
var _assert = require("assert");
class Entry {}
exports.Entry = Entry;
class FunctionEntry extends Entry {
  constructor(returnLoc) {
    super();
    this.returnLoc = void 0;
    this.returnLoc = returnLoc;
  }
}
exports.FunctionEntry = FunctionEntry;
class LoopEntry extends Entry {
  constructor(breakLoc, continueLoc, label = null) {
    super();
    this.breakLoc = void 0;
    this.continueLoc = void 0;
    this.label = void 0;
    this.breakLoc = breakLoc;
    this.continueLoc = continueLoc;
    this.label = label;
  }
}
exports.LoopEntry = LoopEntry;
class SwitchEntry extends Entry {
  constructor(breakLoc) {
    super();
    this.breakLoc = void 0;
    this.breakLoc = breakLoc;
  }
}
exports.SwitchEntry = SwitchEntry;
class TryEntry extends Entry {
  constructor(firstLoc, catchEntry = null, finallyEntry = null) {
    super();
    this.firstLoc = void 0;
    this.catchEntry = void 0;
    this.finallyEntry = void 0;
    _assert.ok(catchEntry || finallyEntry);
    this.firstLoc = firstLoc;
    this.catchEntry = catchEntry;
    this.finallyEntry = finallyEntry;
  }
}
exports.TryEntry = TryEntry;
class CatchEntry extends Entry {
  constructor(firstLoc, paramId) {
    super();
    this.firstLoc = void 0;
    this.paramId = void 0;
    this.firstLoc = firstLoc;
    this.paramId = paramId;
  }
}
exports.CatchEntry = CatchEntry;
class FinallyEntry extends Entry {
  constructor(firstLoc, afterLoc) {
    super();
    this.firstLoc = void 0;
    this.afterLoc = void 0;
    this.firstLoc = firstLoc;
    this.afterLoc = afterLoc;
  }
}
exports.FinallyEntry = FinallyEntry;
class LabeledEntry extends Entry {
  constructor(breakLoc, label) {
    super();
    this.breakLoc = void 0;
    this.label = void 0;
    this.breakLoc = breakLoc;
    this.label = label;
  }
}
exports.LabeledEntry = LabeledEntry;
class LeapManager {
  constructor(emitter) {
    this.emitter = void 0;
    this.entryStack = void 0;
    this.emitter = emitter;
    this.entryStack = [new FunctionEntry(emitter.finalLoc)];
  }
  withEntry(entry, callback) {
    this.entryStack.push(entry);
    try {
      callback.call(this.emitter);
    } finally {
      const popped = this.entryStack.pop();
      _assert.strictEqual(popped, entry);
    }
  }
  _findLeapLocation(property, label) {
    for (let i = this.entryStack.length - 1; i >= 0; --i) {
      const entry = this.entryStack[i];
      const loc = entry[property];
      if (loc) {
        if (label) {
          if (entry.label && entry.label.name === label.name) {
            return loc;
          }
        } else if (entry instanceof LabeledEntry) {} else {
          return loc;
        }
      }
    }
    return null;
  }
  getBreakLoc(label) {
    return this._findLeapLocation("breakLoc", label);
  }
  getContinueLoc(label) {
    return this._findLeapLocation("continueLoc", label);
  }
}
exports.LeapManager = LeapManager;

//# sourceMappingURL=leap.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\meta.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasSideEffects = exports.containsLeap = void 0;
var _assert = require("assert");
var _util = require("./util.js");
const mMap = new WeakMap();
function m(node) {
  if (!mMap.has(node)) {
    mMap.set(node, {});
  }
  return mMap.get(node);
}
const hasOwn = Object.prototype.hasOwnProperty;
function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    const t = (0, _util.getTypes)();
    t.assertNode(node);
    let result = false;
    function check(child) {
      if (result) {} else if (Array.isArray(child)) {
        child.some(check);
      } else if (t.isNode(child)) {
        _assert.strictEqual(result, false);
        result = predicate(child);
      }
      return result;
    }
    const keys = t.VISITOR_KEYS[node.type];
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const child = node[key];
        check(child);
      }
    }
    return result;
  }
  function predicate(node) {
    (0, _util.getTypes)().assertNode(node);
    const meta = m(node);
    if (hasOwn.call(meta, propertyName)) return meta[propertyName];
    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;
    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;
    return meta[propertyName] = onlyChildren(node);
  }
  predicate.onlyChildren = onlyChildren;
  return predicate;
}
const opaqueTypes = {
  FunctionExpression: true,
  ArrowFunctionExpression: true
};
const sideEffectTypes = {
  CallExpression: true,
  ForInStatement: true,
  UnaryExpression: true,
  BinaryExpression: true,
  AssignmentExpression: true,
  UpdateExpression: true,
  NewExpression: true
};
const leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
};
for (const type in leapTypes) {
  if (hasOwn.call(leapTypes, type)) {
    sideEffectTypes[type] = leapTypes[type];
  }
}
const hasSideEffects = exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
const containsLeap = exports.containsLeap = makePredicate("containsLeap", leapTypes);

//# sourceMappingURL=meta.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\replaceShorthandObjectMethod.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = replaceShorthandObjectMethod;
var util = require("./util.js");
function replaceShorthandObjectMethod(path) {
  const t = util.getTypes();
  if (!path.node || !t.isFunction(path.node)) {
    throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
  }
  if (!t.isObjectMethod(path.node)) {
    return path;
  }
  if (!path.node.generator) {
    return path;
  }
  const parameters = path.node.params.map(function (param) {
    return t.cloneDeep(param);
  });
  const functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
  return path.get("value");
}

//# sourceMappingURL=replaceShorthandObjectMethod.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\util.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypes = getTypes;
exports.isReference = isReference;
exports.newHelpersAvailable = void 0;
exports.replaceWithOrRemove = replaceWithOrRemove;
exports.runtimeProperty = void 0;
exports.wrapWithTypes = wrapWithTypes;
let currentTypes = null;
function wrapWithTypes(types, fn) {
  return function (...args) {
    const oldTypes = currentTypes;
    currentTypes = types;
    try {
      return fn.apply(this, args);
    } finally {
      currentTypes = oldTypes;
    }
  };
}
function getTypes() {
  return currentTypes;
}
let newHelpersAvailable = exports.newHelpersAvailable = void 0;
{
  exports.newHelpersAvailable = newHelpersAvailable = file => {
    ;
    return file.availableHelper("regenerator") && !getTypes().isIdentifier(file.addHelper("regenerator"), {
      name: "__interal_marker_fallback_regenerator__"
    });
  };
}
let runtimeProperty = exports.runtimeProperty = void 0;
{
  exports.runtimeProperty = runtimeProperty = function (file, name) {
    const t = getTypes();
    const helper = file.addHelper("regeneratorRuntime");
    return t.memberExpression(t.isArrowFunctionExpression(helper) && t.isIdentifier(helper.body) ? helper.body : t.callExpression(helper, []), t.identifier(name), false);
  };
}
function isReference(path) {
  return path.isReferenced() || path.parentPath.isAssignmentExpression({
    left: path.node
  });
}
function replaceWithOrRemove(path, replacement) {
  if (replacement) {
    path.replaceWith(replacement);
  } else {
    path.remove();
  }
}

//# sourceMappingURL=util.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\lib\regenerator\visit.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisitor = void 0;
var _assert = require("assert");
var _hoist = require("./hoist.js");
var _emit = require("./emit.js");
var _replaceShorthandObjectMethod = require("./replaceShorthandObjectMethod.js");
var util = require("./util.js");
const getVisitor = t => ({
  Method(path, state) {
    const node = path.node;
    if (!shouldRegenerate(node, state)) return;
    const container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
    path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
  },
  Function: {
    exit: util.wrapWithTypes(t, function (path, state) {
      let node = path.node;
      if (!shouldRegenerate(node, state)) return;
      path = (0, _replaceShorthandObjectMethod.default)(path);
      node = path.node;
      const contextId = path.scope.generateUidIdentifier("context");
      const argsId = path.scope.generateUidIdentifier("args");
      path.ensureBlock();
      const bodyBlockPath = path.get("body");
      if (node.async) {
        bodyBlockPath.traverse(awaitVisitor, this);
      }
      bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId,
        pluginPass: this
      });
      const outerBody = [];
      const innerBody = [];
      bodyBlockPath.get("body").forEach(function (childPath) {
        const node = childPath.node;
        if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
          outerBody.push(node);
        } else if ((node == null ? void 0 : node._blockHoist) != null) {
          outerBody.push(node);
        } else {
          innerBody.push(node);
        }
      });
      if (outerBody.length > 0) {
        bodyBlockPath.node.body = innerBody;
      }
      const outerFnExpr = getOuterFnExpr(this, path);
      t.assertIdentifier(node.id);
      const vars = (0, _hoist.hoist)(path);
      const context = {
        usesThis: false,
        usesArguments: false,
        getArgsId: () => t.clone(argsId)
      };
      path.traverse(argumentsThisVisitor, context);
      if (context.usesArguments) {
        vars.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
      }
      const emitter = new _emit.Emitter(contextId, path.scope, vars, this);
      emitter.explode(path.get("body"));
      if (vars.length > 0) {
        outerBody.push(t.variableDeclaration("var", vars));
      }
      const wrapArgs = [emitter.getContextFunction()];
      const tryLocsList = emitter.getTryLocsList();
      if (node.generator) {
        wrapArgs.push(outerFnExpr);
      } else if (context.usesThis || tryLocsList || node.async) {
        wrapArgs.push(t.nullLiteral());
      }
      if (context.usesThis) {
        wrapArgs.push(t.thisExpression());
      } else if (tryLocsList || node.async) {
        wrapArgs.push(t.nullLiteral());
      }
      if (tryLocsList) {
        wrapArgs.push(tryLocsList);
      } else if (node.async) {
        wrapArgs.push(t.nullLiteral());
      }
      if (node.async) {
        let currentScope = path.scope;
        do {
          if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
        } while (currentScope = currentScope.parent);
        wrapArgs.push(t.identifier("Promise"));
      }
      const wrapCall = t.callExpression(util.newHelpersAvailable(this) ? !node.async ? t.memberExpression(t.callExpression(this.addHelper("regenerator"), []), t.identifier("w")) : node.generator ? this.addHelper("regeneratorAsyncGen") : this.addHelper("regeneratorAsync") : util.runtimeProperty(this, node.async ? "async" : "wrap"), wrapArgs);
      outerBody.push(t.returnStatement(wrapCall));
      node.body = t.blockStatement(outerBody);
      path.get("body.body").forEach(p => p.scope.registerDeclaration(p));
      const oldDirectives = bodyBlockPath.node.directives;
      if (oldDirectives) {
        node.body.directives = oldDirectives;
      }
      const wasGeneratorFunction = node.generator;
      if (wasGeneratorFunction) {
        node.generator = false;
      }
      if (node.async) {
        node.async = false;
      }
      if (wasGeneratorFunction && t.isExpression(node)) {
        util.replaceWithOrRemove(path, t.callExpression(util.newHelpersAvailable(this) ? t.memberExpression(t.callExpression(this.addHelper("regenerator"), []), t.identifier("m")) : util.runtimeProperty(this, "mark"), [node]));
        path.addComment("leading", "#__PURE__");
      }
      const insertedLocs = emitter.getInsertedLocs();
      path.traverse({
        NumericLiteral(path) {
          if (!insertedLocs.has(path.node)) {
            return;
          }
          path.replaceWith(t.numericLiteral(path.node.value));
        }
      });
      path.requeue();
    })
  }
});
exports.getVisitor = getVisitor;
function shouldRegenerate(node, state) {
  if (node.generator) {
    if (node.async) {
      return state.opts.asyncGenerators !== false;
    } else {
      return state.opts.generators !== false;
    }
  } else if (node.async) {
    return state.opts.async !== false;
  } else {
    return false;
  }
}
function getOuterFnExpr(state, funPath) {
  const t = util.getTypes();
  const node = funPath.node;
  t.assertFunction(node);
  if (!node.id) {
    node.id = funPath.scope.parent.generateUidIdentifier("callee");
  }
  if (node.generator && t.isFunctionDeclaration(node)) {
    return getMarkedFunctionId(state, funPath);
  }
  return t.clone(node.id);
}
const markInfo = new WeakMap();
function getMarkInfo(node) {
  if (!markInfo.has(node)) {
    markInfo.set(node, {});
  }
  return markInfo.get(node);
}
function getMarkedFunctionId(state, funPath) {
  const t = util.getTypes();
  const node = funPath.node;
  t.assertIdentifier(node.id);
  const blockPath = funPath.findParent(function (path) {
    return path.isProgram() || path.isBlockStatement();
  });
  if (!blockPath) {
    return node.id;
  }
  const block = blockPath.node;
  _assert.ok(Array.isArray(block.body));
  const info = getMarkInfo(block);
  if (!info.decl) {
    info.decl = t.variableDeclaration("var", []);
    blockPath.unshiftContainer("body", info.decl);
    info.declPath = blockPath.get("body.0");
  }
  _assert.strictEqual(info.declPath.node, info.decl);
  const markedId = blockPath.scope.generateUidIdentifier("marked");
  const markCallExp = t.callExpression(util.newHelpersAvailable(state) ? t.memberExpression(t.callExpression(state.addHelper("regenerator"), []), t.identifier("m")) : util.runtimeProperty(state, "mark"), [t.clone(node.id)]);
  const index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
  const markCallExpPath = info.declPath.get("declarations." + index + ".init");
  _assert.strictEqual(markCallExpPath.node, markCallExp);
  markCallExpPath.addComment("leading", "#__PURE__");
  return t.clone(markedId);
}
const argumentsThisVisitor = {
  "FunctionExpression|FunctionDeclaration|Method": function (path) {
    path.skip();
  },
  Identifier: function (path, state) {
    if (path.node.name === "arguments" && util.isReference(path)) {
      util.replaceWithOrRemove(path, state.getArgsId());
      state.usesArguments = true;
    }
  },
  ThisExpression: function (path, state) {
    state.usesThis = true;
  }
};
const functionSentVisitor = {
  MetaProperty(path, state) {
    const {
      node
    } = path;
    if (node.meta.name === "function" && node.property.name === "sent") {
      const t = util.getTypes();
      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(util.newHelpersAvailable(state.pluginPass) ? "v" : "_sent")));
    }
  }
};
const awaitVisitor = {
  Function: function (path) {
    path.skip();
  },
  AwaitExpression: function (path) {
    const t = util.getTypes();
    const argument = path.node.argument;
    const helper = util.newHelpersAvailable(this) ? this.addHelper("awaitAsyncGenerator") : util.runtimeProperty(this, "awrap");
    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(helper, [argument]), false));
  }
};

//# sourceMappingURL=visit.js.map


---

File name: node_modules\@babel\plugin-transform-regenerator\package.json

Code:
{
  "name": "@babel/plugin-transform-regenerator",
  "author": "The Babel Team (https://babel.dev/team)",
  "description": "Explode async and generator functions into a state machine.",
  "version": "7.27.5",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-regenerator",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-regenerator"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.4",
    "@babel/helper-check-duplicate-nodes": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/plugin-proposal-function-sent": "^7.27.1",
    "@babel/plugin-transform-arrow-functions": "^7.27.1",
    "@babel/plugin-transform-block-scoping": "^7.27.5",
    "@babel/plugin-transform-classes": "^7.27.1",
    "@babel/plugin-transform-for-of": "^7.27.1",
    "@babel/plugin-transform-modules-commonjs": "^7.27.1",
    "@babel/plugin-transform-parameters": "^7.27.1",
    "@babel/plugin-transform-runtime": "^7.27.4",
    "babel-plugin-polyfill-regenerator": "^0.6.1",
    "mocha": "^10.0.0",
    "recast": "^0.23.3",
    "uglify-js": "^3.14.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-regenerator\README.md

Code:
# @babel/plugin-transform-regenerator

> Explode async and generator functions into a state machine.

See our website [@babel/plugin-transform-regenerator](https://babeljs.io/docs/babel-plugin-transform-regenerator) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-regenerator
```

or using yarn:

```sh
yarn add @babel/plugin-transform-regenerator --dev
```


---

File name: node_modules\@babel\plugin-transform-regexp-modifiers\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-regexp-modifiers",
    feature: "modifiers"
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-regexp-modifiers\package.json

Code:
{
  "name": "@babel/plugin-transform-regexp-modifiers",
  "version": "7.27.1",
  "description": "Compile inline regular expression modifiers",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-regexp-modifiers",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-regexp-modifiers"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-regexp-modifiers\README.md

Code:
# @babel/plugin-transform-regexp-modifiers

> Compile inline regular expression modifiers

See our website [@babel/plugin-transform-regexp-modifiers](https://babeljs.io/docs/babel-plugin-transform-regexp-modifiers) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-regexp-modifiers
```

or using yarn:

```sh
yarn add @babel/plugin-transform-regexp-modifiers --dev
```


---

File name: node_modules\@babel\plugin-transform-reserved-words\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-reserved-words",
    visitor: {
      "BindingIdentifier|ReferencedIdentifier"(path) {
        if (!_core.types.isValidES3Identifier(path.node.name)) {
          path.scope.rename(path.node.name);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-reserved-words\package.json

Code:
{
  "name": "@babel/plugin-transform-reserved-words",
  "version": "7.27.1",
  "description": "Ensure that no reserved words are used.",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-reserved-words"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-reserved-words",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-reserved-words\README.md

Code:
# @babel/plugin-transform-reserved-words

> Ensure that no reserved words are used.

See our website [@babel/plugin-transform-reserved-words](https://babeljs.io/docs/babel-plugin-transform-reserved-words) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-reserved-words
```

or using yarn:

```sh
yarn add @babel/plugin-transform-reserved-words --dev
```


---

File name: node_modules\@babel\plugin-transform-shorthand-properties\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-shorthand-properties",
    visitor: {
      ObjectMethod(path) {
        const {
          node
        } = path;
        if (node.kind === "method") {
          const func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
          func.returnType = node.returnType;
          const computedKey = _core.types.toComputedKey(node);
          if (_core.types.isStringLiteral(computedKey, {
            value: "__proto__"
          })) {
            path.replaceWith(_core.types.objectProperty(computedKey, func, true));
          } else {
            path.replaceWith(_core.types.objectProperty(node.key, func, node.computed));
          }
        }
      },
      ObjectProperty(path) {
        const {
          node
        } = path;
        if (node.shorthand) {
          const computedKey = _core.types.toComputedKey(node);
          if (_core.types.isStringLiteral(computedKey, {
            value: "__proto__"
          })) {
            path.replaceWith(_core.types.objectProperty(computedKey, node.value, true));
          } else {
            node.shorthand = false;
          }
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-shorthand-properties\package.json

Code:
{
  "name": "@babel/plugin-transform-shorthand-properties",
  "version": "7.27.1",
  "description": "Compile ES2015 shorthand properties to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-shorthand-properties"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-shorthand-properties",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-shorthand-properties\README.md

Code:
# @babel/plugin-transform-shorthand-properties

> Compile ES2015 shorthand properties to ES5

See our website [@babel/plugin-transform-shorthand-properties](https://babeljs.io/docs/babel-plugin-transform-shorthand-properties) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-shorthand-properties
```

or using yarn:

```sh
yarn add @babel/plugin-transform-shorthand-properties --dev
```


---

File name: node_modules\@babel\plugin-transform-spread\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperSkipTransparentExpressionWrappers = require("@babel/helper-skip-transparent-expression-wrappers");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _options$allowArrayLi;
  api.assertVersion(7);
  const iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
  function getSpreadLiteral(spread, scope) {
    if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {
      name: "arguments"
    })) {
      return spread.argument;
    } else {
      const node = spread.argument;
      if (_core.types.isIdentifier(node)) {
        const binding = scope.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }
      if (_core.types.isArrayExpression(node)) {
        return node;
      }
      if (_core.types.isIdentifier(node, {
        name: "arguments"
      })) {
        return _core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
      }
      const args = [node];
      let helperName = "toConsumableArray";
      if (arrayLikeIsIterable) {
        args.unshift(scope.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return _core.types.callExpression(scope.path.hub.addHelper(helperName), args);
    }
  }
  function hasHole(spread) {
    return spread.elements.includes(null);
  }
  function hasSpread(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      if (_core.types.isSpreadElement(nodes[i])) {
        return true;
      }
    }
    return false;
  }
  function push(_props, nodes) {
    if (!_props.length) return _props;
    nodes.push(_core.types.arrayExpression(_props));
    return [];
  }
  function build(props, scope, file) {
    const nodes = [];
    let _props = [];
    for (const prop of props) {
      if (_core.types.isSpreadElement(prop)) {
        _props = push(_props, nodes);
        let spreadLiteral = getSpreadLiteral(prop, scope);
        if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {
          spreadLiteral = _core.types.callExpression(file.addHelper("arrayWithoutHoles"), [spreadLiteral]);
        }
        nodes.push(spreadLiteral);
      } else {
        _props.push(prop);
      }
    }
    push(_props, nodes);
    return nodes;
  }
  return {
    name: "transform-spread",
    visitor: {
      ArrayExpression(path) {
        const {
          node,
          scope
        } = path;
        const elements = node.elements;
        if (!hasSpread(elements)) return;
        const nodes = build(elements, scope, this.file);
        let first = nodes[0];
        if (nodes.length === 1 && first !== elements[0].argument) {
          path.replaceWith(first);
          return;
        }
        if (!_core.types.isArrayExpression(first)) {
          first = _core.types.arrayExpression([]);
        } else {
          nodes.shift();
        }
        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
      },
      CallExpression(path) {
        const {
          node,
          scope
        } = path;
        const args = node.arguments;
        if (!hasSpread(args)) return;
        const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("callee"));
        if (calleePath.isSuper()) {
          throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        let contextLiteral = scope.buildUndefinedNode();
        node.arguments = [];
        let nodes;
        if (args.length === 1 && _core.types.isIdentifier(args[0].argument, {
          name: "arguments"
        })) {
          nodes = [args[0].argument];
        } else {
          nodes = build(args, scope, this.file);
        }
        const first = nodes.shift();
        if (nodes.length) {
          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
        } else {
          node.arguments.push(first);
        }
        const callee = calleePath.node;
        if (_core.types.isMemberExpression(callee)) {
          const temp = scope.maybeGenerateMemoised(callee.object);
          if (temp) {
            callee.object = _core.types.assignmentExpression("=", temp, callee.object);
            contextLiteral = temp;
          } else {
            contextLiteral = _core.types.cloneNode(callee.object);
          }
        }
        node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("apply"));
        if (_core.types.isSuper(contextLiteral)) {
          contextLiteral = _core.types.thisExpression();
        }
        node.arguments.unshift(_core.types.cloneNode(contextLiteral));
      },
      NewExpression(path) {
        const {
          node,
          scope
        } = path;
        if (!hasSpread(node.arguments)) return;
        const nodes = build(node.arguments, scope, this.file);
        const first = nodes.shift();
        let args;
        if (nodes.length) {
          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes);
        } else {
          args = first;
        }
        path.replaceWith(_core.types.callExpression(path.hub.addHelper("construct"), [node.callee, args]));
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-spread\package.json

Code:
{
  "name": "@babel/plugin-transform-spread",
  "version": "7.27.1",
  "description": "Compile ES2015 spread to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-spread"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1",
    "@babel/helper-skip-transparent-expression-wrappers": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-spread",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-spread\README.md

Code:
# @babel/plugin-transform-spread

> Compile ES2015 spread to ES5

See our website [@babel/plugin-transform-spread](https://babeljs.io/docs/babel-plugin-transform-spread) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-spread
```

or using yarn:

```sh
yarn add @babel/plugin-transform-spread --dev
```


---

File name: node_modules\@babel\plugin-transform-sticky-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-sticky-regex",
    visitor: {
      RegExpLiteral(path) {
        const {
          node
        } = path;
        if (!node.flags.includes("y")) return;
        path.replaceWith(_core.types.newExpression(_core.types.identifier("RegExp"), [_core.types.stringLiteral(node.pattern), _core.types.stringLiteral(node.flags)]));
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-sticky-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-sticky-regex",
  "version": "7.27.1",
  "description": "Compile ES2015 sticky regex to an ES5 RegExp constructor",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-sticky-regex"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-sticky-regex",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-sticky-regex\README.md

Code:
# @babel/plugin-transform-sticky-regex

> Compile ES2015 sticky regex to an ES5 RegExp constructor

See our website [@babel/plugin-transform-sticky-regex](https://babeljs.io/docs/babel-plugin-transform-sticky-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-sticky-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-sticky-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-template-literals\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
  const mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
  let helperName = "taggedTemplateLiteral";
  if (mutableTemplateObject) helperName += "Loose";
  function buildConcatCallExpressions(items) {
    let avail = true;
    return items.reduce(function (left, right) {
      let canBeInserted = _core.types.isLiteral(right);
      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }
      if (canBeInserted && _core.types.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }
      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
    });
  }
  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression(path) {
        const {
          node
        } = path;
        const {
          quasi
        } = node;
        const strings = [];
        const raws = [];
        let isStringsRawEqual = true;
        for (const elem of quasi.quasis) {
          const {
            raw,
            cooked
          } = elem.value;
          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
          strings.push(value);
          raws.push(_core.types.stringLiteral(raw));
          if (raw !== cooked) {
            isStringsRawEqual = false;
          }
        }
        const helperArgs = [_core.types.arrayExpression(strings)];
        if (!isStringsRawEqual) {
          helperArgs.push(_core.types.arrayExpression(raws));
        }
        const tmp = path.scope.generateUidIdentifier("templateObject");
        path.scope.getProgramParent().push({
          id: _core.types.cloneNode(tmp)
        });
        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`
              ${_core.types.cloneNode(tmp)} || (
                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})
              )
            `, ...quasi.expressions]));
      },
      TemplateLiteral(path) {
        if (path.parent.type === "TSLiteralType") {
          return;
        }
        const nodes = [];
        const expressions = path.get("expressions");
        let index = 0;
        for (const elem of path.node.quasis) {
          if (elem.value.cooked) {
            nodes.push(_core.types.stringLiteral(elem.value.cooked));
          }
          if (index < expressions.length) {
            const expr = expressions[index++];
            const node = expr.node;
            if (!_core.types.isStringLiteral(node, {
              value: ""
            })) {
              nodes.push(node);
            }
          }
        }
        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {
          nodes.unshift(_core.types.stringLiteral(""));
        }
        let root = nodes[0];
        if (ignoreToPrimitiveHint) {
          for (let i = 1; i < nodes.length; i++) {
            root = _core.types.binaryExpression("+", root, nodes[i]);
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExpressions(nodes);
        }
        path.replaceWith(root);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-template-literals\package.json

Code:
{
  "name": "@babel/plugin-transform-template-literals",
  "version": "7.27.1",
  "description": "Compile ES2015 template literals to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-template-literals"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "keywords": [
    "babel-plugin"
  ],
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-template-literals",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-template-literals\README.md

Code:
# @babel/plugin-transform-template-literals

> Compile ES2015 template literals to ES5

See our website [@babel/plugin-transform-template-literals](https://babeljs.io/docs/babel-plugin-transform-template-literals) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-template-literals
```

or using yarn:

```sh
yarn add @babel/plugin-transform-template-literals --dev
```


---

File name: node_modules\@babel\plugin-transform-typeof-symbol\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-typeof-symbol",
    visitor: {
      Scope({
        scope
      }) {
        if (!scope.getBinding("Symbol")) {
          return;
        }
        scope.rename("Symbol");
      },
      UnaryExpression(path) {
        const {
          node,
          parent
        } = path;
        if (node.operator !== "typeof") return;
        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.includes(parent.operator)) {
          const opposite = path.getOpposite();
          if (opposite.isStringLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
            return;
          }
        }
        let isUnderHelper = path.findParent(path => {
          if (path.isFunctionDeclaration()) {
            var _path$get;
            return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
          }
        });
        if (isUnderHelper) return;
        const helper = this.addHelper("typeof");
        {
          isUnderHelper = path.findParent(path => {
            return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
          });
          if (isUnderHelper) {
            return;
          }
        }
        const call = _core.types.callExpression(helper, [node.argument]);
        const arg = path.get("argument");
        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
          const unary = _core.types.unaryExpression("typeof", _core.types.cloneNode(node.argument));
          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("===", unary, _core.types.stringLiteral("undefined")), _core.types.stringLiteral("undefined"), call));
        } else {
          path.replaceWith(call);
        }
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-typeof-symbol\package.json

Code:
{
  "name": "@babel/plugin-transform-typeof-symbol",
  "version": "7.27.1",
  "description": "This transformer wraps all typeof expressions with a method that replicates native behaviour. (ie. returning “symbol” for symbols)",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-typeof-symbol"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1",
    "@babel/runtime": "^7.27.1",
    "@babel/runtime-corejs2": "^7.24.0",
    "@babel/runtime-corejs3": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-typeof-symbol",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-typeof-symbol\README.md

Code:
# @babel/plugin-transform-typeof-symbol

> This transformer wraps all typeof expressions with a method that replicates native behaviour. (ie. returning “symbol” for symbols)

See our website [@babel/plugin-transform-typeof-symbol](https://babeljs.io/docs/babel-plugin-transform-typeof-symbol) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-typeof-symbol
```

or using yarn:

```sh
yarn add @babel/plugin-transform-typeof-symbol --dev
```


---

File name: node_modules\@babel\plugin-transform-unicode-escapes\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const surrogate = /[\ud800-\udfff]/g;
  const unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
  function escape(code) {
    {
      let str = code.toString(16);
      while (str.length < 4) str = "0" + str;
      return "\\u" + str;
    }
  }
  function replacer(match, backslashes, code) {
    if (backslashes.length % 2 === 0) {
      return match;
    }
    const char = String.fromCodePoint(parseInt(code, 16));
    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));
  }
  function replaceUnicodeEscapes(str) {
    return str.replace(unicodeEscape, replacer);
  }
  function getUnicodeEscape(str) {
    let match;
    while (match = unicodeEscape.exec(str)) {
      if (match[1].length % 2 === 0) continue;
      unicodeEscape.lastIndex = 0;
      return match[0];
    }
    return null;
  }
  return {
    name: "transform-unicode-escapes",
    manipulateOptions({
      generatorOpts
    }) {
      var _generatorOpts$jsescO, _generatorOpts$jsescO2;
      if (!generatorOpts.jsescOption) {
        generatorOpts.jsescOption = {};
      }
      (_generatorOpts$jsescO2 = (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal) != null ? _generatorOpts$jsescO2 : _generatorOpts$jsescO.minimal = false;
    },
    visitor: {
      Identifier(path) {
        const {
          node,
          key
        } = path;
        const {
          name
        } = node;
        const replaced = name.replace(surrogate, c => {
          return `_u${c.charCodeAt(0).toString(16)}`;
        });
        if (name === replaced) return;
        const str = _core.types.inherits(_core.types.stringLiteral(name), node);
        if (key === "key") {
          path.replaceWith(str);
          return;
        }
        const {
          parentPath,
          scope
        } = path;
        if (parentPath.isMemberExpression({
          property: node
        }) || parentPath.isOptionalMemberExpression({
          property: node
        })) {
          parentPath.node.computed = true;
          path.replaceWith(str);
          return;
        }
        const binding = scope.getBinding(name);
        if (binding) {
          scope.rename(name, scope.generateUid(replaced));
          return;
        }
        throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);
      },
      "StringLiteral|DirectiveLiteral"(path) {
        const {
          node
        } = path;
        const {
          extra
        } = node;
        if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
      },
      TemplateElement(path) {
        const {
          node,
          parentPath
        } = path;
        const {
          value
        } = node;
        const firstEscape = getUnicodeEscape(value.raw);
        if (!firstEscape) return;
        const grandParent = parentPath.parentPath;
        if (grandParent.isTaggedTemplateExpression()) {
          throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);
        }
        value.raw = replaceUnicodeEscapes(value.raw);
      }
    }
  };
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-unicode-escapes\package.json

Code:
{
  "name": "@babel/plugin-transform-unicode-escapes",
  "version": "7.27.1",
  "description": "Compile ES2015 Unicode escapes to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-escapes"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-escapes",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-unicode-escapes\README.md

Code:
# @babel/plugin-transform-unicode-escapes

> Compile ES2015 Unicode escapes to ES5

See our website [@babel/plugin-transform-unicode-escapes](https://babeljs.io/docs/babel-plugin-transform-unicode-escapes) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-unicode-escapes
```

or using yarn:

```sh
yarn add @babel/plugin-transform-unicode-escapes --dev
```


---

File name: node_modules\@babel\plugin-transform-unicode-property-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    useUnicodeFlag = true
  } = options;
  if (typeof useUnicodeFlag !== "boolean") {
    throw new Error(".useUnicodeFlag must be a boolean, or undefined");
  }
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-unicode-property-regex",
    feature: "unicodePropertyEscape",
    options: {
      useUnicodeFlag
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-unicode-property-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-unicode-property-regex",
  "version": "7.27.1",
  "description": "Compile Unicode property escapes in Unicode regular expressions to ES5.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-property-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "engines": {
    "node": ">=6.9.0"
  },
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "regular expressions",
    "unicode properties",
    "unicode"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-property-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-unicode-property-regex\README.md

Code:
# @babel/plugin-transform-unicode-property-regex

> Compile Unicode property escapes in Unicode regular expressions to ES5.

See our website [@babel/plugin-transform-unicode-property-regex](https://babeljs.io/docs/babel-plugin-transform-unicode-property-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-unicode-property-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-unicode-property-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-unicode-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-unicode-regex",
    feature: "unicodeFlag"
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-unicode-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-unicode-regex",
  "version": "7.27.1",
  "description": "Compile ES2015 Unicode regex to ES5",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-regex"
  },
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin"
  ],
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0-0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-regex",
  "engines": {
    "node": ">=6.9.0"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-unicode-regex\README.md

Code:
# @babel/plugin-transform-unicode-regex

> Compile ES2015 Unicode regex to ES5

See our website [@babel/plugin-transform-unicode-regex](https://babeljs.io/docs/babel-plugin-transform-unicode-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-unicode-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-unicode-regex --dev
```


---

File name: node_modules\@babel\plugin-transform-unicode-sets-regex\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = require("@babel/helper-create-regexp-features-plugin");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-unicode-sets-regex",
    feature: "unicodeSetsFlag",
    manipulateOptions(opts, parserOpts) {
      {
        parserOpts.plugins.push("regexpUnicodeSets");
      }
    }
  });
});

//# sourceMappingURL=index.js.map


---

File name: node_modules\@babel\plugin-transform-unicode-sets-regex\package.json

Code:
{
  "name": "@babel/plugin-transform-unicode-sets-regex",
  "version": "7.27.1",
  "description": "Compile regular expressions' unicodeSets (v) flag.",
  "homepage": "https://babel.dev/docs/en/next/babel-plugin-transform-unicode-sets-regex",
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  },
  "main": "./lib/index.js",
  "keywords": [
    "babel-plugin",
    "regex",
    "regexp",
    "unicode",
    "sets",
    "properties",
    "property",
    "string",
    "strings",
    "regular expressions"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel.git",
    "directory": "packages/babel-plugin-transform-unicode-sets-regex"
  },
  "bugs": "https://github.com/babel/babel/issues",
  "dependencies": {
    "@babel/helper-create-regexp-features-plugin": "^7.27.1",
    "@babel/helper-plugin-utils": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/helper-plugin-test-runner": "^7.27.1"
  },
  "author": "The Babel Team (https://babel.dev/team)",
  "exports": {
    ".": {
      "types": "./lib/index.d.ts",
      "default": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "type": "commonjs"
}

---

File name: node_modules\@babel\plugin-transform-unicode-sets-regex\README.md

Code:
# @babel/plugin-transform-unicode-sets-regex

> Compile regular expressions' unicodeSets (v) flag.

See our website [@babel/plugin-transform-unicode-sets-regex](https://babeljs.io/docs/babel-plugin-transform-unicode-sets-regex) for more information.

## Install

Using npm:

```sh
npm install --save-dev @babel/plugin-transform-unicode-sets-regex
```

or using yarn:

```sh
yarn add @babel/plugin-transform-unicode-sets-regex --dev
```


---

File name: node_modules\@babel\preset-env\CONTRIBUTING.md

Code:
# Contributing

## Adding a new plugin or polyfill to support (when approved in the next ECMAScript version)

### Update [`plugin-features.js`](https://github.com/babel/babel/blob/main/packages/babel-compat-data/scripts/data/plugin-features.js)

*Example:*

If you were going to add `**` which is in ES2016:

Find the relevant entries on [compat-table](https://kangax.github.io/compat-table/es2016plus/#test-exponentiation_(**)_operator):

`exponentiation (**) operator`

Find the corresponding babel plugin:

`@babel/plugin-transform-exponentiation-operator`

And add them in this structure:

```js
// es2016
"@babel/plugin-transform-exponentiation-operator": {
  features: [
    "exponentiation (**) operator",
  ],
},
```

### Update data for `core-js@2` polyfilling

*Example:*

In case you want to add `Object.values` which is in ES2017:

Find the relevant feature and subfeature on [compat-table](https://kangax.github.io/compat-table/es2016plus/#test-Object_static_methods_Object.values)
and split it with `/`:

`Object static methods / Object.values`

Find the corresponding module on [`core-js@2`](https://github.com/zloirock/core-js/tree/v2/modules):

`es7.object.values.js`

Find required ES version in [`corejs2-built-in-features.js`](https://github.com/babel/babel/blob/main/packages/babel-preset-env/data/corejs2-built-in-features.js) and add the new feature:

```js
const es = {
  //...
  "es7.object.values": "Object static methods / Object.values"
}
```

If you want to transform a new built-in by `useBuiltIns: 'usage'`, add mapping to related `core-js` modules to [this file](https://github.com/babel/babel/blob/main/packages/babel-preset-env/polyfills/corejs2/built-in-definitions.js).

### Update data for `core-js@3` polyfilling

Just update the version of [`core-js-compat`](https://github.com/zloirock/core-js/tree/main/packages/core-js-compat) in dependencies.

If you want to transform a new built-in by `useBuiltIns: 'usage'`, add mapping to related [`core-js`](https://github.com/zloirock/core-js/tree/main/packages/core-js/modules) modules to [this file](https://github.com/babel/babel/blob/main/packages/babel-preset-env/polyfills/corejs3/built-in-definitions.js).

If you want to mark a new proposal as shipped, add it to [this list](https://github.com/babel/babel/blob/main/packages/babel-preset-env/polyfills/corejs3/shipped-proposals.js).

### Update [`plugins.json`](https://github.com/babel/babel/blob/main/packages/babel-preset-env/data/plugins.json)

Until `compat-table` is a standalone npm module for data we are using the git commit in `packages/babel-compat-data/scripts/download-compat-table.sh`

`COMPAT_TABLE_COMMIT=[latest-commit-hash]`,

So we update and then run `npm run build-data`. If there are no changes, then `plugins.json` will be the same.

## Tests

### Running tests
See general [CONTRIBUTING.md](https://github.com/babel/babel/blob/main/CONTRIBUTING.md#running-lintingtests).

### Writing tests

#### General

All the tests for `@babel/preset-env` exist in the `test/fixtures` folder. The
test setup and conventions are exactly the same as testing a Babel plugin, so
please read our [documentation on writing tests](https://github.com/babel/babel/blob/main/CONTRIBUTING.md#babel-plugin-x).

#### Testing the `debug` option

Testing debug output to `stdout` is similar. Under the `test/debug-fixtures`,
create a folder with a descriptive name of your test, and add the following:

* Add a `options.json` file (just as the other tests, this is essentially a
`.babelrc`) with the desired test configuration (required)
* Add a `stdout.txt` file with the expected debug output. For added
convenience, if there is no `stdout.txt` present, the test runner will
generate one for you.


---

File name: node_modules\@babel\preset-env\data\built-in-modules.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/native-modules");


---

File name: node_modules\@babel\preset-env\data\built-in-modules.json.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/native-modules");


---

File name: node_modules\@babel\preset-env\data\built-ins.js

Code:
// TODO: Remove in Babel 8
// https://github.com/vuejs/vue-cli/issues/3671

module.exports = require("./corejs2-built-ins.json");


---

File name: node_modules\@babel\preset-env\data\built-ins.json.js

Code:
// TODO: Remove in Babel 8
// https://github.com/vuejs/vue-cli/issues/3671

module.exports = require("./corejs2-built-ins.json");


---

File name: node_modules\@babel\preset-env\data\core-js-compat.js

Code:
// TODO: Remove in Babel 8

module.exports = require("core-js-compat/data.json");


---

File name: node_modules\@babel\preset-env\data\corejs2-built-ins.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/corejs2-built-ins");


---

File name: node_modules\@babel\preset-env\data\corejs2-built-ins.json.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/corejs2-built-ins");


---

File name: node_modules\@babel\preset-env\data\package.json

Code:
{ "type": "commonjs" }

---

File name: node_modules\@babel\preset-env\data\plugins.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/plugins");


---

File name: node_modules\@babel\preset-env\data\plugins.json.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/compat-data/plugins");


---

File name: node_modules\@babel\preset-env\data\shipped-proposals.js

Code:
// TODO: Remove in Babel 8

const { pluginSyntaxMap, proposalPlugins, proposalSyntaxPlugins } = require("../lib/shipped-proposals");
module.exports = { pluginSyntaxMap, proposalPlugins, proposalSyntaxPlugins };


---

File name: node_modules\@babel\preset-env\data\unreleased-labels.js

Code:
// TODO: Remove in Babel 8

module.exports = require("@babel/helper-compilation-targets").unreleasedLabels;


---



---

