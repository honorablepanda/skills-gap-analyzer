File name: node_modules\@testing-library\user-event\dist\esm\event\selection\index.js

Code:
export { getInputRange } from './getInputRange.js';
export { modifySelection } from './modifySelection.js';
export { moveSelection } from './moveSelection.js';
export { setSelectionPerMouseDown } from './setSelectionPerMouse.js';
export { modifySelectionPerMouseMove } from './modifySelectionPerMouse.js';
export { isAllSelected, selectAll } from './selectAll.js';
export { setSelectionRange } from './setSelectionRange.js';
export { setSelection } from './setSelection.js';
export { updateSelectionOnFocus } from './updateSelectionOnFocus.js';


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\modifySelection.js

Code:
import { setUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { getTargetTypeAndSelection } from './getTargetTypeAndSelection.js';

/**
 * Extend/shrink the selection like with Shift+Arrows or Shift+Mouse
 */ function modifySelection({ focusNode, focusOffset }) {
    var _focusNode_ownerDocument_getSelection, _focusNode_ownerDocument;
    const typeAndSelection = getTargetTypeAndSelection(focusNode);
    if (typeAndSelection.type === 'input') {
        return setUISelection(focusNode, {
            anchorOffset: typeAndSelection.selection.anchorOffset,
            focusOffset
        }, 'modify');
    }
    (_focusNode_ownerDocument = focusNode.ownerDocument) === null || _focusNode_ownerDocument === undefined ? undefined : (_focusNode_ownerDocument_getSelection = _focusNode_ownerDocument.getSelection()) === null || _focusNode_ownerDocument_getSelection === undefined ? undefined : _focusNode_ownerDocument_getSelection.extend(focusNode, focusOffset);
}

export { modifySelection };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\modifySelectionPerMouse.js

Code:
import { setUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { resolveCaretPosition } from './resolveCaretPosition.js';

function modifySelectionPerMouseMove(selectionRange, { document, target, node, offset }) {
    const selectionFocus = resolveCaretPosition({
        target,
        node,
        offset
    });
    if ('node' in selectionRange) {
        // When the mouse is dragged outside of an input/textarea,
        // the selection is extended to the beginning or end of the input
        // depending on pointer position.
        // TODO: extend selection according to pointer position
        /* istanbul ignore else */ if (selectionFocus.node === selectionRange.node) {
            const anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start;
            const focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
            setUISelection(selectionRange.node, {
                anchorOffset,
                focusOffset
            });
        }
    } else {
        const range = selectionRange.cloneRange();
        const cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
        if (cmp < 0) {
            range.setStart(selectionFocus.node, selectionFocus.offset);
        } else if (cmp > 0) {
            range.setEnd(selectionFocus.node, selectionFocus.offset);
        }
        const selection = document.getSelection();
        selection === null || selection === undefined ? undefined : selection.removeAllRanges();
        selection === null || selection === undefined ? undefined : selection.addRange(range.cloneRange());
    }
}

export { modifySelectionPerMouseMove };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\moveSelection.js

Code:
import { getUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { getNextCursorPosition } from '../../utils/focus/cursor.js';
import { hasOwnSelection } from '../../utils/focus/selection.js';
import { setSelection } from './setSelection.js';

/**
 * Move the selection
 */ function moveSelection(node, direction) {
    // TODO: implement shift
    if (hasOwnSelection(node)) {
        const selection = getUISelection(node);
        setSelection({
            focusNode: node,
            focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
        });
    } else {
        const selection = node.ownerDocument.getSelection();
        if (!(selection === null || selection === undefined ? undefined : selection.focusNode)) {
            return;
        }
        if (selection.isCollapsed) {
            const nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
            if (nextPosition) {
                setSelection({
                    focusNode: nextPosition.node,
                    focusOffset: nextPosition.offset
                });
            }
        } else {
            selection[direction < 0 ? 'collapseToStart' : 'collapseToEnd']();
        }
    }
}

export { moveSelection };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\resolveCaretPosition.js

Code:
import { getUIValue } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { hasOwnSelection } from '../../utils/focus/selection.js';

function resolveCaretPosition({ target, node, offset }) {
    if (hasOwnSelection(target)) {
        return {
            node: target,
            offset: offset !== null && offset !== undefined ? offset : getUIValue(target).length
        };
    } else if (node) {
        return {
            node,
            offset: offset !== null && offset !== undefined ? offset : node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length
        };
    }
    return findNodeAtTextOffset(target, offset);
}
function findNodeAtTextOffset(node, offset, isRoot = true) {
    // When clicking after the content the browser behavior can be complicated:
    // 1. If there is textContent after the last element child,
    // the cursor is moved there.
    // 2. If there is textContent in the last element child,
    // the browser moves the cursor to the last non-empty text node inside this element.
    // 3. Otherwise the cursor is moved to the end of the target.
    let i = offset === undefined ? node.childNodes.length - 1 : 0;
    const step = offset === undefined ? -1 : 1;
    while(offset === undefined ? i >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i <= node.childNodes.length){
        if (offset && i === node.childNodes.length) {
            throw new Error('The given offset is out of bounds.');
        }
        const c = node.childNodes.item(i);
        const text = String(c.textContent);
        if (text.length) {
            if (offset !== undefined && text.length < offset) {
                offset -= text.length;
            } else if (c.nodeType === 1) {
                return findNodeAtTextOffset(c, offset, false);
            } else {
                // The pre-commit hooks keeps changing this
                // See https://github.com/kentcdodds/kcd-scripts/issues/218
                /* istanbul ignore else */ // eslint-disable-next-line no-lonely-if
                if (c.nodeType === 3) {
                    return {
                        node: c,
                        offset: offset !== null && offset !== undefined ? offset : c.nodeValue.length
                    };
                }
            }
        }
        i += step;
    }
    return {
        node,
        offset: node.childNodes.length
    };
}

export { resolveCaretPosition };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\selectAll.js

Code:
import { getUIValue, getUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { getContentEditable } from '../../utils/edit/isContentEditable.js';
import { hasOwnSelection } from '../../utils/focus/selection.js';
import { setSelection } from './setSelection.js';

/**
 * Expand a selection like the browser does when pressing Ctrl+A.
 */ function selectAll(target) {
    if (hasOwnSelection(target)) {
        return setSelection({
            focusNode: target,
            anchorOffset: 0,
            focusOffset: getUIValue(target).length
        });
    }
    var _getContentEditable;
    const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== undefined ? _getContentEditable : target.ownerDocument.body;
    setSelection({
        focusNode,
        anchorOffset: 0,
        focusOffset: focusNode.childNodes.length
    });
}
function isAllSelected(target) {
    if (hasOwnSelection(target)) {
        return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
    }
    var _getContentEditable;
    const focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== undefined ? _getContentEditable : target.ownerDocument.body;
    const selection = target.ownerDocument.getSelection();
    return (selection === null || selection === undefined ? undefined : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
}

export { isAllSelected, selectAll };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\setSelection.js

Code:
import { setUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { getTargetTypeAndSelection } from './getTargetTypeAndSelection.js';

/**
 * Set the selection
 */ function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
    var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
    const typeAndSelection = getTargetTypeAndSelection(focusNode);
    if (typeAndSelection.type === 'input') {
        return setUISelection(focusNode, {
            anchorOffset,
            focusOffset
        });
    }
    (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === undefined ? undefined : (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === undefined ? undefined : _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}

export { setSelection };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\setSelectionPerMouse.js

Code:
import { getUIValue, setUISelection } from '../../document/UI.js';
import '../../utils/dataTransfer/Clipboard.js';
import { hasNoSelection, hasOwnSelection } from '../../utils/focus/selection.js';
import { resolveCaretPosition } from './resolveCaretPosition.js';

function setSelectionPerMouseDown({ document, target, clickCount, node, offset }) {
    if (hasNoSelection(target)) {
        return;
    }
    const targetHasOwnSelection = hasOwnSelection(target);
    // On non-input elements the text selection per multiple click
    // can extend beyond the target boundaries.
    // The exact mechanism what is considered in the same line is unclear.
    // Looks it might be every inline element.
    // TODO: Check what might be considered part of the same line of text.
    const text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent);
    const [start, end] = node ? // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
        offset,
        offset
    ] : getTextRange(text, offset, clickCount);
    // TODO: implement modifying selection per shift/ctrl+mouse
    if (targetHasOwnSelection) {
        setUISelection(target, {
            anchorOffset: start !== null && start !== undefined ? start : text.length,
            focusOffset: end !== null && end !== undefined ? end : text.length
        });
        return {
            node: target,
            start: start !== null && start !== undefined ? start : 0,
            end: end !== null && end !== undefined ? end : text.length
        };
    } else {
        const { node: startNode, offset: startOffset } = resolveCaretPosition({
            target,
            node,
            offset: start
        });
        const { node: endNode, offset: endOffset } = resolveCaretPosition({
            target,
            node,
            offset: end
        });
        const range = target.ownerDocument.createRange();
        try {
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
        } catch (e) {
            throw new Error('The given offset is out of bounds.');
        }
        const selection = document.getSelection();
        selection === null || selection === undefined ? undefined : selection.removeAllRanges();
        selection === null || selection === undefined ? undefined : selection.addRange(range.cloneRange());
        return range;
    }
}
function getTextRange(text, pos, clickCount) {
    if (clickCount % 3 === 1 || text.length === 0) {
        return [
            pos,
            pos
        ];
    }
    const textPos = pos !== null && pos !== undefined ? pos : text.length;
    if (clickCount % 3 === 2) {
        return [
            textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
            pos === undefined ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
        ];
    }
    // triple click
    return [
        textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
        pos === undefined ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
    ];
}

export { setSelectionPerMouseDown };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\setSelectionRange.js

Code:
import '../../utils/dataTransfer/Clipboard.js';
import { isContentEditable } from '../../utils/edit/isContentEditable.js';
import { hasOwnSelection } from '../../utils/focus/selection.js';
import { setSelection } from './setSelection.js';

/**
 * Backward-compatible selection.
 *
 * Handles input elements and contenteditable if it only contains a single text node.
 */ function setSelectionRange(element, anchorOffset, focusOffset) {
    var _element_firstChild;
    if (hasOwnSelection(element)) {
        return setSelection({
            focusNode: element,
            anchorOffset,
            focusOffset
        });
    }
    /* istanbul ignore else */ if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === undefined ? undefined : _element_firstChild.nodeType) === 3) {
        return setSelection({
            focusNode: element.firstChild,
            anchorOffset,
            focusOffset
        });
    }
    /* istanbul ignore next */ throw new Error('Not implemented. The result of this interaction is unreliable.');
}

export { setSelectionRange };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\selection\updateSelectionOnFocus.js

Code:
import '../../utils/dataTransfer/Clipboard.js';
import { getContentEditable } from '../../utils/edit/isContentEditable.js';
import { hasOwnSelection } from '../../utils/focus/selection.js';

// The browser implementation seems to have changed.
// When focus is inside <input type="text"/>,
// Chrome updates Selection to be collapsed at the position of the input element.
// TODO: update implementation to match that of current browsers
/**
 * Reset the Document Selection when moving focus into an element
 * with own selection implementation.
 */ function updateSelectionOnFocus(element) {
    const selection = element.ownerDocument.getSelection();
    /* istanbul ignore if */ if (!(selection === null || selection === undefined ? undefined : selection.focusNode)) {
        return;
    }
    // If the focus moves inside an element with own selection implementation,
    // the document selection will be this element.
    // But if the focused element is inside a contenteditable,
    // 1) a collapsed selection will be retained.
    // 2) other selections will be replaced by a cursor
    //  2.a) at the start of the first child if it is a text node
    //  2.b) at the start of the contenteditable.
    if (hasOwnSelection(element)) {
        const contenteditable = getContentEditable(selection.focusNode);
        if (contenteditable) {
            if (!selection.isCollapsed) {
                var _contenteditable_firstChild;
                const focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === undefined ? undefined : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
                selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
            }
        } else {
            selection.setBaseAndExtent(element, 0, element, 0);
        }
    }
}

export { updateSelectionOnFocus };


---

File name: node_modules\@testing-library\user-event\dist\esm\event\types.js

Code:



---

File name: node_modules\@testing-library\user-event\dist\esm\event\wrapEvent.js

Code:
import { getConfig } from '@testing-library/dom';

function wrapEvent(cb, _element) {
    return getConfig().eventWrapper(cb);
}

export { wrapEvent };


---

File name: node_modules\@testing-library\user-event\dist\esm\index.js

Code:
export { userEvent as default, userEvent } from './setup/index.js';
export { PointerEventsCheckLevel } from './options.js';


---

File name: node_modules\@testing-library\user-event\dist\esm\keyboard\index.js

Code:
import '../utils/dataTransfer/Clipboard.js';
import { wait } from '../utils/misc/wait.js';
import { parseKeyDef } from './parseKeyDef.js';

async function keyboard(text) {
    const actions = parseKeyDef(this.config.keyboardMap, text);
    for(let i = 0; i < actions.length; i++){
        await wait(this.config);
        await keyboardAction(this, actions[i]);
    }
}
async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
    const { system } = instance;
    // Release the key automatically if it was pressed before.
    if (system.keyboard.isKeyPressed(keyDef)) {
        await system.keyboard.keyup(instance, keyDef);
    }
    if (!releasePrevious) {
        for(let i = 1; i <= repeat; i++){
            await system.keyboard.keydown(instance, keyDef);
            if (i < repeat) {
                await wait(instance.config);
            }
        }
        // Release the key only on the last iteration on `state.repeatKey`.
        if (releaseSelf) {
            await system.keyboard.keyup(instance, keyDef);
        }
    }
}
async function releaseAllKeys(instance) {
    for (const k of instance.system.keyboard.getPressedKeys()){
        await instance.system.keyboard.keyup(instance, k);
    }
}

export { keyboard, releaseAllKeys };


---

File name: node_modules\@testing-library\user-event\dist\esm\keyboard\keyMap.js

Code:
import { DOM_KEY_LOCATION } from '../system/keyboard.js';

/**
 * Mapping for a default US-104-QWERTY keyboard
 */ const defaultKeyMap = [
    // alphanumeric block - writing system
    ...'0123456789'.split('').map((c)=>({
            code: `Digit${c}`,
            key: c
        })),
    ...')!@#$%^&*('.split('').map((c, i)=>({
            code: `Digit${i}`,
            key: c,
            shiftKey: true
        })),
    ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({
            code: `Key${c.toUpperCase()}`,
            key: c
        })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({
            code: `Key${c}`,
            key: c,
            shiftKey: true
        })),
    {
        code: 'BracketLeft',
        key: '['
    },
    {
        code: 'BracketLeft',
        key: '{',
        shiftKey: true
    },
    {
        code: 'BracketRight',
        key: ']'
    },
    {
        code: 'BracketRight',
        key: '}',
        shiftKey: true
    },
    // alphanumeric block - functional
    {
        code: 'Space',
        key: ' '
    },
    {
        code: 'AltLeft',
        key: 'Alt',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'AltRight',
        key: 'Alt',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ShiftLeft',
        key: 'Shift',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ShiftRight',
        key: 'Shift',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ControlLeft',
        key: 'Control',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ControlRight',
        key: 'Control',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'MetaLeft',
        key: 'Meta',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'MetaRight',
        key: 'Meta',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'OSLeft',
        key: 'OS',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'OSRight',
        key: 'OS',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ContextMenu',
        key: 'ContextMenu'
    },
    {
        code: 'Tab',
        key: 'Tab'
    },
    {
        code: 'CapsLock',
        key: 'CapsLock'
    },
    {
        code: 'Backspace',
        key: 'Backspace'
    },
    {
        code: 'Enter',
        key: 'Enter'
    },
    // function
    {
        code: 'Escape',
        key: 'Escape'
    },
    // arrows
    {
        code: 'ArrowUp',
        key: 'ArrowUp'
    },
    {
        code: 'ArrowDown',
        key: 'ArrowDown'
    },
    {
        code: 'ArrowLeft',
        key: 'ArrowLeft'
    },
    {
        code: 'ArrowRight',
        key: 'ArrowRight'
    },
    // control pad
    {
        code: 'Home',
        key: 'Home'
    },
    {
        code: 'End',
        key: 'End'
    },
    {
        code: 'Delete',
        key: 'Delete'
    },
    {
        code: 'PageUp',
        key: 'PageUp'
    },
    {
        code: 'PageDown',
        key: 'PageDown'
    },
    // Special keys that are not part of a default US-layout but included for specific behavior
    {
        code: 'Fn',
        key: 'Fn'
    },
    {
        code: 'Symbol',
        key: 'Symbol'
    },
    {
        code: 'AltRight',
        key: 'AltGraph'
    }
];

export { defaultKeyMap };


---

File name: node_modules\@testing-library\user-event\dist\esm\keyboard\parseKeyDef.js

Code:
import '../utils/dataTransfer/Clipboard.js';
import { readNextDescriptor } from '../utils/keyDef/readNextDescriptor.js';

/**
 * Parse key definitions per `keyboardMap`
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * Keeping the key pressed can be written as `{key>}`.
 * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.
 * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.
 */ function parseKeyDef(keyboardMap, text) {
    const defs = [];
    do {
        const { type, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, 'keyboard');
        var _keyboardMap_find;
        const keyDef = (_keyboardMap_find = keyboardMap.find((def)=>{
            if (type === '[') {
                var _def_code;
                return ((_def_code = def.code) === null || _def_code === undefined ? undefined : _def_code.toLowerCase()) === descriptor.toLowerCase();
            } else if (type === '{') {
                var _def_key;
                return ((_def_key = def.key) === null || _def_key === undefined ? undefined : _def_key.toLowerCase()) === descriptor.toLowerCase();
            }
            return def.key === descriptor;
        })) !== null && _keyboardMap_find !== undefined ? _keyboardMap_find : {
            key: 'Unknown',
            code: 'Unknown',
            [type === '[' ? 'code' : 'key']: descriptor
        };
        defs.push({
            keyDef,
            releasePrevious,
            releaseSelf,
            repeat
        });
        text = text.slice(consumedLength);
    }while (text)
    return defs;
}

export { parseKeyDef };


---

File name: node_modules\@testing-library\user-event\dist\esm\options.js

Code:
var PointerEventsCheckLevel = /*#__PURE__*/ function(PointerEventsCheckLevel) {
    /**
   * Check pointer events on every user interaction that triggers a bunch of events.
   * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
   */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTrigger"] = 4] = "EachTrigger";
    /** Check each target once per call to pointer (related) API */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachApiCall"] = 2] = "EachApiCall";
    /** Check each event target once */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTarget"] = 1] = "EachTarget";
    /** No pointer events check */ PointerEventsCheckLevel[PointerEventsCheckLevel["Never"] = 0] = "Never";
    return PointerEventsCheckLevel;
}({});

export { PointerEventsCheckLevel };


---

File name: node_modules\@testing-library\user-event\dist\esm\package.json

Code:
{
  "type": "module"
}

---

File name: node_modules\@testing-library\user-event\dist\esm\pointer\index.js

Code:
import '../utils/dataTransfer/Clipboard.js';
import { setLevelRef, ApiLevel } from '../utils/misc/level.js';
import { wait } from '../utils/misc/wait.js';
import { parseKeyDef } from './parseKeyDef.js';

async function pointer(input) {
    const { pointerMap } = this.config;
    const actions = [];
    (Array.isArray(input) ? input : [
        input
    ]).forEach((actionInput)=>{
        if (typeof actionInput === 'string') {
            actions.push(...parseKeyDef(pointerMap, actionInput));
        } else if ('keys' in actionInput) {
            actions.push(...parseKeyDef(pointerMap, actionInput.keys).map((i)=>({
                    ...actionInput,
                    ...i
                })));
        } else {
            actions.push(actionInput);
        }
    });
    for(let i = 0; i < actions.length; i++){
        await wait(this.config);
        await pointerAction(this, actions[i]);
    }
    this.system.pointer.resetClickCount();
}
async function pointerAction(instance, action) {
    var _previousPosition_caret, _previousPosition_caret1;
    const pointerName = 'pointerName' in action && action.pointerName ? action.pointerName : 'keyDef' in action ? instance.system.pointer.getPointerName(action.keyDef) : 'mouse';
    const previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
    var _action_target, _action_coords, _action_node, _action_offset;
    const position = {
        target: (_action_target = action.target) !== null && _action_target !== undefined ? _action_target : getPrevTarget(instance, previousPosition),
        coords: (_action_coords = action.coords) !== null && _action_coords !== undefined ? _action_coords : previousPosition === null || previousPosition === undefined ? undefined : previousPosition.coords,
        caret: {
            node: (_action_node = action.node) !== null && _action_node !== undefined ? _action_node : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === undefined ? undefined : (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === undefined ? undefined : _previousPosition_caret.node,
            offset: (_action_offset = action.offset) !== null && _action_offset !== undefined ? _action_offset : hasCaretPosition(action) ? undefined : previousPosition === null || previousPosition === undefined ? undefined : (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === undefined ? undefined : _previousPosition_caret1.offset
        }
    };
    if ('keyDef' in action) {
        if (instance.system.pointer.isKeyPressed(action.keyDef)) {
            setLevelRef(instance, ApiLevel.Trigger);
            await instance.system.pointer.release(instance, action.keyDef, position);
        }
        if (!action.releasePrevious) {
            setLevelRef(instance, ApiLevel.Trigger);
            await instance.system.pointer.press(instance, action.keyDef, position);
            if (action.releaseSelf) {
                setLevelRef(instance, ApiLevel.Trigger);
                await instance.system.pointer.release(instance, action.keyDef, position);
            }
        }
    } else {
        setLevelRef(instance, ApiLevel.Trigger);
        await instance.system.pointer.move(instance, pointerName, position);
    }
}
function hasCaretPosition(action) {
    var _action_target, _ref;
    return !!((_ref = (_action_target = action.target) !== null && _action_target !== undefined ? _action_target : action.node) !== null && _ref !== undefined ? _ref : action.offset !== undefined);
}
function getPrevTarget(instance, position) {
    if (!position) {
        throw new Error('This pointer has no previous position. Provide a target property!');
    }
    var _position_target;
    return (_position_target = position.target) !== null && _position_target !== undefined ? _position_target : instance.config.document.body;
}

export { pointer };


---

File name: node_modules\@testing-library\user-event\dist\esm\pointer\keyMap.js

Code:
const defaultKeyMap = [
    {
        name: 'MouseLeft',
        pointerType: 'mouse',
        button: 'primary'
    },
    {
        name: 'MouseRight',
        pointerType: 'mouse',
        button: 'secondary'
    },
    {
        name: 'MouseMiddle',
        pointerType: 'mouse',
        button: 'auxiliary'
    },
    {
        name: 'TouchA',
        pointerType: 'touch'
    },
    {
        name: 'TouchB',
        pointerType: 'touch'
    },
    {
        name: 'TouchC',
        pointerType: 'touch'
    }
];

export { defaultKeyMap };


---

File name: node_modules\@testing-library\user-event\dist\esm\pointer\parseKeyDef.js

Code:
import '../utils/dataTransfer/Clipboard.js';
import { readNextDescriptor } from '../utils/keyDef/readNextDescriptor.js';

function parseKeyDef(pointerMap, keys) {
    const defs = [];
    do {
        const { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys, 'pointer');
        const keyDef = pointerMap.find((p)=>p.name === descriptor);
        if (keyDef) {
            defs.push({
                keyDef,
                releasePrevious,
                releaseSelf
            });
        }
        keys = keys.slice(consumedLength);
    }while (keys)
    return defs;
}

export { parseKeyDef };


---

File name: node_modules\@testing-library\user-event\dist\esm\setup\api.js

Code:
import { click, dblClick, tripleClick } from '../convenience/click.js';
import { hover, unhover } from '../convenience/hover.js';
import { tab } from '../convenience/tab.js';
import { keyboard } from '../keyboard/index.js';
import { copy } from '../clipboard/copy.js';
import { cut } from '../clipboard/cut.js';
import { paste } from '../clipboard/paste.js';
import { pointer } from '../pointer/index.js';
import { clear } from '../utility/clear.js';
import { deselectOptions, selectOptions } from '../utility/selectOptions.js';
import { type } from '../utility/type.js';
import { upload } from '../utility/upload.js';

const userEventApi = {
    click,
    dblClick,
    tripleClick,
    hover,
    unhover,
    tab,
    keyboard,
    copy,
    cut,
    paste,
    pointer,
    clear,
    deselectOptions,
    selectOptions,
    type,
    upload
};

export { userEventApi };


---

File name: node_modules\@testing-library\user-event\dist\esm\setup\directApi.js

Code:
import { setupDirect } from './setup.js';

function clear(element) {
    return setupDirect().api.clear(element);
}
function click(element, options = {}) {
    return setupDirect(options, element).api.click(element);
}
function copy(options = {}) {
    return setupDirect(options).api.copy();
}
function cut(options = {}) {
    return setupDirect(options).api.cut();
}
function dblClick(element, options = {}) {
    return setupDirect(options).api.dblClick(element);
}
function deselectOptions(select, values, options = {}) {
    return setupDirect(options).api.deselectOptions(select, values);
}
function hover(element, options = {}) {
    return setupDirect(options).api.hover(element);
}
async function keyboard(text, options = {}) {
    const { api, system } = setupDirect(options);
    return api.keyboard(text).then(()=>system);
}
async function pointer(input, options = {}) {
    const { api, system } = setupDirect(options);
    return api.pointer(input).then(()=>system);
}
function paste(clipboardData, options) {
    return setupDirect(options).api.paste(clipboardData);
}
function selectOptions(select, values, options = {}) {
    return setupDirect(options).api.selectOptions(select, values);
}
function tripleClick(element, options = {}) {
    return setupDirect(options).api.tripleClick(element);
}
function type(element, text, options = {}) {
    return setupDirect(options, element).api.type(element, text, options);
}
function unhover(element, options = {}) {
    const { api, system } = setupDirect(options);
    system.pointer.setMousePosition({
        target: element
    });
    return api.unhover(element);
}
function upload(element, fileOrFiles, options = {}) {
    return setupDirect(options).api.upload(element, fileOrFiles);
}
function tab(options = {}) {
    return setupDirect().api.tab(options);
}

export { clear, click, copy, cut, dblClick, deselectOptions, hover, keyboard, paste, pointer, selectOptions, tab, tripleClick, type, unhover, upload };


---

File name: node_modules\@testing-library\user-event\dist\esm\setup\index.js

Code:
import { setupMain } from './setup.js';
import * as directApi from './directApi.js';

const userEvent = {
    ...directApi,
    setup: setupMain
};

export { userEvent };


---

File name: node_modules\@testing-library\user-event\dist\esm\setup\setup.js

Code:
import { patchFocus } from '../document/patchFocus.js';
import { prepareDocument } from '../document/prepareDocument.js';
import { dispatchEvent, dispatchUIEvent } from '../event/dispatchEvent.js';
import { attachClipboardStubToView } from '../utils/dataTransfer/Clipboard.js';
import { getWindow } from '../utils/misc/getWindow.js';
import { getDocumentFromNode } from '../utils/misc/getDocumentFromNode.js';
import { setLevelRef, ApiLevel } from '../utils/misc/level.js';
import { wait } from '../utils/misc/wait.js';
import { PointerEventsCheckLevel } from '../options.js';
import '@testing-library/dom';
import { defaultKeyMap } from '../keyboard/keyMap.js';
import { defaultKeyMap as defaultKeyMap$1 } from '../pointer/keyMap.js';
import { System } from '../system/index.js';
import { userEventApi } from './api.js';
import { wrapAsync } from './wrapAsync.js';

/**
 * Default options applied when API is called per `userEvent.anyApi()`
 */ const defaultOptionsDirect = {
    applyAccept: true,
    autoModify: true,
    delay: 0,
    document: globalThis.document,
    keyboardMap: defaultKeyMap,
    pointerMap: defaultKeyMap$1,
    pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
    skipAutoClose: false,
    skipClick: false,
    skipHover: false,
    writeToClipboard: false,
    advanceTimers: ()=>Promise.resolve()
};
/**
 * Default options applied when API is called per `userEvent().anyApi()`
 */ const defaultOptionsSetup = {
    ...defaultOptionsDirect,
    writeToClipboard: true
};
function createConfig(options = {}, defaults = defaultOptionsSetup, node) {
    const document = getDocument(options, node, defaults);
    return {
        ...defaults,
        ...options,
        document
    };
}
/**
 * Start a "session" with userEvent.
 * All APIs returned by this function share an input device state and a default configuration.
 */ function setupMain(options = {}) {
    const config = createConfig(options);
    prepareDocument(config.document);
    patchFocus(getWindow(config.document).HTMLElement);
    var _config_document_defaultView;
    const view = (_config_document_defaultView = config.document.defaultView) !== null && _config_document_defaultView !== undefined ? _config_document_defaultView : /* istanbul ignore next */ globalThis.window;
    attachClipboardStubToView(view);
    return createInstance(config).api;
}
/**
 * Setup in direct call per `userEvent.anyApi()`
 */ function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {
    const config = createConfig(options, defaultOptionsDirect, node);
    prepareDocument(config.document);
    patchFocus(getWindow(config.document).HTMLElement);
    var _ref;
    const system = (_ref = pointerState !== null && pointerState !== undefined ? pointerState : keyboardState) !== null && _ref !== undefined ? _ref : new System();
    return {
        api: createInstance(config, system).api,
        system
    };
}
/**
 * Create a set of callbacks with different default settings but the same state.
 */ function setupSub(options) {
    return createInstance({
        ...this.config,
        ...options
    }, this.system).api;
}
function wrapAndBindImpl(instance, impl) {
    function method(...args) {
        setLevelRef(instance, ApiLevel.Call);
        return wrapAsync(()=>impl.apply(instance, args).then(async (ret)=>{
                await wait(instance.config);
                return ret;
            }));
    }
    Object.defineProperty(method, 'name', {
        get: ()=>impl.name
    });
    return method;
}
function createInstance(config, system = new System()) {
    const instance = {};
    Object.assign(instance, {
        config,
        dispatchEvent: dispatchEvent.bind(instance),
        dispatchUIEvent: dispatchUIEvent.bind(instance),
        system,
        levelRefs: {},
        ...userEventApi
    });
    return {
        instance,
        api: {
            ...Object.fromEntries(Object.entries(userEventApi).map(([name, api])=>[
                    name,
                    wrapAndBindImpl(instance, api)
                ])),
            setup: setupSub.bind(instance)
        }
    };
}
function getDocument(options, node, defaults) {
    var _options_document, _ref;
    return (_ref = (_options_document = options.document) !== null && _options_document !== undefined ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== undefined ? _ref : defaults.document;
}

export { createConfig, createInstance, setupDirect, setupMain, setupSub };


---

File name: node_modules\@testing-library\user-event\dist\esm\setup\wrapAsync.js

Code:
import { getConfig } from '@testing-library/dom';

/**
 * Wrap an internal Promise
 */ function wrapAsync(implementation) {
    return getConfig().asyncWrapper(implementation);
}

export { wrapAsync };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\index.js

Code:
import { KeyboardHost } from './keyboard.js';
import { PointerHost } from './pointer/index.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * @internal Do not create/alter this by yourself as this type might be subject to changes.
 */ class System {
    getUIEventModifiers() {
        return {
            altKey: this.keyboard.modifiers.Alt,
            ctrlKey: this.keyboard.modifiers.Control,
            metaKey: this.keyboard.modifiers.Meta,
            shiftKey: this.keyboard.modifiers.Shift,
            modifierAltGraph: this.keyboard.modifiers.AltGraph,
            modifierCapsLock: this.keyboard.modifiers.CapsLock,
            modifierFn: this.keyboard.modifiers.Fn,
            modifierFnLock: this.keyboard.modifiers.FnLock,
            modifierNumLock: this.keyboard.modifiers.NumLock,
            modifierScrollLock: this.keyboard.modifiers.ScrollLock,
            modifierSymbol: this.keyboard.modifiers.Symbol,
            modifierSymbolLock: this.keyboard.modifiers.SymbolLock
        };
    }
    constructor(){
        _define_property(this, "keyboard", new KeyboardHost(this));
        _define_property(this, "pointer", new PointerHost(this));
    }
}

export { System };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\keyboard.js

Code:
import '../utils/dataTransfer/Clipboard.js';
import { getActiveElementOrBody } from '../utils/focus/getActiveElement.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DOM_KEY_LOCATION = /*#__PURE__*/ function(DOM_KEY_LOCATION) {
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["STANDARD"] = 0] = "STANDARD";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["LEFT"] = 1] = "LEFT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["RIGHT"] = 2] = "RIGHT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["NUMPAD"] = 3] = "NUMPAD";
    return DOM_KEY_LOCATION;
}({});
const modifierKeys = [
    'Alt',
    'AltGraph',
    'Control',
    'Fn',
    'Meta',
    'Shift',
    'Symbol'
];
function isModifierKey(key) {
    return modifierKeys.includes(key);
}
const modifierLocks = [
    'CapsLock',
    'FnLock',
    'NumLock',
    'ScrollLock',
    'SymbolLock'
];
function isModifierLock(key) {
    return modifierLocks.includes(key);
}
class KeyboardHost {
    isKeyPressed(keyDef) {
        return this.pressed.has(String(keyDef.code));
    }
    getPressedKeys() {
        return this.pressed.values().map((p)=>p.keyDef);
    }
    /** Press a key */ async keydown(instance, keyDef) {
        const key = String(keyDef.key);
        const code = String(keyDef.code);
        const target = getActiveElementOrBody(instance.config.document);
        this.setKeydownTarget(target);
        this.pressed.add(code, keyDef);
        if (isModifierKey(key)) {
            this.modifiers[key] = true;
        }
        const unprevented = instance.dispatchUIEvent(target, 'keydown', {
            key,
            code
        });
        if (isModifierLock(key) && !this.modifiers[key]) {
            this.modifiers[key] = true;
            this.modifierLockStart[key] = true;
        }
        if (unprevented) {
            this.pressed.setUnprevented(code);
        }
        if (unprevented && this.hasKeyPress(key)) {
            instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keypress', {
                key,
                code,
                charCode: keyDef.key === 'Enter' ? 13 : String(keyDef.key).charCodeAt(0)
            });
        }
    }
    /** Release a key */ async keyup(instance, keyDef) {
        const key = String(keyDef.key);
        const code = String(keyDef.code);
        const unprevented = this.pressed.isUnprevented(code);
        this.pressed.delete(code);
        if (isModifierKey(key) && !this.pressed.values().find((p)=>p.keyDef.key === key)) {
            this.modifiers[key] = false;
        }
        instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), 'keyup', {
            key,
            code
        }, !unprevented);
        if (isModifierLock(key) && this.modifiers[key]) {
            if (this.modifierLockStart[key]) {
                this.modifierLockStart[key] = false;
            } else {
                this.modifiers[key] = false;
            }
        }
    }
    setKeydownTarget(target) {
        if (target !== this.lastKeydownTarget) {
            this.carryChar = '';
        }
        this.lastKeydownTarget = target;
    }
    hasKeyPress(key) {
        return (key.length === 1 || key === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
    }
    constructor(system){
        _define_property(this, "system", undefined);
        _define_property(this, "modifiers", {
            Alt: false,
            AltGraph: false,
            CapsLock: false,
            Control: false,
            Fn: false,
            FnLock: false,
            Meta: false,
            NumLock: false,
            ScrollLock: false,
            Shift: false,
            Symbol: false,
            SymbolLock: false
        });
        _define_property(this, "pressed", new class {
            add(code, keyDef) {
                var _this_registry, _code;
                var _;
                (_ = (_this_registry = this.registry)[_code = code]) !== null && _ !== undefined ? _ : _this_registry[_code] = {
                    keyDef,
                    unpreventedDefault: false
                };
            }
            has(code) {
                return !!this.registry[code];
            }
            setUnprevented(code) {
                const o = this.registry[code];
                if (o) {
                    o.unpreventedDefault = true;
                }
            }
            isUnprevented(code) {
                var _this_registry_code;
                return !!((_this_registry_code = this.registry[code]) === null || _this_registry_code === undefined ? undefined : _this_registry_code.unpreventedDefault);
            }
            delete(code) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this.registry[code];
            }
            values() {
                return Object.values(this.registry);
            }
            constructor(){
                _define_property(this, "registry", {});
            }
        }());
        _define_property(this, "carryChar", '');
        _define_property(this, "lastKeydownTarget", undefined);
        _define_property(this, "modifierLockStart", {});
        this.system = system;
    }
}

export { DOM_KEY_LOCATION, KeyboardHost };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\buttons.js

Code:
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class Buttons {
    getButtons() {
        let v = 0;
        for (const button of Object.keys(this.pressed)){
            // eslint-disable-next-line no-bitwise
            v |= 2 ** Number(button);
        }
        return v;
    }
    down(keyDef) {
        const button = getMouseButtonId(keyDef.button);
        if (button in this.pressed) {
            this.pressed[button].push(keyDef);
            return undefined;
        }
        this.pressed[button] = [
            keyDef
        ];
        return button;
    }
    up(keyDef) {
        const button = getMouseButtonId(keyDef.button);
        if (button in this.pressed) {
            this.pressed[button] = this.pressed[button].filter((k)=>k.name !== keyDef.name);
            if (this.pressed[button].length === 0) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this.pressed[button];
                return button;
            }
        }
        return undefined;
    }
    constructor(){
        _define_property(this, "pressed", {});
    }
}
const MouseButton = {
    primary: 0,
    secondary: 1,
    auxiliary: 2,
    back: 3,
    X1: 3,
    forward: 4,
    X2: 4
};
function getMouseButtonId(button = 0) {
    if (button in MouseButton) {
        return MouseButton[button];
    }
    return Number(button);
}
// On the `MouseEvent.button` property auxiliary and secondary button are flipped compared to `MouseEvent.buttons`.
const MouseButtonFlip = {
    1: 2,
    2: 1
};
function getMouseEventButton(button) {
    button = getMouseButtonId(button);
    if (button in MouseButtonFlip) {
        return MouseButtonFlip[button];
    }
    return button;
}

export { Buttons, MouseButton, MouseButtonFlip, getMouseButtonId, getMouseEventButton };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\device.js

Code:
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class Device {
    get countPressed() {
        return this.pressedKeys.size;
    }
    isPressed(keyDef) {
        return this.pressedKeys.has(keyDef.name);
    }
    addPressed(keyDef) {
        return this.pressedKeys.add(keyDef.name);
    }
    removePressed(keyDef) {
        return this.pressedKeys.delete(keyDef.name);
    }
    constructor(){
        _define_property(this, "pressedKeys", new Set());
    }
}

export { Device };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\index.js

Code:
import { Buttons } from './buttons.js';
import { Device } from './device.js';
import { Mouse } from './mouse.js';
import { Pointer } from './pointer.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class PointerHost {
    isKeyPressed(keyDef) {
        return this.devices.get(keyDef.pointerType).isPressed(keyDef);
    }
    async press(instance, keyDef, position) {
        this.devices.get(keyDef.pointerType).addPressed(keyDef);
        this.buttons.down(keyDef);
        const pointerName = this.getPointerName(keyDef);
        const pointer = keyDef.pointerType === 'touch' ? this.pointers.new(pointerName, keyDef.pointerType, this.buttons) : this.pointers.get(pointerName);
        // TODO: deprecate the following implicit setting of position
        pointer.position = position;
        if (pointer.pointerType !== 'touch') {
            this.mouse.position = position;
        }
        if (pointer.pointerType === 'touch') {
            pointer.init(instance);
        }
        pointer.down(instance, keyDef.button);
        if (pointer.pointerType !== 'touch') {
            this.mouse.down(instance, keyDef, pointer.isPrevented);
        }
    }
    async move(instance, pointerName, position) {
        const pointer = this.pointers.get(pointerName);
        // In (some?) browsers this order of events can be observed.
        // This interweaving of events is probably unnecessary.
        // While the order of mouse (or pointer) events is defined per spec,
        // the order in which they interweave/follow on a user interaction depends on the implementation.
        const pointermove = pointer.move(instance, position);
        const mousemove = pointer.pointerType === 'touch' ? undefined : this.mouse.move(instance, position, pointer.isPrevented);
        pointermove === null || pointermove === undefined ? undefined : pointermove.leave();
        mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
        pointermove === null || pointermove === undefined ? undefined : pointermove.enter();
        mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
        pointermove === null || pointermove === undefined ? undefined : pointermove.move();
        mousemove === null || mousemove === undefined ? undefined : mousemove.move();
    }
    async release(instance, keyDef, position) {
        const device = this.devices.get(keyDef.pointerType);
        device.removePressed(keyDef);
        this.buttons.up(keyDef);
        const pointer = this.pointers.get(this.getPointerName(keyDef));
        const isPrevented = pointer.isPrevented;
        // TODO: deprecate the following implicit setting of position
        pointer.position = position;
        if (pointer.pointerType !== 'touch') {
            this.mouse.position = position;
        }
        if (device.countPressed === 0) {
            pointer.up(instance, keyDef.button);
        }
        if (pointer.pointerType === 'touch') {
            pointer.release(instance);
        }
        if (pointer.pointerType === 'touch' && !pointer.isMultitouch) {
            const mousemove = this.mouse.move(instance, position, isPrevented);
            mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
            mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
            mousemove === null || mousemove === undefined ? undefined : mousemove.move();
            this.mouse.down(instance, keyDef, isPrevented);
        }
        if (!pointer.isMultitouch) {
            const mousemove = this.mouse.move(instance, position, isPrevented);
            mousemove === null || mousemove === undefined ? undefined : mousemove.leave();
            mousemove === null || mousemove === undefined ? undefined : mousemove.enter();
            mousemove === null || mousemove === undefined ? undefined : mousemove.move();
            this.mouse.up(instance, keyDef, isPrevented);
        }
    }
    getPointerName(keyDef) {
        return keyDef.pointerType === 'touch' ? keyDef.name : keyDef.pointerType;
    }
    getPreviousPosition(pointerName) {
        return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : undefined;
    }
    resetClickCount() {
        this.mouse.resetClickCount();
    }
    getMouseTarget(instance) {
        var _this_mouse_position_target;
        return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== undefined ? _this_mouse_position_target : instance.config.document.body;
    }
    setMousePosition(position) {
        this.mouse.position = position;
        this.pointers.get('mouse').position = position;
    }
    constructor(system){
        _define_property(this, "system", undefined);
        _define_property(this, "mouse", undefined);
        _define_property(this, "buttons", undefined);
        _define_property(this, "devices", new class {
            get(k) {
                var _this_registry, _k;
                var _;
                return (_ = (_this_registry = this.registry)[_k = k]) !== null && _ !== undefined ? _ : _this_registry[_k] = new Device();
            }
            constructor(){
                _define_property(this, "registry", {});
            }
        }());
        _define_property(this, "pointers", new class {
            new(pointerName, pointerType, buttons) {
                const isPrimary = pointerType !== 'touch' || !Object.values(this.registry).some((p)=>p.pointerType === 'touch' && !p.isCancelled);
                if (!isPrimary) {
                    Object.values(this.registry).forEach((p)=>{
                        if (p.pointerType === pointerType && !p.isCancelled) {
                            p.isMultitouch = true;
                        }
                    });
                }
                this.registry[pointerName] = new Pointer({
                    pointerId: this.nextId++,
                    pointerType,
                    isPrimary
                }, buttons);
                return this.registry[pointerName];
            }
            get(pointerName) {
                if (!this.has(pointerName)) {
                    throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
                }
                return this.registry[pointerName];
            }
            has(pointerName) {
                return pointerName in this.registry;
            }
            constructor(){
                _define_property(this, "registry", {});
                _define_property(this, "nextId", 1);
            }
        }());
        this.system = system;
        this.buttons = new Buttons();
        this.mouse = new Mouse();
        this.pointers.new('mouse', 'mouse', this.buttons);
    }
}

export { PointerHost };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\mouse.js

Code:
import '../../event/behavior/click.js';
import '../../event/behavior/cut.js';
import '../../event/behavior/keydown.js';
import '../../event/behavior/keypress.js';
import '../../event/behavior/keyup.js';
import '../../event/behavior/paste.js';
import '@testing-library/dom';
import '../../utils/dataTransfer/Clipboard.js';
import { isDisabled } from '../../utils/misc/isDisabled.js';
import { getTreeDiff } from '../../utils/misc/getTreeDiff.js';
import { focusElement } from '../../event/focus.js';
import { setSelectionPerMouseDown } from '../../event/selection/setSelectionPerMouse.js';
import { modifySelectionPerMouseMove } from '../../event/selection/modifySelectionPerMouse.js';
import { getMouseEventButton, Buttons } from './buttons.js';
import { isDifferentPointerPosition } from './shared.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * This object is the single "virtual" mouse that might be controlled by multiple different pointer devices.
 */ class Mouse {
    move(instance, position, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
        const prevPosition = this.position;
        const prevTarget = this.getTarget(instance);
        this.position = position;
        if (!isDifferentPointerPosition(prevPosition, position)) {
            return;
        }
        const nextTarget = this.getTarget(instance);
        const init = this.getEventInit('mousemove');
        const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
        return {
            leave: ()=>{
                if (prevTarget !== nextTarget) {
                    instance.dispatchUIEvent(prevTarget, 'mouseout', init);
                    leave.forEach((el)=>instance.dispatchUIEvent(el, 'mouseleave', init));
                }
            },
            enter: ()=>{
                if (prevTarget !== nextTarget) {
                    instance.dispatchUIEvent(nextTarget, 'mouseover', init);
                    enter.forEach((el)=>instance.dispatchUIEvent(el, 'mouseenter', init));
                }
            },
            move: ()=>{
                if (isPrevented) {
                    return;
                }
                instance.dispatchUIEvent(nextTarget, 'mousemove', init);
                this.modifySelecting(instance);
            }
        };
    }
    down(instance, keyDef, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
        const button = this.buttons.down(keyDef);
        if (button === undefined) {
            return;
        }
        const target = this.getTarget(instance);
        this.buttonDownTarget[button] = target;
        const init = this.getEventInit('mousedown', keyDef.button);
        const disabled = isDisabled(target);
        if (!isPrevented && (disabled || instance.dispatchUIEvent(target, 'mousedown', init))) {
            this.startSelecting(instance, init.detail);
            focusElement(target);
        }
        if (!disabled && getMouseEventButton(keyDef.button) === 2) {
            instance.dispatchUIEvent(target, 'contextmenu', this.getEventInit('contextmenu', keyDef.button));
        }
    }
    up(instance, keyDef, /** Whether `preventDefault()` has been called on the `pointerdown` event */ isPrevented) {
        const button = this.buttons.up(keyDef);
        if (button === undefined) {
            return;
        }
        const target = this.getTarget(instance);
        if (!isDisabled(target)) {
            if (!isPrevented) {
                const mouseUpInit = this.getEventInit('mouseup', keyDef.button);
                instance.dispatchUIEvent(target, 'mouseup', mouseUpInit);
                this.endSelecting();
            }
            const clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
            if (clickTarget) {
                const init = this.getEventInit('click', keyDef.button);
                if (init.detail) {
                    instance.dispatchUIEvent(clickTarget, init.button === 0 ? 'click' : 'auxclick', init);
                    if (init.button === 0 && init.detail === 2) {
                        instance.dispatchUIEvent(clickTarget, 'dblclick', {
                            ...this.getEventInit('dblclick', keyDef.button),
                            detail: init.detail
                        });
                    }
                }
            }
        }
    }
    resetClickCount() {
        this.clickCount.reset();
    }
    getEventInit(type, button) {
        const init = {
            ...this.position.coords
        };
        init.button = getMouseEventButton(button);
        init.buttons = this.buttons.getButtons();
        if (type === 'mousedown') {
            init.detail = this.clickCount.getOnDown(init.button);
        } else if (type === 'mouseup') {
            init.detail = this.clickCount.getOnUp(init.button);
        } else if (type === 'click' || type === 'auxclick') {
            init.detail = this.clickCount.incOnClick(init.button);
        }
        return init;
    }
    getTarget(instance) {
        var _this_position_target;
        return (_this_position_target = this.position.target) !== null && _this_position_target !== undefined ? _this_position_target : instance.config.document.body;
    }
    startSelecting(instance, clickCount) {
        var _this_position_caret, _this_position_caret1;
        // TODO: support extending range (shift)
        this.selecting = setSelectionPerMouseDown({
            document: instance.config.document,
            target: this.getTarget(instance),
            node: (_this_position_caret = this.position.caret) === null || _this_position_caret === undefined ? undefined : _this_position_caret.node,
            offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === undefined ? undefined : _this_position_caret1.offset,
            clickCount
        });
    }
    modifySelecting(instance) {
        var _this_position_caret, _this_position_caret1;
        if (!this.selecting) {
            return;
        }
        modifySelectionPerMouseMove(this.selecting, {
            document: instance.config.document,
            target: this.getTarget(instance),
            node: (_this_position_caret = this.position.caret) === null || _this_position_caret === undefined ? undefined : _this_position_caret.node,
            offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === undefined ? undefined : _this_position_caret1.offset
        });
    }
    endSelecting() {
        this.selecting = undefined;
    }
    constructor(){
        _define_property(this, "position", {});
        _define_property(this, "buttons", new Buttons());
        _define_property(this, "selecting", undefined);
        _define_property(this, "buttonDownTarget", {});
        // According to spec the `detail` on click events should be the number
        // of *consecutive* clicks with a specific button.
        // On `mousedown` and `mouseup` it should be this number increased by one.
        // But the browsers don't implement it this way.
        // If another button is pressed,
        //   in Webkit: the `mouseup` on the previously pressed button has `detail: 0` and no `click`/`auxclick`.
        //   in Gecko: the `mouseup` and click events have the same detail as the `mousedown`.
        // If there is a delay while a button is pressed,
        // the `mouseup` and `click` are normal, but a following `mousedown` starts a new click count.
        // We'll follow the minimal implementation of Webkit.
        _define_property(this, "clickCount", new class {
            incOnClick(button) {
                const current = this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;
                this.count = this.count[button] === undefined ? {} : {
                    [button]: Number(this.count[button]) + 1
                };
                return current;
            }
            getOnDown(button) {
                var _this_count_button;
                this.down = {
                    [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== undefined ? _this_count_button : 0
                };
                var _this_count_button1;
                this.count = {
                    [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== undefined ? _this_count_button1 : 0
                };
                return Number(this.count[button]) + 1;
            }
            getOnUp(button) {
                return this.down[button] === undefined ? undefined : Number(this.down[button]) + 1;
            }
            reset() {
                this.count = {};
            }
            constructor(){
                _define_property(this, "down", {});
                _define_property(this, "count", {});
            }
        }());
    }
}

export { Mouse };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\pointer.js

Code:
import '../../utils/dataTransfer/Clipboard.js';
import { getTreeDiff } from '../../utils/misc/getTreeDiff.js';
import { assertPointerEvents, hasPointerEvents } from '../../utils/pointer/cssPointerEvents.js';
import { isDifferentPointerPosition } from './shared.js';
import { getMouseEventButton } from './buttons.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class Pointer {
    init(instance) {
        const target = this.getTarget(instance);
        const [, enter] = getTreeDiff(null, target);
        const init = this.getEventInit();
        assertPointerEvents(instance, target);
        instance.dispatchUIEvent(target, 'pointerover', init);
        enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));
        return this;
    }
    move(instance, position) {
        const prevPosition = this.position;
        const prevTarget = this.getTarget(instance);
        this.position = position;
        if (!isDifferentPointerPosition(prevPosition, position)) {
            return;
        }
        const nextTarget = this.getTarget(instance);
        const init = this.getEventInit(-1);
        const [leave, enter] = getTreeDiff(prevTarget, nextTarget);
        return {
            leave: ()=>{
                if (hasPointerEvents(instance, prevTarget)) {
                    if (prevTarget !== nextTarget) {
                        instance.dispatchUIEvent(prevTarget, 'pointerout', init);
                        leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));
                    }
                }
            },
            enter: ()=>{
                assertPointerEvents(instance, nextTarget);
                if (prevTarget !== nextTarget) {
                    instance.dispatchUIEvent(nextTarget, 'pointerover', init);
                    enter.forEach((el)=>instance.dispatchUIEvent(el, 'pointerenter', init));
                }
            },
            move: ()=>{
                instance.dispatchUIEvent(nextTarget, 'pointermove', init);
            }
        };
    }
    down(instance, button = 0) {
        if (this.isDown) {
            return;
        }
        const target = this.getTarget(instance);
        assertPointerEvents(instance, target);
        this.isDown = true;
        this.isPrevented = !instance.dispatchUIEvent(target, 'pointerdown', this.getEventInit(button));
    }
    up(instance, button = 0) {
        if (!this.isDown) {
            return;
        }
        const target = this.getTarget(instance);
        assertPointerEvents(instance, target);
        this.isPrevented = false;
        this.isDown = false;
        instance.dispatchUIEvent(target, 'pointerup', this.getEventInit(button));
    }
    release(instance) {
        const target = this.getTarget(instance);
        const [leave] = getTreeDiff(target, null);
        const init = this.getEventInit();
        // Currently there is no PointerEventsCheckLevel that would
        // make this check not use the *asserted* cached value from `up`.
        /* istanbul ignore else */ if (hasPointerEvents(instance, target)) {
            instance.dispatchUIEvent(target, 'pointerout', init);
            leave.forEach((el)=>instance.dispatchUIEvent(el, 'pointerleave', init));
        }
        this.isCancelled = true;
    }
    getTarget(instance) {
        var _this_position_target;
        return (_this_position_target = this.position.target) !== null && _this_position_target !== undefined ? _this_position_target : instance.config.document.body;
    }
    getEventInit(/**
     * The `button` that caused the event.
     *
     * This should be `-1` if the event is not caused by a button or touch/pen contact,
     * e.g. a moving pointer.
     */ button) {
        return {
            ...this.position.coords,
            pointerId: this.pointerId,
            pointerType: this.pointerType,
            isPrimary: this.isPrimary,
            button: getMouseEventButton(button),
            buttons: this.buttons.getButtons()
        };
    }
    constructor({ pointerId, pointerType, isPrimary }, buttons){
        _define_property(this, "pointerId", undefined);
        _define_property(this, "pointerType", undefined);
        _define_property(this, "isPrimary", undefined);
        _define_property(this, "buttons", undefined);
        _define_property(this, "isMultitouch", false);
        _define_property(this, "isCancelled", false);
        _define_property(this, "isDown", false);
        _define_property(this, "isPrevented", false);
        _define_property(this, "position", {});
        this.pointerId = pointerId;
        this.pointerType = pointerType;
        this.isPrimary = isPrimary;
        this.isMultitouch = !isPrimary;
        this.buttons = buttons;
    }
}

export { Pointer };


---

File name: node_modules\@testing-library\user-event\dist\esm\system\pointer\shared.js

Code:
function isDifferentPointerPosition(positionA, positionB) {
    var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_coords2, _positionB_coords2, _positionA_coords3, _positionB_coords3, _positionA_coords4, _positionB_coords4, _positionA_coords5, _positionB_coords5, _positionA_coords6, _positionB_coords6, _positionA_coords7, _positionB_coords7, _positionA_coords8, _positionB_coords8, _positionA_coords9, _positionB_coords9, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
    return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === undefined ? undefined : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === undefined ? undefined : _positionB_coords.x) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === undefined ? undefined : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === undefined ? undefined : _positionB_coords1.y) || ((_positionA_coords2 = positionA.coords) === null || _positionA_coords2 === undefined ? undefined : _positionA_coords2.clientX) !== ((_positionB_coords2 = positionB.coords) === null || _positionB_coords2 === undefined ? undefined : _positionB_coords2.clientX) || ((_positionA_coords3 = positionA.coords) === null || _positionA_coords3 === undefined ? undefined : _positionA_coords3.clientY) !== ((_positionB_coords3 = positionB.coords) === null || _positionB_coords3 === undefined ? undefined : _positionB_coords3.clientY) || ((_positionA_coords4 = positionA.coords) === null || _positionA_coords4 === undefined ? undefined : _positionA_coords4.offsetX) !== ((_positionB_coords4 = positionB.coords) === null || _positionB_coords4 === undefined ? undefined : _positionB_coords4.offsetX) || ((_positionA_coords5 = positionA.coords) === null || _positionA_coords5 === undefined ? undefined : _positionA_coords5.offsetY) !== ((_positionB_coords5 = positionB.coords) === null || _positionB_coords5 === undefined ? undefined : _positionB_coords5.offsetY) || ((_positionA_coords6 = positionA.coords) === null || _positionA_coords6 === undefined ? undefined : _positionA_coords6.pageX) !== ((_positionB_coords6 = positionB.coords) === null || _positionB_coords6 === undefined ? undefined : _positionB_coords6.pageX) || ((_positionA_coords7 = positionA.coords) === null || _positionA_coords7 === undefined ? undefined : _positionA_coords7.pageY) !== ((_positionB_coords7 = positionB.coords) === null || _positionB_coords7 === undefined ? undefined : _positionB_coords7.pageY) || ((_positionA_coords8 = positionA.coords) === null || _positionA_coords8 === undefined ? undefined : _positionA_coords8.screenX) !== ((_positionB_coords8 = positionB.coords) === null || _positionB_coords8 === undefined ? undefined : _positionB_coords8.screenX) || ((_positionA_coords9 = positionA.coords) === null || _positionA_coords9 === undefined ? undefined : _positionA_coords9.screenY) !== ((_positionB_coords9 = positionB.coords) === null || _positionB_coords9 === undefined ? undefined : _positionB_coords9.screenY) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === undefined ? undefined : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === undefined ? undefined : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === undefined ? undefined : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === undefined ? undefined : _positionB_caret1.offset);
}

export { isDifferentPointerPosition };


---

File name: node_modules\@testing-library\user-event\dist\esm\utility\clear.js

Code:
import '../event/behavior/click.js';
import '../event/behavior/cut.js';
import '../event/behavior/keydown.js';
import '../event/behavior/keypress.js';
import '../event/behavior/keyup.js';
import '../event/behavior/paste.js';
import '@testing-library/dom';
import '../utils/dataTransfer/Clipboard.js';
import { isEditable } from '../utils/edit/isEditable.js';
import { isDisabled } from '../utils/misc/isDisabled.js';
import { focusElement } from '../event/focus.js';
import { input } from '../event/input.js';
import { selectAll, isAllSelected } from '../event/selection/selectAll.js';

async function clear(element) {
    if (!isEditable(element) || isDisabled(element)) {
        throw new Error('clear()` is only supported on editable elements.');
    }
    focusElement(element);
    if (element.ownerDocument.activeElement !== element) {
        throw new Error('The element to be cleared could not be focused.');
    }
    selectAll(element);
    if (!isAllSelected(element)) {
        throw new Error('The element content to be cleared could not be selected.');
    }
    input(this, element, '', 'deleteContentBackward');
}

export { clear };


---

File name: node_modules\@testing-library\user-event\dist\esm\utility\index.js

Code:
export { clear } from './clear.js';
export { deselectOptions, selectOptions } from './selectOptions.js';
export { type } from './type.js';
export { upload } from './upload.js';


---

File name: node_modules\@testing-library\user-event\dist\esm\utility\selectOptions.js

Code:
import { getConfig } from '@testing-library/dom';
import { isElementType } from '../utils/misc/isElementType.js';
import '../utils/dataTransfer/Clipboard.js';
import { isDisabled } from '../utils/misc/isDisabled.js';
import { wait } from '../utils/misc/wait.js';
import { hasPointerEvents } from '../utils/pointer/cssPointerEvents.js';
import '../event/behavior/click.js';
import '../event/behavior/cut.js';
import '../event/behavior/keydown.js';
import '../event/behavior/keypress.js';
import '../event/behavior/keyup.js';
import '../event/behavior/paste.js';
import { focusElement } from '../event/focus.js';

async function selectOptions(select, values) {
    return selectOptionsBase.call(this, true, select, values);
}
async function deselectOptions(select, values) {
    return selectOptionsBase.call(this, false, select, values);
}
async function selectOptionsBase(newValue, select, values) {
    if (!newValue && !select.multiple) {
        throw getConfig().getElementError(`Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.`, select);
    }
    const valArray = Array.isArray(values) ? values : [
        values
    ];
    const allOptions = Array.from(select.querySelectorAll('option, [role="option"]'));
    const selectedOptions = valArray.map((val)=>{
        if (typeof val !== 'string' && allOptions.includes(val)) {
            return val;
        } else {
            const matchingOption = allOptions.find((o)=>o.value === val || o.innerHTML === val);
            if (matchingOption) {
                return matchingOption;
            } else {
                throw getConfig().getElementError(`Value "${String(val)}" not found in options`, select);
            }
        }
    }).filter((option)=>!isDisabled(option));
    if (isDisabled(select) || !selectedOptions.length) return;
    const selectOption = (option)=>{
        option.selected = newValue;
        this.dispatchUIEvent(select, 'input', {
            bubbles: true,
            cancelable: false,
            composed: true
        });
        this.dispatchUIEvent(select, 'change');
    };
    if (isElementType(select, 'select')) {
        if (select.multiple) {
            for (const option of selectedOptions){
                const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
                // events fired for multiple select are weird. Can't use hover...
                if (withPointerEvents) {
                    this.dispatchUIEvent(option, 'pointerover');
                    this.dispatchUIEvent(select, 'pointerenter');
                    this.dispatchUIEvent(option, 'mouseover');
                    this.dispatchUIEvent(select, 'mouseenter');
                    this.dispatchUIEvent(option, 'pointermove');
                    this.dispatchUIEvent(option, 'mousemove');
                    this.dispatchUIEvent(option, 'pointerdown');
                    this.dispatchUIEvent(option, 'mousedown');
                }
                focusElement(select);
                if (withPointerEvents) {
                    this.dispatchUIEvent(option, 'pointerup');
                    this.dispatchUIEvent(option, 'mouseup');
                }
                selectOption(option);
                if (withPointerEvents) {
                    this.dispatchUIEvent(option, 'click');
                }
                await wait(this.config);
            }
        } else if (selectedOptions.length === 1) {
            const withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
            // the click to open the select options
            if (withPointerEvents) {
                await this.click(select);
            } else {
                focusElement(select);
            }
            selectOption(selectedOptions[0]);
            if (withPointerEvents) {
                // the browser triggers another click event on the select for the click on the option
                // this second click has no 'down' phase
                this.dispatchUIEvent(select, 'pointerover');
                this.dispatchUIEvent(select, 'pointerenter');
                this.dispatchUIEvent(select, 'mouseover');
                this.dispatchUIEvent(select, 'mouseenter');
                this.dispatchUIEvent(select, 'pointerup');
                this.dispatchUIEvent(select, 'mouseup');
                this.dispatchUIEvent(select, 'click');
            }
            await wait(this.config);
        } else {
            throw getConfig().getElementError(`Cannot select multiple options on a non-multiple select`, select);
        }
    } else if (select.getAttribute('role') === 'listbox') {
        for (const option of selectedOptions){
            await this.click(option);
            await this.unhover(option);
        }
    } else {
        throw getConfig().getElementError(`Cannot select options on elements that are neither select nor listbox elements`, select);
    }
}

export { deselectOptions, selectOptions };


---

File name: node_modules\@testing-library\user-event\dist\esm\utility\type.js

Code:
import { releaseAllKeys } from '../keyboard/index.js';
import '../utils/dataTransfer/Clipboard.js';
import { setSelectionRange } from '../event/selection/setSelectionRange.js';

async function type(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
    // TODO: properly type guard
    // we use this workaround for now to prevent changing behavior
    if (element.disabled) return;
    if (!skipClick) {
        await this.click(element);
    }
    if (initialSelectionStart !== undefined) {
        setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== undefined ? initialSelectionEnd : initialSelectionStart);
    }
    await this.keyboard(text);
    if (!skipAutoClose) {
        await releaseAllKeys(this);
    }
}

export { type };


---

File name: node_modules\@testing-library\user-event\dist\esm\utility\upload.js

Code:
import { isElementType } from '../utils/misc/isElementType.js';
import { createFileList } from '../utils/dataTransfer/FileList.js';
import '../utils/dataTransfer/Clipboard.js';
import { setFiles } from '../utils/edit/setFiles.js';
import { isDisabled } from '../utils/misc/isDisabled.js';
import { getWindow } from '../utils/misc/getWindow.js';

async function upload(element, fileOrFiles) {
    const input = isElementType(element, 'label') ? element.control : element;
    if (!input || !isElementType(input, 'input', {
        type: 'file'
    })) {
        throw new TypeError(`The ${input === element ? 'given' : 'associated'} ${input === null || input === undefined ? undefined : input.tagName} element does not accept file uploads`);
    }
    if (isDisabled(element)) return;
    const files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
        fileOrFiles
    ]).filter((file)=>!this.config.applyAccept || isAcceptableFile(file, input.accept)).slice(0, input.multiple ? undefined : 1);
    const fileDialog = ()=>{
        var _input_files;
        // do not fire an input event if the file selection does not change
        if (files.length === ((_input_files = input.files) === null || _input_files === undefined ? undefined : _input_files.length) && files.every((f, i)=>{
            var _input_files;
            return f === ((_input_files = input.files) === null || _input_files === undefined ? undefined : _input_files.item(i));
        })) {
            return;
        }
        setFiles(input, createFileList(getWindow(element), files));
        this.dispatchUIEvent(input, 'input');
        this.dispatchUIEvent(input, 'change');
    };
    input.addEventListener('fileDialog', fileDialog);
    await this.click(element);
    input.removeEventListener('fileDialog', fileDialog);
}
// When matching files, browsers ignore case and consider jpeg/jpg interchangeable.
function normalize(nameOrType) {
    return nameOrType.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
}
function isAcceptableFile(file, accept) {
    if (!accept) {
        return true;
    }
    const wildcards = [
        'audio/*',
        'image/*',
        'video/*'
    ];
    return normalize(accept).trim().split(/\s*,\s*/).some((acceptToken)=>{
        // tokens starting with a dot represent a file extension
        if (acceptToken.startsWith('.')) {
            return normalize(file.name).endsWith(acceptToken);
        } else if (wildcards.includes(acceptToken)) {
            return normalize(file.type).startsWith(acceptToken.replace('*', ''));
        }
        return normalize(file.type) === acceptToken;
    });
}

export { upload };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\click\isClickableInput.js

Code:
import { isElementType } from '../misc/isElementType.js';

var clickableInputTypes = /*#__PURE__*/ function(clickableInputTypes) {
    clickableInputTypes["button"] = "button";
    clickableInputTypes["color"] = "color";
    clickableInputTypes["file"] = "file";
    clickableInputTypes["image"] = "image";
    clickableInputTypes["reset"] = "reset";
    clickableInputTypes["submit"] = "submit";
    clickableInputTypes["checkbox"] = "checkbox";
    clickableInputTypes["radio"] = "radio";
    return clickableInputTypes;
}(clickableInputTypes || {});
function isClickableInput(element) {
    return isElementType(element, 'button') || isElementType(element, 'input') && element.type in clickableInputTypes;
}

export { isClickableInput };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\dataTransfer\Blob.js

Code:
// jsdom does not implement Blob.text()
function readBlobText(blob, FileReader) {
    return new Promise((res, rej)=>{
        const fr = new FileReader();
        fr.onerror = rej;
        fr.onabort = rej;
        fr.onload = ()=>{
            res(String(fr.result));
        };
        fr.readAsText(blob);
    });
}

export { readBlobText };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\dataTransfer\Clipboard.js

Code:
import { getWindow } from '../misc/getWindow.js';
import { readBlobText } from './Blob.js';
import { createDataTransfer, getBlobFromDataTransferItem } from './DataTransfer.js';

// Clipboard is not available in jsdom
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData
// lib.dom.d.ts lists only Promise<Blob|string>
// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax
function createClipboardItem(window, ...blobs) {
    const dataMap = Object.fromEntries(blobs.map((b)=>[
            typeof b === 'string' ? 'text/plain' : b.type,
            Promise.resolve(b)
        ]));
    // use real ClipboardItem if available
    /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {
        return new window.ClipboardItem(dataMap);
    }
    return new class ClipboardItem {
        get types() {
            return Array.from(Object.keys(this.data));
        }
        async getType(type) {
            const value = await this.data[type];
            if (!value) {
                throw new Error(`${type} is not one of the available MIME types on this item.`);
            }
            return value instanceof window.Blob ? value : new window.Blob([
                value
            ], {
                type
            });
        }
        constructor(d){
            _define_property(this, "data", undefined);
            this.data = d;
        }
    }(dataMap);
}
const ClipboardStubControl = Symbol('Manage ClipboardSub');
function createClipboardStub(window, control) {
    return Object.assign(new class Clipboard extends window.EventTarget {
        async read() {
            return Array.from(this.items);
        }
        async readText() {
            let text = '';
            for (const item of this.items){
                const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));
                if (type) {
                    text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));
                }
            }
            return text;
        }
        async write(data) {
            this.items = data;
        }
        async writeText(text) {
            this.items = [
                createClipboardItem(window, text)
            ];
        }
        constructor(...args){
            super(...args), _define_property(this, "items", []);
        }
    }(), {
        [ClipboardStubControl]: control
    });
}
function isClipboardStub(clipboard) {
    return !!(clipboard === null || clipboard === undefined ? undefined : clipboard[ClipboardStubControl]);
}
function attachClipboardStubToView(window) {
    if (isClipboardStub(window.navigator.clipboard)) {
        return window.navigator.clipboard[ClipboardStubControl];
    }
    const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');
    let stub;
    const control = {
        resetClipboardStub: ()=>{
            stub = createClipboardStub(window, control);
        },
        detachClipboardStub: ()=>{
            /* istanbul ignore if */ if (realClipboard) {
                Object.defineProperty(window.navigator, 'clipboard', realClipboard);
            } else {
                Object.defineProperty(window.navigator, 'clipboard', {
                    value: undefined,
                    configurable: true
                });
            }
        }
    };
    stub = createClipboardStub(window, control);
    Object.defineProperty(window.navigator, 'clipboard', {
        get: ()=>stub,
        configurable: true
    });
    return stub[ClipboardStubControl];
}
function resetClipboardStubOnView(window) {
    if (isClipboardStub(window.navigator.clipboard)) {
        window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
    }
}
function detachClipboardStubFromView(window) {
    if (isClipboardStub(window.navigator.clipboard)) {
        window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
    }
}
async function readDataTransferFromClipboard(document) {
    const window = document.defaultView;
    const clipboard = window === null || window === undefined ? undefined : window.navigator.clipboard;
    const items = clipboard && await clipboard.read();
    if (!items) {
        throw new Error('The Clipboard API is unavailable.');
    }
    const dt = createDataTransfer(window);
    for (const item of items){
        for (const type of item.types){
            dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));
        }
    }
    return dt;
}
async function writeDataTransferToClipboard(document, clipboardData) {
    const window = getWindow(document);
    const clipboard = window.navigator.clipboard;
    const items = [];
    for(let i = 0; i < clipboardData.items.length; i++){
        const dtItem = clipboardData.items[i];
        const blob = await getBlobFromDataTransferItem(window, dtItem);
        items.push(createClipboardItem(window, blob));
    }
    const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */ ()=>false);
    if (!written) {
        throw new Error('The Clipboard API is unavailable.');
    }
}
const g = globalThis;
/* istanbul ignore else */ if (typeof g.afterEach === 'function') {
    g.afterEach(()=>resetClipboardStubOnView(globalThis.window));
}
/* istanbul ignore else */ if (typeof g.afterAll === 'function') {
    g.afterAll(()=>detachClipboardStubFromView(globalThis.window));
}

export { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\dataTransfer\DataTransfer.js

Code:
import { createFileList } from './FileList.js';

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// DataTransfer is not implemented in jsdom.
// DataTransfer with FileList is being created by the browser on certain events.
class DataTransferItemStub {
    getAsFile() {
        return this.file;
    }
    getAsString(callback) {
        if (typeof this.data === 'string') {
            callback(this.data);
        }
    }
    /* istanbul ignore next */ webkitGetAsEntry() {
        throw new Error('not implemented');
    }
    constructor(dataOrFile, type){
        _define_property(this, "kind", undefined);
        _define_property(this, "type", undefined);
        _define_property(this, "file", null);
        _define_property(this, "data", undefined);
        if (typeof dataOrFile === 'string') {
            this.kind = 'string';
            this.type = String(type);
            this.data = dataOrFile;
        } else {
            this.kind = 'file';
            this.type = dataOrFile.type;
            this.file = dataOrFile;
        }
    }
}
class DataTransferItemListStub extends Array {
    add(...args) {
        const item = new DataTransferItemStub(args[0], args[1]);
        this.push(item);
        return item;
    }
    clear() {
        this.splice(0, this.length);
    }
    remove(index) {
        this.splice(index, 1);
    }
}
function getTypeMatcher(type, exact) {
    const [group, sub] = type.split('/');
    const isGroup = !sub || sub === '*';
    return (item)=>{
        return exact ? item.type === (isGroup ? group : type) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
    };
}
function createDataTransferStub(window) {
    return new class DataTransferStub {
        getData(format) {
            var _this_items_find;
            const match = (_this_items_find = this.items.find(getTypeMatcher(format, true))) !== null && _this_items_find !== undefined ? _this_items_find : this.items.find(getTypeMatcher(format, false));
            let text = '';
            match === null || match === undefined ? undefined : match.getAsString((t)=>{
                text = t;
            });
            return text;
        }
        setData(format, data) {
            const matchIndex = this.items.findIndex(getTypeMatcher(format, true));
            const item = new DataTransferItemStub(data, format);
            if (matchIndex >= 0) {
                this.items.splice(matchIndex, 1, item);
            } else {
                this.items.push(item);
            }
        }
        clearData(format) {
            if (format) {
                const matchIndex = this.items.findIndex(getTypeMatcher(format, true));
                if (matchIndex >= 0) {
                    this.items.remove(matchIndex);
                }
            } else {
                this.items.clear();
            }
        }
        get types() {
            const t = [];
            if (this.files.length) {
                t.push('Files');
            }
            this.items.forEach((i)=>t.push(i.type));
            Object.freeze(t);
            return t;
        }
        /* istanbul ignore next */ setDragImage() {}
        constructor(){
            _define_property(this, "dropEffect", 'none');
            _define_property(this, "effectAllowed", 'uninitialized');
            _define_property(this, "items", new DataTransferItemListStub());
            _define_property(this, "files", createFileList(window, []));
        }
    }();
}
function createDataTransfer(window, files = []) {
    // Use real DataTransfer if available
    const dt = typeof window.DataTransfer === 'undefined' ? createDataTransferStub(window) : /* istanbul ignore next */ new window.DataTransfer();
    Object.defineProperty(dt, 'files', {
        get: ()=>createFileList(window, files)
    });
    return dt;
}
async function getBlobFromDataTransferItem(window, item) {
    if (item.kind === 'file') {
        return item.getAsFile();
    }
    return new window.Blob([
        await new Promise((r)=>item.getAsString(r))
    ], {
        type: item.type
    });
}

export { createDataTransfer, getBlobFromDataTransferItem };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\dataTransfer\FileList.js

Code:
// FileList can not be created per constructor.
function createFileList(window, files) {
    const list = {
        ...files,
        length: files.length,
        item: (index)=>list[index],
        [Symbol.iterator]: function* nextFile() {
            for(let i = 0; i < list.length; i++){
                yield list[i];
            }
        }
    };
    list.constructor = window.FileList;
    // guard for environments without FileList
    /* istanbul ignore else */ if (window.FileList) {
        Object.setPrototypeOf(list, window.FileList.prototype);
    }
    Object.freeze(list);
    return list;
}

export { createFileList };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\edit\isContentEditable.js

Code:
//jsdom is not supporting isContentEditable
function isContentEditable(element) {
    return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');
}
/**
 * If a node is a contenteditable or inside one, return that element.
 */ function getContentEditable(node) {
    const element = getElement(node);
    return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
}
function getElement(node) {
    return node.nodeType === 1 ? node : node.parentElement;
}

export { getContentEditable, isContentEditable };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\edit\isEditable.js

Code:
import { isElementType } from '../misc/isElementType.js';
import { isContentEditable } from './isContentEditable.js';

function isEditable(element) {
    return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
}
var editableInputTypes = /*#__PURE__*/ function(editableInputTypes) {
    editableInputTypes["text"] = "text";
    editableInputTypes["date"] = "date";
    editableInputTypes["datetime-local"] = "datetime-local";
    editableInputTypes["email"] = "email";
    editableInputTypes["month"] = "month";
    editableInputTypes["number"] = "number";
    editableInputTypes["password"] = "password";
    editableInputTypes["search"] = "search";
    editableInputTypes["tel"] = "tel";
    editableInputTypes["time"] = "time";
    editableInputTypes["url"] = "url";
    editableInputTypes["week"] = "week";
    return editableInputTypes;
}(editableInputTypes || {});
function isEditableInputOrTextArea(element) {
    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in editableInputTypes;
}

export { isEditable, isEditableInputOrTextArea };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\edit\maxLength.js

Code:
import { isElementType } from '../misc/isElementType.js';

var maxLengthSupportedTypes = /*#__PURE__*/ function(maxLengthSupportedTypes) {
    maxLengthSupportedTypes["email"] = "email";
    maxLengthSupportedTypes["password"] = "password";
    maxLengthSupportedTypes["search"] = "search";
    maxLengthSupportedTypes["telephone"] = "telephone";
    maxLengthSupportedTypes["text"] = "text";
    maxLengthSupportedTypes["url"] = "url";
    return maxLengthSupportedTypes;
}(maxLengthSupportedTypes || {});
// can't use .maxLength property because of a jsdom bug:
// https://github.com/jsdom/jsdom/issues/2927
function getMaxLength(element) {
    var _element_getAttribute;
    const attr = (_element_getAttribute = element.getAttribute('maxlength')) !== null && _element_getAttribute !== undefined ? _element_getAttribute : '';
    return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : undefined;
}
function supportsMaxLength(element) {
    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in maxLengthSupportedTypes;
}

export { getMaxLength, supportsMaxLength };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\edit\setFiles.js

Code:
// It is not possible to create a real FileList programmatically.
// Therefore assigning `files` property with a programmatically created FileList results in an error.
// Just assigning the property (as per fireEvent) breaks the interweaving with the `value` property.
const fakeFiles = Symbol('files and value properties are mocked');
function restoreProperty(obj, prop, descriptor) {
    if (descriptor) {
        Object.defineProperty(obj, prop, descriptor);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete obj[prop];
    }
}
function setFiles(el, files) {
    var _el_fakeFiles;
    (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === undefined ? undefined : _el_fakeFiles.restore();
    const typeDescr = Object.getOwnPropertyDescriptor(el, 'type');
    const valueDescr = Object.getOwnPropertyDescriptor(el, 'value');
    const filesDescr = Object.getOwnPropertyDescriptor(el, 'files');
    function restore() {
        restoreProperty(el, 'type', typeDescr);
        restoreProperty(el, 'value', valueDescr);
        restoreProperty(el, 'files', filesDescr);
    }
    el[fakeFiles] = {
        restore
    };
    Object.defineProperties(el, {
        files: {
            configurable: true,
            get: ()=>files
        },
        value: {
            configurable: true,
            get: ()=>files.length ? `C:\\fakepath\\${files[0].name}` : '',
            set (v) {
                if (v === '') {
                    restore();
                } else {
                    var _valueDescr_set;
                    valueDescr === null || valueDescr === undefined ? undefined : (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === undefined ? undefined : _valueDescr_set.call(el, v);
                }
            }
        },
        type: {
            configurable: true,
            get: ()=>'file',
            set (v) {
                if (v !== 'file') {
                    restore();
                    el.type = v;
                }
            }
        }
    });
}

export { setFiles };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\edit\timeValue.js

Code:
const parseInt = globalThis.parseInt;
function buildTimeValue(value) {
    const onlyDigitsValue = value.replace(/\D/g, '');
    if (onlyDigitsValue.length < 2) {
        return value;
    }
    const firstDigit = parseInt(onlyDigitsValue[0], 10);
    const secondDigit = parseInt(onlyDigitsValue[1], 10);
    if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
        let index;
        if (firstDigit >= 3) {
            index = 1;
        } else {
            index = 2;
        }
        return build(onlyDigitsValue, index);
    }
    if (value.length === 2) {
        return value;
    }
    return build(onlyDigitsValue, 2);
}
function build(onlyDigitsValue, index) {
    const hours = onlyDigitsValue.slice(0, index);
    const validHours = Math.min(parseInt(hours, 10), 23);
    const minuteCharacters = onlyDigitsValue.slice(index);
    const parsedMinutes = parseInt(minuteCharacters, 10);
    const validMinutes = Math.min(parsedMinutes, 59);
    return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;
}
function isValidDateOrTimeValue(element, value) {
    const clone = element.cloneNode();
    clone.value = value;
    return clone.value === value;
}

export { buildTimeValue, isValidDateOrTimeValue };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\cursor.js

Code:
import { isContentEditable } from '../edit/isContentEditable.js';
import { isElementType } from '../misc/isElementType.js';

function getNextCursorPosition(node, offset, direction, inputType) {
    // The behavior at text node zero offset is inconsistent.
    // When walking backwards:
    // Firefox always moves to zero offset and jumps over last offset.
    // Chrome jumps over zero offset per default but over last offset when Shift is pressed.
    // The cursor always moves to zero offset if the focus area (contenteditable or body) ends there.
    // When walking forward both ignore zero offset.
    // When walking over input elements the cursor moves before or after that element.
    // When walking over line breaks the cursor moves inside any following text node.
    if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) {
        return {
            node,
            offset: offset + direction
        };
    }
    const nextNode = getNextCharacterContentNode(node, offset, direction);
    if (nextNode) {
        if (isTextNode(nextNode)) {
            return {
                node: nextNode,
                offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
            };
        } else if (isElementType(nextNode, 'br')) {
            const nextPlusOne = getNextCharacterContentNode(nextNode, undefined, direction);
            if (!nextPlusOne) {
                // The behavior when there is no possible cursor position beyond the line break is inconsistent.
                // In Chrome outside of contenteditable moving before a leading line break is possible.
                // A leading line break can still be removed per deleteContentBackward.
                // A trailing line break on the other hand is not removed by deleteContentForward.
                if (direction < 0 && inputType === 'deleteContentBackward') {
                    return {
                        node: nextNode.parentNode,
                        offset: getOffset(nextNode)
                    };
                }
                return undefined;
            } else if (isTextNode(nextPlusOne)) {
                return {
                    node: nextPlusOne,
                    offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
                };
            } else if (direction < 0 && isElementType(nextPlusOne, 'br')) {
                return {
                    node: nextNode.parentNode,
                    offset: getOffset(nextNode)
                };
            } else {
                return {
                    node: nextPlusOne.parentNode,
                    offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
                };
            }
        } else {
            return {
                node: nextNode.parentNode,
                offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
            };
        }
    }
}
function getNextCharacterContentNode(node, offset, direction) {
    const nextOffset = Number(offset) + (direction < 0 ? -1 : 0);
    if (offset !== undefined && isElement(node) && nextOffset >= 0 && nextOffset < node.children.length) {
        node = node.children[nextOffset];
    }
    return walkNodes(node, direction === 1 ? 'next' : 'previous', isTreatedAsCharacterContent);
}
function isTreatedAsCharacterContent(node) {
    if (isTextNode(node)) {
        return true;
    }
    if (isElement(node)) {
        if (isElementType(node, [
            'input',
            'textarea'
        ])) {
            return node.type !== 'hidden';
        } else if (isElementType(node, 'br')) {
            return true;
        }
    }
    return false;
}
function getOffset(node) {
    let i = 0;
    while(node.previousSibling){
        i++;
        node = node.previousSibling;
    }
    return i;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isTextNode(node) {
    return node.nodeType === 3;
}
function walkNodes(node, direction, callback) {
    for(;;){
        var _node_ownerDocument;
        const sibling = node[`${direction}Sibling`];
        if (sibling) {
            node = getDescendant(sibling, direction === 'next' ? 'first' : 'last');
            if (callback(node)) {
                return node;
            }
        } else if (node.parentNode && (!isElement(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === undefined ? undefined : _node_ownerDocument.body))) {
            node = node.parentNode;
        } else {
            break;
        }
    }
}
function getDescendant(node, direction) {
    while(node.hasChildNodes()){
        node = node[`${direction}Child`];
    }
    return node;
}

export { getNextCursorPosition };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\getActiveElement.js

Code:
import { isDisabled } from '../misc/isDisabled.js';

function getActiveElement(document) {
    const activeElement = document.activeElement;
    if (activeElement === null || activeElement === undefined ? undefined : activeElement.shadowRoot) {
        return getActiveElement(activeElement.shadowRoot);
    } else {
        // Browser does not yield disabled elements as document.activeElement - jsdom does
        if (isDisabled(activeElement)) {
            return document.ownerDocument ? /* istanbul ignore next */ document.ownerDocument.body : document.body;
        }
        return activeElement;
    }
}
function getActiveElementOrBody(document) {
    var _getActiveElement;
    return (_getActiveElement = getActiveElement(document)) !== null && _getActiveElement !== undefined ? _getActiveElement : /* istanbul ignore next */ document.body;
}

export { getActiveElement, getActiveElementOrBody };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\getTabDestination.js

Code:
import { isDisabled } from '../misc/isDisabled.js';
import { isElementType } from '../misc/isElementType.js';
import { isVisible } from '../misc/isVisible.js';
import { FOCUSABLE_SELECTOR } from './selector.js';

function getTabDestination(activeElement, shift) {
    const document = activeElement.ownerDocument;
    const focusableElements = document.querySelectorAll(FOCUSABLE_SELECTOR);
    const enabledElements = Array.from(focusableElements).filter((el)=>el === activeElement || !(Number(el.getAttribute('tabindex')) < 0 || isDisabled(el)));
    // tabindex has no effect if the active element has negative tabindex
    if (Number(activeElement.getAttribute('tabindex')) >= 0) {
        enabledElements.sort((a, b)=>{
            const i = Number(a.getAttribute('tabindex'));
            const j = Number(b.getAttribute('tabindex'));
            if (i === j) {
                return 0;
            } else if (i === 0) {
                return 1;
            } else if (j === 0) {
                return -1;
            }
            return i - j;
        });
    }
    const checkedRadio = {};
    let prunedElements = [
        document.body
    ];
    const activeRadioGroup = isElementType(activeElement, 'input', {
        type: 'radio'
    }) ? activeElement.name : undefined;
    enabledElements.forEach((currentElement)=>{
        const el = currentElement;
        // For radio groups keep only the active radio
        // If there is no active radio, keep only the checked radio
        // If there is no checked radio, treat like everything else
        if (isElementType(el, 'input', {
            type: 'radio'
        }) && el.name) {
            // If the active element is part of the group, add only that
            if (el === activeElement) {
                prunedElements.push(el);
                return;
            } else if (el.name === activeRadioGroup) {
                return;
            }
            // If we stumble upon a checked radio, remove the others
            if (el.checked) {
                prunedElements = prunedElements.filter((e)=>!isElementType(e, 'input', {
                        type: 'radio',
                        name: el.name
                    }));
                prunedElements.push(el);
                checkedRadio[el.name] = el;
                return;
            }
            // If we already found the checked one, skip
            if (typeof checkedRadio[el.name] !== 'undefined') {
                return;
            }
        }
        prunedElements.push(el);
    });
    for(let index = prunedElements.findIndex((el)=>el === activeElement);;){
        index += shift ? -1 : 1;
        // loop at overflow
        if (index === prunedElements.length) {
            index = 0;
        } else if (index === -1) {
            index = prunedElements.length - 1;
        }
        if (prunedElements[index] === activeElement || prunedElements[index] === document.body || isVisible(prunedElements[index])) {
            return prunedElements[index];
        }
    }
}

export { getTabDestination };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\isFocusable.js

Code:
import { FOCUSABLE_SELECTOR } from './selector.js';

function isFocusable(element) {
    return element.matches(FOCUSABLE_SELECTOR);
}

export { isFocusable };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\selection.js

Code:
import { isClickableInput } from '../click/isClickableInput.js';
import { isEditableInputOrTextArea } from '../edit/isEditable.js';

/**
 * Determine if the element has its own selection implementation
 * and does not interact with the Document Selection API.
 */ function hasOwnSelection(node) {
    return isElement(node) && isEditableInputOrTextArea(node);
}
function hasNoSelection(node) {
    return isElement(node) && isClickableInput(node);
}
function isElement(node) {
    return node.nodeType === 1;
}

export { hasNoSelection, hasOwnSelection };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\focus\selector.js

Code:
const FOCUSABLE_SELECTOR = [
    'input:not([type=hidden]):not([disabled])',
    'button:not([disabled])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    '[contenteditable=""]',
    '[contenteditable="true"]',
    'a[href]',
    '[tabindex]:not([disabled])'
].join(', ');

export { FOCUSABLE_SELECTOR };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\index.js

Code:
export { isClickableInput } from './click/isClickableInput.js';
export { readBlobText } from './dataTransfer/Blob.js';
export { createDataTransfer, getBlobFromDataTransferItem } from './dataTransfer/DataTransfer.js';
export { createFileList } from './dataTransfer/FileList.js';
export { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard } from './dataTransfer/Clipboard.js';
export { buildTimeValue, isValidDateOrTimeValue } from './edit/timeValue.js';
export { getContentEditable, isContentEditable } from './edit/isContentEditable.js';
export { isEditable, isEditableInputOrTextArea } from './edit/isEditable.js';
export { getMaxLength, supportsMaxLength } from './edit/maxLength.js';
export { setFiles } from './edit/setFiles.js';
export { getNextCursorPosition } from './focus/cursor.js';
export { getActiveElement, getActiveElementOrBody } from './focus/getActiveElement.js';
export { getTabDestination } from './focus/getTabDestination.js';
export { isFocusable } from './focus/isFocusable.js';
export { hasNoSelection, hasOwnSelection } from './focus/selection.js';
export { FOCUSABLE_SELECTOR } from './focus/selector.js';
export { readNextDescriptor } from './keyDef/readNextDescriptor.js';
export { cloneEvent } from './misc/cloneEvent.js';
export { findClosest } from './misc/findClosest.js';
export { getDocumentFromNode } from './misc/getDocumentFromNode.js';
export { getTreeDiff } from './misc/getTreeDiff.js';
export { getWindow } from './misc/getWindow.js';
export { isDescendantOrSelf } from './misc/isDescendantOrSelf.js';
export { isElementType } from './misc/isElementType.js';
export { isVisible } from './misc/isVisible.js';
export { isDisabled } from './misc/isDisabled.js';
export { ApiLevel, getLevelRef, setLevelRef } from './misc/level.js';
export { wait } from './misc/wait.js';
export { assertPointerEvents, hasPointerEvents } from './pointer/cssPointerEvents.js';


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\keyDef\readNextDescriptor.js

Code:
var bracketDict = /*#__PURE__*/ function(bracketDict) {
    bracketDict["{"] = "}";
    bracketDict["["] = "]";
    return bracketDict;
}(bracketDict || {});
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */ function readNextDescriptor(text, context) {
    let pos = 0;
    const startBracket = text[pos] in bracketDict ? text[pos] : '';
    pos += startBracket.length;
    const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
    const type = isEscapedChar ? '' : startBracket;
    return {
        type,
        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)
    };
}
function readPrintableChar(text, pos, context) {
    const descriptor = text[pos];
    assertDescriptor(descriptor, text, pos, context);
    pos += descriptor.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: false,
        releaseSelf: true,
        repeat: 1
    };
}
function readTag(text, pos, startBracket, context) {
    var _text_slice_match, _text_slice_match1;
    const releasePreviousModifier = text[pos] === '/' ? '/' : '';
    pos += releasePreviousModifier.length;
    const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
    pos += Number(escapedDescriptor);
    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === undefined ? undefined : _text_slice_match[0];
    assertDescriptor(descriptor, text, pos, context);
    pos += descriptor.length;
    var _text_slice_match_;
    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === undefined ? undefined : _text_slice_match1[0]) !== null && _text_slice_match_ !== undefined ? _text_slice_match_ : '';
    pos += repeatModifier.length;
    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
    pos += releaseSelfModifier.length;
    const expectedEndBracket = bracketDict[startBracket];
    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
    if (!endBracket) {
        throw new Error(getErrorMessage([
            !repeatModifier && 'repeat modifier',
            !releaseSelfModifier && 'release modifier',
            `"${expectedEndBracket}"`
        ].filter(Boolean).join(' or '), text[pos], text, context));
    }
    pos += endBracket.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: !!releasePreviousModifier,
        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
    };
}
function assertDescriptor(descriptor, text, pos, context) {
    if (!descriptor) {
        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));
    }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
    if (releaseSelfModifier) {
        return releaseSelfModifier === '/';
    }
    if (repeatModifier) {
        return false;
    }
}
function getErrorMessage(expected, found, text, context) {
    return `Expected ${expected} but found "${found !== null && found !== undefined ? found : ''}" in "${text}"
    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}

export { readNextDescriptor };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\cloneEvent.js

Code:
function cloneEvent(event) {
    return new event.constructor(event.type, event);
}

export { cloneEvent };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\findClosest.js

Code:
function findClosest(element, callback) {
    let el = element;
    do {
        if (callback(el)) {
            return el;
        }
        el = el.parentElement;
    }while (el && el !== element.ownerDocument.body)
    return undefined;
}

export { findClosest };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\getDocumentFromNode.js

Code:
function getDocumentFromNode(el) {
    return isDocument(el) ? el : el.ownerDocument;
}
function isDocument(node) {
    return node.nodeType === 9;
}

export { getDocumentFromNode };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\getTreeDiff.js

Code:
function getTreeDiff(a, b) {
    const treeA = [];
    for(let el = a; el; el = el.parentElement){
        treeA.push(el);
    }
    const treeB = [];
    for(let el = b; el; el = el.parentElement){
        treeB.push(el);
    }
    let i = 0;
    for(;; i++){
        if (i >= treeA.length || i >= treeB.length || treeA[treeA.length - 1 - i] !== treeB[treeB.length - 1 - i]) {
            break;
        }
    }
    return [
        treeA.slice(0, treeA.length - i),
        treeB.slice(0, treeB.length - i),
        treeB.slice(treeB.length - i)
    ];
}

export { getTreeDiff };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\getWindow.js

Code:
function getWindow(node) {
    var _node_ownerDocument;
    if (isDocument(node) && node.defaultView) {
        return node.defaultView;
    } else if ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === undefined ? undefined : _node_ownerDocument.defaultView) {
        return node.ownerDocument.defaultView;
    }
    throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
}
function isDocument(node) {
    return node.nodeType === 9;
}
function describe(val) {
    return typeof val === 'function' ? `function ${val.name}` : val === null ? 'null' : String(val);
}

export { getWindow };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\isDescendantOrSelf.js

Code:
function isDescendantOrSelf(potentialDescendant, potentialAncestor) {
    let el = potentialDescendant;
    do {
        if (el === potentialAncestor) {
            return true;
        }
        el = el.parentElement;
    }while (el)
    return false;
}

export { isDescendantOrSelf };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\isDisabled.js

Code:
import { isElementType } from './isElementType.js';

// This should probably just rely on the :disabled pseudo-class, but JSDOM doesn't implement it properly.
function isDisabled(element) {
    for(let el = element; el; el = el.parentElement){
        if (isElementType(el, [
            'button',
            'input',
            'select',
            'textarea',
            'optgroup',
            'option'
        ])) {
            if (el.hasAttribute('disabled')) {
                return true;
            }
        } else if (isElementType(el, 'fieldset')) {
            var _el_querySelector;
            if (el.hasAttribute('disabled') && !((_el_querySelector = el.querySelector(':scope > legend')) === null || _el_querySelector === undefined ? undefined : _el_querySelector.contains(element))) {
                return true;
            }
        } else if (el.tagName.includes('-')) {
            if (el.constructor.formAssociated && el.hasAttribute('disabled')) {
                return true;
            }
        }
    }
    return false;
}

export { isDisabled };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\isElementType.js

Code:
function isElementType(element, tag, props) {
    if (element.namespaceURI && element.namespaceURI !== 'http://www.w3.org/1999/xhtml') {
        return false;
    }
    tag = Array.isArray(tag) ? tag : [
        tag
    ];
    // tagName is uppercase in HTMLDocument and lowercase in XMLDocument
    if (!tag.includes(element.tagName.toLowerCase())) {
        return false;
    }
    if (props) {
        return Object.entries(props).every(([k, v])=>element[k] === v);
    }
    return true;
}

export { isElementType };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\isVisible.js

Code:
import { getWindow } from './getWindow.js';

function isVisible(element) {
    const window = getWindow(element);
    for(let el = element; el === null || el === undefined ? undefined : el.ownerDocument; el = el.parentElement){
        const { display, visibility } = window.getComputedStyle(el);
        if (display === 'none') {
            return false;
        }
        if (visibility === 'hidden') {
            return false;
        }
    }
    return true;
}

export { isVisible };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\level.js

Code:
var ApiLevel = /*#__PURE__*/ function(ApiLevel) {
    ApiLevel[ApiLevel["Trigger"] = 2] = "Trigger";
    ApiLevel[ApiLevel["Call"] = 1] = "Call";
    return ApiLevel;
}({});
function setLevelRef(instance, level) {
    instance.levelRefs[level] = {};
}
function getLevelRef(instance, level) {
    return instance.levelRefs[level];
}

export { ApiLevel, getLevelRef, setLevelRef };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\misc\wait.js

Code:
function wait(config) {
    const delay = config.delay;
    if (typeof delay !== 'number') {
        return;
    }
    return Promise.all([
        new Promise((resolve)=>globalThis.setTimeout(()=>resolve(), delay)),
        config.advanceTimers(delay)
    ]);
}

export { wait };


---

File name: node_modules\@testing-library\user-event\dist\esm\utils\pointer\cssPointerEvents.js

Code:
import { PointerEventsCheckLevel } from '../../options.js';
import { getWindow } from '../misc/getWindow.js';
import { isElementType } from '../misc/isElementType.js';
import { ApiLevel, getLevelRef } from '../misc/level.js';

function hasPointerEvents(instance, element) {
    var _checkPointerEvents;
    return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === undefined ? undefined : _checkPointerEvents.pointerEvents) !== 'none';
}
function closestPointerEventsDeclaration(element) {
    const window = getWindow(element);
    for(let el = element, tree = []; el === null || el === undefined ? undefined : el.ownerDocument; el = el.parentElement){
        tree.push(el);
        const pointerEvents = window.getComputedStyle(el).pointerEvents;
        if (pointerEvents && ![
            'inherit',
            'unset'
        ].includes(pointerEvents)) {
            return {
                pointerEvents,
                tree
            };
        }
    }
    return undefined;
}
const PointerEventsCheck = Symbol('Last check for pointer-events');
function checkPointerEvents(instance, element) {
    const lastCheck = element[PointerEventsCheck];
    const needsCheck = instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger));
    if (!needsCheck) {
        return lastCheck === null || lastCheck === undefined ? undefined : lastCheck.result;
    }
    const declaration = closestPointerEventsDeclaration(element);
    element[PointerEventsCheck] = {
        [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
        [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
        result: declaration
    };
    return declaration;
}
function assertPointerEvents(instance, element) {
    const declaration = checkPointerEvents(instance, element);
    if ((declaration === null || declaration === undefined ? undefined : declaration.pointerEvents) === 'none') {
        throw new Error([
            `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
            '',
            printTree(declaration.tree)
        ].join('\n'));
    }
}
function printTree(tree) {
    return tree.reverse().map((el, i)=>[
            ''.padEnd(i),
            el.tagName,
            el.id && `#${el.id}`,
            el.hasAttribute('data-testid') && `(testId=${el.getAttribute('data-testid')})`,
            getLabelDescr(el),
            tree.length > 1 && i === 0 && '  <-- This element declared `pointer-events: none`',
            tree.length > 1 && i === tree.length - 1 && '  <-- Asserted pointer events here'
        ].filter(Boolean).join('')).join('\n');
}
function getLabelDescr(element) {
    var _element_labels;
    let label;
    if (element.hasAttribute('aria-label')) {
        label = element.getAttribute('aria-label');
    } else if (element.hasAttribute('aria-labelledby')) {
        var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
        label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute('aria-labelledby'))) === null || _element_ownerDocument_getElementById === undefined ? undefined : (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === undefined ? undefined : _element_ownerDocument_getElementById_textContent.trim();
    } else if (isElementType(element, [
        'button',
        'input',
        'meter',
        'output',
        'progress',
        'select',
        'textarea'
    ]) && ((_element_labels = element.labels) === null || _element_labels === undefined ? undefined : _element_labels.length)) {
        label = Array.from(element.labels).map((el)=>{
            var _el_textContent;
            return (_el_textContent = el.textContent) === null || _el_textContent === undefined ? undefined : _el_textContent.trim();
        }).join('|');
    } else if (isElementType(element, 'button')) {
        var _element_textContent;
        label = (_element_textContent = element.textContent) === null || _element_textContent === undefined ? undefined : _element_textContent.trim();
    }
    label = label === null || label === undefined ? undefined : label.replace(/\n/g, '  ');
    if (Number(label === null || label === undefined ? undefined : label.length) > 30) {
        label = `${label === null || label === undefined ? undefined : label.substring(0, 29)}…`;
    }
    return label ? `(label=${label})` : '';
}
// With the eslint rule and prettier the bitwise operation isn't nice to read
function hasBitFlag(conf, flag) {
    // eslint-disable-next-line no-bitwise
    return (conf & flag) > 0;
}

export { assertPointerEvents, hasPointerEvents };


---

File name: node_modules\@testing-library\user-event\dist\types\clipboard\copy.d.ts

Code:
import { type Instance } from '../setup';
export declare function copy(this: Instance): Promise<DataTransfer | undefined>;


---

File name: node_modules\@testing-library\user-event\dist\types\clipboard\cut.d.ts

Code:
import { type Instance } from '../setup';
export declare function cut(this: Instance): Promise<DataTransfer | undefined>;


---

File name: node_modules\@testing-library\user-event\dist\types\clipboard\index.d.ts

Code:
export * from './copy';
export * from './cut';
export * from './paste';


---

File name: node_modules\@testing-library\user-event\dist\types\clipboard\paste.d.ts

Code:
import { type Instance } from '../setup';
export declare function paste(this: Instance, clipboardData?: DataTransfer | string): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\convenience\click.d.ts

Code:
import { type Instance } from '../setup';
export declare function click(this: Instance, element: Element): Promise<void>;
export declare function dblClick(this: Instance, element: Element): Promise<void>;
export declare function tripleClick(this: Instance, element: Element): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\convenience\hover.d.ts

Code:
import { type Instance } from '../setup';
export declare function hover(this: Instance, element: Element): Promise<void>;
export declare function unhover(this: Instance, element: Element): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\convenience\index.d.ts

Code:
export * from './click';
export * from './hover';
export * from './tab';


---

File name: node_modules\@testing-library\user-event\dist\types\convenience\tab.d.ts

Code:
import { type Instance } from '../setup';
export declare function tab(this: Instance, { shift, }?: {
    shift?: boolean;
}): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\document\copySelection.d.ts

Code:
export declare function copySelection(target: Element): DataTransfer;


---

File name: node_modules\@testing-library\user-event\dist\types\document\getValueOrTextContent.d.ts

Code:
export declare function getValueOrTextContent<T extends Element | null>(element: T): T extends HTMLInputElement | HTMLTextAreaElement ? string : string | null;


---

File name: node_modules\@testing-library\user-event\dist\types\document\index.d.ts

Code:
export { getUISelection, getUIValue, setUISelection, setUIValue, clearInitialValue, } from './UI';
export type { UISelectionRange } from './UI';
export { getValueOrTextContent } from './getValueOrTextContent';
export { copySelection } from './copySelection';
export { commitValueAfterInput } from './trackValue';


---

File name: node_modules\@testing-library\user-event\dist\types\document\interceptor.d.ts

Code:
type anyFunc = (...a: any[]) => any;
type Params<Prop> = Prop extends anyFunc ? Parameters<Prop> : [Prop];
type ImplReturn<Prop> = Prop extends anyFunc ? Parameters<Prop> : Prop;
export declare function prepareInterceptor<ElementType extends Element, PropName extends keyof ElementType>(element: ElementType, propName: PropName, interceptorImpl: (this: ElementType, ...args: Params<ElementType[PropName]>) => {
    /**
     * React tracks the changes on element properties.
     * This workaround tries to alter the DOM element without React noticing,
     * so that it later picks up the change.
     *
     * @see https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-dom/src/client/inputValueTracking.js#L51-L104
     */
    applyNative?: boolean;
    realArgs?: ImplReturn<ElementType[PropName]>;
    then?: () => void;
}): void;
export declare function prepareValueInterceptor(element: HTMLInputElement | HTMLTextAreaElement): void;
export declare function prepareSelectionInterceptor(element: HTMLInputElement | HTMLTextAreaElement): void;
export declare function prepareRangeTextInterceptor(element: HTMLInputElement | HTMLTextAreaElement): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\document\patchFocus.d.ts

Code:
declare const patched: unique symbol;
declare global {
    interface HTMLElement {
        readonly [patched]?: Pick<HTMLElement, 'focus' | 'blur'>;
    }
}
export declare function patchFocus(HTMLElement: typeof globalThis['HTMLElement']): void;
export declare function restoreFocus(HTMLElement: typeof globalThis['HTMLElement']): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\document\prepareDocument.d.ts

Code:
declare const isPrepared: unique symbol;
declare global {
    interface Node {
        [isPrepared]?: typeof isPrepared;
    }
}
export declare function prepareDocument(document: Document): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\document\trackValue.d.ts

Code:
declare const TrackChanges: unique symbol;
declare global {
    interface Window {
        REACT_VERSION?: number;
    }
    interface Element {
        [TrackChanges]?: {
            previousValue?: string;
            tracked?: string[];
            nextValue?: string;
        };
    }
}
export declare function startTrackValue(element: HTMLInputElement | HTMLTextAreaElement): void;
export declare function trackOrSetValue(element: HTMLInputElement | HTMLTextAreaElement, v: string): void;
export declare function commitValueAfterInput(element: HTMLInputElement | HTMLTextAreaElement, cursorOffset: number): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\document\UI.d.ts

Code:
declare const UIValue: unique symbol;
declare const UISelection: unique symbol;
declare const InitialValue: unique symbol;
declare global {
    interface Element {
        [UIValue]?: string;
        [InitialValue]?: string;
        [UISelection]?: UISelection;
    }
}
interface UISelection {
    anchorOffset: number;
    focusOffset: number;
}
export type UIValueString = String & {
    [UIValue]: true;
};
export type UISelectionStart = Number & {
    [UISelection]: true;
};
export declare function isUIValue(value: string | UIValueString): value is UIValueString;
export declare function isUISelectionStart(start: number | UISelectionStart | null): start is UISelectionStart;
export declare function setUIValue(element: HTMLInputElement | HTMLTextAreaElement, value: string): void;
export declare function getUIValue(element: HTMLInputElement | HTMLTextAreaElement): string;
/** Flag the IDL value as clean. This does not change the value.*/
export declare function setUIValueClean(element: HTMLInputElement | HTMLTextAreaElement): void;
export declare function clearInitialValue(element: HTMLInputElement | HTMLTextAreaElement): void;
export declare function getInitialValue(element: HTMLInputElement | HTMLTextAreaElement): string | undefined;
export declare function setUISelectionRaw(element: HTMLInputElement | HTMLTextAreaElement, selection: UISelection): void;
export declare function setUISelection(element: HTMLInputElement | HTMLTextAreaElement, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam, }: {
    anchorOffset?: number;
    focusOffset: number;
}, mode?: 'replace' | 'modify'): void;
export type UISelectionRange = UISelection & {
    startOffset: number;
    endOffset: number;
};
export declare function getUISelection(element: HTMLInputElement | HTMLTextAreaElement): UISelectionRange;
export declare function hasUISelection(element: HTMLInputElement | HTMLTextAreaElement): boolean;
/** Flag the IDL selection as clean. This does not change the selection. */
export declare function setUISelectionClean(element: HTMLInputElement | HTMLTextAreaElement): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\click.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\cut.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\index.d.ts

Code:
import './click';
import './cut';
import './keydown';
import './keypress';
import './keyup';
import './paste';
export { behavior } from './registry';
export type { BehaviorPlugin } from './registry';


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\keydown.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\keypress.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\keyup.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\paste.d.ts

Code:
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\behavior\registry.d.ts

Code:
import { type Instance } from '../../setup';
import { EventType } from '../types';
export interface BehaviorPlugin<Type extends EventType> {
    (event: DocumentEventMap[Type], target: Element, instance: Instance): // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    void | (() => void);
}
export declare const behavior: {
    [Type in EventType]?: BehaviorPlugin<Type>;
};


---

File name: node_modules\@testing-library\user-event\dist\types\event\createEvent.d.ts

Code:
import { type EventType, type EventTypeInit, type FixedDocumentEventMap } from './types';
export declare function createEvent<K extends EventType>(type: K, target: Element, init?: EventTypeInit<K>): FixedDocumentEventMap[K];


---

File name: node_modules\@testing-library\user-event\dist\types\event\dispatchEvent.d.ts

Code:
import { type Instance } from '../setup';
import { EventType, EventTypeInit } from './types';
export declare function dispatchUIEvent<K extends EventType>(this: Instance, target: Element, type: K, init?: EventTypeInit<K>, preventDefault?: boolean): boolean;
export declare function dispatchEvent(this: Instance, target: Element, event: Event, preventDefault?: boolean): boolean;
export declare function dispatchDOMEvent<K extends EventType>(target: Element, type: K, init?: EventTypeInit<K>): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\eventMap.d.ts

Code:
import { EventType } from './types';
export declare const eventMap: {
    readonly auxclick: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly beforeinput: {
        readonly EventType: "InputEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly blur: {
        readonly EventType: "FocusEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly click: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly contextmenu: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly copy: {
        readonly EventType: "ClipboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly change: {
        readonly EventType: "Event";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: false;
        };
    };
    readonly cut: {
        readonly EventType: "ClipboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly dblclick: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly focus: {
        readonly EventType: "FocusEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly focusin: {
        readonly EventType: "FocusEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly focusout: {
        readonly EventType: "FocusEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly keydown: {
        readonly EventType: "KeyboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly keypress: {
        readonly EventType: "KeyboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly keyup: {
        readonly EventType: "KeyboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly paste: {
        readonly EventType: "ClipboardEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly input: {
        readonly EventType: "InputEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly mousedown: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly mouseenter: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly mouseleave: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly mousemove: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly mouseout: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly mouseover: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly mouseup: {
        readonly EventType: "MouseEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointerover: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointerenter: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
        };
    };
    readonly pointerdown: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointermove: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointerup: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointercancel: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: false;
            readonly composed: true;
        };
    };
    readonly pointerout: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
            readonly composed: true;
        };
    };
    readonly pointerleave: {
        readonly EventType: "PointerEvent";
        readonly defaultInit: {
            readonly bubbles: false;
            readonly cancelable: false;
        };
    };
    readonly submit: {
        readonly EventType: "Event";
        readonly defaultInit: {
            readonly bubbles: true;
            readonly cancelable: true;
        };
    };
};
export declare function isMouseEvent(type: EventType): boolean;
export declare function isKeyboardEvent(type: EventType): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\event\focus.d.ts

Code:
/**
 * Focus closest focusable element.
 */
export declare function focusElement(element: Element): void;
export declare function blurElement(element: Element): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\index.d.ts

Code:
import { EventType, PointerCoords } from './types';
export type { EventType, PointerCoords };
export { dispatchEvent, dispatchUIEvent, dispatchDOMEvent } from './dispatchEvent';
export { blurElement, focusElement } from './focus';
export { input } from './input';
export type { SelectionRange } from './selection';
export { isAllSelected, modifySelectionPerMouseMove, setSelectionPerMouseDown, selectAll, } from './selection';


---

File name: node_modules\@testing-library\user-event\dist\types\event\input.d.ts

Code:
import { type Instance } from '../setup';
export declare function input(instance: Instance, element: Element, data: string, inputType?: string): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\radio.d.ts

Code:
import { type Instance } from '../setup';
export declare function walkRadio(instance: Instance, el: HTMLInputElement & {
    type: 'radio';
}, direction: -1 | 1): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\getInputRange.d.ts

Code:
import { UISelectionRange } from '../../document';
/**
 * Get the range that would be overwritten by input.
 */
export declare function getInputRange(focusNode: Node): UISelectionRange | Range | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\getTargetTypeAndSelection.d.ts

Code:
/**
 * Determine which selection logic and selection ranges to consider.
 */
export declare function getTargetTypeAndSelection(node: Node): {
    readonly type: "input";
    readonly selection: import("../../document").UISelectionRange;
} | {
    readonly type: "contenteditable" | "default";
    readonly selection: Selection | null | undefined;
};


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\index.d.ts

Code:
import { type EditableInputOrTextarea } from '../../utils';
export { getInputRange } from './getInputRange';
export { modifySelection } from './modifySelection';
export { moveSelection } from './moveSelection';
export { setSelectionPerMouseDown } from './setSelectionPerMouse';
export { modifySelectionPerMouseMove } from './modifySelectionPerMouse';
export { isAllSelected, selectAll } from './selectAll';
export { setSelectionRange } from './setSelectionRange';
export { setSelection } from './setSelection';
export { updateSelectionOnFocus } from './updateSelectionOnFocus';
export type SelectionRange = {
    node: EditableInputOrTextarea;
    start: number;
    end: number;
};


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\modifySelection.d.ts

Code:
/**
 * Extend/shrink the selection like with Shift+Arrows or Shift+Mouse
 */
export declare function modifySelection({ focusNode, focusOffset, }: {
    focusNode: Node;
    /** DOM Offset */
    focusOffset: number;
}): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\modifySelectionPerMouse.d.ts

Code:
import { type SelectionRange } from '.';
export declare function modifySelectionPerMouseMove(selectionRange: Range | SelectionRange, { document, target, node, offset, }: {
    document: Document;
    target: Element;
    node?: Node;
    offset?: number;
}): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\moveSelection.d.ts

Code:
/**
 * Move the selection
 */
export declare function moveSelection(node: Element, direction: -1 | 1): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\resolveCaretPosition.d.ts

Code:
export declare function resolveCaretPosition({ target, node, offset, }: {
    target: Element;
    node?: Node;
    offset?: number;
}): {
    node: Node;
    offset: number;
};


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\selectAll.d.ts

Code:
/**
 * Expand a selection like the browser does when pressing Ctrl+A.
 */
export declare function selectAll(target: Element): void;
export declare function isAllSelected(target: Element): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\setSelection.d.ts

Code:
/**
 * Set the selection
 */
export declare function setSelection({ focusNode, focusOffset, anchorNode, anchorOffset, }: {
    anchorNode?: Node;
    /** DOM offset */
    anchorOffset?: number;
    focusNode: Node;
    focusOffset: number;
}): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\setSelectionPerMouse.d.ts

Code:
import { type SelectionRange } from '.';
export declare function setSelectionPerMouseDown({ document, target, clickCount, node, offset, }: {
    document: Document;
    target: Element;
    clickCount: number;
    node?: Node;
    offset?: number;
}): Range | SelectionRange | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\setSelectionRange.d.ts

Code:
/**
 * Backward-compatible selection.
 *
 * Handles input elements and contenteditable if it only contains a single text node.
 */
export declare function setSelectionRange(element: Element, anchorOffset: number, focusOffset: number): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\selection\updateSelectionOnFocus.d.ts

Code:
/**
 * Reset the Document Selection when moving focus into an element
 * with own selection implementation.
 */
export declare function updateSelectionOnFocus(element: Element): void;


---

File name: node_modules\@testing-library\user-event\dist\types\event\types.d.ts

Code:
import { eventMap } from './eventMap';
export type EventType = keyof typeof eventMap;
export type EventTypeInit<K extends EventType> = SpecificEventInit<FixedDocumentEventMap[K]>;
export interface FixedDocumentEventMap extends DocumentEventMap {
    input: InputEvent;
}
type SpecificEventInit<E extends Event> = E extends InputEvent ? InputEventInit : E extends ClipboardEvent ? ClipboardEventInit : E extends KeyboardEvent ? KeyboardEventInit : E extends PointerEvent ? PointerEventInit : E extends MouseEvent ? MouseEventInit : E extends FocusEvent ? FocusEventInit : E extends UIEvent ? UIEventInit : EventInit;
export interface PointerCoords {
    x?: number;
    y?: number;
    clientX?: number;
    clientY?: number;
    offsetX?: number;
    offsetY?: number;
    pageX?: number;
    pageY?: number;
    screenX?: number;
    screenY?: number;
}
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\event\wrapEvent.d.ts

Code:
export declare function wrapEvent<R>(cb: () => R, _element: Element): R;


---

File name: node_modules\@testing-library\user-event\dist\types\index.d.ts

Code:
export { userEvent as default } from './setup';
export { userEvent } from './setup';
export type { UserEvent } from './setup/setup';
export type { keyboardKey } from './system/keyboard';
export type { pointerKey } from './system/pointer';
export { PointerEventsCheckLevel, type Options } from './options';


---

File name: node_modules\@testing-library\user-event\dist\types\keyboard\index.d.ts

Code:
import { type Instance } from '../setup';
export declare function keyboard(this: Instance, text: string): Promise<void>;
export declare function releaseAllKeys(instance: Instance): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\keyboard\keyMap.d.ts

Code:
import { keyboardKey } from '../system/keyboard';
/**
 * Mapping for a default US-104-QWERTY keyboard
 */
export declare const defaultKeyMap: keyboardKey[];


---

File name: node_modules\@testing-library\user-event\dist\types\keyboard\parseKeyDef.d.ts

Code:
import { keyboardKey } from '../system/keyboard';
/**
 * Parse key definitions per `keyboardMap`
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * Keeping the key pressed can be written as `{key>}`.
 * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.
 * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.
 */
export declare function parseKeyDef(keyboardMap: keyboardKey[], text: string): {
    keyDef: keyboardKey;
    releasePrevious: boolean;
    releaseSelf: boolean;
    repeat: number;
}[];


---

File name: node_modules\@testing-library\user-event\dist\types\options.d.ts

Code:
import { type keyboardKey } from './system/keyboard';
import { type pointerKey } from './system/pointer';
export declare enum PointerEventsCheckLevel {
    /**
     * Check pointer events on every user interaction that triggers a bunch of events.
     * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
     */
    EachTrigger = 4,
    /** Check each target once per call to pointer (related) API */
    EachApiCall = 2,
    /** Check each event target once */
    EachTarget = 1,
    /** No pointer events check */
    Never = 0
}
export interface Options {
    /**
     * When using `userEvent.upload`, automatically discard files
     * that don't match an `accept` property if it exists.
     *
     * @default true
     */
    applyAccept?: boolean;
    /**
     * We intend to automatically apply modifier keys for printable characters in the future.
     * I.e. `A` implying `{Shift>}a{/Shift}` if caps lock is not active.
     *
     * This options allows you to opt out of this change in foresight.
     * The feature therefore will not constitute a breaking change.
     *
     * @default true
     */
    autoModify?: boolean;
    /**
     * Between some subsequent inputs like typing a series of characters
     * the code execution is delayed per `setTimeout` for (at least) `delay` milliseconds.
     * This moves the next changes at least to next macro task
     * and allows other (asynchronous) code to run between events.
     *
     * `null` prevents `setTimeout` from being called.
     *
     * @default 0
     */
    delay?: number | null;
    /**
     * The document.
     *
     * This defaults to the owner document of an element if an API is called directly with an element and without setup.
     * Otherwise it falls back to the global document.
     *
     * @default element.ownerDocument??globalThis.document
     */
    document?: Document;
    /**
     * An array of keyboard keys the keyboard device consists of.
     *
     * This allows to plug in different layouts / localizations.
     *
     * Defaults to a "standard" US-104-QWERTY keyboard.
     */
    keyboardMap?: keyboardKey[];
    /**
     * An array of available pointer keys.
     *
     * This allows to plug in different pointer devices.
     */
    pointerMap?: pointerKey[];
    /**
     * The pointer API includes a check if an element has or inherits `pointer-events: none`.
     * This check is known to be expensive and very expensive when checking deeply nested nodes.
     * This option determines how often the pointer related APIs perform the check.
     *
     * This is a binary flag option. You can combine multiple Levels.
     *
     * @default PointerEventsCheckLevel.EachCall
     */
    pointerEventsCheck?: PointerEventsCheckLevel | number;
    /**
     * `userEvent.type` automatically releases any keys still pressed at the end of the call.
     * This option allows to opt out of this feature.
     *
     * @default false
     */
    skipAutoClose?: boolean;
    /**
     * `userEvent.type` implies a click at the end of the element content/value.
     * This option allows to opt out of this feature.
     *
     * @default false
     */
    skipClick?: boolean;
    /**
     * `userEvent.click` implies moving the cursor to the target element first.
     * This options allows to opt out of this feature.
     *
     * @default false
     */
    skipHover?: boolean;
    /**
     * Write selected data to Clipboard API when a `cut` or `copy` is triggered.
     *
     * The Clipboard API is usually not available to test code.
     * Our `setup` replaces the `navigator.clipboard` property with a stub.
     *
     * Defaults to `false` when calling the APIs directly.
     * Defaults to `true` when calling the APIs per `setup`.
     */
    writeToClipboard?: boolean;
    /**
     * A function to be called internally to advance your fake timers (if applicable)
     *
     * @example jest.advanceTimersByTime
     */
    advanceTimers?: ((delay: number) => Promise<void>) | ((delay: number) => void);
}


---

File name: node_modules\@testing-library\user-event\dist\types\pointer\index.d.ts

Code:
import { type PointerCoords } from '../event';
import { type Instance } from '../setup';
import { type pointerKey } from '../system/pointer';
type PointerActionInput = string | ({
    keys: string;
} & PointerActionPosition) | PointerAction;
export type PointerInput = PointerActionInput | Array<PointerActionInput>;
type PointerAction = PointerPressAction | PointerMoveAction;
type PointerActionPosition = {
    target?: Element;
    coords?: PointerCoords;
    node?: Node;
    /**
     * If `node` is set, this is the DOM offset.
     * Otherwise this is the `textContent`/`value` offset on the `target`.
     */
    offset?: number;
};
interface PointerPressAction extends PointerActionPosition {
    keyDef: pointerKey;
    releasePrevious: boolean;
    releaseSelf: boolean;
}
interface PointerMoveAction extends PointerActionPosition {
    pointerName?: string;
}
export declare function pointer(this: Instance, input: PointerInput): Promise<void>;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\pointer\keyMap.d.ts

Code:
import { pointerKey } from '../system/pointer';
export declare const defaultKeyMap: pointerKey[];


---

File name: node_modules\@testing-library\user-event\dist\types\pointer\parseKeyDef.d.ts

Code:
import { pointerKey } from '../system/pointer';
export declare function parseKeyDef(pointerMap: pointerKey[], keys: string): {
    keyDef: pointerKey;
    releasePrevious: boolean;
    releaseSelf: boolean;
}[];


---

File name: node_modules\@testing-library\user-event\dist\types\setup\api.d.ts

Code:
import { click, dblClick, tripleClick, hover, unhover, tab } from '../convenience';
import { keyboard } from '../keyboard';
import { copy, cut, paste } from '../clipboard';
import { pointer } from '../pointer';
import { clear, deselectOptions, selectOptions, type, upload } from '../utility';
export declare const userEventApi: {
    click: typeof click;
    dblClick: typeof dblClick;
    tripleClick: typeof tripleClick;
    hover: typeof hover;
    unhover: typeof unhover;
    tab: typeof tab;
    keyboard: typeof keyboard;
    copy: typeof copy;
    cut: typeof cut;
    paste: typeof paste;
    pointer: typeof pointer;
    clear: typeof clear;
    deselectOptions: typeof deselectOptions;
    selectOptions: typeof selectOptions;
    type: typeof type;
    upload: typeof upload;
};


---

File name: node_modules\@testing-library\user-event\dist\types\setup\directApi.d.ts

Code:
import { type Options } from '../options';
import { type PointerInput } from '../pointer';
import { type System } from '../system';
import { type UserEventApi } from './setup';
export type DirectOptions = Options & {
    keyboardState?: System;
    pointerState?: System;
};
export declare function clear(element: Element): Promise<void>;
export declare function click(element: Element, options?: DirectOptions): Promise<void>;
export declare function copy(options?: DirectOptions): Promise<DataTransfer | undefined>;
export declare function cut(options?: DirectOptions): Promise<DataTransfer | undefined>;
export declare function dblClick(element: Element, options?: DirectOptions): Promise<void>;
export declare function deselectOptions(select: Element, values: HTMLElement | HTMLElement[] | string[] | string, options?: DirectOptions): Promise<void>;
export declare function hover(element: Element, options?: DirectOptions): Promise<void>;
export declare function keyboard(text: string, options?: DirectOptions): Promise<System>;
export declare function pointer(input: PointerInput, options?: DirectOptions): Promise<System>;
export declare function paste(clipboardData?: DataTransfer | string, options?: DirectOptions): Promise<void>;
export declare function selectOptions(select: Element, values: HTMLElement | HTMLElement[] | string[] | string, options?: DirectOptions): Promise<void>;
export declare function tripleClick(element: Element, options?: DirectOptions): Promise<void>;
export declare function type(element: Element, text: string, options?: DirectOptions & Parameters<UserEventApi['type']>[2]): Promise<void>;
export declare function unhover(element: Element, options?: DirectOptions): Promise<void>;
export declare function upload(element: HTMLElement, fileOrFiles: File | File[], options?: DirectOptions): Promise<void>;
export declare function tab(options?: DirectOptions & Parameters<UserEventApi['tab']>[0]): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\setup\index.d.ts

Code:
import { setupMain } from './setup';
import * as directApi from './directApi';
export type { Instance } from './setup';
export declare const userEvent: {
    readonly setup: typeof setupMain;
    readonly clear: typeof directApi.clear;
    readonly click: typeof directApi.click;
    readonly copy: typeof directApi.copy;
    readonly cut: typeof directApi.cut;
    readonly dblClick: typeof directApi.dblClick;
    readonly deselectOptions: typeof directApi.deselectOptions;
    readonly hover: typeof directApi.hover;
    readonly keyboard: typeof directApi.keyboard;
    readonly pointer: typeof directApi.pointer;
    readonly paste: typeof directApi.paste;
    readonly selectOptions: typeof directApi.selectOptions;
    readonly tripleClick: typeof directApi.tripleClick;
    readonly type: typeof directApi.type;
    readonly unhover: typeof directApi.unhover;
    readonly upload: typeof directApi.upload;
    readonly tab: typeof directApi.tab;
};


---

File name: node_modules\@testing-library\user-event\dist\types\setup\setup.d.ts

Code:
import { dispatchEvent, dispatchUIEvent } from '../event';
import { Options } from '../options';
import { System } from '../system';
import { userEventApi } from './api';
import { DirectOptions } from './directApi';
export type UserEventApi = typeof userEventApi;
export type UserEvent = {
    readonly setup: (...args: Parameters<typeof setupSub>) => UserEvent;
} & {
    readonly [k in keyof UserEventApi]: (...args: Parameters<UserEventApi[k]>) => ReturnType<UserEventApi[k]>;
};
export type Instance = UserEventApi & {
    config: Config;
    dispatchEvent: OmitThisParameter<typeof dispatchEvent>;
    dispatchUIEvent: OmitThisParameter<typeof dispatchUIEvent>;
    system: System;
    levelRefs: Record<number, object | undefined>;
};
export type Config = Required<Options>;
export declare function createConfig(options?: Options, defaults?: Required<Options>, node?: Node): Config;
/**
 * Start a "session" with userEvent.
 * All APIs returned by this function share an input device state and a default configuration.
 */
export declare function setupMain(options?: Options): UserEvent;
/**
 * Setup in direct call per `userEvent.anyApi()`
 */
export declare function setupDirect({ keyboardState, pointerState, ...options }?: DirectOptions & {
    keyboardState?: System;
    pointerState?: System;
}, // backward-compatibility
node?: Node): {
    api: UserEvent;
    system: System;
};
/**
 * Create a set of callbacks with different default settings but the same state.
 */
export declare function setupSub(this: Instance, options: Options): UserEvent;
export declare function createInstance(config: Config, system?: System): {
    instance: Instance;
    api: UserEvent;
};


---

File name: node_modules\@testing-library\user-event\dist\types\setup\wrapAsync.d.ts

Code:
/**
 * Wrap an internal Promise
 */
export declare function wrapAsync<R, P extends (() => Promise<R>) | (() => R)>(implementation: P): Promise<R>;


---

File name: node_modules\@testing-library\user-event\dist\types\system\index.d.ts

Code:
import { KeyboardHost } from './keyboard';
import { PointerHost } from './pointer';
/**
 * @internal Do not create/alter this by yourself as this type might be subject to changes.
 */
export declare class System {
    readonly keyboard: KeyboardHost;
    readonly pointer: PointerHost;
    getUIEventModifiers(): EventModifierInit;
}


---

File name: node_modules\@testing-library\user-event\dist\types\system\keyboard.d.ts

Code:
import { type Instance } from '../setup';
import { type System } from '.';
export declare enum DOM_KEY_LOCATION {
    STANDARD = 0,
    LEFT = 1,
    RIGHT = 2,
    NUMPAD = 3
}
export interface keyboardKey {
    /** Physical location on a keyboard */
    code?: string;
    /** Character or functional key descriptor */
    key?: string;
    /** Location on the keyboard for keys with multiple representation */
    location?: DOM_KEY_LOCATION;
    /** Does the character in `key` require/imply AltRight to be pressed? */
    altGr?: boolean;
    /** Does the character in `key` require/imply a shiftKey to be pressed? */
    shift?: boolean;
}
export declare class KeyboardHost {
    readonly system: System;
    constructor(system: System);
    readonly modifiers: {
        Alt: boolean;
        AltGraph: boolean;
        CapsLock: boolean;
        Control: boolean;
        Fn: boolean;
        FnLock: boolean;
        Meta: boolean;
        NumLock: boolean;
        ScrollLock: boolean;
        Shift: boolean;
        Symbol: boolean;
        SymbolLock: boolean;
    };
    private readonly pressed;
    carryChar: string;
    private lastKeydownTarget;
    private readonly modifierLockStart;
    isKeyPressed(keyDef: keyboardKey): boolean;
    getPressedKeys(): keyboardKey[];
    /** Press a key */
    keydown(instance: Instance, keyDef: keyboardKey): Promise<void>;
    /** Release a key */
    keyup(instance: Instance, keyDef: keyboardKey): Promise<void>;
    private setKeydownTarget;
    private hasKeyPress;
}


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\buttons.d.ts

Code:
import { type pointerKey } from './shared';
export declare class Buttons {
    private readonly pressed;
    getButtons(): number;
    down(keyDef: pointerKey): number | undefined;
    up(keyDef: pointerKey): number | undefined;
}
export declare const MouseButton: {
    readonly primary: 0;
    readonly secondary: 1;
    readonly auxiliary: 2;
    readonly back: 3;
    readonly X1: 3;
    readonly forward: 4;
    readonly X2: 4;
};
export type MouseButton = keyof typeof MouseButton | number;
export declare function getMouseButtonId(button?: MouseButton): number;
export declare const MouseButtonFlip: {
    readonly 1: 2;
    readonly 2: 1;
};
export declare function getMouseEventButton(button?: MouseButton): number;


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\device.d.ts

Code:
import { type pointerKey } from '.';
export declare class Device {
    private pressedKeys;
    get countPressed(): number;
    isPressed(keyDef: pointerKey): boolean;
    addPressed(keyDef: pointerKey): Set<string>;
    removePressed(keyDef: pointerKey): boolean;
}


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\index.d.ts

Code:
import { System } from '..';
import { Instance } from '../../setup';
import { pointerKey, PointerPosition } from './shared';
export type { pointerKey, PointerPosition } from './shared';
export declare class PointerHost {
    readonly system: System;
    constructor(system: System);
    private readonly mouse;
    private readonly buttons;
    private readonly devices;
    private readonly pointers;
    isKeyPressed(keyDef: pointerKey): boolean;
    press(instance: Instance, keyDef: pointerKey, position: PointerPosition): Promise<void>;
    move(instance: Instance, pointerName: string, position: PointerPosition): Promise<void>;
    release(instance: Instance, keyDef: pointerKey, position: PointerPosition): Promise<void>;
    getPointerName(keyDef: pointerKey): string;
    getPreviousPosition(pointerName: string): PointerPosition | undefined;
    resetClickCount(): void;
    getMouseTarget(instance: Instance): Element;
    setMousePosition(position: PointerPosition): void;
}


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\mouse.d.ts

Code:
import { type Instance } from '../../setup';
import { pointerKey, PointerPosition } from './shared';
/**
 * This object is the single "virtual" mouse that might be controlled by multiple different pointer devices.
 */
export declare class Mouse {
    position: PointerPosition;
    private readonly buttons;
    private selecting?;
    private buttonDownTarget;
    private readonly clickCount;
    move(instance: Instance, position: PointerPosition, 
    /** Whether `preventDefault()` has been called on the `pointerdown` event */
    isPrevented: boolean): {
        leave: () => void;
        enter: () => void;
        move: () => void;
    } | undefined;
    down(instance: Instance, keyDef: pointerKey, 
    /** Whether `preventDefault()` has been called on the `pointerdown` event */
    isPrevented: boolean): void;
    up(instance: Instance, keyDef: pointerKey, 
    /** Whether `preventDefault()` has been called on the `pointerdown` event */
    isPrevented: boolean): void;
    resetClickCount(): void;
    private getEventInit;
    private getTarget;
    private startSelecting;
    private modifySelecting;
    private endSelecting;
}


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\pointer.d.ts

Code:
import { type Instance } from '../../setup';
import { PointerPosition } from './shared';
import { Buttons, MouseButton } from './buttons';
type PointerInit = {
    pointerId: number;
    pointerType: string;
    isPrimary: boolean;
};
export declare class Pointer {
    constructor({ pointerId, pointerType, isPrimary }: PointerInit, buttons: Buttons);
    readonly pointerId: number;
    readonly pointerType: string;
    readonly isPrimary: boolean;
    readonly buttons: Buttons;
    isMultitouch: boolean;
    isCancelled: boolean;
    isDown: boolean;
    isPrevented: boolean;
    position: PointerPosition;
    init(instance: Instance): this;
    move(instance: Instance, position: PointerPosition): {
        leave: () => void;
        enter: () => void;
        move: () => void;
    } | undefined;
    down(instance: Instance, button?: MouseButton): void;
    up(instance: Instance, button?: MouseButton): void;
    release(instance: Instance): void;
    private getTarget;
    private getEventInit;
}
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\system\pointer\shared.d.ts

Code:
import { PointerCoords } from '../../event';
import { MouseButton } from './buttons';
export interface pointerKey {
    /** Name of the pointer key */
    name: string;
    /** Type of the pointer device */
    pointerType: 'mouse' | 'pen' | 'touch';
    /** Type of button */
    button?: MouseButton;
}
export interface PointerPosition {
    target?: Element;
    coords?: PointerCoords;
    caret?: CaretPosition;
}
export interface CaretPosition {
    node?: Node;
    offset?: number;
}
export declare function isDifferentPointerPosition(positionA: PointerPosition, positionB: PointerPosition): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\utility\clear.d.ts

Code:
import { type Instance } from '../setup';
export declare function clear(this: Instance, element: Element): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\utility\index.d.ts

Code:
export * from './clear';
export * from './selectOptions';
export * from './type';
export * from './upload';


---

File name: node_modules\@testing-library\user-event\dist\types\utility\selectOptions.d.ts

Code:
import { type Instance } from '../setup';
export declare function selectOptions(this: Instance, select: Element, values: HTMLElement | HTMLElement[] | string[] | string): Promise<void>;
export declare function deselectOptions(this: Instance, select: Element, values: HTMLElement | HTMLElement[] | string[] | string): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\utility\type.d.ts

Code:
import { type Instance } from '../setup';
import { type Options } from '../options';
export interface typeOptions {
    skipClick?: Options['skipClick'];
    skipAutoClose?: Options['skipAutoClose'];
    initialSelectionStart?: number;
    initialSelectionEnd?: number;
}
export declare function type(this: Instance, element: Element, text: string, { skipClick, skipAutoClose, initialSelectionStart, initialSelectionEnd, }?: typeOptions): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\utility\upload.d.ts

Code:
import { type Instance } from '../setup';
export interface uploadInit {
    changeInit?: EventInit;
}
export declare function upload(this: Instance, element: HTMLElement, fileOrFiles: File | File[]): Promise<void>;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\click\isClickableInput.d.ts

Code:
declare enum clickableInputTypes {
    'button' = "button",
    'color' = "color",
    'file' = "file",
    'image' = "image",
    'reset' = "reset",
    'submit' = "submit",
    'checkbox' = "checkbox",
    'radio' = "radio"
}
export type ClickableInputOrButton = HTMLButtonElement | (HTMLInputElement & {
    type: clickableInputTypes;
});
export declare function isClickableInput(element: Element): element is ClickableInputOrButton;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\dataTransfer\Blob.d.ts

Code:
export declare function readBlobText(blob: Blob, FileReader: {
    new (): FileReader;
}): Promise<string>;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\dataTransfer\Clipboard.d.ts

Code:
export declare function createClipboardItem(window: Window & typeof globalThis, ...blobs: Array<Blob | string>): ClipboardItem;
type ClipboardStubControlInstance = {
    resetClipboardStub: () => void;
    detachClipboardStub: () => void;
};
export declare function attachClipboardStubToView(window: Window & typeof globalThis): ClipboardStubControlInstance;
export declare function resetClipboardStubOnView(window: Window & typeof globalThis): void;
export declare function detachClipboardStubFromView(window: Window & typeof globalThis): void;
export declare function readDataTransferFromClipboard(document: Document): Promise<DataTransfer>;
export declare function writeDataTransferToClipboard(document: Document, clipboardData: DataTransfer): Promise<void>;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\dataTransfer\DataTransfer.d.ts

Code:
export declare function createDataTransfer(window: Window & typeof globalThis, files?: File[]): DataTransfer;
export declare function getBlobFromDataTransferItem(window: Window & typeof globalThis, item: DataTransferItem): Promise<Blob>;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\dataTransfer\FileList.d.ts

Code:
export declare function createFileList(window: Window & typeof globalThis, files: File[]): FileList;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\edit\isContentEditable.d.ts

Code:
export declare function isContentEditable(element: Element): element is HTMLElement & {
    contenteditable: 'true';
};
/**
 * If a node is a contenteditable or inside one, return that element.
 */
export declare function getContentEditable(node: Node): Element | null;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\edit\isEditable.d.ts

Code:
import { isContentEditable } from './isContentEditable';
type GuardedType<T> = T extends (x: any) => x is infer R ? R : never;
export declare function isEditable(element: Element): element is GuardedType<typeof isContentEditable> | (EditableInputOrTextarea & {
    readOnly: false;
});
declare enum editableInputTypes {
    'text' = "text",
    'date' = "date",
    'datetime-local' = "datetime-local",
    'email' = "email",
    'month' = "month",
    'number' = "number",
    'password' = "password",
    'search' = "search",
    'tel' = "tel",
    'time' = "time",
    'url' = "url",
    'week' = "week"
}
export type EditableInputOrTextarea = HTMLTextAreaElement | (HTMLInputElement & {
    type: editableInputTypes;
});
export declare function isEditableInputOrTextArea(element: Element): element is EditableInputOrTextarea;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\edit\maxLength.d.ts

Code:
declare enum maxLengthSupportedTypes {
    'email' = "email",
    'password' = "password",
    'search' = "search",
    'telephone' = "telephone",
    'text' = "text",
    'url' = "url"
}
type ElementWithMaxLengthSupport = HTMLTextAreaElement | (HTMLInputElement & {
    type: maxLengthSupportedTypes;
});
export declare function getMaxLength(element: ElementWithMaxLengthSupport): number | undefined;
export declare function supportsMaxLength(element: Element): element is ElementWithMaxLengthSupport;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\edit\setFiles.d.ts

Code:
declare const fakeFiles: unique symbol;
declare global {
    interface HTMLInputElement {
        [fakeFiles]?: {
            restore: () => void;
        };
    }
}
export declare function setFiles(el: HTMLInputElement & {
    type: 'file';
}, files: FileList): void;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\edit\timeValue.d.ts

Code:
export declare function buildTimeValue(value: string): string;
export declare function isValidDateOrTimeValue(element: HTMLInputElement & {
    type: 'date' | 'time';
}, value: string): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\cursor.d.ts

Code:
declare global {
    interface Text {
        nodeValue: string;
    }
}
export declare function getNextCursorPosition(node: Node, offset: number, direction: -1 | 1, inputType?: string): {
    node: Node;
    offset: number;
} | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\getActiveElement.d.ts

Code:
export declare function getActiveElement(document: Document | ShadowRoot): Element | null;
export declare function getActiveElementOrBody(document: Document): Element;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\getTabDestination.d.ts

Code:
export declare function getTabDestination(activeElement: Element, shift: boolean): HTMLElement;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\isFocusable.d.ts

Code:
export declare function isFocusable(element: Element): element is HTMLElement;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\selection.d.ts

Code:
import { ClickableInputOrButton } from '../click/isClickableInput';
import { EditableInputOrTextarea } from '../edit/isEditable';
/**
 * Determine if the element has its own selection implementation
 * and does not interact with the Document Selection API.
 */
export declare function hasOwnSelection(node: Node): node is EditableInputOrTextarea;
export declare function hasNoSelection(node: Node): node is ClickableInputOrButton;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\focus\selector.d.ts

Code:
export declare const FOCUSABLE_SELECTOR: string;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\index.d.ts

Code:
export * from './click/isClickableInput';
export * from './dataTransfer/Blob';
export * from './dataTransfer/DataTransfer';
export * from './dataTransfer/FileList';
export * from './dataTransfer/Clipboard';
export * from './edit/timeValue';
export * from './edit/isContentEditable';
export * from './edit/isEditable';
export * from './edit/maxLength';
export * from './edit/setFiles';
export * from './focus/cursor';
export * from './focus/getActiveElement';
export * from './focus/getTabDestination';
export * from './focus/isFocusable';
export * from './focus/selection';
export * from './focus/selector';
export * from './keyDef/readNextDescriptor';
export * from './misc/cloneEvent';
export * from './misc/findClosest';
export * from './misc/getDocumentFromNode';
export * from './misc/getTreeDiff';
export * from './misc/getWindow';
export * from './misc/isDescendantOrSelf';
export * from './misc/isElementType';
export * from './misc/isVisible';
export * from './misc/isDisabled';
export * from './misc/level';
export * from './misc/wait';
export * from './pointer/cssPointerEvents';


---

File name: node_modules\@testing-library\user-event\dist\types\utils\keyDef\readNextDescriptor.d.ts

Code:
type Context = 'pointer' | 'keyboard';
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */
export declare function readNextDescriptor(text: string, context: Context): {
    consumedLength: number;
    descriptor: string;
    releasePrevious: boolean;
    repeat: number;
    releaseSelf: boolean | undefined;
    type: string;
};
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\cloneEvent.d.ts

Code:
export declare function cloneEvent<E extends Event>(event: E): E;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\findClosest.d.ts

Code:
export declare function findClosest<T extends Element>(element: Element, callback: (e: Element) => e is T): T | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\getDocumentFromNode.d.ts

Code:
export declare function getDocumentFromNode(el: Node): Document | null;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\getTreeDiff.d.ts

Code:
export declare function getTreeDiff(a: Element | null, b: Element | null): readonly [Element[], Element[], Element[]];


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\getWindow.d.ts

Code:
export declare function getWindow(node: Node): Window & typeof globalThis;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\isDescendantOrSelf.d.ts

Code:
export declare function isDescendantOrSelf(potentialDescendant: Element, potentialAncestor: Element): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\isDisabled.d.ts

Code:
export declare function isDisabled(element: Element | null): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\isElementType.d.ts

Code:
type tag = keyof HTMLElementTagNameMap;
export declare function isElementType<T extends tag, P extends {
    [k: string]: unknown;
} | undefined = undefined>(element: Element, tag: T | T[], props?: P): element is P extends undefined ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap[T] & P;
export {};


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\isVisible.d.ts

Code:
export declare function isVisible(element: Element): boolean;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\level.d.ts

Code:
import { type Instance } from '../../setup';
export declare enum ApiLevel {
    Trigger = 2,
    Call = 1
}
export type LevelRefs = Record<ApiLevel, object | undefined>;
export declare function setLevelRef(instance: Instance, level: ApiLevel): void;
export declare function getLevelRef(instance: Instance, level: ApiLevel): object | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\misc\wait.d.ts

Code:
import { type Instance } from '../../setup';
export declare function wait(config: Instance['config']): Promise<[void, void]> | undefined;


---

File name: node_modules\@testing-library\user-event\dist\types\utils\pointer\cssPointerEvents.d.ts

Code:
import { type Instance } from '../../setup';
import { ApiLevel } from '../misc/level';
export declare function hasPointerEvents(instance: Instance, element: Element): boolean;
declare function closestPointerEventsDeclaration(element: Element): {
    pointerEvents: string;
    tree: Element[];
} | undefined;
declare const PointerEventsCheck: unique symbol;
declare global {
    interface Element {
        [PointerEventsCheck]?: {
            [k in ApiLevel]?: object;
        } & {
            result: ReturnType<typeof closestPointerEventsDeclaration>;
        };
    }
}
export declare function assertPointerEvents(instance: Instance, element: Element): void;
export {};


---

File name: node_modules\@testing-library\user-event\package.json

Code:
{
  "name": "@testing-library/user-event",
  "version": "14.6.1",
  "description": "Fire events the same way the user does",
  "keywords": [
    "react-testing-library",
    "dom-testing-library",
    "react",
    "testing"
  ],
  "author": "Giorgio Polvara <polvara@gmail.com>",
  "license": "MIT",
  "engines": {
    "node": ">=12",
    "npm": ">=6"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/testing-library/user-event"
  },
  "bugs": {
    "url": "https://github.com/testing-library/user-event/issues"
  },
  "homepage": "https://github.com/testing-library/user-event#readme",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "scripts ts-build2 --cjs --target es2019",
    "lint": "kcd-scripts lint",
    "setup": "npm install && npm run validate -s",
    "setup:env": "node --experimental-import-meta-resolve scripts/setup.js",
    "test": "kcd-scripts test",
    "test:jest": "kcd-scripts test",
    "test:toolbox": "NODE_OPTIONS='--experimental-vm-modules --experimental-modules --experimental-import-meta-resolve' node scripts/test.js",
    "test:debug": "kcd-scripts --inspect-brk test --runInBand",
    "test:update": "npm test -- --updateSnapshot --coverage",
    "validate": "kcd-scripts typecheck"
  },
  "devDependencies": {
    "@esbuild-plugins/node-modules-polyfill": "^0.2.2",
    "@ph.fritsche/scripts-config": "^2.4.0",
    "@ph.fritsche/toolbox": "^1.0.0-alpha.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^5.16.3",
    "@testing-library/react": "^16.1.0",
    "@types/jest-in-case": "^1.0.3",
    "@types/react": "^18.0.25",
    "@types/sinonjs__fake-timers": "^8.1.2",
    "css.escape": "^1.5.1",
    "esbuild": "^0.19.10",
    "esbuild-plugin-globals": "^0.2.0",
    "eslint-import-resolver-typescript": "^3.5.2",
    "eslint-plugin-local-rules": "^1.3.2",
    "expect": "^28.1.3",
    "is-ci": "^3.0.1",
    "istanbul-lib-coverage": "^3.2.0",
    "istanbul-lib-report": "^3.0.0",
    "istanbul-lib-source-maps": "^4.0.1",
    "istanbul-reports": "^3.1.5",
    "jest-in-case": "^1.0.2",
    "jest-mock": "^28.1.3",
    "jest-serializer-ansi": "^1.0.3",
    "jsdom": "^20.0.3",
    "kcd-scripts": "^12.1.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "shared-scripts": "^1.5.1",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.3"
  },
  "peerDependencies": {
    "@testing-library/dom": ">=7.21.4"
  },
  "dependencies": {},
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "types": "./dist/types/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/types/index.d.ts",
      "require": "./dist/cjs/index.js",
      "default": "./dist/esm/index.js"
    },
    "./dist/cjs/*.js": {
      "types": "./dist/types/*.d.ts",
      "import": "./dist/esm/*.js",
      "default": "./dist/cjs/*.js"
    },
    "./dist/esm/*.js": {
      "types": "./dist/types/*.d.ts",
      "default": "./dist/esm/*.js",
      "require": "./dist/cjs/*.js"
    }
  },
  "typesVersions": {
    "*": {
      "dist/types/*": [
        "./dist/types/*"
      ],
      "dist/cjs/*.js": [
        "./dist/types/*.d.ts"
      ],
      "dist/esm/*.js": [
        "./dist/types/*.d.ts"
      ],
      "*": [
        "./dist/types/*.d.ts"
      ]
    }
  }
}


---

File name: node_modules\@testing-library\user-event\README.md

Code:
<div align="center">
<h1>user-event</h1>

<a href="https://www.joypixels.com/profiles/emoji/1f415">
  <img
    height="80"
    width="80"
    alt="dog"
    src="https://raw.githubusercontent.com/testing-library/user-event/main/other/dog.png"
  />
</a>

<p>Fire events the same way the user does</p>

<br />

[**Read The Docs**](https://testing-library.com/docs/user-event/intro)

<br />
</div>

---

<!-- prettier-ignore-start -->
[![Build Status][build-badge]][build]
[![Code Coverage][coverage-badge]][coverage]
[![version][version-badge]][package]
[![downloads][downloads-badge]][npmtrends]
[![MIT License][license-badge]][license]
[![All Contributors][all-contributors-badge]](#contributors)
[![PRs Welcome][prs-badge]][prs]
[![Code of Conduct][coc-badge]][coc]
[![Discord][discord-badge]][discord]

[![Watch on GitHub][github-watch-badge]][github-watch]
[![Star on GitHub][github-star-badge]][github-star]
[![Tweet][twitter-badge]][twitter]
<!-- prettier-ignore-end -->

## The problem

From
[testing-library/dom-testing-library#107](https://github.com/testing-library/dom-testing-library/issues/107):

> [...] it is becoming apparent the need to express user actions on a web page
> using a higher-level abstraction than [`fireEvent`][fire-event]

## The solution

`user-event` tries to simulate the real events that would happen in the browser
as the user interacts with it. For example `userEvent.click(checkbox)` would
change the state of the checkbox.

> [The more your tests resemble the way your software is used, the more
> confidence they can give you.][guiding-principle]

## Issues

Looking to contribute? Look for the [Good First Issue][good-first-issue] label.

### 🐛 Bugs

Please file an issue for bugs, missing documentation, or unexpected behavior.

[**See Bugs**][bugs]

### 💡 Feature Requests

Please file an issue to suggest new features. Vote on feature requests by adding
a 👍. This helps maintainers prioritize what to work on.

[**See Feature Requests**][requests]

### ❓ Questions

For questions related to using the library, please visit a support community
instead of filing an issue on GitHub.

- [Discord][discord]
- [Stack Overflow][stackoverflow]

## Contributors

We most sincerely thank [the people who make this project
possible][contributors]. Contributions of any kind are welcome! 💚

## License

[MIT](LICENSE)

<!-- prettier-ignore-start -->
[npm]: https://www.npmjs.com
[node]: https://nodejs.org
[build-badge]: https://img.shields.io/github/workflow/status/testing-library/user-event/validate/main?logo=github&style=flat-square
[build]: https://github.com/testing-library/user-event/actions?query=workflow%3Avalidate
[coverage-badge]: https://img.shields.io/codecov/c/github/testing-library/user-event.svg?style=flat-square
[coverage]: https://codecov.io/github/testing-library/user-event
[version-badge]: https://img.shields.io/npm/v/@testing-library/user-event.svg?style=flat-square
[package]: https://www.npmjs.com/package/@testing-library/user-event
[downloads-badge]: https://img.shields.io/npm/dm/@testing-library/user-event.svg?style=flat-square
[npmtrends]: http://www.npmtrends.com/@testing-library/user-event
[license-badge]: https://img.shields.io/npm/l/@testing-library/user-event.svg?style=flat-square
[license]: https://github.com/testing-library/user-event/blob/main/LICENSE
[prs-badge]: https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square
[prs]: http://makeapullrequest.com
[coc-badge]: https://img.shields.io/badge/code%20of-conduct-ff69b4.svg?style=flat-square
[coc]: https://github.com/testing-library/.github/blob/main/CODE_OF_CONDUCT.md
[github-watch-badge]: https://img.shields.io/github/watchers/testing-library/user-event.svg?style=social
[github-watch]: https://github.com/testing-library/user-event/watchers
[github-star-badge]: https://img.shields.io/github/stars/testing-library/user-event.svg?style=social
[github-star]: https://github.com/testing-library/user-event/stargazers
[twitter]: https://twitter.com/intent/tweet?text=Check%20out%20user-event%20by%20%40@TestingLib%20https%3A%2F%2Fgithub.com%2Ftesting-library%2Fuser-event%20%F0%9F%91%8D
[twitter-badge]: https://img.shields.io/twitter/url/https/github.com/testing-library/user-event.svg?style=social
[all-contributors-badge]: https://img.shields.io/github/all-contributors/testing-library/user-event?color=orange&style=flat-square
[guiding-principle]: https://twitter.com/kentcdodds/status/977018512689455106
[bugs]: https://github.com/testing-library/user-event/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+sort%3Acreated-desc+label%3Abug
[requests]: https://github.com/testing-library/user-event/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc+label%3Aenhancement
[good-first-issue]: https://github.com/testing-library/user-event/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc+label%3Aenhancement+label%3A%22good+first+issue%22
[fire-event]: https://testing-library.com/docs/dom-testing-library/api-events#fireevent
[discord-badge]: https://img.shields.io/discord/723559267868737556.svg?color=7389D8&labelColor=6A7EC2&logo=discord&logoColor=ffffff&style=flat-square
[discord]: https://discord.gg/testing-library
[stackoverflow]: https://stackoverflow.com/questions/tagged/user-event
[contributors]: https://github.com/testing-library/user-event/blob/main/CONTRIBUTORS.md
<!-- prettier-ignore-end -->


---

File name: node_modules\@types\aria-query\index.d.ts

Code:
// Disable automatic exports.
export {};

interface MapLike<Key, Value> {
    entries: () => Array<[Key, Value]>;
    get: (key: Key) => Value | undefined;
    has: (key: Key) => boolean;
    keys: () => Key[];
    values: () => Value[];
}

// index.js
export type ARIARoleDefinitionKey = ARIAAbstractRole | ARIARole | ARIADPubRole;

export const aria: MapLike<ARIAProperty, ARIAPropertyDefinition>;
export interface DOMDefinition {
    reserved?: boolean | undefined;
    interactive?: boolean | undefined;
}
export const dom: MapLike<string, DOMDefinition>;
export const elementRoles: MapLike<ARIARoleRelationConcept, Set<ARIARoleDefinitionKey>>;
export const roles: MapLike<ARIARoleDefinitionKey, ARIARoleDefinition>;
export const roleElements: MapLike<ARIARoleDefinitionKey, Set<ARIARoleRelationConcept>>;

// types
export type ARIAAbstractRole =
    | "command"
    | "composite"
    | "input"
    | "landmark"
    | "range"
    | "roletype"
    | "section"
    | "sectionhead"
    | "select"
    | "structure"
    | "widget"
    | "window";

export type ARIAWidgetRole =
    | "button"
    | "checkbox"
    | "gridcell"
    | "link"
    | "menuitem"
    | "menuitemcheckbox"
    | "menuitemradio"
    | "option"
    | "progressbar"
    | "radio"
    | "scrollbar"
    | "searchbox"
    | "slider"
    | "spinbutton"
    | "switch"
    | "tab"
    | "tabpanel"
    | "textbox"
    | "treeitem";

export type ARIACompositeWidgetRole =
    | "combobox"
    | "grid"
    | "listbox"
    | "menu"
    | "menubar"
    | "radiogroup"
    | "tablist"
    | "tree"
    | "treegrid";

export type ARIADocumentStructureRole =
    | "application"
    | "article"
    | "blockquote"
    | "caption"
    | "cell"
    | "columnheader"
    | "definition"
    | "deletion"
    | "directory"
    | "document"
    | "emphasis"
    | "feed"
    | "figure"
    | "generic"
    | "group"
    | "heading"
    | "img"
    | "insertion"
    | "list"
    | "listitem"
    | "math"
    | "meter"
    | "none"
    | "note"
    | "paragraph"
    | "presentation"
    | "row"
    | "rowgroup"
    | "rowheader"
    | "separator"
    | "strong"
    | "subscript"
    | "superscript"
    | "table"
    | "term"
    | "time"
    | "toolbar"
    | "tooltip";

export type ARIALandmarkRole =
    | "banner"
    | "complementary"
    | "contentinfo"
    | "form"
    | "main"
    | "navigation"
    | "region"
    | "search";

export type ARIALiveRegionRole = "alert" | "log" | "marquee" | "status" | "timer";

export type ARIAWindowRole = "alertdialog" | "dialog";

export type ARIAUncategorizedRole = "code";

export type ARIADPubRole =
    | "doc-abstract"
    | "doc-acknowledgments"
    | "doc-afterword"
    | "doc-appendix"
    | "doc-backlink"
    | "doc-biblioentry"
    | "doc-bibliography"
    | "doc-biblioref"
    | "doc-chapter"
    | "doc-colophon"
    | "doc-conclusion"
    | "doc-cover"
    | "doc-credit"
    | "doc-credits"
    | "doc-dedication"
    | "doc-endnote"
    | "doc-endnotes"
    | "doc-epigraph"
    | "doc-epilogue"
    | "doc-errata"
    | "doc-example"
    | "doc-footnote"
    | "doc-foreword"
    | "doc-glossary"
    | "doc-glossref"
    | "doc-index"
    | "doc-introduction"
    | "doc-noteref"
    | "doc-notice"
    | "doc-pagebreak"
    | "doc-pagelist"
    | "doc-part"
    | "doc-preface"
    | "doc-prologue"
    | "doc-pullquote"
    | "doc-qna"
    | "doc-subtitle"
    | "doc-tip"
    | "doc-toc";

export type ARIARole =
    | ARIAWidgetRole
    | ARIACompositeWidgetRole
    | ARIADocumentStructureRole
    | ARIALandmarkRole
    | ARIALiveRegionRole
    | ARIAWindowRole
    | ARIAUncategorizedRole;

export interface ARIARoleDefinition {
    /* Abstract roles may not be used in HTML. */
    abstract: boolean;
    /* The concepts in related domains that inform behavior mappings. */
    baseConcepts: ARIARoleRelation[];
    /* Child presentational roles strip child nodes of roles and flatten the
     * content to text. */
    childrenPresentational: boolean;
    /* aria-* properties and states disallowed on this role. */
    prohibitedProps: ARIAPropertyMap;
    /* aria-* properties and states allowed on this role. */
    props: ARIAPropertyMap;
    /* The concepts in related domains that inform behavior mappings. */
    relatedConcepts: ARIARoleRelation[];
    /* aria-* properties and states required on this role. */
    requiredProps: ARIAPropertyMap;
    /* An array or super class "stacks." Each stack contains a LIFO list of
     * strings correspond to a super class in the inheritance chain of this
     * role. Roles may have more than one inheritance chain, which is why
     * this property is an array of arrays and not a single array. */
    superClass: Array<Array<ARIAAbstractRole | ARIARole | ARIADPubRole>>;
}

export type ARIAState =
    | "aria-busy"
    | "aria-checked"
    | "aria-disabled"
    | "aria-expanded"
    | "aria-grabbed"
    | "aria-hidden"
    | "aria-invalid"
    | "aria-pressed"
    | "aria-selected";

export type ARIAProperty =
    | "aria-activedescendant"
    | "aria-atomic"
    | "aria-autocomplete"
    | "aria-colcount"
    | "aria-colindex"
    | "aria-colspan"
    | "aria-controls"
    | "aria-current"
    | "aria-describedby"
    | "aria-details"
    | "aria-dropeffect"
    | "aria-errormessage"
    | "aria-flowto"
    | "aria-haspopup"
    | "aria-keyshortcuts"
    | "aria-label"
    | "aria-labelledby"
    | "aria-level"
    | "aria-live"
    | "aria-modal"
    | "aria-multiline"
    | "aria-multiselectable"
    | "aria-orientation"
    | "aria-owns"
    | "aria-placeholder"
    | "aria-posinset"
    | "aria-readonly"
    | "aria-relevant"
    | "aria-required"
    | "aria-roledescription"
    | "aria-rowcount"
    | "aria-rowindex"
    | "aria-rowspan"
    | "aria-setsize"
    | "aria-sort"
    | "aria-valuemax"
    | "aria-valuemin"
    | "aria-valuenow"
    | "aria-valuetext"
    | ARIAState;

export interface ARIAPropertyMap {
    "aria-busy"?: unknown | undefined;
    "aria-checked"?: unknown | undefined;
    "aria-disabled"?: unknown | undefined;
    "aria-expanded"?: unknown | undefined;
    "aria-grabbed"?: unknown | undefined;
    "aria-hidden"?: unknown | undefined;
    "aria-invalid"?: unknown | undefined;
    "aria-pressed"?: unknown | undefined;
    "aria-selected"?: unknown | undefined;
    "aria-activedescendant"?: unknown | undefined;
    "aria-atomic"?: unknown | undefined;
    "aria-autocomplete"?: unknown | undefined;
    "aria-colcount"?: unknown | undefined;
    "aria-colindex"?: unknown | undefined;
    "aria-colspan"?: unknown | undefined;
    "aria-controls"?: unknown | undefined;
    "aria-current"?: ARIAPropertyCurrent | null | undefined;
    "aria-describedat"?: unknown | undefined;
    "aria-describedby"?: unknown | undefined;
    "aria-details"?: unknown | undefined;
    "aria-dropeffect"?: unknown | undefined;
    "aria-errormessage"?: unknown | undefined;
    "aria-flowto"?: unknown | undefined;
    "aria-haspopup"?: unknown | undefined;
    "aria-keyshortcuts"?: unknown | undefined;
    "aria-label"?: unknown | undefined;
    "aria-labelledby"?: unknown | undefined;
    "aria-level"?: unknown | undefined;
    "aria-live"?: unknown | undefined;
    "aria-modal"?: unknown | undefined;
    "aria-multiline"?: unknown | undefined;
    "aria-multiselectable"?: unknown | undefined;
    "aria-orientation"?: unknown | undefined;
    "aria-owns"?: unknown | undefined;
    "aria-placeholder"?: unknown | undefined;
    "aria-posinset"?: unknown | undefined;
    "aria-readonly"?: unknown | undefined;
    "aria-relevant"?: unknown | undefined;
    "aria-required"?: unknown | undefined;
    "aria-roledescription"?: unknown | undefined;
    "aria-rowcount"?: unknown | undefined;
    "aria-rowindex"?: unknown | undefined;
    "aria-rowspan"?: unknown | undefined;
    "aria-setsize"?: unknown | undefined;
    "aria-sort"?: unknown | undefined;
    "aria-valuemax"?: unknown | undefined;
    "aria-valuemin"?: unknown | undefined;
    "aria-valuenow"?: unknown | undefined;
    "aria-valuetext"?: unknown | undefined;
}

export interface ARIAPropertyDefinition {
    type: "string" | "id" | "idlist" | "integer" | "number" | "boolean" | "token" | "tokenlist" | "tristate";
    values?: Array<string | boolean> | undefined;
    allowundefined?: boolean | undefined;
}

export type ARIAPropertyCurrent = "page" | "step" | "location" | "date" | "time" | "true" | "false" | true | false;

export interface ARIARoleRelation {
    module?: string | undefined;
    concept?: ARIARoleRelationConcept | undefined;
}

/* The concept in a related domain that informs behavior mappings.
 * Related domains include: HTML, "Device Independence Delivery Unit", XForms,
 * and ARIA to name a few. */
export interface ARIARoleRelationConcept {
    name: string;
    attributes?: ARIARoleRelationConceptAttribute[] | undefined;
    // These constraints are drawn from the mapping between ARIA and HTML:
    // https://www.w3.org/TR/html-aria
    constraints?:
        | Array<
            | "direct descendant of document"
            | "direct descendant of ol, ul or menu"
            | "direct descendant of details element with the open attribute defined"
            | "descendant of table"
        >
        | undefined;
}

export interface ARIARoleRelationConceptAttribute {
    name: string;
    value?: string | number | undefined;
    // These constraints are drawn from the mapping between ARIA and HTML:
    // https://www.w3.org/TR/html-aria
    constraints?: Array<"unset" | ">1"> | undefined;
}


---

File name: node_modules\@types\aria-query\package.json

Code:
{
    "name": "@types/aria-query",
    "version": "5.0.4",
    "description": "TypeScript definitions for aria-query",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/aria-query",
    "license": "MIT",
    "contributors": [
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/aria-query"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "df81e762ea003d46edaa1ce65e6e72487611400664e3105baa1610186c630902",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\aria-query\README.md

Code:
# Installation
> `npm install --save @types/aria-query`

# Summary
This package contains type definitions for aria-query (https://github.com/A11yance/aria-query#readme).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/aria-query.

### Additional Details
 * Last updated: Mon, 06 Nov 2023 22:41:04 GMT
 * Dependencies: none

# Credits
These definitions were written by [Sebastian Silbermann](https://github.com/eps1lon).


---

File name: node_modules\@types\babel__core\index.d.ts

Code:
import { GeneratorOptions } from "@babel/generator";
import { ParserOptions } from "@babel/parser";
import template from "@babel/template";
import traverse, { Hub, NodePath, Scope, Visitor } from "@babel/traverse";
import * as t from "@babel/types";

export { GeneratorOptions, NodePath, ParserOptions, t as types, template, traverse, Visitor };

export type Node = t.Node;
export type ParseResult = ReturnType<typeof import("@babel/parser").parse>;
export const version: string;
export const DEFAULT_EXTENSIONS: [".js", ".jsx", ".es6", ".es", ".mjs"];

/**
 * Source map standard format as to revision 3
 * @see {@link https://sourcemaps.info/spec.html}
 * @see {@link https://github.com/mozilla/source-map/blob/HEAD/source-map.d.ts}
 */
interface InputSourceMap {
    version: number;
    sources: string[];
    names: string[];
    sourceRoot?: string | undefined;
    sourcesContent?: string[] | undefined;
    mappings: string;
    file: string;
}

export interface TransformOptions {
    /**
     * Specify which assumptions it can make about your code, to better optimize the compilation result. **NOTE**: This replaces the various `loose` options in plugins in favor of
     * top-level options that can apply to multiple plugins
     *
     * @see https://babeljs.io/docs/en/assumptions
     */
    assumptions?: { [name: string]: boolean } | null | undefined;

    /**
     * Include the AST in the returned object
     *
     * Default: `false`
     */
    ast?: boolean | null | undefined;

    /**
     * Attach a comment after all non-user injected code
     *
     * Default: `null`
     */
    auxiliaryCommentAfter?: string | null | undefined;

    /**
     * Attach a comment before all non-user injected code
     *
     * Default: `null`
     */
    auxiliaryCommentBefore?: string | null | undefined;

    /**
     * Specify the "root" folder that defines the location to search for "babel.config.js", and the default folder to allow `.babelrc` files inside of.
     *
     * Default: `"."`
     */
    root?: string | null | undefined;

    /**
     * This option, combined with the "root" value, defines how Babel chooses its project root.
     * The different modes define different ways that Babel can process the "root" value to get
     * the final project root.
     *
     * @see https://babeljs.io/docs/en/next/options#rootmode
     */
    rootMode?: "root" | "upward" | "upward-optional" | undefined;

    /**
     * The config file to load Babel's config from. Defaults to searching for "babel.config.js" inside the "root" folder. `false` will disable searching for config files.
     *
     * Default: `undefined`
     */
    configFile?: string | boolean | null | undefined;

    /**
     * Specify whether or not to use .babelrc and
     * .babelignore files.
     *
     * Default: `true`
     */
    babelrc?: boolean | null | undefined;

    /**
     * Specify which packages should be search for .babelrc files when they are being compiled. `true` to always search, or a path string or an array of paths to packages to search
     * inside of. Defaults to only searching the "root" package.
     *
     * Default: `(root)`
     */
    babelrcRoots?: boolean | MatchPattern | MatchPattern[] | null | undefined;

    /**
     * Toggles whether or not browserslist config sources are used, which includes searching for any browserslist files or referencing the browserslist key inside package.json.
     * This is useful for projects that use a browserslist config for files that won't be compiled with Babel.
     *
     * If a string is specified, it must represent the path of a browserslist configuration file. Relative paths are resolved relative to the configuration file which specifies
     * this option, or to `cwd` when it's passed as part of the programmatic options.
     *
     * Default: `true`
     */
    browserslistConfigFile?: boolean | null | undefined;

    /**
     * The Browserslist environment to use.
     *
     * Default: `undefined`
     */
    browserslistEnv?: string | null | undefined;

    /**
     * By default `babel.transformFromAst` will clone the input AST to avoid mutations.
     * Specifying `cloneInputAst: false` can improve parsing performance if the input AST is not used elsewhere.
     *
     * Default: `true`
     */
    cloneInputAst?: boolean | null | undefined;

    /**
     * Defaults to environment variable `BABEL_ENV` if set, or else `NODE_ENV` if set, or else it defaults to `"development"`
     *
     * Default: env vars
     */
    envName?: string | undefined;

    /**
     * If any of patterns match, the current configuration object is considered inactive and is ignored during config processing.
     */
    exclude?: MatchPattern | MatchPattern[] | undefined;

    /**
     * Enable code generation
     *
     * Default: `true`
     */
    code?: boolean | null | undefined;

    /**
     * Output comments in generated output
     *
     * Default: `true`
     */
    comments?: boolean | null | undefined;

    /**
     * Do not include superfluous whitespace characters and line terminators. When set to `"auto"` compact is set to `true` on input sizes of >500KB
     *
     * Default: `"auto"`
     */
    compact?: boolean | "auto" | null | undefined;

    /**
     * The working directory that Babel's programmatic options are loaded relative to.
     *
     * Default: `"."`
     */
    cwd?: string | null | undefined;

    /**
     * Utilities may pass a caller object to identify themselves to Babel and
     * pass capability-related flags for use by configs, presets and plugins.
     *
     * @see https://babeljs.io/docs/en/next/options#caller
     */
    caller?: TransformCaller | undefined;

    /**
     * This is an object of keys that represent different environments. For example, you may have: `{ env: { production: { \/* specific options *\/ } } }`
     * which will use those options when the `envName` is `production`
     *
     * Default: `{}`
     */
    env?: { [index: string]: TransformOptions | null | undefined } | null | undefined;

    /**
     * A path to a `.babelrc` file to extend
     *
     * Default: `null`
     */
    extends?: string | null | undefined;

    /**
     * Filename for use in errors etc
     *
     * Default: `"unknown"`
     */
    filename?: string | null | undefined;

    /**
     * Filename relative to `sourceRoot`
     *
     * Default: `(filename)`
     */
    filenameRelative?: string | null | undefined;

    /**
     * An object containing the options to be passed down to the babel code generator, @babel/generator
     *
     * Default: `{}`
     */
    generatorOpts?: GeneratorOptions | null | undefined;

    /**
     * Specify a custom callback to generate a module id with. Called as `getModuleId(moduleName)`. If falsy value is returned then the generated module id is used
     *
     * Default: `null`
     */
    getModuleId?: ((moduleName: string) => string | null | undefined) | null | undefined;

    /**
     * ANSI highlight syntax error code frames
     *
     * Default: `true`
     */
    highlightCode?: boolean | null | undefined;

    /**
     * Opposite to the `only` option. `ignore` is disregarded if `only` is specified
     *
     * Default: `null`
     */
    ignore?: MatchPattern[] | null | undefined;

    /**
     * This option is a synonym for "test"
     */
    include?: MatchPattern | MatchPattern[] | undefined;

    /**
     * A source map object that the output source map will be based on
     *
     * Default: `null`
     */
    inputSourceMap?: InputSourceMap | null | undefined;

    /**
     * Should the output be minified (not printing last semicolons in blocks, printing literal string values instead of escaped ones, stripping `()` from `new` when safe)
     *
     * Default: `false`
     */
    minified?: boolean | null | undefined;

    /**
     * Specify a custom name for module ids
     *
     * Default: `null`
     */
    moduleId?: string | null | undefined;

    /**
     * If truthy, insert an explicit id for modules. By default, all modules are anonymous. (Not available for `common` modules)
     *
     * Default: `false`
     */
    moduleIds?: boolean | null | undefined;

    /**
     * Optional prefix for the AMD module formatter that will be prepend to the filename on module definitions
     *
     * Default: `(sourceRoot)`
     */
    moduleRoot?: string | null | undefined;

    /**
     * A glob, regex, or mixed array of both, matching paths to **only** compile. Can also be an array of arrays containing paths to explicitly match. When attempting to compile
     * a non-matching file it's returned verbatim
     *
     * Default: `null`
     */
    only?: MatchPattern[] | null | undefined;

    /**
     * Allows users to provide an array of options that will be merged into the current configuration one at a time.
     * This feature is best used alongside the "test"/"include"/"exclude" options to provide conditions for which an override should apply
     */
    overrides?: TransformOptions[] | undefined;

    /**
     * An object containing the options to be passed down to the babel parser, @babel/parser
     *
     * Default: `{}`
     */
    parserOpts?: ParserOptions | null | undefined;

    /**
     * List of plugins to load and use
     *
     * Default: `[]`
     */
    plugins?: PluginItem[] | null | undefined;

    /**
     * List of presets (a set of plugins) to load and use
     *
     * Default: `[]`
     */
    presets?: PluginItem[] | null | undefined;

    /**
     * Retain line numbers. This will lead to wacky code but is handy for scenarios where you can't use source maps. (**NOTE**: This will not retain the columns)
     *
     * Default: `false`
     */
    retainLines?: boolean | null | undefined;

    /**
     * An optional callback that controls whether a comment should be output or not. Called as `shouldPrintComment(commentContents)`. **NOTE**: This overrides the `comment` option when used
     *
     * Default: `null`
     */
    shouldPrintComment?: ((commentContents: string) => boolean) | null | undefined;

    /**
     * Set `sources[0]` on returned source map
     *
     * Default: `(filenameRelative)`
     */
    sourceFileName?: string | null | undefined;

    /**
     * If truthy, adds a `map` property to returned output. If set to `"inline"`, a comment with a sourceMappingURL directive is added to the bottom of the returned code. If set to `"both"`
     * then a `map` property is returned as well as a source map comment appended. **This does not emit sourcemap files by itself!**
     *
     * Default: `false`
     */
    sourceMaps?: boolean | "inline" | "both" | null | undefined;

    /**
     * The root from which all sources are relative
     *
     * Default: `(moduleRoot)`
     */
    sourceRoot?: string | null | undefined;

    /**
     * Indicate the mode the code should be parsed in. Can be one of "script", "module", or "unambiguous". `"unambiguous"` will make Babel attempt to guess, based on the presence of ES6
     * `import` or `export` statements. Files with ES6 `import`s and `export`s are considered `"module"` and are otherwise `"script"`.
     *
     * Default: `("module")`
     */
    sourceType?: "script" | "module" | "unambiguous" | null | undefined;

    /**
     * If all patterns fail to match, the current configuration object is considered inactive and is ignored during config processing.
     */
    test?: MatchPattern | MatchPattern[] | undefined;

    /**
     * Describes the environments you support/target for your project.
     * This can either be a [browserslist-compatible](https://github.com/ai/browserslist) query (with [caveats](https://babeljs.io/docs/en/babel-preset-env#ineffective-browserslist-queries))
     *
     * Default: `{}`
     */
    targets?:
        | string
        | string[]
        | {
            esmodules?: boolean;
            node?: Omit<string, "current"> | "current" | true;
            safari?: Omit<string, "tp"> | "tp";
            browsers?: string | string[];
            android?: string;
            chrome?: string;
            deno?: string;
            edge?: string;
            electron?: string;
            firefox?: string;
            ie?: string;
            ios?: string;
            opera?: string;
            rhino?: string;
            samsung?: string;
        };

    /**
     * An optional callback that can be used to wrap visitor methods. **NOTE**: This is useful for things like introspection, and not really needed for implementing anything. Called as
     * `wrapPluginVisitorMethod(pluginAlias, visitorType, callback)`.
     */
    wrapPluginVisitorMethod?:
        | ((
            pluginAlias: string,
            visitorType: "enter" | "exit",
            callback: (path: NodePath, state: any) => void,
        ) => (path: NodePath, state: any) => void)
        | null
        | undefined;
}

export interface TransformCaller {
    // the only required property
    name: string;
    // e.g. set to true by `babel-loader` and false by `babel-jest`
    supportsStaticESM?: boolean | undefined;
    supportsDynamicImport?: boolean | undefined;
    supportsExportNamespaceFrom?: boolean | undefined;
    supportsTopLevelAwait?: boolean | undefined;
    // augment this with a "declare module '@babel/core' { ... }" if you need more keys
}

export type FileResultCallback = (err: Error | null, result: BabelFileResult | null) => any;

export interface MatchPatternContext {
    envName: string;
    dirname: string;
    caller: TransformCaller | undefined;
}
export type MatchPattern = string | RegExp | ((filename: string | undefined, context: MatchPatternContext) => boolean);

/**
 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
 */
export function transform(code: string, callback: FileResultCallback): void;

/**
 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
 */
export function transform(code: string, opts: TransformOptions | undefined, callback: FileResultCallback): void;

/**
 * Here for backward-compatibility. Ideally use `transformSync` if you want a synchronous API.
 */
export function transform(code: string, opts?: TransformOptions): BabelFileResult | null;

/**
 * Transforms the passed in code. Returning an object with the generated code, source map, and AST.
 */
export function transformSync(code: string, opts?: TransformOptions): BabelFileResult | null;

/**
 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
 */
export function transformAsync(code: string, opts?: TransformOptions): Promise<BabelFileResult | null>;

/**
 * Asynchronously transforms the entire contents of a file.
 */
export function transformFile(filename: string, callback: FileResultCallback): void;

/**
 * Asynchronously transforms the entire contents of a file.
 */
export function transformFile(filename: string, opts: TransformOptions | undefined, callback: FileResultCallback): void;

/**
 * Synchronous version of `babel.transformFile`. Returns the transformed contents of the `filename`.
 */
export function transformFileSync(filename: string, opts?: TransformOptions): BabelFileResult | null;

/**
 * Asynchronously transforms the entire contents of a file.
 */
export function transformFileAsync(filename: string, opts?: TransformOptions): Promise<BabelFileResult | null>;

/**
 * Given an AST, transform it.
 */
export function transformFromAst(ast: Node, code: string | undefined, callback: FileResultCallback): void;

/**
 * Given an AST, transform it.
 */
export function transformFromAst(
    ast: Node,
    code: string | undefined,
    opts: TransformOptions | undefined,
    callback: FileResultCallback,
): void;

/**
 * Here for backward-compatibility. Ideally use ".transformSync" if you want a synchronous API.
 */
export function transformFromAstSync(ast: Node, code?: string, opts?: TransformOptions): BabelFileResult | null;

/**
 * Given an AST, transform it.
 */
export function transformFromAstAsync(
    ast: Node,
    code?: string,
    opts?: TransformOptions,
): Promise<BabelFileResult | null>;

// A babel plugin is a simple function which must return an object matching
// the following interface. Babel will throw if it finds unknown properties.
// The list of allowed plugin keys is here:
// https://github.com/babel/babel/blob/4e50b2d9d9c376cee7a2cbf56553fe5b982ea53c/packages/babel-core/src/config/option-manager.js#L71
export interface PluginObj<S = PluginPass> {
    name?: string | undefined;
    manipulateOptions?(opts: any, parserOpts: any): void;
    pre?(this: S, file: BabelFile): void;
    visitor: Visitor<S>;
    post?(this: S, file: BabelFile): void;
    inherits?: any;
}

export interface BabelFile {
    ast: t.File;
    opts: TransformOptions;
    hub: Hub;
    metadata: object;
    path: NodePath<t.Program>;
    scope: Scope;
    inputMap: object | null;
    code: string;
}

export interface PluginPass {
    file: BabelFile;
    key: string;
    opts: object;
    cwd: string;
    filename: string | undefined;
    get(key: unknown): any;
    set(key: unknown, value: unknown): void;
    [key: string]: unknown;
}

export interface BabelFileResult {
    ast?: t.File | null | undefined;
    code?: string | null | undefined;
    ignored?: boolean | undefined;
    map?:
        | {
            version: number;
            sources: string[];
            names: string[];
            sourceRoot?: string | undefined;
            sourcesContent?: string[] | undefined;
            mappings: string;
            file: string;
        }
        | null
        | undefined;
    metadata?: BabelFileMetadata | undefined;
}

export interface BabelFileMetadata {
    usedHelpers: string[];
    marked: Array<{
        type: string;
        message: string;
        loc: object;
    }>;
    modules: BabelFileModulesMetadata;
}

export interface BabelFileModulesMetadata {
    imports: object[];
    exports: {
        exported: object[];
        specifiers: object[];
    };
}

export type FileParseCallback = (err: Error | null, result: ParseResult | null) => any;

/**
 * Given some code, parse it using Babel's standard behavior.
 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
 */
export function parse(code: string, callback: FileParseCallback): void;

/**
 * Given some code, parse it using Babel's standard behavior.
 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
 */
export function parse(code: string, options: TransformOptions | undefined, callback: FileParseCallback): void;

/**
 * Given some code, parse it using Babel's standard behavior.
 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
 */
export function parse(code: string, options?: TransformOptions): ParseResult | null;

/**
 * Given some code, parse it using Babel's standard behavior.
 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
 */
export function parseSync(code: string, options?: TransformOptions): ParseResult | null;

/**
 * Given some code, parse it using Babel's standard behavior.
 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
 */
export function parseAsync(code: string, options?: TransformOptions): Promise<ParseResult | null>;

/**
 * Resolve Babel's options fully, resulting in an options object where:
 *
 * * opts.plugins is a full list of Plugin instances.
 * * opts.presets is empty and all presets are flattened into opts.
 * * It can be safely passed back to Babel. Fields like babelrc have been set to false so that later calls to Babel
 * will not make a second attempt to load config files.
 *
 * Plugin instances aren't meant to be manipulated directly, but often callers will serialize this opts to JSON to
 * use it as a cache key representing the options Babel has received. Caching on this isn't 100% guaranteed to
 * invalidate properly, but it is the best we have at the moment.
 */
export function loadOptions(options?: TransformOptions): object | null;

/**
 * To allow systems to easily manipulate and validate a user's config, this function resolves the plugins and
 * presets and proceeds no further. The expectation is that callers will take the config's .options, manipulate it
 * as then see fit and pass it back to Babel again.
 *
 * * `babelrc: string | void` - The path of the `.babelrc` file, if there was one.
 * * `babelignore: string | void` - The path of the `.babelignore` file, if there was one.
 * * `options: ValidatedOptions` - The partially resolved options, which can be manipulated and passed back
 * to Babel again.
 *  * `plugins: Array<ConfigItem>` - See below.
 *  * `presets: Array<ConfigItem>` - See below.
 *  * It can be safely passed back to Babel. Fields like `babelrc` have been set to false so that later calls to
 * Babel will not make a second attempt to load config files.
 *
 * `ConfigItem` instances expose properties to introspect the values, but each item should be treated as
 * immutable. If changes are desired, the item should be removed from the list and replaced with either a normal
 * Babel config value, or with a replacement item created by `babel.createConfigItem`. See that function for
 * information about `ConfigItem` fields.
 */
export function loadPartialConfig(options?: TransformOptions): Readonly<PartialConfig> | null;
export function loadPartialConfigAsync(options?: TransformOptions): Promise<Readonly<PartialConfig> | null>;

export interface PartialConfig {
    options: TransformOptions;
    babelrc?: string | undefined;
    babelignore?: string | undefined;
    config?: string | undefined;
    hasFilesystemConfig: () => boolean;
}

export interface ConfigItem {
    /**
     * The name that the user gave the plugin instance, e.g. `plugins: [ ['env', {}, 'my-env'] ]`
     */
    name?: string | undefined;

    /**
     * The resolved value of the plugin.
     */
    value: object | ((...args: any[]) => any);

    /**
     * The options object passed to the plugin.
     */
    options?: object | false | undefined;

    /**
     * The path that the options are relative to.
     */
    dirname: string;

    /**
     * Information about the plugin's file, if Babel knows it.
     *  *
     */
    file?:
        | {
            /**
             * The file that the user requested, e.g. `"@babel/env"`
             */
            request: string;

            /**
             * The full path of the resolved file, e.g. `"/tmp/node_modules/@babel/preset-env/lib/index.js"`
             */
            resolved: string;
        }
        | null
        | undefined;
}

export type PluginOptions = object | undefined | false;

export type PluginTarget = string | object | ((...args: any[]) => any);

export type PluginItem =
    | ConfigItem
    | PluginObj<any>
    | PluginTarget
    | [PluginTarget, PluginOptions]
    | [PluginTarget, PluginOptions, string | undefined];

export function resolvePlugin(name: string, dirname: string): string | null;
export function resolvePreset(name: string, dirname: string): string | null;

export interface CreateConfigItemOptions {
    dirname?: string | undefined;
    type?: "preset" | "plugin" | undefined;
}

/**
 * Allows build tooling to create and cache config items up front. If this function is called multiple times for a
 * given plugin, Babel will call the plugin's function itself multiple times. If you have a clear set of expected
 * plugins and presets to inject, pre-constructing the config items would be recommended.
 */
export function createConfigItem(
    value: PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | undefined],
    options?: CreateConfigItemOptions,
): ConfigItem;

// NOTE: the documentation says the ConfigAPI also exposes @babel/core's exports, but it actually doesn't
/**
 * @see https://babeljs.io/docs/en/next/config-files#config-function-api
 */
export interface ConfigAPI {
    /**
     * The version string for the Babel version that is loading the config file.
     *
     * @see https://babeljs.io/docs/en/next/config-files#apiversion
     */
    version: string;
    /**
     * @see https://babeljs.io/docs/en/next/config-files#apicache
     */
    cache: SimpleCacheConfigurator;
    /**
     * @see https://babeljs.io/docs/en/next/config-files#apienv
     */
    env: EnvFunction;
    // undocumented; currently hardcoded to return 'false'
    // async(): boolean
    /**
     * This API is used as a way to access the `caller` data that has been passed to Babel.
     * Since many instances of Babel may be running in the same process with different `caller` values,
     * this API is designed to automatically configure `api.cache`, the same way `api.env()` does.
     *
     * The `caller` value is available as the first parameter of the callback function.
     * It is best used with something like this to toggle configuration behavior
     * based on a specific environment:
     *
     * @example
     * function isBabelRegister(caller?: { name: string }) {
     *   return !!(caller && caller.name === "@babel/register")
     * }
     * api.caller(isBabelRegister)
     *
     * @see https://babeljs.io/docs/en/next/config-files#apicallercb
     */
    caller<T extends SimpleCacheKey>(callerCallback: (caller: TransformOptions["caller"]) => T): T;
    /**
     * While `api.version` can be useful in general, it's sometimes nice to just declare your version.
     * This API exposes a simple way to do that with:
     *
     * @example
     * api.assertVersion(7) // major version only
     * api.assertVersion("^7.2")
     *
     * @see https://babeljs.io/docs/en/next/config-files#apiassertversionrange
     */
    assertVersion(versionRange: number | string): boolean;
    // NOTE: this is an undocumented reexport from "@babel/parser" but it's missing from its types
    // tokTypes: typeof tokTypes
}

/**
 * JS configs are great because they can compute a config on the fly,
 * but the downside there is that it makes caching harder.
 * Babel wants to avoid re-executing the config function every time a file is compiled,
 * because then it would also need to re-execute any plugin and preset functions
 * referenced in that config.
 *
 * To avoid this, Babel expects users of config functions to tell it how to manage caching
 * within a config file.
 *
 * @see https://babeljs.io/docs/en/next/config-files#apicache
 */
export interface SimpleCacheConfigurator {
    // there is an undocumented call signature that is a shorthand for forever()/never()/using().
    // (ever: boolean): void
    // <T extends SimpleCacheKey>(callback: CacheCallback<T>): T
    /**
     * Permacache the computed config and never call the function again.
     */
    forever(): void;
    /**
     * Do not cache this config, and re-execute the function every time.
     */
    never(): void;
    /**
     * Any time the using callback returns a value other than the one that was expected,
     * the overall config function will be called again and a new entry will be added to the cache.
     *
     * @example
     * api.cache.using(() => process.env.NODE_ENV)
     */
    using<T extends SimpleCacheKey>(callback: SimpleCacheCallback<T>): T;
    /**
     * Any time the using callback returns a value other than the one that was expected,
     * the overall config function will be called again and all entries in the cache will
     * be replaced with the result.
     *
     * @example
     * api.cache.invalidate(() => process.env.NODE_ENV)
     */
    invalidate<T extends SimpleCacheKey>(callback: SimpleCacheCallback<T>): T;
}

// https://github.com/babel/babel/blob/v7.3.3/packages/babel-core/src/config/caching.js#L231
export type SimpleCacheKey = string | boolean | number | null | undefined;
export type SimpleCacheCallback<T extends SimpleCacheKey> = () => T;

/**
 * Since `NODE_ENV` is a fairly common way to toggle behavior, Babel also includes an API function
 * meant specifically for that. This API is used as a quick way to check the `"envName"` that Babel
 * was loaded with, which takes `NODE_ENV` into account if no other overriding environment is set.
 *
 * @see https://babeljs.io/docs/en/next/config-files#apienv
 */
export interface EnvFunction {
    /**
     * @returns the current `envName` string
     */
    (): string;
    /**
     * @returns `true` if the `envName` is `===` any of the given strings
     */
    (envName: string | readonly string[]): boolean;
    // the official documentation is misleading for this one...
    // this just passes the callback to `cache.using` but with an additional argument.
    // it returns its result instead of necessarily returning a boolean.
    <T extends SimpleCacheKey>(envCallback: (envName: NonNullable<TransformOptions["envName"]>) => T): T;
}

export type ConfigFunction = (api: ConfigAPI) => TransformOptions;

export as namespace babel;


---

File name: node_modules\@types\babel__core\package.json

Code:
{
    "name": "@types/babel__core",
    "version": "7.20.5",
    "description": "TypeScript definitions for @babel/core",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__core",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Jessica Franco",
            "githubUsername": "Jessidhia",
            "url": "https://github.com/Jessidhia"
        },
        {
            "name": "Ifiok Jr.",
            "githubUsername": "ifiokjr",
            "url": "https://github.com/ifiokjr"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__core"
    },
    "scripts": {},
    "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
    },
    "typesPublisherContentHash": "3ece429b02ff9f70503a5644f2b303b04d10e6da7940c91a9eff5e52f2c76b91",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\babel__core\README.md

Code:
# Installation
> `npm install --save @types/babel__core`

# Summary
This package contains type definitions for @babel/core (https://github.com/babel/babel/tree/master/packages/babel-core).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__core.

### Additional Details
 * Last updated: Mon, 20 Nov 2023 23:36:23 GMT
 * Dependencies: [@babel/parser](https://npmjs.com/package/@babel/parser), [@babel/types](https://npmjs.com/package/@babel/types), [@types/babel__generator](https://npmjs.com/package/@types/babel__generator), [@types/babel__template](https://npmjs.com/package/@types/babel__template), [@types/babel__traverse](https://npmjs.com/package/@types/babel__traverse)

# Credits
These definitions were written by [Troy Gerwien](https://github.com/yortus), [Marvin Hagemeister](https://github.com/marvinhagemeister), [Melvin Groenhoff](https://github.com/mgroenhoff), [Jessica Franco](https://github.com/Jessidhia), and [Ifiok Jr.](https://github.com/ifiokjr).


---

File name: node_modules\@types\babel__generator\index.d.ts

Code:
import * as t from "@babel/types";

export interface GeneratorOptions {
    /**
     * Optional string to add as a block comment at the start of the output file.
     */
    auxiliaryCommentBefore?: string | undefined;

    /**
     * Optional string to add as a block comment at the end of the output file.
     */
    auxiliaryCommentAfter?: string | undefined;

    /**
     * Function that takes a comment (as a string) and returns true if the comment should be included in the output.
     * By default, comments are included if `opts.comments` is `true` or if `opts.minifed` is `false` and the comment
     * contains `@preserve` or `@license`.
     */
    shouldPrintComment?(comment: string): boolean;

    /**
     * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).
     * Defaults to `false`.
     */
    retainLines?: boolean | undefined;

    /**
     * Retain parens around function expressions (could be used to change engine parsing behavior)
     * Defaults to `false`.
     */
    retainFunctionParens?: boolean | undefined;

    /**
     * Should comments be included in output? Defaults to `true`.
     */
    comments?: boolean | undefined;

    /**
     * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.
     */
    compact?: boolean | "auto" | undefined;

    /**
     * Should the output be minified. Defaults to `false`.
     */
    minified?: boolean | undefined;

    /**
     * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.
     */
    concise?: boolean | undefined;

    /**
     * Used in warning messages
     */
    filename?: string | undefined;

    /**
     * Enable generating source maps. Defaults to `false`.
     */
    sourceMaps?: boolean | undefined;

    /**
     * A root for all relative URLs in the source map.
     */
    sourceRoot?: string | undefined;

    /**
     * The filename for the source code (i.e. the code in the `code` argument).
     * This will only be used if `code` is a string.
     */
    sourceFileName?: string | undefined;

    /**
     * Set to true to run jsesc with "json": true to print "\u00A9" vs. "©";
     */
    jsonCompatibleStrings?: boolean | undefined;

    /**
     * Set to true to enable support for experimental decorators syntax before module exports.
     * Defaults to `false`.
     */
    decoratorsBeforeExport?: boolean | undefined;

    /**
     * The import attributes/assertions syntax to use.
     * When not specified, @babel/generator will try to match the style in the input code based on the AST shape.
     */
    importAttributesKeyword?: "with" | "assert" | "with-legacy";

    /**
     * Options for outputting jsesc representation.
     */
    jsescOption?: {
        /**
         * The default value for the quotes option is 'single'. This means that any occurrences of ' in the input
         * string are escaped as \', so that the output can be used in a string literal wrapped in single quotes.
         */
        quotes?: "single" | "double" | "backtick" | undefined;

        /**
         * The default value for the numbers option is 'decimal'. This means that any numeric values are represented
         * using decimal integer literals. Other valid options are binary, octal, and hexadecimal, which result in
         * binary integer literals, octal integer literals, and hexadecimal integer literals, respectively.
         */
        numbers?: "binary" | "octal" | "decimal" | "hexadecimal" | undefined;

        /**
         * The wrap option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
         * output is a valid JavaScript string literal wrapped in quotes. The type of quotes can be specified through
         * the quotes setting.
         */
        wrap?: boolean | undefined;

        /**
         * The es6 option takes a boolean value (true or false), and defaults to false (disabled). When enabled, any
         * astral Unicode symbols in the input are escaped using ECMAScript 6 Unicode code point escape sequences
         * instead of using separate escape sequences for each surrogate half. If backwards compatibility with ES5
         * environments is a concern, don’t enable this setting. If the json setting is enabled, the value for the es6
         * setting is ignored (as if it was false).
         */
        es6?: boolean | undefined;

        /**
         * The escapeEverything option takes a boolean value (true or false), and defaults to false (disabled). When
         * enabled, all the symbols in the output are escaped — even printable ASCII symbols.
         */
        escapeEverything?: boolean | undefined;

        /**
         * The minimal option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
         * only a limited set of symbols in the output are escaped: \0, \b, \t, \n, \f, \r, \\, \u2028, \u2029.
         */
        minimal?: boolean | undefined;

        /**
         * The isScriptContext option takes a boolean value (true or false), and defaults to false (disabled). When
         * enabled, occurrences of </script and </style in the output are escaped as <\/script and <\/style, and <!--
         * is escaped as \x3C!-- (or \u003C!-- when the json option is enabled). This setting is useful when jsesc’s
         * output ends up as part of a <script> or <style> element in an HTML document.
         */
        isScriptContext?: boolean | undefined;

        /**
         * The compact option takes a boolean value (true or false), and defaults to true (enabled). When enabled,
         * the output for arrays and objects is as compact as possible; it’s not formatted nicely.
         */
        compact?: boolean | undefined;

        /**
         * The indent option takes a string value, and defaults to '\t'. When the compact setting is enabled (true),
         * the value of the indent option is used to format the output for arrays and objects.
         */
        indent?: string | undefined;

        /**
         * The indentLevel option takes a numeric value, and defaults to 0. It represents the current indentation level,
         * i.e. the number of times the value of the indent option is repeated.
         */
        indentLevel?: number | undefined;

        /**
         * The json option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
         * output is valid JSON. Hexadecimal character escape sequences and the \v or \0 escape sequences are not used.
         * Setting json: true implies quotes: 'double', wrap: true, es6: false, although these values can still be
         * overridden if needed — but in such cases, the output won’t be valid JSON anymore.
         */
        json?: boolean | undefined;

        /**
         * The lowercaseHex option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
         * any alphabetical hexadecimal digits in escape sequences as well as any hexadecimal integer literals (see the
         * numbers option) in the output are in lowercase.
         */
        lowercaseHex?: boolean | undefined;
    } | undefined;
}

export class CodeGenerator {
    constructor(ast: t.Node, opts?: GeneratorOptions, code?: string);
    generate(): GeneratorResult;
}

/**
 * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.
 * @param ast - the abstract syntax tree from which to generate output code.
 * @param opts - used for specifying options for code generation.
 * @param code - the original source code, used for source maps.
 * @returns - an object containing the output code and source map.
 */
export function generate(
    ast: t.Node,
    opts?: GeneratorOptions,
    code?: string | { [filename: string]: string },
): GeneratorResult;

export default generate;

export interface GeneratorResult {
    code: string;
    map: {
        version: number;
        sources: string[];
        names: string[];
        sourceRoot?: string | undefined;
        sourcesContent?: string[] | undefined;
        mappings: string;
        file: string;
    } | null;
}


---

File name: node_modules\@types\babel__generator\package.json

Code:
{
    "name": "@types/babel__generator",
    "version": "7.27.0",
    "description": "TypeScript definitions for @babel/generator",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__generator",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Cameron Yan",
            "githubUsername": "khell",
            "url": "https://github.com/khell"
        },
        {
            "name": "Lyanbin",
            "githubUsername": "Lyanbin",
            "url": "https://github.com/Lyanbin"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__generator"
    },
    "scripts": {},
    "dependencies": {
        "@babel/types": "^7.0.0"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "b5c7deac65dbd6ab9b313d1d71c86afe4383b881dcb4e3b3ac51dab07b8f95fb",
    "typeScriptVersion": "5.1"
}

---

File name: node_modules\@types\babel__generator\README.md

Code:
# Installation
> `npm install --save @types/babel__generator`

# Summary
This package contains type definitions for @babel/generator (https://github.com/babel/babel/tree/master/packages/babel-generator).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__generator.

### Additional Details
 * Last updated: Thu, 03 Apr 2025 16:02:41 GMT
 * Dependencies: [@babel/types](https://npmjs.com/package/@babel/types)

# Credits
These definitions were written by [Troy Gerwien](https://github.com/yortus), [Melvin Groenhoff](https://github.com/mgroenhoff), [Cameron Yan](https://github.com/khell), and [Lyanbin](https://github.com/Lyanbin).


---

File name: node_modules\@types\babel__template\index.d.ts

Code:
import { ParserOptions } from "@babel/parser";
import { Expression, Program, Statement } from "@babel/types";

export interface TemplateBuilderOptions extends ParserOptions {
    /**
     * A set of placeholder names to automatically accept.
     * Items in this list do not need to match `placeholderPattern`.
     *
     * This option cannot be used when using `%%foo%%` style placeholders.
     */
    placeholderWhitelist?: Set<string> | null | undefined;

    /**
     * A pattern to search for when looking for `Identifier` and `StringLiteral`
     * nodes that should be considered as placeholders.
     *
     * `false` will disable placeholder searching placeholders, leaving only
     * the `placeholderWhitelist` value to find replacements.
     *
     * This option cannot be used when using `%%foo%%` style placeholders.
     *
     * @default /^[_$A-Z0-9]+$/
     */
    placeholderPattern?: RegExp | false | null | undefined;

    /**
     * Set this to `true` to preserve comments from the template string
     * into the resulting AST, or `false` to automatically discard comments.
     *
     * @default false
     */
    preserveComments?: boolean | null | undefined;

    /**
     * Set to `true` to use `%%foo%%` style placeholders, `false` to use legacy placeholders
     * described by `placeholderPattern` or `placeholderWhitelist`.
     *
     * When it is not set, it behaves as `true` if there are syntactic placeholders, otherwise as `false`.
     *
     * @since 7.4.0
     */
    syntacticPlaceholders?: boolean | null | undefined;
}

export interface TemplateBuilder<T> {
    /**
     * Build a new builder, merging the given options with the previous ones.
     */
    (opts: TemplateBuilderOptions): TemplateBuilder<T>;

    /**
     * Building from a string produces an AST builder function by default.
     */
    (code: string, opts?: TemplateBuilderOptions): (arg?: PublicReplacements) => T;

    /**
     * Building from a template literal produces an AST builder function by default.
     */
    (tpl: TemplateStringsArray, ...args: unknown[]): (arg?: PublicReplacements) => T;

    /**
     * Allow users to explicitly create templates that produce ASTs,
     * skipping the need for an intermediate function.
     *
     * Does not allow `%%foo%%` style placeholders.
     */
    ast: {
        (tpl: string, opts?: TemplateBuilderOptions): T;
        (tpl: TemplateStringsArray, ...args: unknown[]): T;
    };
}

export type PublicReplacements = { [index: string]: unknown } | unknown[];

export const smart: TemplateBuilder<Statement | Statement[]>;
export const statement: TemplateBuilder<Statement>;
export const statements: TemplateBuilder<Statement[]>;
export const expression: TemplateBuilder<Expression>;
export const program: TemplateBuilder<Program>;

type DefaultTemplateBuilder = typeof smart & {
    smart: typeof smart;
    statement: typeof statement;
    statements: typeof statements;
    expression: typeof expression;
    program: typeof program;
    ast: typeof smart.ast;
};

declare const templateBuilder: DefaultTemplateBuilder;

export default templateBuilder;


---

File name: node_modules\@types\babel__template\package.json

Code:
{
    "name": "@types/babel__template",
    "version": "7.4.4",
    "description": "TypeScript definitions for @babel/template",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__template",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__template"
    },
    "scripts": {},
    "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
    },
    "typesPublisherContentHash": "5730d754b4d1fcd41676b093f9e32b340c749c4d37b126dfa312e394467e86c6",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\babel__template\README.md

Code:
# Installation
> `npm install --save @types/babel__template`

# Summary
This package contains type definitions for @babel/template (https://github.com/babel/babel/tree/master/packages/babel-template).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__template.

### Additional Details
 * Last updated: Mon, 06 Nov 2023 22:41:04 GMT
 * Dependencies: [@babel/parser](https://npmjs.com/package/@babel/parser), [@babel/types](https://npmjs.com/package/@babel/types)

# Credits
These definitions were written by [Troy Gerwien](https://github.com/yortus), [Marvin Hagemeister](https://github.com/marvinhagemeister), [Melvin Groenhoff](https://github.com/mgroenhoff), and [ExE Boss](https://github.com/ExE-Boss).


---

File name: node_modules\@types\babel__traverse\index.d.ts

Code:
import * as t from "@babel/types";
export import Node = t.Node;
export import RemovePropertiesOptions = t.RemovePropertiesOptions;

declare const traverse: {
    <S>(parent: Node, opts: TraverseOptions<S>, scope: Scope | undefined, state: S, parentPath?: NodePath): void;
    (parent: Node, opts?: TraverseOptions, scope?: Scope, state?: any, parentPath?: NodePath): void;

    visitors: typeof visitors;
    verify: typeof visitors.verify;
    explode: typeof visitors.explode;

    cheap: (node: Node, enter: (node: Node) => void) => void;
    node: (
        node: Node,
        opts: TraverseOptions,
        scope?: Scope,
        state?: any,
        path?: NodePath,
        skipKeys?: Record<string, boolean>,
    ) => void;
    clearNode: (node: Node, opts?: RemovePropertiesOptions) => void;
    removeProperties: (tree: Node, opts?: RemovePropertiesOptions) => Node;
    hasType: (tree: Node, type: Node["type"], denylistTypes?: string[]) => boolean;

    cache: typeof cache;
};

export namespace visitors {
    /**
     * `explode()` will take a `Visitor` object with all of the various shorthands
     * that we support, and validates & normalizes it into a common format, ready
     * to be used in traversal.
     *
     * The various shorthands are:
     * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
     * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
     * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
     *
     * Other normalizations are:
     * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
     * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
     */
    function explode<S = unknown>(
        visitor: Visitor<S>,
    ): {
        [Type in Exclude<Node, t.DeprecatedAliases>["type"]]?: VisitNodeObject<S, Extract<Node, { type: Type }>>;
    };
    function verify(visitor: Visitor): void;
    function merge<State>(visitors: Array<Visitor<State>>): Visitor<State>;
    function merge(
        visitors: Visitor[],
        states?: any[],
        wrapper?: (
            stateKey: any,
            visitorKey: keyof Visitor,
            func: VisitNodeFunction<unknown, Node>,
        ) => VisitNodeFunction<unknown, Node> | null,
    ): Visitor;
}

export namespace cache {
    let path: WeakMap<t.Node, Map<t.Node, NodePath>>;
    let scope: WeakMap<t.Node, Scope>;
    function clear(): void;
    function clearPath(): void;
    function clearScope(): void;
}

export default traverse;

export type TraverseOptions<S = Node> = {
    scope?: Scope;
    noScope?: boolean;
    denylist?: NodeType[];
    /** @deprecated will be removed in Babel 8 */
    blacklist?: NodeType[];
    shouldSkip?: (node: NodePath) => boolean;
} & Visitor<S>;

export class Scope {
    /**
     * This searches the current "scope" and collects all references/bindings
     * within.
     */
    constructor(path: NodePath, parentScope?: Scope);
    uid: number;
    path: NodePath;
    block: Node;
    labels: Map<string, NodePath<t.LabeledStatement>>;
    parentBlock: Node;
    parent: Scope;
    hub: HubInterface;
    bindings: { [name: string]: Binding };
    references: { [name: string]: true };
    globals: { [name: string]: t.Identifier | t.JSXIdentifier };
    uids: { [name: string]: boolean };
    data: Record<string | symbol, unknown>;
    crawling: boolean;

    static globals: string[];
    /** Variables available in current context. */
    static contextVariables: string[];

    /** Traverse node with current scope and path. */
    traverse<S>(node: Node | Node[], opts: TraverseOptions<S>, state: S): void;
    traverse(node: Node | Node[], opts?: TraverseOptions, state?: any): void;

    /** Generate a unique identifier and add it to the current scope. */
    generateDeclaredUidIdentifier(name?: string): t.Identifier;

    /** Generate a unique identifier. */
    generateUidIdentifier(name?: string): t.Identifier;

    /** Generate a unique `_id1` binding. */
    generateUid(name?: string): string;

    /** Generate a unique identifier based on a node. */
    generateUidIdentifierBasedOnNode(parent: Node, defaultName?: string): t.Identifier;

    /**
     * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
     * evaluating it wont result in potentially arbitrary code from being ran. The following are
     * whitelisted and determined not to cause side effects:
     *
     *  - `this` expressions
     *  - `super` expressions
     *  - Bound identifiers
     */
    isStatic(node: Node): boolean;

    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    maybeGenerateMemoised(node: Node, dontPush?: boolean): t.Identifier;

    checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: string, id: object): void;

    rename(oldName: string, newName?: string, block?: Node): void;

    dump(): void;

    toArray(
        node: t.Node,
        i?: number | boolean,
        arrayLikeIsIterable?: boolean,
    ): t.ArrayExpression | t.CallExpression | t.Identifier;

    hasLabel(name: string): boolean;

    getLabel(name: string): NodePath<t.LabeledStatement> | undefined;

    registerLabel(path: NodePath<t.LabeledStatement>): void;

    registerDeclaration(path: NodePath): void;

    buildUndefinedNode(): t.UnaryExpression;

    registerConstantViolation(path: NodePath): void;

    registerBinding(kind: BindingKind, path: NodePath, bindingPath?: NodePath): void;

    addGlobal(node: t.Identifier | t.JSXIdentifier): void;

    hasUid(name: string): boolean;

    hasGlobal(name: string): boolean;

    hasReference(name: string): boolean;

    isPure(node: Node, constantsOnly?: boolean): boolean;

    /**
     * Set some arbitrary data on the current scope.
     */
    setData(key: string, val: any): any;

    /**
     * Recursively walk up scope tree looking for the data `key`.
     */
    getData(key: string): any;

    /**
     * Recursively walk up scope tree looking for the data `key` and if it exists,
     * remove it.
     */
    removeData(key: string): void;

    crawl(): void;

    push(opts: {
        id: t.LVal;
        init?: t.Expression;
        unique?: boolean;
        _blockHoist?: number | undefined;
        kind?: "var" | "let" | "const";
    }): void;

    /** Walk up to the top of the scope tree and get the `Program`. */
    getProgramParent(): Scope;

    /** Walk up the scope tree until we hit either a Function or return null. */
    getFunctionParent(): Scope | null;

    /**
     * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the
     * very top and hit Program.
     */
    getBlockParent(): Scope;

    /**
     * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,
     * then returns its block parent
     * @returns An ancestry scope whose path is a block parent
     */
    getPatternParent(): Scope;

    /** Walks the scope tree and gathers **all** bindings. */
    getAllBindings(): Record<string, Binding>;

    /** Walks the scope tree and gathers all declarations of `kind`. */
    getAllBindingsOfKind(...kinds: string[]): Record<string, Binding>;

    bindingIdentifierEquals(name: string, node: Node): boolean;

    getBinding(name: string): Binding | undefined;

    getOwnBinding(name: string): Binding | undefined;

    getBindingIdentifier(name: string): t.Identifier;

    getOwnBindingIdentifier(name: string): t.Identifier;

    hasOwnBinding(name: string): boolean;

    hasBinding(
        name: string,
        optsOrNoGlobals?:
            | boolean
            | {
                noGlobals?: boolean;
                noUids?: boolean;
            },
    ): boolean;

    parentHasBinding(
        name: string,
        opts?: {
            noGlobals?: boolean;
            noUids?: boolean;
        },
    ): boolean;

    /** Move a binding of `name` to another `scope`. */
    moveBindingTo(name: string, scope: Scope): void;

    removeOwnBinding(name: string): void;

    removeBinding(name: string): void;
}

export type BindingKind = "var" | "let" | "const" | "module" | "hoisted" | "param" | "local" | "unknown";

/**
 * This class is responsible for a binding inside of a scope.
 *
 * It tracks the following:
 *
 *  * Node path.
 *  * Amount of times referenced by other nodes.
 *  * Paths to nodes that reassign or modify this binding.
 *  * The kind of binding. (Is it a parameter, declaration etc)
 */
export class Binding {
    constructor(opts: { identifier: t.Identifier; scope: Scope; path: NodePath; kind: BindingKind });
    identifier: t.Identifier;
    scope: Scope;
    path: NodePath;
    kind: BindingKind;
    referenced: boolean;
    references: number;
    referencePaths: NodePath[];
    constant: boolean;
    constantViolations: NodePath[];
    hasDeoptedValue: boolean;
    hasValue: boolean;
    value: any;

    deopValue(): void;
    setValue(value: any): void;
    clearValue(): void;

    /** Register a constant violation with the provided `path`. */
    reassign(path: NodePath): void;
    /** Increment the amount of references to this binding. */
    reference(path: NodePath): void;
    /** Decrement the amount of references to this binding. */
    dereference(): void;
}

export type Visitor<S = unknown> =
    & VisitNodeObject<S, Node>
    & {
        [N in Node as N["type"]]?: VisitNode<S, N extends { type: N["type"] } ? N : never>;
    }
    & {
        [K in keyof t.Aliases]?: VisitNode<S, t.Aliases[K]>;
    }
    & {
        [K in keyof VirtualTypeAliases]?: VisitNode<S, VirtualTypeAliases[K]>;
    }
    & {
        // Babel supports `NodeTypesWithoutComment | NodeTypesWithoutComment | ... ` but it is
        // too complex for TS. So we type it as a general visitor only if the key contains `|`
        // this is good enough for non-visitor traverse options e.g. `noScope`
        [k: `${string}|${string}`]: VisitNode<S, Node>;
    };

export type VisitNode<S, P extends Node> = VisitNodeFunction<S, P> | VisitNodeObject<S, P>;

export type VisitNodeFunction<S, P extends Node> = (this: S, path: NodePath<P>, state: S) => void;

type NodeType = Node["type"] | keyof t.Aliases;

export interface VisitNodeObject<S, P extends Node> {
    enter?: VisitNodeFunction<S, P>;
    exit?: VisitNodeFunction<S, P>;
}

export type NodeKeyOfArrays<T extends Node> = {
    [P in keyof T]-?: T[P] extends Array<Node | null | undefined> ? P : never;
}[keyof T];

export type NodeKeyOfNodes<T extends Node> = {
    [P in keyof T]-?: T[P] extends Node | null | undefined ? P : never;
}[keyof T];

export type NodePaths<T extends Node | readonly Node[]> = T extends readonly Node[]
    ? { -readonly [K in keyof T]: NodePath<Extract<T[K], Node>> }
    : T extends Node ? [NodePath<T>]
    : never;

type NodeListType<N, K extends keyof N> = N[K] extends Array<infer P> ? (P extends Node ? P : never) : never;

type NodesInsertionParam<T extends Node> = T | readonly T[] | [T, ...T[]];

export class NodePath<T = Node> {
    constructor(hub: HubInterface, parent: Node);
    parent: Node;
    hub: Hub;
    data: Record<string | symbol, unknown>;
    context: TraversalContext;
    scope: Scope;
    contexts: TraversalContext[];
    state: any;
    opts: any; // exploded TraverseOptions
    skipKeys: Record<string, boolean> | null;
    parentPath: T extends t.Program ? null : NodePath;
    container: Node | Node[] | null;
    listKey: string | null;
    key: string | number | null;
    node: T;
    type: T extends Node ? T["type"] : T extends null | undefined ? undefined : Node["type"] | undefined;
    shouldSkip: boolean;
    shouldStop: boolean;
    removed: boolean;
    inList: boolean;
    parentKey: string;
    typeAnnotation: object;

    static get<C extends Node, K extends keyof C>(opts: {
        hub?: HubInterface;
        parentPath: NodePath | null;
        parent: Node;
        container: C;
        key: K;
    }): NodePath<C[K]>;
    static get<C extends Node, L extends NodeKeyOfArrays<C>>(opts: {
        hub?: HubInterface;
        parentPath: NodePath | null;
        parent: Node;
        container: C;
        listKey: L;
        key: number;
    }): C[L] extends Array<Node | null | undefined> ? NodePath<C[L][number]> : never;

    getScope(scope: Scope): Scope;

    setData(key: string | symbol, val: any): any;

    getData(key: string | symbol, def?: any): any;

    hasNode(): this is NodePath<Exclude<T, null | undefined>>;

    buildCodeFrameError(msg: string, Error?: ErrorConstructor): Error;

    traverse<T>(visitor: TraverseOptions<T>, state: T): void;
    traverse(visitor: TraverseOptions): void;

    set(key: string, node: any): void;

    getPathLocation(): string;

    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    debug(buildMessage: () => string): void;

    // #region ------------------------- ancestry -------------------------
    /**
     * Starting at the parent path of the current `NodePath` and going up the
     * tree, return the first `NodePath` that causes the provided `callback`
     * to return a truthy value, or `null` if the `callback` never returns a
     * truthy value.
     */
    findParent(callback: (path: NodePath) => boolean): NodePath | null;

    /**
     * Starting at current `NodePath` and going up the tree, return the first
     * `NodePath` that causes the provided `callback` to return a truthy value,
     * or `null` if the `callback` never returns a truthy value.
     */
    find(callback: (path: NodePath) => boolean): NodePath | null;

    /** Get the parent function of the current path. */
    getFunctionParent(): NodePath<t.Function> | null;

    /** Walk up the tree until we hit a parent node path in a list. */
    getStatementParent(): NodePath<t.Statement> | null;

    /**
     * Get the deepest common ancestor and then from it, get the earliest relationship path
     * to that ancestor.
     *
     * Earliest is defined as being "before" all the other nodes in terms of list container
     * position and visiting key.
     */
    getEarliestCommonAncestorFrom(paths: NodePath[]): NodePath;

    /** Get the earliest path in the tree where the provided `paths` intersect. */
    getDeepestCommonAncestorFrom(
        paths: NodePath[],
        filter?: (deepest: Node, i: number, ancestries: NodePath[][]) => NodePath,
    ): NodePath;

    /**
     * Build an array of node paths containing the entire ancestry of the current node path.
     *
     * NOTE: The current node path is included in this.
     */
    getAncestry(): [this, ...NodePath[]];

    /**
     * A helper to find if `this` path is an ancestor of `maybeDescendant`
     */
    isAncestor(maybeDescendant: NodePath): boolean;

    /**
     * A helper to find if `this` path is a descendant of `maybeAncestor`
     */
    isDescendant(maybeAncestor: NodePath): boolean;

    inType(...candidateTypes: string[]): boolean;
    // #endregion

    // #region ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    getTypeAnnotation(): t.FlowType | t.TSType;

    isBaseType(baseName: string, soft?: boolean): boolean;

    couldBeBaseType(name: string): boolean;

    baseTypeStrictlyMatches(rightArg: NodePath): boolean;

    isGenericType(genericName: string): boolean;
    // #endregion

    // #region ------------------------- replacement -------------------------
    /**
     * Replace a node with an array of multiple. This method performs the following steps:
     *
     *  - Inherit the comments of first provided node with that of the current node.
     *  - Insert the provided nodes after the current node.
     *  - Remove the current node.
     */
    replaceWithMultiple<Nodes extends Node | readonly Node[] | [Node, ...Node[]]>(nodes: Nodes): NodePaths<Nodes>;

    /**
     * Parse a string as an expression and replace the current node with the result.
     *
     * NOTE: This is typically not a good idea to use. Building source strings when
     * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
     * easier to use, your transforms will be extremely brittle.
     */
    replaceWithSourceString(replacement: string): [NodePath];

    /** Replace the current node with another. */
    replaceWith<R extends Node>(replacementPath: R | NodePath<R>): [NodePath<R>];
    replaceWith<R extends NodePath>(replacementPath: R): [R];

    /**
     * This method takes an array of statements nodes and then explodes it
     * into expressions. This method retains completion records which is
     * extremely important to retain original semantics.
     */
    replaceExpressionWithStatements(nodes: t.Statement[]): NodePaths<t.Expression | t.Statement>;

    replaceInline<Nodes extends Node | readonly Node[] | [Node, ...Node[]]>(nodes: Nodes): NodePaths<Nodes>;
    // #endregion

    // #region ------------------------- evaluation -------------------------
    /**
     * Walk the input `node` and statically evaluate if it's truthy.
     *
     * Returning `true` when we're sure that the expression will evaluate to a
     * truthy value, `false` if we're sure that it will evaluate to a falsy
     * value and `undefined` if we aren't sure. Because of this please do not
     * rely on coercion when using this method and check with === if it's false.
     */
    evaluateTruthy(): boolean | undefined;

    /**
     * Walk the input `node` and statically evaluate it.
     *
     * Returns an object in the form `{ confident, value, deopt }`. `confident`
     * indicates whether or not we had to drop out of evaluating the expression
     * because of hitting an unknown node that we couldn't confidently find the
     * value of, in which case `deopt` is the path of said node.
     *
     * Example:
     *
     *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
     *   t.evaluate(parse("!true")) // { confident: true, value: false }
     *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined, deopt: NodePath }
     */
    evaluate(): {
        confident: boolean;
        value: any;
        deopt?: NodePath;
    };
    // #endregion

    // #region ------------------------- introspection -------------------------
    /**
     * Match the current node if it matches the provided `pattern`.
     *
     * For example, given the match `React.createClass` it would match the
     * parsed nodes of `React.createClass` and `React["createClass"]`.
     */
    matchesPattern(pattern: string, allowPartial?: boolean): boolean;

    /**
     * Check whether we have the input `key`. If the `key` references an array then we check
     * if the array has any items, otherwise we just check if it's falsy.
     */
    has(key: string): boolean;
    // has(key: keyof T): boolean;

    isStatic(): boolean;

    /** Alias of `has`. */
    is(key: string): boolean;
    // is(key: keyof T): boolean;

    /** Opposite of `has`. */
    isnt(key: string): boolean;
    // isnt(key: keyof T): boolean;

    /** Check whether the path node `key` strict equals `value`. */
    equals(key: string, value: any): boolean;
    // equals(key: keyof T, value: any): boolean;

    /**
     * Check the type against our stored internal type of the node. This is handy when a node has
     * been removed yet we still internally know the type and need it to calculate node replacement.
     */
    isNodeType(type: string): boolean;

    /**
     * This checks whether or not we're in one of the following positions:
     *
     *   for (KEY in right);
     *   for (KEY;;);
     *
     * This is because these spots allow VariableDeclarations AND normal expressions so we need
     * to tell the path replacement that it's ok to replace this with an expression.
     */
    canHaveVariableDeclarationOrExpression(): boolean;

    /**
     * This checks whether we are swapping an arrow function's body between an
     * expression and a block statement (or vice versa).
     *
     * This is because arrow functions may implicitly return an expression, which
     * is the same as containing a block statement.
     */
    canSwapBetweenExpressionAndStatement(replacement: Node): boolean;

    /** Check whether the current path references a completion record */
    isCompletionRecord(allowInsideFunction?: boolean): boolean;

    /**
     * Check whether or not the current `key` allows either a single statement or block statement
     * so we can explode it if necessary.
     */
    isStatementOrBlock(): boolean;

    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    referencesImport(moduleSource: string, importName: string): boolean;

    /** Get the source code associated with this node. */
    getSource(): string;

    /** Check if the current path will maybe execute before another path */
    willIMaybeExecuteBefore(target: NodePath): boolean;

    resolve(dangerous?: boolean, resolved?: NodePath[]): NodePath;

    isConstantExpression(): boolean;

    isInStrictMode(): boolean;
    // #endregion

    // #region ------------------------- context -------------------------
    call(key: string): boolean;

    isDenylisted(): boolean;

    /** @deprecated will be removed in Babel 8 */
    isBlacklisted(): boolean;

    visit(): boolean;

    skip(): void;

    skipKey(key: string): void;

    stop(): void;

    setScope(): void;

    setContext(context?: TraversalContext): this;

    /**
     * Here we resync the node paths `key` and `container`. If they've changed according
     * to what we have stored internally then we attempt to resync by crawling and looking
     * for the new values.
     */
    resync(): void;

    popContext(): void;

    pushContext(context: TraversalContext): void;

    requeue(pathToQueue?: NodePath): void;
    // #endregion

    // #region ------------------------- removal -------------------------
    remove(): void;
    // #endregion

    // #region ------------------------- conversion -------------------------
    toComputedKey(): t.PrivateName | t.Expression;

    /** @deprecated Use `arrowFunctionToExpression` */
    arrowFunctionToShadowed(): void;

    /**
     * Given an arbitrary function, process its content as if it were an arrow function, moving references
     * to "this", "arguments", "super", and such into the function's parent scope. This method is useful if
     * you have wrapped some set of items in an IIFE or other function, but want "this", "arguments", and super"
     * to continue behaving as expected.
     */
    unwrapFunctionEnvironment(): void;

    /**
     * Convert a given arrow function into a normal ES5 function expression.
     */
    arrowFunctionToExpression({
        allowInsertArrow,
        allowInsertArrowWithRest,
        /** @deprecated Use `noNewArrows` instead */
        specCompliant,
        noNewArrows,
    }?: {
        allowInsertArrow?: boolean;
        allowInsertArrowWithRest?: boolean;
        specCompliant?: boolean;
        noNewArrows?: boolean;
    }): NodePath<Exclude<t.Function, t.Method | t.ArrowFunctionExpression> | t.CallExpression>;

    ensureBlock(
        this: NodePath<t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause>,
    ): asserts this is NodePath<
        T & {
            body: t.BlockStatement;
        }
    >;
    // #endregion

    // #region ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    insertBefore<Nodes extends NodesInsertionParam<Node>>(nodes: Nodes): NodePaths<Nodes>;

    /**
     * Insert the provided nodes after the current one. When inserting nodes after an
     * expression, ensure that the completion record is correct by pushing the current node.
     */
    insertAfter<Nodes extends NodesInsertionParam<Node>>(nodes: Nodes): NodePaths<Nodes>;

    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    updateSiblingKeys(fromIndex: number, incrementBy: number): void;

    /**
     * Insert child nodes at the start of the current node.
     * @param listKey - The key at which the child nodes are stored (usually body).
     * @param nodes - the nodes to insert.
     */
    unshiftContainer<
        T extends Node,
        K extends NodeKeyOfArrays<T>,
        Nodes extends NodesInsertionParam<NodeListType<T, K>>,
    >(this: NodePath<T>, listKey: K, nodes: Nodes): NodePaths<Nodes>;

    /**
     * Insert child nodes at the end of the current node.
     * @param listKey - The key at which the child nodes are stored (usually body).
     * @param nodes - the nodes to insert.
     */
    pushContainer<T extends Node, K extends NodeKeyOfArrays<T>, Nodes extends NodesInsertionParam<NodeListType<T, K>>>(
        this: NodePath<T>,
        listKey: K,
        nodes: Nodes,
    ): NodePaths<Nodes>;

    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    hoist(scope: Scope): void;
    // #endregion

    // #region ------------------------- family -------------------------
    getOpposite(): NodePath | null;

    getCompletionRecords(): NodePath[];

    getSibling(key: string | number): NodePath;
    getPrevSibling(): NodePath;
    getNextSibling(): NodePath;
    getAllPrevSiblings(): NodePath[];
    getAllNextSiblings(): NodePath[];

    get<K extends keyof T>(key: K, context?: boolean | TraversalContext): NodePathResult<T[K]>;
    get<P extends string>(path: P, context?: boolean | TraversalContext): NodePathResult<ImplGetRecursive<T, P>>;
    get(key: string, context?: boolean | TraversalContext): NodePath | NodePath[];

    getBindingIdentifiers(duplicates: true): Record<string, t.Identifier[]>;
    getBindingIdentifiers(duplicates?: false): Record<string, t.Identifier>;
    getBindingIdentifiers(duplicates?: boolean): Record<string, t.Identifier | t.Identifier[]>;

    getOuterBindingIdentifiers(duplicates: true): Record<string, t.Identifier[]>;
    getOuterBindingIdentifiers(duplicates?: false): Record<string, t.Identifier>;
    getOuterBindingIdentifiers(duplicates?: boolean): Record<string, t.Identifier | t.Identifier[]>;

    getBindingIdentifierPaths(duplicates: true, outerOnly?: boolean): Record<string, Array<NodePath<t.Identifier>>>;
    getBindingIdentifierPaths(duplicates?: false, outerOnly?: boolean): Record<string, NodePath<t.Identifier>>;
    getBindingIdentifierPaths(
        duplicates?: boolean,
        outerOnly?: boolean,
    ): Record<string, NodePath<t.Identifier> | Array<NodePath<t.Identifier>>>;

    getOuterBindingIdentifierPaths(duplicates: true): Record<string, Array<NodePath<t.Identifier>>>;
    getOuterBindingIdentifierPaths(duplicates?: false): Record<string, NodePath<t.Identifier>>;
    getOuterBindingIdentifierPaths(
        duplicates?: boolean,
        outerOnly?: boolean,
    ): Record<string, NodePath<t.Identifier> | Array<NodePath<t.Identifier>>>;
    // #endregion

    // #region ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    shareCommentsWithSiblings(): void;

    addComment(type: t.CommentTypeShorthand, content: string, line?: boolean): void;

    /** Give node `comments` of the specified `type`. */
    addComments(type: t.CommentTypeShorthand, comments: t.Comment[]): void;
    // #endregion

    // #region ------------------------- isXXX -------------------------
    isAccessor(opts?: object): this is NodePath<t.Accessor>;
    isAnyTypeAnnotation(opts?: object): this is NodePath<t.AnyTypeAnnotation>;
    isArgumentPlaceholder(opts?: object): this is NodePath<t.ArgumentPlaceholder>;
    isArrayExpression(opts?: object): this is NodePath<t.ArrayExpression>;
    isArrayPattern(opts?: object): this is NodePath<t.ArrayPattern>;
    isArrayTypeAnnotation(opts?: object): this is NodePath<t.ArrayTypeAnnotation>;
    isArrowFunctionExpression(opts?: object): this is NodePath<t.ArrowFunctionExpression>;
    isAssignmentExpression(opts?: object): this is NodePath<t.AssignmentExpression>;
    isAssignmentPattern(opts?: object): this is NodePath<t.AssignmentPattern>;
    isAwaitExpression(opts?: object): this is NodePath<t.AwaitExpression>;
    isBigIntLiteral(opts?: object): this is NodePath<t.BigIntLiteral>;
    isBinary(opts?: object): this is NodePath<t.Binary>;
    isBinaryExpression(opts?: object): this is NodePath<t.BinaryExpression>;
    isBindExpression(opts?: object): this is NodePath<t.BindExpression>;
    isBlock(opts?: object): this is NodePath<t.Block>;
    isBlockParent(opts?: object): this is NodePath<t.BlockParent>;
    isBlockStatement(opts?: object): this is NodePath<t.BlockStatement>;
    isBooleanLiteral(opts?: object): this is NodePath<t.BooleanLiteral>;
    isBooleanLiteralTypeAnnotation(opts?: object): this is NodePath<t.BooleanLiteralTypeAnnotation>;
    isBooleanTypeAnnotation(opts?: object): this is NodePath<t.BooleanTypeAnnotation>;
    isBreakStatement(opts?: object): this is NodePath<t.BreakStatement>;
    isCallExpression(opts?: object): this is NodePath<t.CallExpression>;
    isCatchClause(opts?: object): this is NodePath<t.CatchClause>;
    isClass(opts?: object): this is NodePath<t.Class>;
    isClassAccessorProperty(opts?: object): this is NodePath<t.ClassAccessorProperty>;
    isClassBody(opts?: object): this is NodePath<t.ClassBody>;
    isClassDeclaration(opts?: object): this is NodePath<t.ClassDeclaration>;
    isClassExpression(opts?: object): this is NodePath<t.ClassExpression>;
    isClassImplements(opts?: object): this is NodePath<t.ClassImplements>;
    isClassMethod(opts?: object): this is NodePath<t.ClassMethod>;
    isClassPrivateMethod(opts?: object): this is NodePath<t.ClassPrivateMethod>;
    isClassPrivateProperty(opts?: object): this is NodePath<t.ClassPrivateProperty>;
    isClassProperty(opts?: object): this is NodePath<t.ClassProperty>;
    isCompletionStatement(opts?: object): this is NodePath<t.CompletionStatement>;
    isConditional(opts?: object): this is NodePath<t.Conditional>;
    isConditionalExpression(opts?: object): this is NodePath<t.ConditionalExpression>;
    isContinueStatement(opts?: object): this is NodePath<t.ContinueStatement>;
    isDebuggerStatement(opts?: object): this is NodePath<t.DebuggerStatement>;
    isDecimalLiteral(opts?: object): this is NodePath<t.DecimalLiteral>;
    isDeclaration(opts?: object): this is NodePath<t.Declaration>;
    isDeclareClass(opts?: object): this is NodePath<t.DeclareClass>;
    isDeclareExportAllDeclaration(opts?: object): this is NodePath<t.DeclareExportAllDeclaration>;
    isDeclareExportDeclaration(opts?: object): this is NodePath<t.DeclareExportDeclaration>;
    isDeclareFunction(opts?: object): this is NodePath<t.DeclareFunction>;
    isDeclareInterface(opts?: object): this is NodePath<t.DeclareInterface>;
    isDeclareModule(opts?: object): this is NodePath<t.DeclareModule>;
    isDeclareModuleExports(opts?: object): this is NodePath<t.DeclareModuleExports>;
    isDeclareOpaqueType(opts?: object): this is NodePath<t.DeclareOpaqueType>;
    isDeclareTypeAlias(opts?: object): this is NodePath<t.DeclareTypeAlias>;
    isDeclareVariable(opts?: object): this is NodePath<t.DeclareVariable>;
    isDeclaredPredicate(opts?: object): this is NodePath<t.DeclaredPredicate>;
    isDecorator(opts?: object): this is NodePath<t.Decorator>;
    isDirective(opts?: object): this is NodePath<t.Directive>;
    isDirectiveLiteral(opts?: object): this is NodePath<t.DirectiveLiteral>;
    isDoExpression(opts?: object): this is NodePath<t.DoExpression>;
    isDoWhileStatement(opts?: object): this is NodePath<t.DoWhileStatement>;
    isEmptyStatement(opts?: object): this is NodePath<t.EmptyStatement>;
    isEmptyTypeAnnotation(opts?: object): this is NodePath<t.EmptyTypeAnnotation>;
    isEnumBody(opts?: object): this is NodePath<t.EnumBody>;
    isEnumBooleanBody(opts?: object): this is NodePath<t.EnumBooleanBody>;
    isEnumBooleanMember(opts?: object): this is NodePath<t.EnumBooleanMember>;
    isEnumDeclaration(opts?: object): this is NodePath<t.EnumDeclaration>;
    isEnumDefaultedMember(opts?: object): this is NodePath<t.EnumDefaultedMember>;
    isEnumMember(opts?: object): this is NodePath<t.EnumMember>;
    isEnumNumberBody(opts?: object): this is NodePath<t.EnumNumberBody>;
    isEnumNumberMember(opts?: object): this is NodePath<t.EnumNumberMember>;
    isEnumStringBody(opts?: object): this is NodePath<t.EnumStringBody>;
    isEnumStringMember(opts?: object): this is NodePath<t.EnumStringMember>;
    isEnumSymbolBody(opts?: object): this is NodePath<t.EnumSymbolBody>;
    isExistsTypeAnnotation(opts?: object): this is NodePath<t.ExistsTypeAnnotation>;
    isExportAllDeclaration(opts?: object): this is NodePath<t.ExportAllDeclaration>;
    isExportDeclaration(opts?: object): this is NodePath<t.ExportDeclaration>;
    isExportDefaultDeclaration(opts?: object): this is NodePath<t.ExportDefaultDeclaration>;
    isExportDefaultSpecifier(opts?: object): this is NodePath<t.ExportDefaultSpecifier>;
    isExportNamedDeclaration(opts?: object): this is NodePath<t.ExportNamedDeclaration>;
    isExportNamespaceSpecifier(opts?: object): this is NodePath<t.ExportNamespaceSpecifier>;
    isExportSpecifier(opts?: object): this is NodePath<t.ExportSpecifier>;
    isExpression(opts?: object): this is NodePath<t.Expression>;
    isExpressionStatement(opts?: object): this is NodePath<t.ExpressionStatement>;
    isExpressionWrapper(opts?: object): this is NodePath<t.ExpressionWrapper>;
    isFile(opts?: object): this is NodePath<t.File>;
    isFlow(opts?: object): this is NodePath<t.Flow>;
    isFlowBaseAnnotation(opts?: object): this is NodePath<t.FlowBaseAnnotation>;
    isFlowDeclaration(opts?: object): this is NodePath<t.FlowDeclaration>;
    isFlowPredicate(opts?: object): this is NodePath<t.FlowPredicate>;
    isFlowType(opts?: object): this is NodePath<t.FlowType>;
    isFor(opts?: object): this is NodePath<t.For>;
    isForInStatement(opts?: object): this is NodePath<t.ForInStatement>;
    isForOfStatement(opts?: object): this is NodePath<t.ForOfStatement>;
    isForStatement(opts?: object): this is NodePath<t.ForStatement>;
    isForXStatement(opts?: object): this is NodePath<t.ForXStatement>;
    isFunction(opts?: object): this is NodePath<t.Function>;
    isFunctionDeclaration(opts?: object): this is NodePath<t.FunctionDeclaration>;
    isFunctionExpression(opts?: object): this is NodePath<t.FunctionExpression>;
    isFunctionParent(opts?: object): this is NodePath<t.FunctionParent>;
    isFunctionTypeAnnotation(opts?: object): this is NodePath<t.FunctionTypeAnnotation>;
    isFunctionTypeParam(opts?: object): this is NodePath<t.FunctionTypeParam>;
    isGenericTypeAnnotation(opts?: object): this is NodePath<t.GenericTypeAnnotation>;
    isIdentifier(opts?: object): this is NodePath<t.Identifier>;
    isIfStatement(opts?: object): this is NodePath<t.IfStatement>;
    isImmutable(opts?: object): this is NodePath<t.Immutable>;
    isImport(opts?: object): this is NodePath<t.Import>;
    isImportAttribute(opts?: object): this is NodePath<t.ImportAttribute>;
    isImportDeclaration(opts?: object): this is NodePath<t.ImportDeclaration>;
    isImportDefaultSpecifier(opts?: object): this is NodePath<t.ImportDefaultSpecifier>;
    isImportNamespaceSpecifier(opts?: object): this is NodePath<t.ImportNamespaceSpecifier>;
    isImportSpecifier(opts?: object): this is NodePath<t.ImportSpecifier>;
    isIndexedAccessType(opts?: object): this is NodePath<t.IndexedAccessType>;
    isInferredPredicate(opts?: object): this is NodePath<t.InferredPredicate>;
    isInterfaceDeclaration(opts?: object): this is NodePath<t.InterfaceDeclaration>;
    isInterfaceExtends(opts?: object): this is NodePath<t.InterfaceExtends>;
    isInterfaceTypeAnnotation(opts?: object): this is NodePath<t.InterfaceTypeAnnotation>;
    isInterpreterDirective(opts?: object): this is NodePath<t.InterpreterDirective>;
    isIntersectionTypeAnnotation(opts?: object): this is NodePath<t.IntersectionTypeAnnotation>;
    isJSX(opts?: object): this is NodePath<t.JSX>;
    isJSXAttribute(opts?: object): this is NodePath<t.JSXAttribute>;
    isJSXClosingElement(opts?: object): this is NodePath<t.JSXClosingElement>;
    isJSXClosingFragment(opts?: object): this is NodePath<t.JSXClosingFragment>;
    isJSXElement(opts?: object): this is NodePath<t.JSXElement>;
    isJSXEmptyExpression(opts?: object): this is NodePath<t.JSXEmptyExpression>;
    isJSXExpressionContainer(opts?: object): this is NodePath<t.JSXExpressionContainer>;
    isJSXFragment(opts?: object): this is NodePath<t.JSXFragment>;
    isJSXIdentifier(opts?: object): this is NodePath<t.JSXIdentifier>;
    isJSXMemberExpression(opts?: object): this is NodePath<t.JSXMemberExpression>;
    isJSXNamespacedName(opts?: object): this is NodePath<t.JSXNamespacedName>;
    isJSXOpeningElement(opts?: object): this is NodePath<t.JSXOpeningElement>;
    isJSXOpeningFragment(opts?: object): this is NodePath<t.JSXOpeningFragment>;
    isJSXSpreadAttribute(opts?: object): this is NodePath<t.JSXSpreadAttribute>;
    isJSXSpreadChild(opts?: object): this is NodePath<t.JSXSpreadChild>;
    isJSXText(opts?: object): this is NodePath<t.JSXText>;
    isLVal(opts?: object): this is NodePath<t.LVal>;
    isLabeledStatement(opts?: object): this is NodePath<t.LabeledStatement>;
    isLiteral(opts?: object): this is NodePath<t.Literal>;
    isLogicalExpression(opts?: object): this is NodePath<t.LogicalExpression>;
    isLoop(opts?: object): this is NodePath<t.Loop>;
    isMemberExpression(opts?: object): this is NodePath<t.MemberExpression>;
    isMetaProperty(opts?: object): this is NodePath<t.MetaProperty>;
    isMethod(opts?: object): this is NodePath<t.Method>;
    isMiscellaneous(opts?: object): this is NodePath<t.Miscellaneous>;
    isMixedTypeAnnotation(opts?: object): this is NodePath<t.MixedTypeAnnotation>;
    isModuleDeclaration(opts?: object): this is NodePath<t.ModuleDeclaration>;
    isModuleExpression(opts?: object): this is NodePath<t.ModuleExpression>;
    isModuleSpecifier(opts?: object): this is NodePath<t.ModuleSpecifier>;
    isNewExpression(opts?: object): this is NodePath<t.NewExpression>;
    isNoop(opts?: object): this is NodePath<t.Noop>;
    isNullLiteral(opts?: object): this is NodePath<t.NullLiteral>;
    isNullLiteralTypeAnnotation(opts?: object): this is NodePath<t.NullLiteralTypeAnnotation>;
    isNullableTypeAnnotation(opts?: object): this is NodePath<t.NullableTypeAnnotation>;

    /** @deprecated Use `isNumericLiteral` */
    isNumberLiteral(opts?: object): this is NodePath<t.NumberLiteral>;
    isNumberLiteralTypeAnnotation(opts?: object): this is NodePath<t.NumberLiteralTypeAnnotation>;
    isNumberTypeAnnotation(opts?: object): this is NodePath<t.NumberTypeAnnotation>;
    isNumericLiteral(opts?: object): this is NodePath<t.NumericLiteral>;
    isObjectExpression(opts?: object): this is NodePath<t.ObjectExpression>;
    isObjectMember(opts?: object): this is NodePath<t.ObjectMember>;
    isObjectMethod(opts?: object): this is NodePath<t.ObjectMethod>;
    isObjectPattern(opts?: object): this is NodePath<t.ObjectPattern>;
    isObjectProperty(opts?: object): this is NodePath<t.ObjectProperty>;
    isObjectTypeAnnotation(opts?: object): this is NodePath<t.ObjectTypeAnnotation>;
    isObjectTypeCallProperty(opts?: object): this is NodePath<t.ObjectTypeCallProperty>;
    isObjectTypeIndexer(opts?: object): this is NodePath<t.ObjectTypeIndexer>;
    isObjectTypeInternalSlot(opts?: object): this is NodePath<t.ObjectTypeInternalSlot>;
    isObjectTypeProperty(opts?: object): this is NodePath<t.ObjectTypeProperty>;
    isObjectTypeSpreadProperty(opts?: object): this is NodePath<t.ObjectTypeSpreadProperty>;
    isOpaqueType(opts?: object): this is NodePath<t.OpaqueType>;
    isOptionalCallExpression(opts?: object): this is NodePath<t.OptionalCallExpression>;
    isOptionalIndexedAccessType(opts?: object): this is NodePath<t.OptionalIndexedAccessType>;
    isOptionalMemberExpression(opts?: object): this is NodePath<t.OptionalMemberExpression>;
    isParenthesizedExpression(opts?: object): this is NodePath<t.ParenthesizedExpression>;
    isPattern(opts?: object): this is NodePath<t.Pattern>;
    isPatternLike(opts?: object): this is NodePath<t.PatternLike>;
    isPipelineBareFunction(opts?: object): this is NodePath<t.PipelineBareFunction>;
    isPipelinePrimaryTopicReference(opts?: object): this is NodePath<t.PipelinePrimaryTopicReference>;
    isPipelineTopicExpression(opts?: object): this is NodePath<t.PipelineTopicExpression>;
    isPlaceholder(opts?: object): this is NodePath<t.Placeholder>;
    isPrivate(opts?: object): this is NodePath<t.Private>;
    isPrivateName(opts?: object): this is NodePath<t.PrivateName>;
    isProgram(opts?: object): this is NodePath<t.Program>;
    isProperty(opts?: object): this is NodePath<t.Property>;
    isPureish(opts?: object): this is NodePath<t.Pureish>;
    isQualifiedTypeIdentifier(opts?: object): this is NodePath<t.QualifiedTypeIdentifier>;
    isRecordExpression(opts?: object): this is NodePath<t.RecordExpression>;
    isRegExpLiteral(opts?: object): this is NodePath<t.RegExpLiteral>;

    /** @deprecated Use `isRegExpLiteral` */
    isRegexLiteral(opts?: object): this is NodePath<t.RegexLiteral>;
    isRestElement(opts?: object): this is NodePath<t.RestElement>;

    /** @deprecated Use `isRestElement` */
    isRestProperty(opts?: object): this is NodePath<t.RestProperty>;
    isReturnStatement(opts?: object): this is NodePath<t.ReturnStatement>;
    isScopable(opts?: object): this is NodePath<t.Scopable>;
    isSequenceExpression(opts?: object): this is NodePath<t.SequenceExpression>;
    isSpreadElement(opts?: object): this is NodePath<t.SpreadElement>;

    /** @deprecated Use `isSpreadElement` */
    isSpreadProperty(opts?: object): this is NodePath<t.SpreadProperty>;
    isStandardized(opts?: object): this is NodePath<t.Standardized>;
    isStatement(opts?: object): this is NodePath<t.Statement>;
    isStaticBlock(opts?: object): this is NodePath<t.StaticBlock>;
    isStringLiteral(opts?: object): this is NodePath<t.StringLiteral>;
    isStringLiteralTypeAnnotation(opts?: object): this is NodePath<t.StringLiteralTypeAnnotation>;
    isStringTypeAnnotation(opts?: object): this is NodePath<t.StringTypeAnnotation>;
    isSuper(opts?: object): this is NodePath<t.Super>;
    isSwitchCase(opts?: object): this is NodePath<t.SwitchCase>;
    isSwitchStatement(opts?: object): this is NodePath<t.SwitchStatement>;
    isSymbolTypeAnnotation(opts?: object): this is NodePath<t.SymbolTypeAnnotation>;
    isTSAnyKeyword(opts?: object): this is NodePath<t.TSAnyKeyword>;
    isTSArrayType(opts?: object): this is NodePath<t.TSArrayType>;
    isTSAsExpression(opts?: object): this is NodePath<t.TSAsExpression>;
    isTSBaseType(opts?: object): this is NodePath<t.TSBaseType>;
    isTSBigIntKeyword(opts?: object): this is NodePath<t.TSBigIntKeyword>;
    isTSBooleanKeyword(opts?: object): this is NodePath<t.TSBooleanKeyword>;
    isTSCallSignatureDeclaration(opts?: object): this is NodePath<t.TSCallSignatureDeclaration>;
    isTSConditionalType(opts?: object): this is NodePath<t.TSConditionalType>;
    isTSConstructSignatureDeclaration(opts?: object): this is NodePath<t.TSConstructSignatureDeclaration>;
    isTSConstructorType(opts?: object): this is NodePath<t.TSConstructorType>;
    isTSDeclareFunction(opts?: object): this is NodePath<t.TSDeclareFunction>;
    isTSDeclareMethod(opts?: object): this is NodePath<t.TSDeclareMethod>;
    isTSEntityName(opts?: object): this is NodePath<t.TSEntityName>;
    isTSEnumDeclaration(opts?: object): this is NodePath<t.TSEnumDeclaration>;
    isTSEnumMember(opts?: object): this is NodePath<t.TSEnumMember>;
    isTSExportAssignment(opts?: object): this is NodePath<t.TSExportAssignment>;
    isTSExpressionWithTypeArguments(opts?: object): this is NodePath<t.TSExpressionWithTypeArguments>;
    isTSExternalModuleReference(opts?: object): this is NodePath<t.TSExternalModuleReference>;
    isTSFunctionType(opts?: object): this is NodePath<t.TSFunctionType>;
    isTSImportEqualsDeclaration(opts?: object): this is NodePath<t.TSImportEqualsDeclaration>;
    isTSImportType(opts?: object): this is NodePath<t.TSImportType>;
    isTSIndexSignature(opts?: object): this is NodePath<t.TSIndexSignature>;
    isTSIndexedAccessType(opts?: object): this is NodePath<t.TSIndexedAccessType>;
    isTSInferType(opts?: object): this is NodePath<t.TSInferType>;
    isTSInstantiationExpression(opts?: object): this is NodePath<t.TSInstantiationExpression>;
    isTSInterfaceBody(opts?: object): this is NodePath<t.TSInterfaceBody>;
    isTSInterfaceDeclaration(opts?: object): this is NodePath<t.TSInterfaceDeclaration>;
    isTSIntersectionType(opts?: object): this is NodePath<t.TSIntersectionType>;
    isTSIntrinsicKeyword(opts?: object): this is NodePath<t.TSIntrinsicKeyword>;
    isTSLiteralType(opts?: object): this is NodePath<t.TSLiteralType>;
    isTSMappedType(opts?: object): this is NodePath<t.TSMappedType>;
    isTSMethodSignature(opts?: object): this is NodePath<t.TSMethodSignature>;
    isTSModuleBlock(opts?: object): this is NodePath<t.TSModuleBlock>;
    isTSModuleDeclaration(opts?: object): this is NodePath<t.TSModuleDeclaration>;
    isTSNamedTupleMember(opts?: object): this is NodePath<t.TSNamedTupleMember>;
    isTSNamespaceExportDeclaration(opts?: object): this is NodePath<t.TSNamespaceExportDeclaration>;
    isTSNeverKeyword(opts?: object): this is NodePath<t.TSNeverKeyword>;
    isTSNonNullExpression(opts?: object): this is NodePath<t.TSNonNullExpression>;
    isTSNullKeyword(opts?: object): this is NodePath<t.TSNullKeyword>;
    isTSNumberKeyword(opts?: object): this is NodePath<t.TSNumberKeyword>;
    isTSObjectKeyword(opts?: object): this is NodePath<t.TSObjectKeyword>;
    isTSOptionalType(opts?: object): this is NodePath<t.TSOptionalType>;
    isTSParameterProperty(opts?: object): this is NodePath<t.TSParameterProperty>;
    isTSParenthesizedType(opts?: object): this is NodePath<t.TSParenthesizedType>;
    isTSPropertySignature(opts?: object): this is NodePath<t.TSPropertySignature>;
    isTSQualifiedName(opts?: object): this is NodePath<t.TSQualifiedName>;
    isTSRestType(opts?: object): this is NodePath<t.TSRestType>;
    isTSSatisfiesExpression(opts?: object): this is NodePath<t.TSSatisfiesExpression>;
    isTSStringKeyword(opts?: object): this is NodePath<t.TSStringKeyword>;
    isTSSymbolKeyword(opts?: object): this is NodePath<t.TSSymbolKeyword>;
    isTSThisType(opts?: object): this is NodePath<t.TSThisType>;
    isTSTupleType(opts?: object): this is NodePath<t.TSTupleType>;
    isTSType(opts?: object): this is NodePath<t.TSType>;
    isTSTypeAliasDeclaration(opts?: object): this is NodePath<t.TSTypeAliasDeclaration>;
    isTSTypeAnnotation(opts?: object): this is NodePath<t.TSTypeAnnotation>;
    isTSTypeAssertion(opts?: object): this is NodePath<t.TSTypeAssertion>;
    isTSTypeElement(opts?: object): this is NodePath<t.TSTypeElement>;
    isTSTypeLiteral(opts?: object): this is NodePath<t.TSTypeLiteral>;
    isTSTypeOperator(opts?: object): this is NodePath<t.TSTypeOperator>;
    isTSTypeParameter(opts?: object): this is NodePath<t.TSTypeParameter>;
    isTSTypeParameterDeclaration(opts?: object): this is NodePath<t.TSTypeParameterDeclaration>;
    isTSTypeParameterInstantiation(opts?: object): this is NodePath<t.TSTypeParameterInstantiation>;
    isTSTypePredicate(opts?: object): this is NodePath<t.TSTypePredicate>;
    isTSTypeQuery(opts?: object): this is NodePath<t.TSTypeQuery>;
    isTSTypeReference(opts?: object): this is NodePath<t.TSTypeReference>;
    isTSUndefinedKeyword(opts?: object): this is NodePath<t.TSUndefinedKeyword>;
    isTSUnionType(opts?: object): this is NodePath<t.TSUnionType>;
    isTSUnknownKeyword(opts?: object): this is NodePath<t.TSUnknownKeyword>;
    isTSVoidKeyword(opts?: object): this is NodePath<t.TSVoidKeyword>;
    isTaggedTemplateExpression(opts?: object): this is NodePath<t.TaggedTemplateExpression>;
    isTemplateElement(opts?: object): this is NodePath<t.TemplateElement>;
    isTemplateLiteral(opts?: object): this is NodePath<t.TemplateLiteral>;
    isTerminatorless(opts?: object): this is NodePath<t.Terminatorless>;
    isThisExpression(opts?: object): this is NodePath<t.ThisExpression>;
    isThisTypeAnnotation(opts?: object): this is NodePath<t.ThisTypeAnnotation>;
    isThrowStatement(opts?: object): this is NodePath<t.ThrowStatement>;
    isTopicReference(opts?: object): this is NodePath<t.TopicReference>;
    isTryStatement(opts?: object): this is NodePath<t.TryStatement>;
    isTupleExpression(opts?: object): this is NodePath<t.TupleExpression>;
    isTupleTypeAnnotation(opts?: object): this is NodePath<t.TupleTypeAnnotation>;
    isTypeAlias(opts?: object): this is NodePath<t.TypeAlias>;
    isTypeAnnotation(opts?: object): this is NodePath<t.TypeAnnotation>;
    isTypeCastExpression(opts?: object): this is NodePath<t.TypeCastExpression>;
    isTypeParameter(opts?: object): this is NodePath<t.TypeParameter>;
    isTypeParameterDeclaration(opts?: object): this is NodePath<t.TypeParameterDeclaration>;
    isTypeParameterInstantiation(opts?: object): this is NodePath<t.TypeParameterInstantiation>;
    isTypeScript(opts?: object): this is NodePath<t.TypeScript>;
    isTypeofTypeAnnotation(opts?: object): this is NodePath<t.TypeofTypeAnnotation>;
    isUnaryExpression(opts?: object): this is NodePath<t.UnaryExpression>;
    isUnaryLike(opts?: object): this is NodePath<t.UnaryLike>;
    isUnionTypeAnnotation(opts?: object): this is NodePath<t.UnionTypeAnnotation>;
    isUpdateExpression(opts?: object): this is NodePath<t.UpdateExpression>;
    isUserWhitespacable(opts?: object): this is NodePath<t.UserWhitespacable>;
    isV8IntrinsicIdentifier(opts?: object): this is NodePath<t.V8IntrinsicIdentifier>;
    isVariableDeclaration(opts?: object): this is NodePath<t.VariableDeclaration>;
    isVariableDeclarator(opts?: object): this is NodePath<t.VariableDeclarator>;
    isVariance(opts?: object): this is NodePath<t.Variance>;
    isVoidTypeAnnotation(opts?: object): this is NodePath<t.VoidTypeAnnotation>;
    isWhile(opts?: object): this is NodePath<t.While>;
    isWhileStatement(opts?: object): this is NodePath<t.WhileStatement>;
    isWithStatement(opts?: object): this is NodePath<t.WithStatement>;
    isYieldExpression(opts?: object): this is NodePath<t.YieldExpression>;

    isBindingIdentifier(opts?: object): this is NodePath<VirtualTypeAliases["BindingIdentifier"]>;
    isBlockScoped(opts?: object): this is NodePath<t.FunctionDeclaration | t.ClassDeclaration | t.VariableDeclaration>;

    /** @deprecated */
    isExistentialTypeParam(opts?: object): this is NodePath<VirtualTypeAliases["ExistentialTypeParam"]>;
    isForAwaitStatement(opts?: object): this is NodePath<VirtualTypeAliases["ForAwaitStatement"]>;
    isGenerated(opts?: object): boolean;

    /** @deprecated */
    isNumericLiteralTypeAnnotation(opts?: object): void;
    isPure(opts?: object): boolean;
    isReferenced(opts?: object): boolean;
    isReferencedIdentifier(opts?: object): this is NodePath<VirtualTypeAliases["ReferencedIdentifier"]>;
    isReferencedMemberExpression(opts?: object): this is NodePath<VirtualTypeAliases["ReferencedMemberExpression"]>;
    isScope(opts?: object): this is NodePath<VirtualTypeAliases["Scope"]>;
    isUser(opts?: object): boolean;
    isVar(opts?: object): this is NodePath<VirtualTypeAliases["Var"]>;
    // #endregion

    // #region ------------------------- assertXXX -------------------------
    assertAccessor(opts?: object): asserts this is NodePath<t.Accessor>;
    assertAnyTypeAnnotation(opts?: object): asserts this is NodePath<t.AnyTypeAnnotation>;
    assertArgumentPlaceholder(opts?: object): asserts this is NodePath<t.ArgumentPlaceholder>;
    assertArrayExpression(opts?: object): asserts this is NodePath<t.ArrayExpression>;
    assertArrayPattern(opts?: object): asserts this is NodePath<t.ArrayPattern>;
    assertArrayTypeAnnotation(opts?: object): asserts this is NodePath<t.ArrayTypeAnnotation>;
    assertArrowFunctionExpression(opts?: object): asserts this is NodePath<t.ArrowFunctionExpression>;
    assertAssignmentExpression(opts?: object): asserts this is NodePath<t.AssignmentExpression>;
    assertAssignmentPattern(opts?: object): asserts this is NodePath<t.AssignmentPattern>;
    assertAwaitExpression(opts?: object): asserts this is NodePath<t.AwaitExpression>;
    assertBigIntLiteral(opts?: object): asserts this is NodePath<t.BigIntLiteral>;
    assertBinary(opts?: object): asserts this is NodePath<t.Binary>;
    assertBinaryExpression(opts?: object): asserts this is NodePath<t.BinaryExpression>;
    assertBindExpression(opts?: object): asserts this is NodePath<t.BindExpression>;
    assertBlock(opts?: object): asserts this is NodePath<t.Block>;
    assertBlockParent(opts?: object): asserts this is NodePath<t.BlockParent>;
    assertBlockStatement(opts?: object): asserts this is NodePath<t.BlockStatement>;
    assertBooleanLiteral(opts?: object): asserts this is NodePath<t.BooleanLiteral>;
    assertBooleanLiteralTypeAnnotation(opts?: object): asserts this is NodePath<t.BooleanLiteralTypeAnnotation>;
    assertBooleanTypeAnnotation(opts?: object): asserts this is NodePath<t.BooleanTypeAnnotation>;
    assertBreakStatement(opts?: object): asserts this is NodePath<t.BreakStatement>;
    assertCallExpression(opts?: object): asserts this is NodePath<t.CallExpression>;
    assertCatchClause(opts?: object): asserts this is NodePath<t.CatchClause>;
    assertClass(opts?: object): asserts this is NodePath<t.Class>;
    assertClassAccessorProperty(opts?: object): asserts this is NodePath<t.ClassAccessorProperty>;
    assertClassBody(opts?: object): asserts this is NodePath<t.ClassBody>;
    assertClassDeclaration(opts?: object): asserts this is NodePath<t.ClassDeclaration>;
    assertClassExpression(opts?: object): asserts this is NodePath<t.ClassExpression>;
    assertClassImplements(opts?: object): asserts this is NodePath<t.ClassImplements>;
    assertClassMethod(opts?: object): asserts this is NodePath<t.ClassMethod>;
    assertClassPrivateMethod(opts?: object): asserts this is NodePath<t.ClassPrivateMethod>;
    assertClassPrivateProperty(opts?: object): asserts this is NodePath<t.ClassPrivateProperty>;
    assertClassProperty(opts?: object): asserts this is NodePath<t.ClassProperty>;
    assertCompletionStatement(opts?: object): asserts this is NodePath<t.CompletionStatement>;
    assertConditional(opts?: object): asserts this is NodePath<t.Conditional>;
    assertConditionalExpression(opts?: object): asserts this is NodePath<t.ConditionalExpression>;
    assertContinueStatement(opts?: object): asserts this is NodePath<t.ContinueStatement>;
    assertDebuggerStatement(opts?: object): asserts this is NodePath<t.DebuggerStatement>;
    assertDecimalLiteral(opts?: object): asserts this is NodePath<t.DecimalLiteral>;
    assertDeclaration(opts?: object): asserts this is NodePath<t.Declaration>;
    assertDeclareClass(opts?: object): asserts this is NodePath<t.DeclareClass>;
    assertDeclareExportAllDeclaration(opts?: object): asserts this is NodePath<t.DeclareExportAllDeclaration>;
    assertDeclareExportDeclaration(opts?: object): asserts this is NodePath<t.DeclareExportDeclaration>;
    assertDeclareFunction(opts?: object): asserts this is NodePath<t.DeclareFunction>;
    assertDeclareInterface(opts?: object): asserts this is NodePath<t.DeclareInterface>;
    assertDeclareModule(opts?: object): asserts this is NodePath<t.DeclareModule>;
    assertDeclareModuleExports(opts?: object): asserts this is NodePath<t.DeclareModuleExports>;
    assertDeclareOpaqueType(opts?: object): asserts this is NodePath<t.DeclareOpaqueType>;
    assertDeclareTypeAlias(opts?: object): asserts this is NodePath<t.DeclareTypeAlias>;
    assertDeclareVariable(opts?: object): asserts this is NodePath<t.DeclareVariable>;
    assertDeclaredPredicate(opts?: object): asserts this is NodePath<t.DeclaredPredicate>;
    assertDecorator(opts?: object): asserts this is NodePath<t.Decorator>;
    assertDirective(opts?: object): asserts this is NodePath<t.Directive>;
    assertDirectiveLiteral(opts?: object): asserts this is NodePath<t.DirectiveLiteral>;
    assertDoExpression(opts?: object): asserts this is NodePath<t.DoExpression>;
    assertDoWhileStatement(opts?: object): asserts this is NodePath<t.DoWhileStatement>;
    assertEmptyStatement(opts?: object): asserts this is NodePath<t.EmptyStatement>;
    assertEmptyTypeAnnotation(opts?: object): asserts this is NodePath<t.EmptyTypeAnnotation>;
    assertEnumBody(opts?: object): asserts this is NodePath<t.EnumBody>;
    assertEnumBooleanBody(opts?: object): asserts this is NodePath<t.EnumBooleanBody>;
    assertEnumBooleanMember(opts?: object): asserts this is NodePath<t.EnumBooleanMember>;
    assertEnumDeclaration(opts?: object): asserts this is NodePath<t.EnumDeclaration>;
    assertEnumDefaultedMember(opts?: object): asserts this is NodePath<t.EnumDefaultedMember>;
    assertEnumMember(opts?: object): asserts this is NodePath<t.EnumMember>;
    assertEnumNumberBody(opts?: object): asserts this is NodePath<t.EnumNumberBody>;
    assertEnumNumberMember(opts?: object): asserts this is NodePath<t.EnumNumberMember>;
    assertEnumStringBody(opts?: object): asserts this is NodePath<t.EnumStringBody>;
    assertEnumStringMember(opts?: object): asserts this is NodePath<t.EnumStringMember>;
    assertEnumSymbolBody(opts?: object): asserts this is NodePath<t.EnumSymbolBody>;
    assertExistsTypeAnnotation(opts?: object): asserts this is NodePath<t.ExistsTypeAnnotation>;
    assertExportAllDeclaration(opts?: object): asserts this is NodePath<t.ExportAllDeclaration>;
    assertExportDeclaration(opts?: object): asserts this is NodePath<t.ExportDeclaration>;
    assertExportDefaultDeclaration(opts?: object): asserts this is NodePath<t.ExportDefaultDeclaration>;
    assertExportDefaultSpecifier(opts?: object): asserts this is NodePath<t.ExportDefaultSpecifier>;
    assertExportNamedDeclaration(opts?: object): asserts this is NodePath<t.ExportNamedDeclaration>;
    assertExportNamespaceSpecifier(opts?: object): asserts this is NodePath<t.ExportNamespaceSpecifier>;
    assertExportSpecifier(opts?: object): asserts this is NodePath<t.ExportSpecifier>;
    assertExpression(opts?: object): asserts this is NodePath<t.Expression>;
    assertExpressionStatement(opts?: object): asserts this is NodePath<t.ExpressionStatement>;
    assertExpressionWrapper(opts?: object): asserts this is NodePath<t.ExpressionWrapper>;
    assertFile(opts?: object): asserts this is NodePath<t.File>;
    assertFlow(opts?: object): asserts this is NodePath<t.Flow>;
    assertFlowBaseAnnotation(opts?: object): asserts this is NodePath<t.FlowBaseAnnotation>;
    assertFlowDeclaration(opts?: object): asserts this is NodePath<t.FlowDeclaration>;
    assertFlowPredicate(opts?: object): asserts this is NodePath<t.FlowPredicate>;
    assertFlowType(opts?: object): asserts this is NodePath<t.FlowType>;
    assertFor(opts?: object): asserts this is NodePath<t.For>;
    assertForInStatement(opts?: object): asserts this is NodePath<t.ForInStatement>;
    assertForOfStatement(opts?: object): asserts this is NodePath<t.ForOfStatement>;
    assertForStatement(opts?: object): asserts this is NodePath<t.ForStatement>;
    assertForXStatement(opts?: object): asserts this is NodePath<t.ForXStatement>;
    assertFunction(opts?: object): asserts this is NodePath<t.Function>;
    assertFunctionDeclaration(opts?: object): asserts this is NodePath<t.FunctionDeclaration>;
    assertFunctionExpression(opts?: object): asserts this is NodePath<t.FunctionExpression>;
    assertFunctionParent(opts?: object): asserts this is NodePath<t.FunctionParent>;
    assertFunctionTypeAnnotation(opts?: object): asserts this is NodePath<t.FunctionTypeAnnotation>;
    assertFunctionTypeParam(opts?: object): asserts this is NodePath<t.FunctionTypeParam>;
    assertGenericTypeAnnotation(opts?: object): asserts this is NodePath<t.GenericTypeAnnotation>;
    assertIdentifier(opts?: object): asserts this is NodePath<t.Identifier>;
    assertIfStatement(opts?: object): asserts this is NodePath<t.IfStatement>;
    assertImmutable(opts?: object): asserts this is NodePath<t.Immutable>;
    assertImport(opts?: object): asserts this is NodePath<t.Import>;
    assertImportAttribute(opts?: object): asserts this is NodePath<t.ImportAttribute>;
    assertImportDeclaration(opts?: object): asserts this is NodePath<t.ImportDeclaration>;
    assertImportDefaultSpecifier(opts?: object): asserts this is NodePath<t.ImportDefaultSpecifier>;
    assertImportNamespaceSpecifier(opts?: object): asserts this is NodePath<t.ImportNamespaceSpecifier>;
    assertImportSpecifier(opts?: object): asserts this is NodePath<t.ImportSpecifier>;
    assertIndexedAccessType(opts?: object): asserts this is NodePath<t.IndexedAccessType>;
    assertInferredPredicate(opts?: object): asserts this is NodePath<t.InferredPredicate>;
    assertInterfaceDeclaration(opts?: object): asserts this is NodePath<t.InterfaceDeclaration>;
    assertInterfaceExtends(opts?: object): asserts this is NodePath<t.InterfaceExtends>;
    assertInterfaceTypeAnnotation(opts?: object): asserts this is NodePath<t.InterfaceTypeAnnotation>;
    assertInterpreterDirective(opts?: object): asserts this is NodePath<t.InterpreterDirective>;
    assertIntersectionTypeAnnotation(opts?: object): asserts this is NodePath<t.IntersectionTypeAnnotation>;
    assertJSX(opts?: object): asserts this is NodePath<t.JSX>;
    assertJSXAttribute(opts?: object): asserts this is NodePath<t.JSXAttribute>;
    assertJSXClosingElement(opts?: object): asserts this is NodePath<t.JSXClosingElement>;
    assertJSXClosingFragment(opts?: object): asserts this is NodePath<t.JSXClosingFragment>;
    assertJSXElement(opts?: object): asserts this is NodePath<t.JSXElement>;
    assertJSXEmptyExpression(opts?: object): asserts this is NodePath<t.JSXEmptyExpression>;
    assertJSXExpressionContainer(opts?: object): asserts this is NodePath<t.JSXExpressionContainer>;
    assertJSXFragment(opts?: object): asserts this is NodePath<t.JSXFragment>;
    assertJSXIdentifier(opts?: object): asserts this is NodePath<t.JSXIdentifier>;
    assertJSXMemberExpression(opts?: object): asserts this is NodePath<t.JSXMemberExpression>;
    assertJSXNamespacedName(opts?: object): asserts this is NodePath<t.JSXNamespacedName>;
    assertJSXOpeningElement(opts?: object): asserts this is NodePath<t.JSXOpeningElement>;
    assertJSXOpeningFragment(opts?: object): asserts this is NodePath<t.JSXOpeningFragment>;
    assertJSXSpreadAttribute(opts?: object): asserts this is NodePath<t.JSXSpreadAttribute>;
    assertJSXSpreadChild(opts?: object): asserts this is NodePath<t.JSXSpreadChild>;
    assertJSXText(opts?: object): asserts this is NodePath<t.JSXText>;
    assertLVal(opts?: object): asserts this is NodePath<t.LVal>;
    assertLabeledStatement(opts?: object): asserts this is NodePath<t.LabeledStatement>;
    assertLiteral(opts?: object): asserts this is NodePath<t.Literal>;
    assertLogicalExpression(opts?: object): asserts this is NodePath<t.LogicalExpression>;
    assertLoop(opts?: object): asserts this is NodePath<t.Loop>;
    assertMemberExpression(opts?: object): asserts this is NodePath<t.MemberExpression>;
    assertMetaProperty(opts?: object): asserts this is NodePath<t.MetaProperty>;
    assertMethod(opts?: object): asserts this is NodePath<t.Method>;
    assertMiscellaneous(opts?: object): asserts this is NodePath<t.Miscellaneous>;
    assertMixedTypeAnnotation(opts?: object): asserts this is NodePath<t.MixedTypeAnnotation>;
    assertModuleDeclaration(opts?: object): asserts this is NodePath<t.ModuleDeclaration>;
    assertModuleExpression(opts?: object): asserts this is NodePath<t.ModuleExpression>;
    assertModuleSpecifier(opts?: object): asserts this is NodePath<t.ModuleSpecifier>;
    assertNewExpression(opts?: object): asserts this is NodePath<t.NewExpression>;
    assertNoop(opts?: object): asserts this is NodePath<t.Noop>;
    assertNullLiteral(opts?: object): asserts this is NodePath<t.NullLiteral>;
    assertNullLiteralTypeAnnotation(opts?: object): asserts this is NodePath<t.NullLiteralTypeAnnotation>;
    assertNullableTypeAnnotation(opts?: object): asserts this is NodePath<t.NullableTypeAnnotation>;

    /** @deprecated Use `assertNumericLiteral` */
    assertNumberLiteral(opts?: object): asserts this is NodePath<t.NumberLiteral>;
    assertNumberLiteralTypeAnnotation(opts?: object): asserts this is NodePath<t.NumberLiteralTypeAnnotation>;
    assertNumberTypeAnnotation(opts?: object): asserts this is NodePath<t.NumberTypeAnnotation>;
    assertNumericLiteral(opts?: object): asserts this is NodePath<t.NumericLiteral>;
    assertObjectExpression(opts?: object): asserts this is NodePath<t.ObjectExpression>;
    assertObjectMember(opts?: object): asserts this is NodePath<t.ObjectMember>;
    assertObjectMethod(opts?: object): asserts this is NodePath<t.ObjectMethod>;
    assertObjectPattern(opts?: object): asserts this is NodePath<t.ObjectPattern>;
    assertObjectProperty(opts?: object): asserts this is NodePath<t.ObjectProperty>;
    assertObjectTypeAnnotation(opts?: object): asserts this is NodePath<t.ObjectTypeAnnotation>;
    assertObjectTypeCallProperty(opts?: object): asserts this is NodePath<t.ObjectTypeCallProperty>;
    assertObjectTypeIndexer(opts?: object): asserts this is NodePath<t.ObjectTypeIndexer>;
    assertObjectTypeInternalSlot(opts?: object): asserts this is NodePath<t.ObjectTypeInternalSlot>;
    assertObjectTypeProperty(opts?: object): asserts this is NodePath<t.ObjectTypeProperty>;
    assertObjectTypeSpreadProperty(opts?: object): asserts this is NodePath<t.ObjectTypeSpreadProperty>;
    assertOpaqueType(opts?: object): asserts this is NodePath<t.OpaqueType>;
    assertOptionalCallExpression(opts?: object): asserts this is NodePath<t.OptionalCallExpression>;
    assertOptionalIndexedAccessType(opts?: object): asserts this is NodePath<t.OptionalIndexedAccessType>;
    assertOptionalMemberExpression(opts?: object): asserts this is NodePath<t.OptionalMemberExpression>;
    assertParenthesizedExpression(opts?: object): asserts this is NodePath<t.ParenthesizedExpression>;
    assertPattern(opts?: object): asserts this is NodePath<t.Pattern>;
    assertPatternLike(opts?: object): asserts this is NodePath<t.PatternLike>;
    assertPipelineBareFunction(opts?: object): asserts this is NodePath<t.PipelineBareFunction>;
    assertPipelinePrimaryTopicReference(opts?: object): asserts this is NodePath<t.PipelinePrimaryTopicReference>;
    assertPipelineTopicExpression(opts?: object): asserts this is NodePath<t.PipelineTopicExpression>;
    assertPlaceholder(opts?: object): asserts this is NodePath<t.Placeholder>;
    assertPrivate(opts?: object): asserts this is NodePath<t.Private>;
    assertPrivateName(opts?: object): asserts this is NodePath<t.PrivateName>;
    assertProgram(opts?: object): asserts this is NodePath<t.Program>;
    assertProperty(opts?: object): asserts this is NodePath<t.Property>;
    assertPureish(opts?: object): asserts this is NodePath<t.Pureish>;
    assertQualifiedTypeIdentifier(opts?: object): asserts this is NodePath<t.QualifiedTypeIdentifier>;
    assertRecordExpression(opts?: object): asserts this is NodePath<t.RecordExpression>;
    assertRegExpLiteral(opts?: object): asserts this is NodePath<t.RegExpLiteral>;

    /** @deprecated Use `assertRegExpLiteral` */
    assertRegexLiteral(opts?: object): asserts this is NodePath<t.RegexLiteral>;
    assertRestElement(opts?: object): asserts this is NodePath<t.RestElement>;

    /** @deprecated Use `assertRestElement` */
    assertRestProperty(opts?: object): asserts this is NodePath<t.RestProperty>;
    assertReturnStatement(opts?: object): asserts this is NodePath<t.ReturnStatement>;
    assertScopable(opts?: object): asserts this is NodePath<t.Scopable>;
    assertSequenceExpression(opts?: object): asserts this is NodePath<t.SequenceExpression>;
    assertSpreadElement(opts?: object): asserts this is NodePath<t.SpreadElement>;

    /** @deprecated Use `assertSpreadElement` */
    assertSpreadProperty(opts?: object): asserts this is NodePath<t.SpreadProperty>;
    assertStandardized(opts?: object): asserts this is NodePath<t.Standardized>;
    assertStatement(opts?: object): asserts this is NodePath<t.Statement>;
    assertStaticBlock(opts?: object): asserts this is NodePath<t.StaticBlock>;
    assertStringLiteral(opts?: object): asserts this is NodePath<t.StringLiteral>;
    assertStringLiteralTypeAnnotation(opts?: object): asserts this is NodePath<t.StringLiteralTypeAnnotation>;
    assertStringTypeAnnotation(opts?: object): asserts this is NodePath<t.StringTypeAnnotation>;
    assertSuper(opts?: object): asserts this is NodePath<t.Super>;
    assertSwitchCase(opts?: object): asserts this is NodePath<t.SwitchCase>;
    assertSwitchStatement(opts?: object): asserts this is NodePath<t.SwitchStatement>;
    assertSymbolTypeAnnotation(opts?: object): asserts this is NodePath<t.SymbolTypeAnnotation>;
    assertTSAnyKeyword(opts?: object): asserts this is NodePath<t.TSAnyKeyword>;
    assertTSArrayType(opts?: object): asserts this is NodePath<t.TSArrayType>;
    assertTSAsExpression(opts?: object): asserts this is NodePath<t.TSAsExpression>;
    assertTSBaseType(opts?: object): asserts this is NodePath<t.TSBaseType>;
    assertTSBigIntKeyword(opts?: object): asserts this is NodePath<t.TSBigIntKeyword>;
    assertTSBooleanKeyword(opts?: object): asserts this is NodePath<t.TSBooleanKeyword>;
    assertTSCallSignatureDeclaration(opts?: object): asserts this is NodePath<t.TSCallSignatureDeclaration>;
    assertTSConditionalType(opts?: object): asserts this is NodePath<t.TSConditionalType>;
    assertTSConstructSignatureDeclaration(opts?: object): asserts this is NodePath<t.TSConstructSignatureDeclaration>;
    assertTSConstructorType(opts?: object): asserts this is NodePath<t.TSConstructorType>;
    assertTSDeclareFunction(opts?: object): asserts this is NodePath<t.TSDeclareFunction>;
    assertTSDeclareMethod(opts?: object): asserts this is NodePath<t.TSDeclareMethod>;
    assertTSEntityName(opts?: object): asserts this is NodePath<t.TSEntityName>;
    assertTSEnumDeclaration(opts?: object): asserts this is NodePath<t.TSEnumDeclaration>;
    assertTSEnumMember(opts?: object): asserts this is NodePath<t.TSEnumMember>;
    assertTSExportAssignment(opts?: object): asserts this is NodePath<t.TSExportAssignment>;
    assertTSExpressionWithTypeArguments(opts?: object): asserts this is NodePath<t.TSExpressionWithTypeArguments>;
    assertTSExternalModuleReference(opts?: object): asserts this is NodePath<t.TSExternalModuleReference>;
    assertTSFunctionType(opts?: object): asserts this is NodePath<t.TSFunctionType>;
    assertTSImportEqualsDeclaration(opts?: object): asserts this is NodePath<t.TSImportEqualsDeclaration>;
    assertTSImportType(opts?: object): asserts this is NodePath<t.TSImportType>;
    assertTSIndexSignature(opts?: object): asserts this is NodePath<t.TSIndexSignature>;
    assertTSIndexedAccessType(opts?: object): asserts this is NodePath<t.TSIndexedAccessType>;
    assertTSInferType(opts?: object): asserts this is NodePath<t.TSInferType>;
    assertTSInstantiationExpression(opts?: object): asserts this is NodePath<t.TSInstantiationExpression>;
    assertTSInterfaceBody(opts?: object): asserts this is NodePath<t.TSInterfaceBody>;
    assertTSInterfaceDeclaration(opts?: object): asserts this is NodePath<t.TSInterfaceDeclaration>;
    assertTSIntersectionType(opts?: object): asserts this is NodePath<t.TSIntersectionType>;
    assertTSIntrinsicKeyword(opts?: object): asserts this is NodePath<t.TSIntrinsicKeyword>;
    assertTSLiteralType(opts?: object): asserts this is NodePath<t.TSLiteralType>;
    assertTSMappedType(opts?: object): asserts this is NodePath<t.TSMappedType>;
    assertTSMethodSignature(opts?: object): asserts this is NodePath<t.TSMethodSignature>;
    assertTSModuleBlock(opts?: object): asserts this is NodePath<t.TSModuleBlock>;
    assertTSModuleDeclaration(opts?: object): asserts this is NodePath<t.TSModuleDeclaration>;
    assertTSNamedTupleMember(opts?: object): asserts this is NodePath<t.TSNamedTupleMember>;
    assertTSNamespaceExportDeclaration(opts?: object): asserts this is NodePath<t.TSNamespaceExportDeclaration>;
    assertTSNeverKeyword(opts?: object): asserts this is NodePath<t.TSNeverKeyword>;
    assertTSNonNullExpression(opts?: object): asserts this is NodePath<t.TSNonNullExpression>;
    assertTSNullKeyword(opts?: object): asserts this is NodePath<t.TSNullKeyword>;
    assertTSNumberKeyword(opts?: object): asserts this is NodePath<t.TSNumberKeyword>;
    assertTSObjectKeyword(opts?: object): asserts this is NodePath<t.TSObjectKeyword>;
    assertTSOptionalType(opts?: object): asserts this is NodePath<t.TSOptionalType>;
    assertTSParameterProperty(opts?: object): asserts this is NodePath<t.TSParameterProperty>;
    assertTSParenthesizedType(opts?: object): asserts this is NodePath<t.TSParenthesizedType>;
    assertTSPropertySignature(opts?: object): asserts this is NodePath<t.TSPropertySignature>;
    assertTSQualifiedName(opts?: object): asserts this is NodePath<t.TSQualifiedName>;
    assertTSRestType(opts?: object): asserts this is NodePath<t.TSRestType>;
    assertTSSatisfiesExpression(opts?: object): asserts this is NodePath<t.TSSatisfiesExpression>;
    assertTSStringKeyword(opts?: object): asserts this is NodePath<t.TSStringKeyword>;
    assertTSSymbolKeyword(opts?: object): asserts this is NodePath<t.TSSymbolKeyword>;
    assertTSThisType(opts?: object): asserts this is NodePath<t.TSThisType>;
    assertTSTupleType(opts?: object): asserts this is NodePath<t.TSTupleType>;
    assertTSType(opts?: object): asserts this is NodePath<t.TSType>;
    assertTSTypeAliasDeclaration(opts?: object): asserts this is NodePath<t.TSTypeAliasDeclaration>;
    assertTSTypeAnnotation(opts?: object): asserts this is NodePath<t.TSTypeAnnotation>;
    assertTSTypeAssertion(opts?: object): asserts this is NodePath<t.TSTypeAssertion>;
    assertTSTypeElement(opts?: object): asserts this is NodePath<t.TSTypeElement>;
    assertTSTypeLiteral(opts?: object): asserts this is NodePath<t.TSTypeLiteral>;
    assertTSTypeOperator(opts?: object): asserts this is NodePath<t.TSTypeOperator>;
    assertTSTypeParameter(opts?: object): asserts this is NodePath<t.TSTypeParameter>;
    assertTSTypeParameterDeclaration(opts?: object): asserts this is NodePath<t.TSTypeParameterDeclaration>;
    assertTSTypeParameterInstantiation(opts?: object): asserts this is NodePath<t.TSTypeParameterInstantiation>;
    assertTSTypePredicate(opts?: object): asserts this is NodePath<t.TSTypePredicate>;
    assertTSTypeQuery(opts?: object): asserts this is NodePath<t.TSTypeQuery>;
    assertTSTypeReference(opts?: object): asserts this is NodePath<t.TSTypeReference>;
    assertTSUndefinedKeyword(opts?: object): asserts this is NodePath<t.TSUndefinedKeyword>;
    assertTSUnionType(opts?: object): asserts this is NodePath<t.TSUnionType>;
    assertTSUnknownKeyword(opts?: object): asserts this is NodePath<t.TSUnknownKeyword>;
    assertTSVoidKeyword(opts?: object): asserts this is NodePath<t.TSVoidKeyword>;
    assertTaggedTemplateExpression(opts?: object): asserts this is NodePath<t.TaggedTemplateExpression>;
    assertTemplateElement(opts?: object): asserts this is NodePath<t.TemplateElement>;
    assertTemplateLiteral(opts?: object): asserts this is NodePath<t.TemplateLiteral>;
    assertTerminatorless(opts?: object): asserts this is NodePath<t.Terminatorless>;
    assertThisExpression(opts?: object): asserts this is NodePath<t.ThisExpression>;
    assertThisTypeAnnotation(opts?: object): asserts this is NodePath<t.ThisTypeAnnotation>;
    assertThrowStatement(opts?: object): asserts this is NodePath<t.ThrowStatement>;
    assertTopicReference(opts?: object): asserts this is NodePath<t.TopicReference>;
    assertTryStatement(opts?: object): asserts this is NodePath<t.TryStatement>;
    assertTupleExpression(opts?: object): asserts this is NodePath<t.TupleExpression>;
    assertTupleTypeAnnotation(opts?: object): asserts this is NodePath<t.TupleTypeAnnotation>;
    assertTypeAlias(opts?: object): asserts this is NodePath<t.TypeAlias>;
    assertTypeAnnotation(opts?: object): asserts this is NodePath<t.TypeAnnotation>;
    assertTypeCastExpression(opts?: object): asserts this is NodePath<t.TypeCastExpression>;
    assertTypeParameter(opts?: object): asserts this is NodePath<t.TypeParameter>;
    assertTypeParameterDeclaration(opts?: object): asserts this is NodePath<t.TypeParameterDeclaration>;
    assertTypeParameterInstantiation(opts?: object): asserts this is NodePath<t.TypeParameterInstantiation>;
    assertTypeScript(opts?: object): asserts this is NodePath<t.TypeScript>;
    assertTypeofTypeAnnotation(opts?: object): asserts this is NodePath<t.TypeofTypeAnnotation>;
    assertUnaryExpression(opts?: object): asserts this is NodePath<t.UnaryExpression>;
    assertUnaryLike(opts?: object): asserts this is NodePath<t.UnaryLike>;
    assertUnionTypeAnnotation(opts?: object): asserts this is NodePath<t.UnionTypeAnnotation>;
    assertUpdateExpression(opts?: object): asserts this is NodePath<t.UpdateExpression>;
    assertUserWhitespacable(opts?: object): asserts this is NodePath<t.UserWhitespacable>;
    assertV8IntrinsicIdentifier(opts?: object): asserts this is NodePath<t.V8IntrinsicIdentifier>;
    assertVariableDeclaration(opts?: object): asserts this is NodePath<t.VariableDeclaration>;
    assertVariableDeclarator(opts?: object): asserts this is NodePath<t.VariableDeclarator>;
    assertVariance(opts?: object): asserts this is NodePath<t.Variance>;
    assertVoidTypeAnnotation(opts?: object): asserts this is NodePath<t.VoidTypeAnnotation>;
    assertWhile(opts?: object): asserts this is NodePath<t.While>;
    assertWhileStatement(opts?: object): asserts this is NodePath<t.WhileStatement>;
    assertWithStatement(opts?: object): asserts this is NodePath<t.WithStatement>;
    assertYieldExpression(opts?: object): asserts this is NodePath<t.YieldExpression>;
    // #endregion
}

export interface HubInterface {
    getCode(): string | undefined;
    getScope(): Scope | undefined;
    addHelper(name: string): any;
    buildError(node: Node, msg: string, Error: ErrorConstructor): Error;
}

export class Hub implements HubInterface {
    constructor();
    getCode(): string | undefined;
    getScope(): Scope | undefined;
    addHelper(name: string): any;
    buildError(node: Node, msg: string, Error?: ErrorConstructor): Error;
}

export interface TraversalContext<S = unknown> {
    parentPath: NodePath;
    scope: Scope;
    state: S;
    opts: TraverseOptions;
}

// Based on `GetFieldType`s from `@types/lodash/common/object.d.ts`:
// dprint-ignore
type ImplGetOfArray<T extends readonly unknown[], K extends string> =
    K extends `${infer N extends number}` ? T[N]
    : K extends keyof T ? T[K]
    : never;

// dprint-ignore
type ImplGetByKey<T, K extends string>
    = T extends readonly unknown[] ? ImplGetOfArray<T, K>
    : K extends keyof T ? T[K]
    : K extends `${infer N extends number}`
        ? N extends keyof T ? T[N] : never
    : never;

// dprint-ignore
type ImplGetRecursive<T, K extends string>
    = K extends `${infer L}.${infer R}`
        ? ImplGetRecursive<ImplGetByKey<T, L>, R>
    : ImplGetByKey<T, K>;

export type NodePathResult<T> =
    | (Extract<T, Node | null | undefined> extends never ? never : NodePath<Extract<T, Node | null | undefined>>)
    | (T extends Array<Node | null | undefined> ? Array<NodePath<T[number]>> : never);

export interface VirtualTypeAliases {
    BindingIdentifier: t.Identifier;
    BlockScoped: Node;
    ExistentialTypeParam: t.ExistsTypeAnnotation;
    Flow: t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier;
    ForAwaitStatement: t.ForOfStatement;
    Generated: Node;
    NumericLiteralTypeAnnotation: t.NumberLiteralTypeAnnotation;
    Pure: Node;
    Referenced: Node;
    ReferencedIdentifier: t.Identifier | t.JSXIdentifier;
    ReferencedMemberExpression: t.MemberExpression;
    RestProperty: t.RestElement;
    Scope: t.Scopable | t.Pattern;
    SpreadProperty: t.RestElement;
    User: Node;
    Var: t.VariableDeclaration;
}


---

File name: node_modules\@types\babel__traverse\package.json

Code:
{
    "name": "@types/babel__traverse",
    "version": "7.20.7",
    "description": "TypeScript definitions for @babel/traverse",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__traverse",
    "license": "MIT",
    "contributors": [
        {
            "name": "Troy Gerwien",
            "githubUsername": "yortus",
            "url": "https://github.com/yortus"
        },
        {
            "name": "Marvin Hagemeister",
            "githubUsername": "marvinhagemeister",
            "url": "https://github.com/marvinhagemeister"
        },
        {
            "name": "Ryan Petrich",
            "githubUsername": "rpetrich",
            "url": "https://github.com/rpetrich"
        },
        {
            "name": "Melvin Groenhoff",
            "githubUsername": "mgroenhoff",
            "url": "https://github.com/mgroenhoff"
        },
        {
            "name": "Dean L.",
            "githubUsername": "dlgrit",
            "url": "https://github.com/dlgrit"
        },
        {
            "name": "Ifiok Jr.",
            "githubUsername": "ifiokjr",
            "url": "https://github.com/ifiokjr"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Daniel Tschinder",
            "githubUsername": "danez",
            "url": "https://github.com/danez"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/babel__traverse"
    },
    "scripts": {},
    "dependencies": {
        "@babel/types": "^7.20.7"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "e58d29a4d5c39ba4fa0291c8c7d5abad18881f7ed9f938feeb97726ad48a0544",
    "typeScriptVersion": "5.0"
}

---

File name: node_modules\@types\babel__traverse\README.md

Code:
# Installation
> `npm install --save @types/babel__traverse`

# Summary
This package contains type definitions for @babel/traverse (https://github.com/babel/babel/tree/main/packages/babel-traverse).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/babel__traverse.

### Additional Details
 * Last updated: Wed, 26 Mar 2025 08:02:36 GMT
 * Dependencies: [@babel/types](https://npmjs.com/package/@babel/types)

# Credits
These definitions were written by [Troy Gerwien](https://github.com/yortus), [Marvin Hagemeister](https://github.com/marvinhagemeister), [Ryan Petrich](https://github.com/rpetrich), [Melvin Groenhoff](https://github.com/mgroenhoff), [Dean L.](https://github.com/dlgrit), [Ifiok Jr.](https://github.com/ifiokjr), [ExE Boss](https://github.com/ExE-Boss), and [Daniel Tschinder](https://github.com/danez).


---

File name: node_modules\@types\graceful-fs\index.d.ts

Code:
/// <reference types="node" />

export * from "fs";

/**
 * Use this method to patch the global fs module (or any other fs-like module).
 * NOTE: This should only ever be done at the top-level application layer, in order to delay on
 * EMFILE errors from any fs-using dependencies. You should **not** do this in a library, because
 * it can cause unexpected delays in other parts of the program.
 * @param fsModule The reference to the fs module or an fs-like module.
 */
export function gracefulify<T>(fsModule: T): T;


---

File name: node_modules\@types\graceful-fs\package.json

Code:
{
    "name": "@types/graceful-fs",
    "version": "4.1.9",
    "description": "TypeScript definitions for graceful-fs",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/graceful-fs",
    "license": "MIT",
    "contributors": [
        {
            "name": "Bart van der Schoor",
            "githubUsername": "Bartvds",
            "url": "https://github.com/Bartvds"
        },
        {
            "name": "BendingBender",
            "githubUsername": "BendingBender",
            "url": "https://github.com/BendingBender"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/graceful-fs"
    },
    "scripts": {},
    "dependencies": {
        "@types/node": "*"
    },
    "typesPublisherContentHash": "4e85fab24364f5c04bc484efb612d1c679702932e21e6f4f30c297aa14e21b36",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\graceful-fs\README.md

Code:
# Installation
> `npm install --save @types/graceful-fs`

# Summary
This package contains type definitions for graceful-fs (https://github.com/isaacs/node-graceful-fs).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/graceful-fs.
## [index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/graceful-fs/index.d.ts)
````ts
/// <reference types="node" />

export * from "fs";

/**
 * Use this method to patch the global fs module (or any other fs-like module).
 * NOTE: This should only ever be done at the top-level application layer, in order to delay on
 * EMFILE errors from any fs-using dependencies. You should **not** do this in a library, because
 * it can cause unexpected delays in other parts of the program.
 * @param fsModule The reference to the fs module or an fs-like module.
 */
export function gracefulify<T>(fsModule: T): T;

````

### Additional Details
 * Last updated: Tue, 07 Nov 2023 03:09:37 GMT
 * Dependencies: [@types/node](https://npmjs.com/package/@types/node)

# Credits
These definitions were written by [Bart van der Schoor](https://github.com/Bartvds), and [BendingBender](https://github.com/BendingBender).


---

File name: node_modules\@types\istanbul-lib-coverage\index.d.ts

Code:
export interface CoverageSummaryData {
    lines: Totals;
    statements: Totals;
    branches: Totals;
    functions: Totals;
}

export class CoverageSummary {
    constructor(data: CoverageSummary | CoverageSummaryData);
    merge(obj: CoverageSummary): CoverageSummary;
    toJSON(): CoverageSummaryData;
    isEmpty(): boolean;
    data: CoverageSummaryData;
    lines: Totals;
    statements: Totals;
    branches: Totals;
    functions: Totals;
}

export interface CoverageMapData {
    [key: string]: FileCoverage | FileCoverageData;
}

export class CoverageMap {
    constructor(data: CoverageMapData | CoverageMap);
    addFileCoverage(pathOrObject: string | FileCoverage | FileCoverageData): void;
    files(): string[];
    fileCoverageFor(filename: string): FileCoverage;
    filter(callback: (key: string) => boolean): void;
    getCoverageSummary(): CoverageSummary;
    merge(data: CoverageMapData | CoverageMap): void;
    toJSON(): CoverageMapData;
    data: CoverageMapData;
}

export interface Location {
    line: number;
    column: number;
}

export interface Range {
    start: Location;
    end: Location;
}

export interface BranchMapping {
    loc: Range;
    type: string;
    locations: Range[];
    line: number;
}

export interface FunctionMapping {
    name: string;
    decl: Range;
    loc: Range;
    line: number;
}

export interface FileCoverageData {
    path: string;
    statementMap: { [key: string]: Range };
    fnMap: { [key: string]: FunctionMapping };
    branchMap: { [key: string]: BranchMapping };
    s: { [key: string]: number };
    f: { [key: string]: number };
    b: { [key: string]: number[] };
}

export interface Totals {
    total: number;
    covered: number;
    skipped: number;
    pct: number;
}

export interface Coverage {
    covered: number;
    total: number;
    coverage: number;
}

export class FileCoverage implements FileCoverageData {
    constructor(data: string | FileCoverage | FileCoverageData);
    merge(other: FileCoverageData): void;
    getBranchCoverageByLine(): { [line: number]: Coverage };
    getLineCoverage(): { [line: number]: number };
    getUncoveredLines(): number[];
    resetHits(): void;
    computeBranchTotals(): Totals;
    computeSimpleTotals(): Totals;
    toSummary(): CoverageSummary;
    toJSON(): object;

    data: FileCoverageData;
    path: string;
    statementMap: { [key: string]: Range };
    fnMap: { [key: string]: FunctionMapping };
    branchMap: { [key: string]: BranchMapping };
    s: { [key: string]: number };
    f: { [key: string]: number };
    b: { [key: string]: number[] };
}

export const classes: {
    FileCoverage: FileCoverage;
};

export function createCoverageMap(data?: CoverageMap | CoverageMapData): CoverageMap;
export function createCoverageSummary(obj?: CoverageSummary | CoverageSummaryData): CoverageSummary;
export function createFileCoverage(pathOrObject: string | FileCoverage | FileCoverageData): FileCoverage;


---

File name: node_modules\@types\istanbul-lib-coverage\package.json

Code:
{
    "name": "@types/istanbul-lib-coverage",
    "version": "2.0.6",
    "description": "TypeScript definitions for istanbul-lib-coverage",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-coverage",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-lib-coverage"
    },
    "scripts": {},
    "dependencies": {},
    "typesPublisherContentHash": "36c823c8b3f66dab91254b0f7299de71768ad8836bfbfcaa062409dd86fbbd61",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\istanbul-lib-coverage\README.md

Code:
# Installation
> `npm install --save @types/istanbul-lib-coverage`

# Summary
This package contains type definitions for istanbul-lib-coverage (https://istanbul.js.org).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-coverage.

### Additional Details
 * Last updated: Tue, 07 Nov 2023 03:09:37 GMT
 * Dependencies: none

# Credits
These definitions were written by [Jason Cheatham](https://github.com/jason0x43).


---

File name: node_modules\@types\istanbul-lib-report\index.d.ts

Code:
import { CoverageMap, CoverageSummary, FileCoverage } from "istanbul-lib-coverage";

/**
 * returns a reporting context for the supplied options
 */
export function createContext(options?: Partial<ContextOptions>): Context;
/**
 * returns the default watermarks that would be used when not
 * overridden
 */
export function getDefaultWatermarks(): Watermarks;
export class ReportBase {
    constructor(options?: Partial<ReportBaseOptions>);
    execute(context: Context): void;
}

export interface ReportBaseOptions {
    summarizer: Summarizers;
}

export type Summarizers = "flat" | "nested" | "pkg" | "defaultSummarizer";

export interface ContextOptions {
    coverageMap: CoverageMap;
    defaultSummarizer: Summarizers;
    dir: string;
    watermarks: Partial<Watermarks>;
    sourceFinder(filepath: string): string;
}

export interface Context {
    data: any;
    dir: string;
    sourceFinder(filepath: string): string;
    watermarks: Watermarks;
    writer: FileWriter;
    /**
     * returns the coverage class given a coverage
     * types and a percentage value.
     */
    classForPercent(type: keyof Watermarks, value: number): string;
    /**
     * returns the source code for the specified file path or throws if
     * the source could not be found.
     */
    getSource(filepath: string): string;
    getTree(summarizer?: Summarizers): Tree;
    /**
     * returns a full visitor given a partial one.
     */
    getVisitor<N extends Node = Node>(visitor: Partial<Visitor<N>>): Visitor<N>;
    /**
     * returns a FileWriter implementation for reporting use. Also available
     * as the `writer` property on the context.
     */
    getWriter(): FileWriter;
    /**
     * returns an XML writer for the supplied content writer
     */
    getXmlWriter(contentWriter: ContentWriter): XmlWriter;
}

/**
 * Base class for writing content
 */
export class ContentWriter {
    /**
     * returns the colorized version of a string. Typically,
     * content writers that write to files will return the
     * same string and ones writing to a tty will wrap it in
     * appropriate escape sequences.
     */
    colorize(str: string, clazz?: string): string;
    /**
     * writes a string appended with a newline to the destination
     */
    println(str: string): void;
    /**
     * closes this content writer. Should be called after all writes are complete.
     */
    close(): void;
}

/**
 * a content writer that writes to a file
 */
export class FileContentWriter extends ContentWriter {
    constructor(fileDescriptor: number);
    write(str: string): void;
}

/**
 * a content writer that writes to the console
 */
export class ConsoleWriter extends ContentWriter {
    write(str: string): void;
}

/**
 * utility for writing files under a specific directory
 */
export class FileWriter {
    constructor(baseDir: string);
    static startCapture(): void;
    static stopCapture(): void;
    static getOutput(): string;
    static resetOutput(): void;
    /**
     * returns a FileWriter that is rooted at the supplied subdirectory
     */
    writeForDir(subdir: string): FileWriter;
    /**
     * copies a file from a source directory to a destination name
     */
    copyFile(source: string, dest: string, header?: string): void;
    /**
     * returns a content writer for writing content to the supplied file.
     */
    writeFile(file: string | null): ContentWriter;
}

export interface XmlWriter {
    indent(str: string): string;
    /**
     * writes the opening XML tag with the supplied attributes
     */
    openTag(name: string, attrs?: any): void;
    /**
     * closes an open XML tag.
     */
    closeTag(name: string): void;
    /**
     * writes a tag and its value opening and closing it at the same time
     */
    inlineTag(name: string, attrs?: any, content?: string): void;
    /**
     * closes all open tags and ends the document
     */
    closeAll(): void;
}

export type Watermark = [number, number];

export interface Watermarks {
    statements: Watermark;
    functions: Watermark;
    branches: Watermark;
    lines: Watermark;
}

export interface Node {
    isRoot(): boolean;
    visit(visitor: Visitor, state: any): void;
}

export interface ReportNode extends Node {
    path: string;
    parent: ReportNode | null;
    fileCoverage: FileCoverage;
    children: ReportNode[];
    addChild(child: ReportNode): void;
    asRelative(p: string): string;
    getQualifiedName(): string;
    getRelativeName(): string;
    getParent(): Node;
    getChildren(): Node[];
    isSummary(): boolean;
    getFileCoverage(): FileCoverage;
    getCoverageSummary(filesOnly: boolean): CoverageSummary;
    visit(visitor: Visitor<ReportNode>, state: any): void;
}

export interface Visitor<N extends Node = Node> {
    onStart(root: N, state: any): void;
    onSummary(root: N, state: any): void;
    onDetail(root: N, state: any): void;
    onSummaryEnd(root: N, state: any): void;
    onEnd(root: N, state: any): void;
}

export interface Tree<N extends Node = Node> {
    getRoot(): N;
    visit(visitor: Partial<Visitor<N>>, state: any): void;
}


---

File name: node_modules\@types\istanbul-lib-report\package.json

Code:
{
    "name": "@types/istanbul-lib-report",
    "version": "3.0.3",
    "description": "TypeScript definitions for istanbul-lib-report",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-report",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        },
        {
            "name": "Zacharias Björngren",
            "githubUsername": "zache",
            "url": "https://github.com/zache"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-lib-report"
    },
    "scripts": {},
    "dependencies": {
        "@types/istanbul-lib-coverage": "*"
    },
    "typesPublisherContentHash": "7036cfd1108c02c3ceec9ffab2cbc424c76e2cafd694c550037d808bf66e3946",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\istanbul-lib-report\README.md

Code:
# Installation
> `npm install --save @types/istanbul-lib-report`

# Summary
This package contains type definitions for istanbul-lib-report (https://istanbul.js.org).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-lib-report.

### Additional Details
 * Last updated: Tue, 07 Nov 2023 03:09:37 GMT
 * Dependencies: [@types/istanbul-lib-coverage](https://npmjs.com/package/@types/istanbul-lib-coverage)

# Credits
These definitions were written by [Jason Cheatham](https://github.com/jason0x43), and [Zacharias Björngren](https://github.com/zache).


---

File name: node_modules\@types\istanbul-reports\index.d.ts

Code:
import { Node, ReportBase } from "istanbul-lib-report";

export function create<T extends keyof ReportOptions>(name: T, options?: Partial<ReportOptions[T]>): ReportBase;

export interface FileOptions {
    file: string;
}

export interface ProjectOptions {
    projectRoot: string;
}

export interface ReportOptions {
    clover: CloverOptions;
    cobertura: CoberturaOptions;
    "html-spa": HtmlSpaOptions;
    html: HtmlOptions;
    json: JsonOptions;
    "json-summary": JsonSummaryOptions;
    lcov: LcovOptions;
    lcovonly: LcovOnlyOptions;
    none: never;
    teamcity: TeamcityOptions;
    text: TextOptions;
    "text-lcov": TextLcovOptions;
    "text-summary": TextSummaryOptions;
}

export type ReportType = keyof ReportOptions;

export interface CloverOptions extends FileOptions, ProjectOptions {}

export interface CoberturaOptions extends FileOptions, ProjectOptions {}

export interface HtmlSpaOptions extends HtmlOptions {
    metricsToShow: Array<"lines" | "branches" | "functions" | "statements">;
}
export interface HtmlOptions {
    verbose: boolean;
    skipEmpty: boolean;
    subdir: string;
    linkMapper: LinkMapper;
}

export type JsonOptions = FileOptions;
export type JsonSummaryOptions = FileOptions;

export interface LcovOptions extends FileOptions, ProjectOptions {}
export interface LcovOnlyOptions extends FileOptions, ProjectOptions {}

export interface TeamcityOptions extends FileOptions {
    blockName: string;
}

export interface TextOptions extends FileOptions {
    maxCols: number;
    skipEmpty: boolean;
    skipFull: boolean;
}
export type TextLcovOptions = ProjectOptions;
export type TextSummaryOptions = FileOptions;

export interface LinkMapper {
    getPath(node: string | Node): string;
    relativePath(source: string | Node, target: string | Node): string;
    assetPath(node: Node, name: string): string;
}


---

File name: node_modules\@types\istanbul-reports\package.json

Code:
{
    "name": "@types/istanbul-reports",
    "version": "3.0.4",
    "description": "TypeScript definitions for istanbul-reports",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-reports",
    "license": "MIT",
    "contributors": [
        {
            "name": "Jason Cheatham",
            "githubUsername": "jason0x43",
            "url": "https://github.com/jason0x43"
        },
        {
            "name": "Elena Shcherbakova",
            "githubUsername": "not-a-doctor",
            "url": "https://github.com/not-a-doctor"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/istanbul-reports"
    },
    "scripts": {},
    "dependencies": {
        "@types/istanbul-lib-report": "*"
    },
    "typesPublisherContentHash": "27b4219ea922d9218dd987cb99b49d7fc77c568322e7102565050323987fa6db",
    "typeScriptVersion": "4.5"
}

---

File name: node_modules\@types\istanbul-reports\README.md

Code:
# Installation
> `npm install --save @types/istanbul-reports`

# Summary
This package contains type definitions for istanbul-reports (https://github.com/istanbuljs/istanbuljs).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-reports.
## [index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/istanbul-reports/index.d.ts)
````ts
import { Node, ReportBase } from "istanbul-lib-report";

export function create<T extends keyof ReportOptions>(name: T, options?: Partial<ReportOptions[T]>): ReportBase;

export interface FileOptions {
    file: string;
}

export interface ProjectOptions {
    projectRoot: string;
}

export interface ReportOptions {
    clover: CloverOptions;
    cobertura: CoberturaOptions;
    "html-spa": HtmlSpaOptions;
    html: HtmlOptions;
    json: JsonOptions;
    "json-summary": JsonSummaryOptions;
    lcov: LcovOptions;
    lcovonly: LcovOnlyOptions;
    none: never;
    teamcity: TeamcityOptions;
    text: TextOptions;
    "text-lcov": TextLcovOptions;
    "text-summary": TextSummaryOptions;
}

export type ReportType = keyof ReportOptions;

export interface CloverOptions extends FileOptions, ProjectOptions {}

export interface CoberturaOptions extends FileOptions, ProjectOptions {}

export interface HtmlSpaOptions extends HtmlOptions {
    metricsToShow: Array<"lines" | "branches" | "functions" | "statements">;
}
export interface HtmlOptions {
    verbose: boolean;
    skipEmpty: boolean;
    subdir: string;
    linkMapper: LinkMapper;
}

export type JsonOptions = FileOptions;
export type JsonSummaryOptions = FileOptions;

export interface LcovOptions extends FileOptions, ProjectOptions {}
export interface LcovOnlyOptions extends FileOptions, ProjectOptions {}

export interface TeamcityOptions extends FileOptions {
    blockName: string;
}

export interface TextOptions extends FileOptions {
    maxCols: number;
    skipEmpty: boolean;
    skipFull: boolean;
}
export type TextLcovOptions = ProjectOptions;
export type TextSummaryOptions = FileOptions;

export interface LinkMapper {
    getPath(node: string | Node): string;
    relativePath(source: string | Node, target: string | Node): string;
    assetPath(node: Node, name: string): string;
}

````

### Additional Details
 * Last updated: Tue, 07 Nov 2023 03:09:37 GMT
 * Dependencies: [@types/istanbul-lib-report](https://npmjs.com/package/@types/istanbul-lib-report)

# Credits
These definitions were written by [Jason Cheatham](https://github.com/jason0x43), and [Elena Shcherbakova](https://github.com/not-a-doctor).


---

File name: node_modules\@types\node\assert\strict.d.ts

Code:
declare module "assert/strict" {
    import { strict } from "node:assert";
    export = strict;
}
declare module "node:assert/strict" {
    import { strict } from "node:assert";
    export = strict;
}


---

File name: node_modules\@types\node\assert.d.ts

Code:
/**
 * The `node:assert` module provides a set of assertion functions for verifying
 * invariants.
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/assert.js)
 */
declare module "assert" {
    /**
     * An alias of {@link ok}.
     * @since v0.5.9
     * @param value The input that is checked for being truthy.
     */
    function assert(value: unknown, message?: string | Error): asserts value;
    namespace assert {
        /**
         * Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.
         */
        class AssertionError extends Error {
            /**
             * Set to the `actual` argument for methods such as {@link assert.strictEqual()}.
             */
            actual: unknown;
            /**
             * Set to the `expected` argument for methods such as {@link assert.strictEqual()}.
             */
            expected: unknown;
            /**
             * Set to the passed in operator value.
             */
            operator: string;
            /**
             * Indicates if the message was auto-generated (`true`) or not.
             */
            generatedMessage: boolean;
            /**
             * Value is always `ERR_ASSERTION` to show that the error is an assertion error.
             */
            code: "ERR_ASSERTION";
            constructor(options?: {
                /** If provided, the error message is set to this value. */
                message?: string | undefined;
                /** The `actual` property on the error instance. */
                actual?: unknown | undefined;
                /** The `expected` property on the error instance. */
                expected?: unknown | undefined;
                /** The `operator` property on the error instance. */
                operator?: string | undefined;
                /** If provided, the generated stack trace omits frames before this function. */
                // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
                stackStartFn?: Function | undefined;
            });
        }
        /**
         * This feature is deprecated and will be removed in a future version.
         * Please consider using alternatives such as the `mock` helper function.
         * @since v14.2.0, v12.19.0
         * @deprecated Deprecated
         */
        class CallTracker {
            /**
             * The wrapper function is expected to be called exactly `exact` times. If the
             * function has not been called exactly `exact` times when `tracker.verify()` is called, then `tracker.verify()` will throw an
             * error.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func);
             * ```
             * @since v14.2.0, v12.19.0
             * @param [fn='A no-op function']
             * @param [exact=1]
             * @return A function that wraps `fn`.
             */
            calls(exact?: number): () => void;
            calls(fn: undefined, exact?: number): () => void;
            calls<Func extends (...args: any[]) => any>(fn: Func, exact?: number): Func;
            calls<Func extends (...args: any[]) => any>(fn?: Func, exact?: number): Func | (() => void);
            /**
             * Example:
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             * callsfunc(1, 2, 3);
             *
             * assert.deepStrictEqual(tracker.getCalls(callsfunc),
             *                        [{ thisArg: undefined, arguments: [1, 2, 3] }]);
             * ```
             * @since v18.8.0, v16.18.0
             * @return An array with all the calls to a tracked function.
             */
            getCalls(fn: Function): CallTrackerCall[];
            /**
             * The arrays contains information about the expected and actual number of calls of
             * the functions that have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * // Returns an array containing information on callsfunc()
             * console.log(tracker.report());
             * // [
             * //  {
             * //    message: 'Expected the func function to be executed 2 time(s) but was
             * //    executed 0 time(s).',
             * //    actual: 0,
             * //    expected: 2,
             * //    operator: 'func',
             * //    stack: stack trace
             * //  }
             * // ]
             * ```
             * @since v14.2.0, v12.19.0
             * @return An array of objects containing information about the wrapper functions returned by {@link tracker.calls()}.
             */
            report(): CallTrackerReportInformation[];
            /**
             * Reset calls of the call tracker. If a tracked function is passed as an argument, the calls will be reset for it.
             * If no arguments are passed, all tracked functions will be reset.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             *
             * callsfunc();
             * // Tracker was called once
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 1);
             *
             * tracker.reset(callsfunc);
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 0);
             * ```
             * @since v18.8.0, v16.18.0
             * @param fn a tracked function to reset.
             */
            reset(fn?: Function): void;
            /**
             * Iterates through the list of functions passed to {@link tracker.calls()} and will throw an error for functions that
             * have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * callsfunc();
             *
             * // Will throw an error since callsfunc() was only called once.
             * tracker.verify();
             * ```
             * @since v14.2.0, v12.19.0
             */
            verify(): void;
        }
        interface CallTrackerCall {
            thisArg: object;
            arguments: unknown[];
        }
        interface CallTrackerReportInformation {
            message: string;
            /** The actual number of times the function was called. */
            actual: number;
            /** The number of times the function was expected to be called. */
            expected: number;
            /** The name of the function that is wrapped. */
            operator: string;
            /** A stack trace of the function. */
            stack: object;
        }
        type AssertPredicate = RegExp | (new() => object) | ((thrown: unknown) => boolean) | object | Error;
        /**
         * Throws an `AssertionError` with the provided error message or a default
         * error message. If the `message` parameter is an instance of an `Error` then
         * it will be thrown instead of the `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.fail();
         * // AssertionError [ERR_ASSERTION]: Failed
         *
         * assert.fail('boom');
         * // AssertionError [ERR_ASSERTION]: boom
         *
         * assert.fail(new TypeError('need array'));
         * // TypeError: need array
         * ```
         *
         * Using `assert.fail()` with more than two arguments is possible but deprecated.
         * See below for further details.
         * @since v0.1.21
         * @param [message='Failed']
         */
        function fail(message?: string | Error): never;
        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */
        function fail(
            actual: unknown,
            expected: unknown,
            message?: string | Error,
            operator?: string,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
            stackStartFn?: Function,
        ): never;
        /**
         * Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.
         *
         * If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.
         *
         * Be aware that in the `repl` the error message will be different to the one
         * thrown in a file! See below for further details.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ok(true);
         * // OK
         * assert.ok(1);
         * // OK
         *
         * assert.ok();
         * // AssertionError: No value argument passed to `assert.ok()`
         *
         * assert.ok(false, 'it\'s false');
         * // AssertionError: it's false
         *
         * // In the repl:
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: false == true
         *
         * // In a file (e.g. test.js):
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(typeof 123 === 'string')
         *
         * assert.ok(false);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(false)
         *
         * assert.ok(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(0)
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * // Using `assert()` works the same:
         * assert(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert(0)
         * ```
         * @since v0.1.21
         */
        function ok(value: unknown, message?: string | Error): asserts value;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link strictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link strictEqual} instead.
         *
         * Tests shallow, coercive equality between the `actual` and `expected` parameters
         * using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled
         * and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.equal(1, 1);
         * // OK, 1 == 1
         * assert.equal(1, '1');
         * // OK, 1 == '1'
         * assert.equal(NaN, NaN);
         * // OK
         *
         * assert.equal(1, 2);
         * // AssertionError: 1 == 2
         * assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
         * // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
         * ```
         *
         * If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function equal(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notStrictEqual} instead.
         *
         * Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is
         * specially handled and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.notEqual(1, 2);
         * // OK
         *
         * assert.notEqual(1, 1);
         * // AssertionError: 1 != 1
         *
         * assert.notEqual(1, '1');
         * // AssertionError: 1 != '1'
         * ```
         *
         * If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error
         * message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link deepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link deepStrictEqual} instead.
         *
         * Tests for deep equality between the `actual` and `expected` parameters. Consider
         * using {@link deepStrictEqual} instead. {@link deepEqual} can have
         * surprising results.
         *
         * _Deep equality_ means that the enumerable "own" properties of child objects
         * are also recursively evaluated by the following rules.
         * @since v0.1.21
         */
        function deepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notDeepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notDeepStrictEqual} instead.
         *
         * Tests for any deep inequality. Opposite of {@link deepEqual}.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * const obj1 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj2 = {
         *   a: {
         *     b: 2,
         *   },
         * };
         * const obj3 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj4 = { __proto__: obj1 };
         *
         * assert.notDeepEqual(obj1, obj1);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj2);
         * // OK
         *
         * assert.notDeepEqual(obj1, obj3);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj4);
         * // OK
         * ```
         *
         * If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests strict equality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.strictEqual(1, 2);
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * //
         * // 1 !== 2
         *
         * assert.strictEqual(1, 1);
         * // OK
         *
         * assert.strictEqual('Hello foobar', 'Hello World!');
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * // + actual - expected
         * //
         * // + 'Hello foobar'
         * // - 'Hello World!'
         * //          ^
         *
         * const apples = 1;
         * const oranges = 2;
         * assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);
         * // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2
         *
         * assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));
         * // TypeError: Inputs are not identical
         * ```
         *
         * If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function strictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests strict inequality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notStrictEqual(1, 2);
         * // OK
         *
         * assert.notStrictEqual(1, 1);
         * // AssertionError [ERR_ASSERTION]: Expected "actual" to be strictly unequal to:
         * //
         * // 1
         *
         * assert.notStrictEqual(1, '1');
         * // OK
         * ```
         *
         * If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests for deep equality between the `actual` and `expected` parameters.
         * "Deep" equality means that the enumerable "own" properties of child objects
         * are recursively evaluated also by the following rules.
         * @since v1.2.0
         */
        function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests for deep strict inequality. Opposite of {@link deepStrictEqual}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
         * // OK
         * ```
         *
         * If the values are deeply and strictly equal, an `AssertionError` is thrown
         * with a `message` property set equal to the value of the `message` parameter. If
         * the `message` parameter is undefined, a default error message is assigned. If
         * the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v1.2.0
         */
        function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Expects the function `fn` to throw an error.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * a validation object where each property will be tested for strict deep equality,
         * or an instance of error where each property will be tested for strict deep
         * equality including the non-enumerable `message` and `name` properties. When
         * using an object, it is also possible to use a regular expression, when
         * validating against a string property. See below for examples.
         *
         * If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation
         * fails.
         *
         * Custom validation object/error instance:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * const err = new TypeError('Wrong value');
         * err.code = 404;
         * err.foo = 'bar';
         * err.info = {
         *   nested: true,
         *   baz: 'text',
         * };
         * err.reg = /abc/i;
         *
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *     info: {
         *       nested: true,
         *       baz: 'text',
         *     },
         *     // Only properties on the validation object will be tested for.
         *     // Using nested objects requires all properties to be present. Otherwise
         *     // the validation is going to fail.
         *   },
         * );
         *
         * // Using regular expressions to validate error properties:
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     // The `name` and `message` properties are strings and using regular
         *     // expressions on those will match against the string. If they fail, an
         *     // error is thrown.
         *     name: /^TypeError$/,
         *     message: /Wrong/,
         *     foo: 'bar',
         *     info: {
         *       nested: true,
         *       // It is not possible to use regular expressions for nested properties!
         *       baz: 'text',
         *     },
         *     // The `reg` property contains a regular expression and only if the
         *     // validation object contains an identical regular expression, it is going
         *     // to pass.
         *     reg: /abc/i,
         *   },
         * );
         *
         * // Fails due to the different `message` and `name` properties:
         * assert.throws(
         *   () => {
         *     const otherErr = new Error('Not found');
         *     // Copy all enumerable properties from `err` to `otherErr`.
         *     for (const [key, value] of Object.entries(err)) {
         *       otherErr[key] = value;
         *     }
         *     throw otherErr;
         *   },
         *   // The error's `message` and `name` properties will also be checked when using
         *   // an error as validation object.
         *   err,
         * );
         * ```
         *
         * Validate instanceof using constructor:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   Error,
         * );
         * ```
         *
         * Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):
         *
         * Using a regular expression runs `.toString` on the error object, and will
         * therefore also include the error name.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   /^Error: Wrong value$/,
         * );
         * ```
         *
         * Custom error validation:
         *
         * The function must return `true` to indicate all internal validations passed.
         * It will otherwise fail with an `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   (err) => {
         *     assert(err instanceof Error);
         *     assert(/value/.test(err));
         *     // Avoid returning anything from validation functions besides `true`.
         *     // Otherwise, it's not clear what part of the validation failed. Instead,
         *     // throw an error about the specific validation that failed (as done in this
         *     // example) and add as much helpful debugging information to that error as
         *     // possible.
         *     return true;
         *   },
         *   'unexpected error',
         * );
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second
         * argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same
         * message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using
         * a string as the second argument gets considered:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * function throwingFirst() {
         *   throw new Error('First');
         * }
         *
         * function throwingSecond() {
         *   throw new Error('Second');
         * }
         *
         * function notThrowing() {}
         *
         * // The second argument is a string and the input function threw an Error.
         * // The first case will not throw as it does not match for the error message
         * // thrown by the input function!
         * assert.throws(throwingFirst, 'Second');
         * // In the next example the message has no benefit over the message from the
         * // error and since it is not clear if the user intended to actually match
         * // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
         * assert.throws(throwingSecond, 'Second');
         * // TypeError [ERR_AMBIGUOUS_ARGUMENT]
         *
         * // The string is only used (as message) in case the function does not throw:
         * assert.throws(notThrowing, 'Second');
         * // AssertionError [ERR_ASSERTION]: Missing expected exception: Second
         *
         * // If it was intended to match for the error message do this instead:
         * // It does not throw because the error messages match.
         * assert.throws(throwingSecond, /Second$/);
         *
         * // If the error message does not match, an AssertionError is thrown.
         * assert.throws(throwingFirst, /Second$/);
         * // AssertionError [ERR_ASSERTION]
         * ```
         *
         * Due to the confusing error-prone notation, avoid a string as the second
         * argument.
         * @since v0.1.21
         */
        function throws(block: () => unknown, message?: string | Error): void;
        function throws(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Asserts that the function `fn` does not throw an error.
         *
         * Using `assert.doesNotThrow()` is actually not useful because there
         * is no benefit in catching an error and then rethrowing it. Instead, consider
         * adding a comment next to the specific code path that should not throw and keep
         * error messages as expressive as possible.
         *
         * When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.
         *
         * If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a
         * different type, or if the `error` parameter is undefined, the error is
         * propagated back to the caller.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * The following, for instance, will throw the `TypeError` because there is no
         * matching error type in the assertion:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * However, the following will result in an `AssertionError` with the message
         * 'Got unwanted exception...':
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   TypeError,
         * );
         * ```
         *
         * If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   /Wrong value/,
         *   'Whoops',
         * );
         * // Throws: AssertionError: Got unwanted exception: Whoops
         * ```
         * @since v0.1.21
         */
        function doesNotThrow(block: () => unknown, message?: string | Error): void;
        function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Throws `value` if `value` is not `undefined` or `null`. This is useful when
         * testing the `error` argument in callbacks. The stack trace contains all frames
         * from the error passed to `ifError()` including the potential new frames for `ifError()` itself.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ifError(null);
         * // OK
         * assert.ifError(0);
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
         * assert.ifError('error');
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
         * assert.ifError(new Error());
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error
         *
         * // Create some random error frames.
         * let err;
         * (function errorFrame() {
         *   err = new Error('test error');
         * })();
         *
         * (function ifErrorFrame() {
         *   assert.ifError(err);
         * })();
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
         * //     at ifErrorFrame
         * //     at errorFrame
         * ```
         * @since v0.1.97
         */
        function ifError(value: unknown): asserts value is null | undefined;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the
         * function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value)
         * error. In both cases the error handler is skipped.
         *
         * Besides the async nature to await the completion behaves identically to {@link throws}.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * an object where each property will be tested for, or an instance of error where
         * each property will be tested for including the non-enumerable `message` and `name` properties.
         *
         * If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   (err) => {
         *     assert.strictEqual(err.name, 'TypeError');
         *     assert.strictEqual(err.message, 'Wrong value');
         *     return true;
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.rejects(
         *   Promise.reject(new Error('Wrong value')),
         *   Error,
         * ).then(() => {
         *   // ...
         * });
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to
         * be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the
         * example in {@link throws} carefully if using a string as the second argument gets considered.
         * @since v10.0.0
         */
        function rejects(block: (() => Promise<unknown>) | Promise<unknown>, message?: string | Error): Promise<void>;
        function rejects(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is not rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If
         * the function does not return a promise, `assert.doesNotReject()` will return a
         * rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v24.x/api/errors.html#err_invalid_return_value) error. In both cases
         * the error handler is skipped.
         *
         * Using `assert.doesNotReject()` is actually not useful because there is little
         * benefit in catching a rejection and then rejecting it again. Instead, consider
         * adding a comment next to the specific code path that should not reject and keep
         * error messages as expressive as possible.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * Besides the async nature to await the completion behaves identically to {@link doesNotThrow}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.doesNotReject(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
         *   .then(() => {
         *     // ...
         *   });
         * ```
         * @since v10.0.0
         */
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            message?: string | Error,
        ): Promise<void>;
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Expects the `string` input to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.match('I will fail', /pass/);
         * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...
         *
         * assert.match(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.match('I will pass', /pass/);
         * // OK
         * ```
         *
         * If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function match(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * Expects the `string` input not to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotMatch('I will fail', /fail/);
         * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...
         *
         * assert.doesNotMatch(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.doesNotMatch('I will pass', /different/);
         * // OK
         * ```
         *
         * If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * Tests for partial deep equality between the `actual` and `expected` parameters.
         * "Deep" equality means that the enumerable "own" properties of child objects
         * are recursively evaluated also by the following rules. "Partial" equality means
         * that only properties that exist on the `expected` parameter are going to be
         * compared.
         *
         * This method always passes the same test cases as `assert.deepStrictEqual()`,
         * behaving as a super set of it.
         * @since v22.13.0
         */
        function partialDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example,
         * {@link deepEqual} will behave like {@link deepStrictEqual}.
         *
         * In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error
         * messages for objects display the objects, often truncated.
         *
         * To use strict assertion mode:
         *
         * ```js
         * import { strict as assert } from 'node:assert';
         * import assert from 'node:assert/strict';
         * ```
         *
         * Example error diff:
         *
         * ```js
         * import { strict as assert } from 'node:assert';
         *
         * assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);
         * // AssertionError: Expected inputs to be strictly deep-equal:
         * // + actual - expected ... Lines skipped
         * //
         * //   [
         * //     [
         * // ...
         * //       2,
         * // +     3
         * // -     '3'
         * //     ],
         * // ...
         * //     5
         * //   ]
         * ```
         *
         * To deactivate the colors, use the `NO_COLOR` or `NODE_DISABLE_COLORS` environment variables. This will also
         * deactivate the colors in the REPL. For more on color support in terminal environments, read the tty
         * `getColorDepth()` documentation.
         *
         * @since v15.0.0, v13.9.0, v12.16.2, v9.9.0
         */
        namespace strict {
            type AssertionError = assert.AssertionError;
            type AssertPredicate = assert.AssertPredicate;
            type CallTrackerCall = assert.CallTrackerCall;
            type CallTrackerReportInformation = assert.CallTrackerReportInformation;
        }
        const strict:
            & Omit<
                typeof assert,
                | "equal"
                | "notEqual"
                | "deepEqual"
                | "notDeepEqual"
                | "ok"
                | "strictEqual"
                | "deepStrictEqual"
                | "ifError"
                | "strict"
                | "AssertionError"
            >
            & {
                (value: unknown, message?: string | Error): asserts value;
                equal: typeof strictEqual;
                notEqual: typeof notStrictEqual;
                deepEqual: typeof deepStrictEqual;
                notDeepEqual: typeof notDeepStrictEqual;
                // Mapped types and assertion functions are incompatible?
                // TS2775: Assertions require every name in the call target
                // to be declared with an explicit type annotation.
                ok: typeof ok;
                strictEqual: typeof strictEqual;
                deepStrictEqual: typeof deepStrictEqual;
                ifError: typeof ifError;
                strict: typeof strict;
                AssertionError: typeof AssertionError;
            };
    }
    export = assert;
}
declare module "node:assert" {
    import assert = require("assert");
    export = assert;
}


---

File name: node_modules\@types\node\async_hooks.d.ts

Code:
/**
 * We strongly discourage the use of the `async_hooks` API.
 * Other APIs that can cover most of its use cases include:
 *
 * * [`AsyncLocalStorage`](https://nodejs.org/docs/latest-v24.x/api/async_context.html#class-asynclocalstorage) tracks async context
 * * [`process.getActiveResourcesInfo()`](https://nodejs.org/docs/latest-v24.x/api/process.html#processgetactiveresourcesinfo) tracks active resources
 *
 * The `node:async_hooks` module provides an API to track asynchronous resources.
 * It can be accessed using:
 *
 * ```js
 * import async_hooks from 'node:async_hooks';
 * ```
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/async_hooks.js)
 */
declare module "async_hooks" {
    /**
     * ```js
     * import { executionAsyncId } from 'node:async_hooks';
     * import fs from 'node:fs';
     *
     * console.log(executionAsyncId());  // 1 - bootstrap
     * const path = '.';
     * fs.open(path, 'r', (err, fd) => {
     *   console.log(executionAsyncId());  // 6 - open()
     * });
     * ```
     *
     * The ID returned from `executionAsyncId()` is related to execution timing, not
     * causality (which is covered by `triggerAsyncId()`):
     *
     * ```js
     * const server = net.createServer((conn) => {
     *   // Returns the ID of the server, not of the new connection, because the
     *   // callback runs in the execution scope of the server's MakeCallback().
     *   async_hooks.executionAsyncId();
     *
     * }).listen(port, () => {
     *   // Returns the ID of a TickObject (process.nextTick()) because all
     *   // callbacks passed to .listen() are wrapped in a nextTick().
     *   async_hooks.executionAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get precise `executionAsyncIds` by default.
     * See the section on [promise execution tracking](https://nodejs.org/docs/latest-v24.x/api/async_hooks.html#promise-execution-tracking).
     * @since v8.1.0
     * @return The `asyncId` of the current execution context. Useful to track when something calls.
     */
    function executionAsyncId(): number;
    /**
     * Resource objects returned by `executionAsyncResource()` are most often internal
     * Node.js handle objects with undocumented APIs. Using any functions or properties
     * on the object is likely to crash your application and should be avoided.
     *
     * Using `executionAsyncResource()` in the top-level execution context will
     * return an empty object as there is no handle or request object to use,
     * but having an object representing the top-level can be helpful.
     *
     * ```js
     * import { open } from 'node:fs';
     * import { executionAsyncId, executionAsyncResource } from 'node:async_hooks';
     *
     * console.log(executionAsyncId(), executionAsyncResource());  // 1 {}
     * open(new URL(import.meta.url), 'r', (err, fd) => {
     *   console.log(executionAsyncId(), executionAsyncResource());  // 7 FSReqWrap
     * });
     * ```
     *
     * This can be used to implement continuation local storage without the
     * use of a tracking `Map` to store the metadata:
     *
     * ```js
     * import { createServer } from 'node:http';
     * import {
     *   executionAsyncId,
     *   executionAsyncResource,
     *   createHook,
     * } from 'node:async_hooks';
     * const sym = Symbol('state'); // Private symbol to avoid pollution
     *
     * createHook({
     *   init(asyncId, type, triggerAsyncId, resource) {
     *     const cr = executionAsyncResource();
     *     if (cr) {
     *       resource[sym] = cr[sym];
     *     }
     *   },
     * }).enable();
     *
     * const server = createServer((req, res) => {
     *   executionAsyncResource()[sym] = { state: req.url };
     *   setTimeout(function() {
     *     res.end(JSON.stringify(executionAsyncResource()[sym]));
     *   }, 100);
     * }).listen(3000);
     * ```
     * @since v13.9.0, v12.17.0
     * @return The resource representing the current execution. Useful to store data within the resource.
     */
    function executionAsyncResource(): object;
    /**
     * ```js
     * const server = net.createServer((conn) => {
     *   // The resource that caused (or triggered) this callback to be called
     *   // was that of the new connection. Thus the return value of triggerAsyncId()
     *   // is the asyncId of "conn".
     *   async_hooks.triggerAsyncId();
     *
     * }).listen(port, () => {
     *   // Even though all callbacks passed to .listen() are wrapped in a nextTick()
     *   // the callback itself exists because the call to the server's .listen()
     *   // was made. So the return value would be the ID of the server.
     *   async_hooks.triggerAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get valid `triggerAsyncId`s by default. See
     * the section on [promise execution tracking](https://nodejs.org/docs/latest-v24.x/api/async_hooks.html#promise-execution-tracking).
     * @return The ID of the resource responsible for calling the callback that is currently being executed.
     */
    function triggerAsyncId(): number;
    interface HookCallbacks {
        /**
         * Called when a class is constructed that has the possibility to emit an asynchronous event.
         * @param asyncId A unique ID for the async resource
         * @param type The type of the async resource
         * @param triggerAsyncId The unique ID of the async resource in whose execution context this async resource was created
         * @param resource Reference to the resource representing the async operation, needs to be released during destroy
         */
        init?(asyncId: number, type: string, triggerAsyncId: number, resource: object): void;
        /**
         * When an asynchronous operation is initiated or completes a callback is called to notify the user.
         * The before callback is called just before said callback is executed.
         * @param asyncId the unique identifier assigned to the resource about to execute the callback.
         */
        before?(asyncId: number): void;
        /**
         * Called immediately after the callback specified in `before` is completed.
         *
         * If an uncaught exception occurs during execution of the callback, then `after` will run after the `'uncaughtException'` event is emitted or a `domain`'s handler runs.
         * @param asyncId the unique identifier assigned to the resource which has executed the callback.
         */
        after?(asyncId: number): void;
        /**
         * Called when a promise has resolve() called. This may not be in the same execution id
         * as the promise itself.
         * @param asyncId the unique id for the promise that was resolve()d.
         */
        promiseResolve?(asyncId: number): void;
        /**
         * Called after the resource corresponding to asyncId is destroyed
         * @param asyncId a unique ID for the async resource
         */
        destroy?(asyncId: number): void;
    }
    interface AsyncHook {
        /**
         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.
         */
        enable(): this;
        /**
         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.
         */
        disable(): this;
    }
    /**
     * Registers functions to be called for different lifetime events of each async
     * operation.
     *
     * The callbacks `init()`/`before()`/`after()`/`destroy()` are called for the
     * respective asynchronous event during a resource's lifetime.
     *
     * All callbacks are optional. For example, if only resource cleanup needs to
     * be tracked, then only the `destroy` callback needs to be passed. The
     * specifics of all functions that can be passed to `callbacks` is in the `Hook Callbacks` section.
     *
     * ```js
     * import { createHook } from 'node:async_hooks';
     *
     * const asyncHook = createHook({
     *   init(asyncId, type, triggerAsyncId, resource) { },
     *   destroy(asyncId) { },
     * });
     * ```
     *
     * The callbacks will be inherited via the prototype chain:
     *
     * ```js
     * class MyAsyncCallbacks {
     *   init(asyncId, type, triggerAsyncId, resource) { }
     *   destroy(asyncId) {}
     * }
     *
     * class MyAddedCallbacks extends MyAsyncCallbacks {
     *   before(asyncId) { }
     *   after(asyncId) { }
     * }
     *
     * const asyncHook = async_hooks.createHook(new MyAddedCallbacks());
     * ```
     *
     * Because promises are asynchronous resources whose lifecycle is tracked
     * via the async hooks mechanism, the `init()`, `before()`, `after()`, and`destroy()` callbacks _must not_ be async functions that return promises.
     * @since v8.1.0
     * @param callbacks The `Hook Callbacks` to register
     * @return Instance used for disabling and enabling hooks
     */
    function createHook(callbacks: HookCallbacks): AsyncHook;
    interface AsyncResourceOptions {
        /**
         * The ID of the execution context that created this async event.
         * @default executionAsyncId()
         */
        triggerAsyncId?: number | undefined;
        /**
         * Disables automatic `emitDestroy` when the object is garbage collected.
         * This usually does not need to be set (even if `emitDestroy` is called
         * manually), unless the resource's `asyncId` is retrieved and the
         * sensitive API's `emitDestroy` is called with it.
         * @default false
         */
        requireManualDestroy?: boolean | undefined;
    }
    /**
     * The class `AsyncResource` is designed to be extended by the embedder's async
     * resources. Using this, users can easily trigger the lifetime events of their
     * own resources.
     *
     * The `init` hook will trigger when an `AsyncResource` is instantiated.
     *
     * The following is an overview of the `AsyncResource` API.
     *
     * ```js
     * import { AsyncResource, executionAsyncId } from 'node:async_hooks';
     *
     * // AsyncResource() is meant to be extended. Instantiating a
     * // new AsyncResource() also triggers init. If triggerAsyncId is omitted then
     * // async_hook.executionAsyncId() is used.
     * const asyncResource = new AsyncResource(
     *   type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false },
     * );
     *
     * // Run a function in the execution context of the resource. This will
     * // * establish the context of the resource
     * // * trigger the AsyncHooks before callbacks
     * // * call the provided function `fn` with the supplied arguments
     * // * trigger the AsyncHooks after callbacks
     * // * restore the original execution context
     * asyncResource.runInAsyncScope(fn, thisArg, ...args);
     *
     * // Call AsyncHooks destroy callbacks.
     * asyncResource.emitDestroy();
     *
     * // Return the unique ID assigned to the AsyncResource instance.
     * asyncResource.asyncId();
     *
     * // Return the trigger ID for the AsyncResource instance.
     * asyncResource.triggerAsyncId();
     * ```
     */
    class AsyncResource {
        /**
         * AsyncResource() is meant to be extended. Instantiating a
         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then
         * async_hook.executionAsyncId() is used.
         * @param type The type of async event.
         * @param triggerAsyncId The ID of the execution context that created
         *   this async event (default: `executionAsyncId()`), or an
         *   AsyncResourceOptions object (since v9.3.0)
         */
        constructor(type: string, triggerAsyncId?: number | AsyncResourceOptions);
        /**
         * Binds the given function to the current execution context.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current execution context.
         * @param type An optional name to associate with the underlying `AsyncResource`.
         */
        static bind<Func extends (this: ThisArg, ...args: any[]) => any, ThisArg>(
            fn: Func,
            type?: string,
            thisArg?: ThisArg,
        ): Func;
        /**
         * Binds the given function to execute to this `AsyncResource`'s scope.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current `AsyncResource`.
         */
        bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Call the provided function with the provided arguments in the execution context
         * of the async resource. This will establish the context, trigger the AsyncHooks
         * before callbacks, call the function, trigger the AsyncHooks after callbacks, and
         * then restore the original execution context.
         * @since v9.6.0
         * @param fn The function to call in the execution context of this async resource.
         * @param thisArg The receiver to be used for the function call.
         * @param args Optional arguments to pass to the function.
         */
        runInAsyncScope<This, Result>(
            fn: (this: This, ...args: any[]) => Result,
            thisArg?: This,
            ...args: any[]
        ): Result;
        /**
         * Call all `destroy` hooks. This should only ever be called once. An error will
         * be thrown if it is called more than once. This **must** be manually called. If
         * the resource is left to be collected by the GC then the `destroy` hooks will
         * never be called.
         * @return A reference to `asyncResource`.
         */
        emitDestroy(): this;
        /**
         * @return The unique `asyncId` assigned to the resource.
         */
        asyncId(): number;
        /**
         * @return The same `triggerAsyncId` that is passed to the `AsyncResource` constructor.
         */
        triggerAsyncId(): number;
    }
    interface AsyncLocalStorageOptions {
        /**
         * The default value to be used when no store is provided.
         */
        defaultValue?: any;
        /**
         * A name for the `AsyncLocalStorage` value.
         */
        name?: string | undefined;
    }
    /**
     * This class creates stores that stay coherent through asynchronous operations.
     *
     * While you can create your own implementation on top of the `node:async_hooks` module, `AsyncLocalStorage` should be preferred as it is a performant and memory
     * safe implementation that involves significant optimizations that are non-obvious
     * to implement.
     *
     * The following example uses `AsyncLocalStorage` to build a simple logger
     * that assigns IDs to incoming HTTP requests and includes them in messages
     * logged within each request.
     *
     * ```js
     * import http from 'node:http';
     * import { AsyncLocalStorage } from 'node:async_hooks';
     *
     * const asyncLocalStorage = new AsyncLocalStorage();
     *
     * function logWithId(msg) {
     *   const id = asyncLocalStorage.getStore();
     *   console.log(`${id !== undefined ? id : '-'}:`, msg);
     * }
     *
     * let idSeq = 0;
     * http.createServer((req, res) => {
     *   asyncLocalStorage.run(idSeq++, () => {
     *     logWithId('start');
     *     // Imagine any chain of async operations here
     *     setImmediate(() => {
     *       logWithId('finish');
     *       res.end();
     *     });
     *   });
     * }).listen(8080);
     *
     * http.get('http://localhost:8080');
     * http.get('http://localhost:8080');
     * // Prints:
     * //   0: start
     * //   0: finish
     * //   1: start
     * //   1: finish
     * ```
     *
     * Each instance of `AsyncLocalStorage` maintains an independent storage context.
     * Multiple instances can safely exist simultaneously without risk of interfering
     * with each other's data.
     * @since v13.10.0, v12.17.0
     */
    class AsyncLocalStorage<T> {
        /**
         * Creates a new instance of `AsyncLocalStorage`. Store is only provided within a
         * `run()` call or after an `enterWith()` call.
         */
        constructor(options?: AsyncLocalStorageOptions);
        /**
         * Binds the given function to the current execution context.
         * @since v19.8.0
         * @param fn The function to bind to the current execution context.
         * @return A new function that calls `fn` within the captured execution context.
         */
        static bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Captures the current execution context and returns a function that accepts a
         * function as an argument. Whenever the returned function is called, it
         * calls the function passed to it within the captured context.
         *
         * ```js
         * const asyncLocalStorage = new AsyncLocalStorage();
         * const runInAsyncScope = asyncLocalStorage.run(123, () => AsyncLocalStorage.snapshot());
         * const result = asyncLocalStorage.run(321, () => runInAsyncScope(() => asyncLocalStorage.getStore()));
         * console.log(result);  // returns 123
         * ```
         *
         * AsyncLocalStorage.snapshot() can replace the use of AsyncResource for simple
         * async context tracking purposes, for example:
         *
         * ```js
         * class Foo {
         *   #runInAsyncScope = AsyncLocalStorage.snapshot();
         *
         *   get() { return this.#runInAsyncScope(() => asyncLocalStorage.getStore()); }
         * }
         *
         * const foo = asyncLocalStorage.run(123, () => new Foo());
         * console.log(asyncLocalStorage.run(321, () => foo.get())); // returns 123
         * ```
         * @since v19.8.0
         * @return A new function with the signature `(fn: (...args) : R, ...args) : R`.
         */
        static snapshot(): <R, TArgs extends any[]>(fn: (...args: TArgs) => R, ...args: TArgs) => R;
        /**
         * Disables the instance of `AsyncLocalStorage`. All subsequent calls
         * to `asyncLocalStorage.getStore()` will return `undefined` until `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()` is called again.
         *
         * When calling `asyncLocalStorage.disable()`, all current contexts linked to the
         * instance will be exited.
         *
         * Calling `asyncLocalStorage.disable()` is required before the `asyncLocalStorage` can be garbage collected. This does not apply to stores
         * provided by the `asyncLocalStorage`, as those objects are garbage collected
         * along with the corresponding async resources.
         *
         * Use this method when the `asyncLocalStorage` is not in use anymore
         * in the current process.
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        disable(): void;
        /**
         * Returns the current store.
         * If called outside of an asynchronous context initialized by
         * calling `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()`, it
         * returns `undefined`.
         * @since v13.10.0, v12.17.0
         */
        getStore(): T | undefined;
        /**
         * The name of the `AsyncLocalStorage` instance if provided.
         * @since v24.0.0
         */
        readonly name: string;
        /**
         * Runs a function synchronously within a context and returns its
         * return value. The store is not accessible outside of the callback function.
         * The store is accessible to any asynchronous operations created within the
         * callback.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `run()` too.
         * The stacktrace is not impacted by this call and the context is exited.
         *
         * Example:
         *
         * ```js
         * const store = { id: 2 };
         * try {
         *   asyncLocalStorage.run(store, () => {
         *     asyncLocalStorage.getStore(); // Returns the store object
         *     setTimeout(() => {
         *       asyncLocalStorage.getStore(); // Returns the store object
         *     }, 200);
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns undefined
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         */
        run<R>(store: T, callback: () => R): R;
        run<R, TArgs extends any[]>(store: T, callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Runs a function synchronously outside of a context and returns its
         * return value. The store is not accessible within the callback function or
         * the asynchronous operations created within the callback. Any `getStore()` call done within the callback function will always return `undefined`.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `exit()` too.
         * The stacktrace is not impacted by this call and the context is re-entered.
         *
         * Example:
         *
         * ```js
         * // Within a call to run
         * try {
         *   asyncLocalStorage.getStore(); // Returns the store object or value
         *   asyncLocalStorage.exit(() => {
         *     asyncLocalStorage.getStore(); // Returns undefined
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns the same object or value
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        exit<R, TArgs extends any[]>(callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Transitions into the context for the remainder of the current
         * synchronous execution and then persists the store through any following
         * asynchronous calls.
         *
         * Example:
         *
         * ```js
         * const store = { id: 1 };
         * // Replaces previous store with the given store object
         * asyncLocalStorage.enterWith(store);
         * asyncLocalStorage.getStore(); // Returns the store object
         * someAsyncOperation(() => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         * ```
         *
         * This transition will continue for the _entire_ synchronous execution.
         * This means that if, for example, the context is entered within an event
         * handler subsequent event handlers will also run within that context unless
         * specifically bound to another context with an `AsyncResource`. That is why `run()` should be preferred over `enterWith()` unless there are strong reasons
         * to use the latter method.
         *
         * ```js
         * const store = { id: 1 };
         *
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.enterWith(store);
         * });
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         *
         * asyncLocalStorage.getStore(); // Returns undefined
         * emitter.emit('my-event');
         * asyncLocalStorage.getStore(); // Returns the same object
         * ```
         * @since v13.11.0, v12.17.0
         * @experimental
         */
        enterWith(store: T): void;
    }
    /**
     * @since v17.2.0, v16.14.0
     * @return A map of provider types to the corresponding numeric id.
     * This map contains all the event types that might be emitted by the `async_hooks.init()` event.
     */
    namespace asyncWrapProviders {
        const NONE: number;
        const DIRHANDLE: number;
        const DNSCHANNEL: number;
        const ELDHISTOGRAM: number;
        const FILEHANDLE: number;
        const FILEHANDLECLOSEREQ: number;
        const FIXEDSIZEBLOBCOPY: number;
        const FSEVENTWRAP: number;
        const FSREQCALLBACK: number;
        const FSREQPROMISE: number;
        const GETADDRINFOREQWRAP: number;
        const GETNAMEINFOREQWRAP: number;
        const HEAPSNAPSHOT: number;
        const HTTP2SESSION: number;
        const HTTP2STREAM: number;
        const HTTP2PING: number;
        const HTTP2SETTINGS: number;
        const HTTPINCOMINGMESSAGE: number;
        const HTTPCLIENTREQUEST: number;
        const JSSTREAM: number;
        const JSUDPWRAP: number;
        const MESSAGEPORT: number;
        const PIPECONNECTWRAP: number;
        const PIPESERVERWRAP: number;
        const PIPEWRAP: number;
        const PROCESSWRAP: number;
        const PROMISE: number;
        const QUERYWRAP: number;
        const SHUTDOWNWRAP: number;
        const SIGNALWRAP: number;
        const STATWATCHER: number;
        const STREAMPIPE: number;
        const TCPCONNECTWRAP: number;
        const TCPSERVERWRAP: number;
        const TCPWRAP: number;
        const TTYWRAP: number;
        const UDPSENDWRAP: number;
        const UDPWRAP: number;
        const SIGINTWATCHDOG: number;
        const WORKER: number;
        const WORKERHEAPSNAPSHOT: number;
        const WRITEWRAP: number;
        const ZLIB: number;
        const CHECKPRIMEREQUEST: number;
        const PBKDF2REQUEST: number;
        const KEYPAIRGENREQUEST: number;
        const KEYGENREQUEST: number;
        const KEYEXPORTREQUEST: number;
        const CIPHERREQUEST: number;
        const DERIVEBITSREQUEST: number;
        const HASHREQUEST: number;
        const RANDOMBYTESREQUEST: number;
        const RANDOMPRIMEREQUEST: number;
        const SCRYPTREQUEST: number;
        const SIGNREQUEST: number;
        const TLSWRAP: number;
        const VERIFYREQUEST: number;
    }
}
declare module "node:async_hooks" {
    export * from "async_hooks";
}


---

File name: node_modules\@types\node\buffer.buffer.d.ts

Code:
declare module "buffer" {
    type ImplicitArrayBuffer<T extends WithImplicitCoercion<ArrayBufferLike>> = T extends
        { valueOf(): infer V extends ArrayBufferLike } ? V : T;
    global {
        interface BufferConstructor {
            // see buffer.d.ts for implementation shared with all TypeScript versions

            /**
             * Allocates a new buffer containing the given {str}.
             *
             * @param str String to store in buffer.
             * @param encoding encoding to use, optional.  Default is 'utf8'
             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.
             */
            new(str: string, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            /**
             * Allocates a new buffer of {size} octets.
             *
             * @param size count of octets to allocate.
             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
             */
            new(size: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: ArrayLike<number>): Buffer<ArrayBuffer>;
            /**
             * Produces a Buffer backed by the same allocated memory as
             * the given {ArrayBuffer}/{SharedArrayBuffer}.
             *
             * @param arrayBuffer The ArrayBuffer with which to share memory.
             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.
             */
            new<TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(arrayBuffer: TArrayBuffer): Buffer<TArrayBuffer>;
            /**
             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.
             * Array entries outside that range will be truncated to fit into it.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
             * ```
             *
             * If `array` is an `Array`-like object (that is, one with a `length` property of
             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or
             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an
             * `Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use
             * `Buffer.copyBytesFrom()`.
             *
             * A `TypeError` will be thrown if `array` is not an `Array` or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal
             * `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             */
            from(array: WithImplicitCoercion<ArrayLike<number>>): Buffer<ArrayBuffer>;
            /**
             * This creates a view of the `ArrayBuffer` without copying the underlying
             * memory. For example, when passed a reference to the `.buffer` property of a
             * `TypedArray` instance, the newly created `Buffer` will share the same
             * allocated memory as the `TypedArray`'s underlying `ArrayBuffer`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const arr = new Uint16Array(2);
             *
             * arr[0] = 5000;
             * arr[1] = 4000;
             *
             * // Shares memory with `arr`.
             * const buf = Buffer.from(arr.buffer);
             *
             * console.log(buf);
             * // Prints: <Buffer 88 13 a0 0f>
             *
             * // Changing the original Uint16Array changes the Buffer also.
             * arr[1] = 6000;
             *
             * console.log(buf);
             * // Prints: <Buffer 88 13 70 17>
             * ```
             *
             * The optional `byteOffset` and `length` arguments specify a memory range within
             * the `arrayBuffer` that will be shared by the `Buffer`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const ab = new ArrayBuffer(10);
             * const buf = Buffer.from(ab, 0, 2);
             *
             * console.log(buf.length);
             * // Prints: 2
             * ```
             *
             * A `TypeError` will be thrown if `arrayBuffer` is not an `ArrayBuffer` or a
             * `SharedArrayBuffer` or another type appropriate for `Buffer.from()`
             * variants.
             *
             * It is important to remember that a backing `ArrayBuffer` can cover a range
             * of memory that extends beyond the bounds of a `TypedArray` view. A new
             * `Buffer` created using the `buffer` property of a `TypedArray` may extend
             * beyond the range of the `TypedArray`:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements
             * const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements
             * console.log(arrA.buffer === arrB.buffer); // true
             *
             * const buf = Buffer.from(arrB.buffer);
             * console.log(buf);
             * // Prints: <Buffer 63 64 65 66>
             * ```
             * @since v5.10.0
             * @param arrayBuffer An `ArrayBuffer`, `SharedArrayBuffer`, for example the
             * `.buffer` property of a `TypedArray`.
             * @param byteOffset Index of first byte to expose. **Default:** `0`.
             * @param length Number of bytes to expose. **Default:**
             * `arrayBuffer.byteLength - byteOffset`.
             */
            from<TArrayBuffer extends WithImplicitCoercion<ArrayBufferLike>>(
                arrayBuffer: TArrayBuffer,
                byteOffset?: number,
                length?: number,
            ): Buffer<ImplicitArrayBuffer<TArrayBuffer>>;
            /**
             * Creates a new `Buffer` containing `string`. The `encoding` parameter identifies
             * the character encoding to be used when converting `string` into bytes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('this is a tést');
             * const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
             *
             * console.log(buf1.toString());
             * // Prints: this is a tést
             * console.log(buf2.toString());
             * // Prints: this is a tést
             * console.log(buf1.toString('latin1'));
             * // Prints: this is a tÃ©st
             * ```
             *
             * A `TypeError` will be thrown if `string` is not a string or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(string)` may also use the internal `Buffer` pool like
             * `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             * @param string A string to encode.
             * @param encoding The encoding of `string`. **Default:** `'utf8'`.
             */
            from(string: WithImplicitCoercion<string>, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            from(arrayOrString: WithImplicitCoercion<ArrayLike<number> | string>): Buffer<ArrayBuffer>;
            /**
             * Creates a new Buffer using the passed {data}
             * @param values to create a new Buffer
             */
            of(...items: number[]): Buffer<ArrayBuffer>;
            /**
             * Returns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.
             *
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length `Buffer` is returned.
             *
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances
             * in `list` by adding their lengths.
             *
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
             * truncated to `totalLength`. If the combined length of the `Buffer`s in `list` is
             * less than `totalLength`, the remaining space is filled with zeros.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a single `Buffer` from a list of three `Buffer` instances.
             *
             * const buf1 = Buffer.alloc(10);
             * const buf2 = Buffer.alloc(14);
             * const buf3 = Buffer.alloc(18);
             * const totalLength = buf1.length + buf2.length + buf3.length;
             *
             * console.log(totalLength);
             * // Prints: 42
             *
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
             *
             * console.log(bufA);
             * // Prints: <Buffer 00 00 00 00 ...>
             * console.log(bufA.length);
             * // Prints: 42
             * ```
             *
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v0.7.11
             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.
             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.
             */
            concat(list: readonly Uint8Array[], totalLength?: number): Buffer<ArrayBuffer>;
            /**
             * Copies the underlying memory of `view` into a new `Buffer`.
             *
             * ```js
             * const u16 = new Uint16Array([0, 0xffff]);
             * const buf = Buffer.copyBytesFrom(u16, 1, 1);
             * u16[1] = 0;
             * console.log(buf.length); // 2
             * console.log(buf[0]); // 255
             * console.log(buf[1]); // 255
             * ```
             * @since v19.8.0
             * @param view The {TypedArray} to copy.
             * @param [offset=0] The starting offset within `view`.
             * @param [length=view.length - offset] The number of elements from `view` to copy.
             */
            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5, 'a');
             *
             * console.log(buf);
             * // Prints: <Buffer 61 61 61 61 61>
             * ```
             *
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be
             * initialized by calling `buf.fill(fill, encoding)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
             *
             * console.log(buf);
             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
             * ```
             *
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
             * contents will never contain sensitive data from previous allocations, including
             * data that might not have been allocated for `Buffer`s.
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             * @param [fill=0] A value to pre-fill the new `Buffer` with.
             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.
             */
            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(10);
             *
             * console.log(buf);
             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>
             *
             * buf.fill(0);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             *
             * The `Buffer` module pre-allocates an internal `Buffer` instance of
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new `Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,
             * and `Buffer.concat()` only when `size` is less than `Buffer.poolSize >>> 1` (floor of `Buffer.poolSize` divided by two).
             *
             * Use of this pre-allocated internal memory pool is a key difference between
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less
             * than or equal to half `Buffer.poolSize`. The
             * difference is subtle but can be important when an application requires the
             * additional performance that `Buffer.allocUnsafe()` provides.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafe(size: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if
             * `size` is 0.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize
             * such `Buffer` instances with zeroes.
             *
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This
             * allows applications to avoid the garbage collection overhead of creating many
             * individually allocated `Buffer` instances. This approach improves both
             * performance and memory usage by eliminating the need to track and clean up as
             * many individual `ArrayBuffer` objects.
             *
             * However, in the case where a developer may need to retain a small chunk of
             * memory from a pool for an indeterminate amount of time, it may be appropriate
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
             * then copying out the relevant bits.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Need to keep around a few small chunks of memory.
             * const store = [];
             *
             * socket.on('readable', () => {
             *   let data;
             *   while (null !== (data = readable.read())) {
             *     // Allocate for retained data.
             *     const sb = Buffer.allocUnsafeSlow(10);
             *
             *     // Copy the data into the new allocation.
             *     data.copy(sb, 0, 0, 10);
             *
             *     store.push(sb);
             *   }
             * });
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.12.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafeSlow(size: number): Buffer<ArrayBuffer>;
        }
        interface Buffer<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> extends Uint8Array<TArrayBuffer> {
            // see buffer.d.ts for implementation shared with all TypeScript versions

            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * This method is not compatible with the `Uint8Array.prototype.slice()`,
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * const copiedBuf = Uint8Array.prototype.slice.call(buf);
             * copiedBuf[0]++;
             * console.log(copiedBuf.toString());
             * // Prints: cuffer
             *
             * console.log(buf.toString());
             * // Prints: buffer
             *
             * // With buf.slice(), the original buffer is modified.
             * const notReallyCopiedBuf = buf.slice();
             * notReallyCopiedBuf[0]++;
             * console.log(notReallyCopiedBuf.toString());
             * // Prints: cuffer
             * console.log(buf.toString());
             * // Also prints: cuffer (!)
             * ```
             * @since v0.3.0
             * @deprecated Use `subarray` instead.
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            slice(start?: number, end?: number): Buffer<ArrayBuffer>;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * Specifying `end` greater than `buf.length` will return the same result as
             * that of `end` equal to `buf.length`.
             *
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).
             *
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
             * // from the original `Buffer`.
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * const buf2 = buf1.subarray(0, 3);
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: abc
             *
             * buf1[0] = 33;
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: !bc
             * ```
             *
             * Specifying negative indexes causes the slice to be generated relative to the
             * end of `buf` rather than the beginning.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * console.log(buf.subarray(-6, -1).toString());
             * // Prints: buffe
             * // (Equivalent to buf.subarray(0, 5).)
             *
             * console.log(buf.subarray(-6, -2).toString());
             * // Prints: buff
             * // (Equivalent to buf.subarray(0, 4).)
             *
             * console.log(buf.subarray(-5, -2).toString());
             * // Prints: uff
             * // (Equivalent to buf.subarray(1, 4).)
             * ```
             * @since v3.0.0
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            subarray(start?: number, end?: number): Buffer<TArrayBuffer>;
        }
        type NonSharedBuffer = Buffer<ArrayBuffer>;
        type AllowSharedBuffer = Buffer<ArrayBufferLike>;
    }
    /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */
    var SlowBuffer: {
        /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */
        new(size: number): Buffer<ArrayBuffer>;
        prototype: Buffer;
    };
}


---

