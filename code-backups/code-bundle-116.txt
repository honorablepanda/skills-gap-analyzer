File name: node_modules\@types\node\perf_hooks.d.ts

Code:
/**
 * This module provides an implementation of a subset of the W3C [Web Performance APIs](https://w3c.github.io/perf-timing-primer/) as well as additional APIs for
 * Node.js-specific performance measurements.
 *
 * Node.js supports the following [Web Performance APIs](https://w3c.github.io/perf-timing-primer/):
 *
 * * [High Resolution Time](https://www.w3.org/TR/hr-time-2)
 * * [Performance Timeline](https://w3c.github.io/performance-timeline/)
 * * [User Timing](https://www.w3.org/TR/user-timing/)
 * * [Resource Timing](https://www.w3.org/TR/resource-timing-2/)
 *
 * ```js
 * import { PerformanceObserver, performance } from 'node:perf_hooks';
 *
 * const obs = new PerformanceObserver((items) => {
 *   console.log(items.getEntries()[0].duration);
 *   performance.clearMarks();
 * });
 * obs.observe({ type: 'measure' });
 * performance.measure('Start to Now');
 *
 * performance.mark('A');
 * doSomeLongRunningProcess(() => {
 *   performance.measure('A to Now', 'A');
 *
 *   performance.mark('B');
 *   performance.measure('A to B', 'A', 'B');
 * });
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/perf_hooks.js)
 */
declare module "perf_hooks" {
    import { AsyncResource } from "node:async_hooks";
    type EntryType =
        | "dns" // Node.js only
        | "function" // Node.js only
        | "gc" // Node.js only
        | "http2" // Node.js only
        | "http" // Node.js only
        | "mark" // available on the Web
        | "measure" // available on the Web
        | "net" // Node.js only
        | "node" // Node.js only
        | "resource"; // available on the Web
    interface NodeGCPerformanceDetail {
        /**
         * When `performanceEntry.entryType` is equal to 'gc', the `performance.kind` property identifies
         * the type of garbage collection operation that occurred.
         * See perf_hooks.constants for valid values.
         */
        readonly kind?: number | undefined;
        /**
         * When `performanceEntry.entryType` is equal to 'gc', the `performance.flags`
         * property contains additional information about garbage collection operation.
         * See perf_hooks.constants for valid values.
         */
        readonly flags?: number | undefined;
    }
    /**
     * The constructor of this class is not exposed to users directly.
     * @since v8.5.0
     */
    class PerformanceEntry {
        protected constructor();
        /**
         * The total number of milliseconds elapsed for this entry. This value will not
         * be meaningful for all Performance Entry types.
         * @since v8.5.0
         */
        readonly duration: number;
        /**
         * The name of the performance entry.
         * @since v8.5.0
         */
        readonly name: string;
        /**
         * The high resolution millisecond timestamp marking the starting time of the
         * Performance Entry.
         * @since v8.5.0
         */
        readonly startTime: number;
        /**
         * The type of the performance entry. It may be one of:
         *
         * * `'node'` (Node.js only)
         * * `'mark'` (available on the Web)
         * * `'measure'` (available on the Web)
         * * `'gc'` (Node.js only)
         * * `'function'` (Node.js only)
         * * `'http2'` (Node.js only)
         * * `'http'` (Node.js only)
         * @since v8.5.0
         */
        readonly entryType: EntryType;
        /**
         * Additional detail specific to the `entryType`.
         * @since v16.0.0
         */
        readonly detail?: NodeGCPerformanceDetail | unknown | undefined; // TODO: Narrow this based on entry type.
        toJSON(): any;
    }
    /**
     * Exposes marks created via the `Performance.mark()` method.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceMark extends PerformanceEntry {
        readonly duration: 0;
        readonly entryType: "mark";
    }
    /**
     * Exposes measures created via the `Performance.measure()` method.
     *
     * The constructor of this class is not exposed to users directly.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceMeasure extends PerformanceEntry {
        readonly entryType: "measure";
    }
    interface UVMetrics {
        /**
         * Number of event loop iterations.
         */
        readonly loopCount: number;
        /**
         * Number of events that have been processed by the event handler.
         */
        readonly events: number;
        /**
         * Number of events that were waiting to be processed when the event provider was called.
         */
        readonly eventsWaiting: number;
    }
    /**
     * _This property is an extension by Node.js. It is not available in Web browsers._
     *
     * Provides timing details for Node.js itself. The constructor of this class
     * is not exposed to users.
     * @since v8.5.0
     */
    class PerformanceNodeTiming extends PerformanceEntry {
        readonly entryType: "node";
        /**
         * The high resolution millisecond timestamp at which the Node.js process
         * completed bootstrapping. If bootstrapping has not yet finished, the property
         * has the value of -1.
         * @since v8.5.0
         */
        readonly bootstrapComplete: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js environment was
         * initialized.
         * @since v8.5.0
         */
        readonly environment: number;
        /**
         * The high resolution millisecond timestamp of the amount of time the event loop
         * has been idle within the event loop's event provider (e.g. `epoll_wait`). This
         * does not take CPU usage into consideration. If the event loop has not yet
         * started (e.g., in the first tick of the main script), the property has the
         * value of 0.
         * @since v14.10.0, v12.19.0
         */
        readonly idleTime: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * exited. If the event loop has not yet exited, the property has the value of -1\.
         * It can only have a value of not -1 in a handler of the `'exit'` event.
         * @since v8.5.0
         */
        readonly loopExit: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * started. If the event loop has not yet started (e.g., in the first tick of the
         * main script), the property has the value of -1.
         * @since v8.5.0
         */
        readonly loopStart: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js process was initialized.
         * @since v8.5.0
         */
        readonly nodeStart: number;
        /**
         * This is a wrapper to the `uv_metrics_info` function.
         * It returns the current set of event loop metrics.
         *
         * It is recommended to use this property inside a function whose execution was
         * scheduled using `setImmediate` to avoid collecting metrics before finishing all
         * operations scheduled during the current loop iteration.
         * @since v22.8.0, v20.18.0
         */
        readonly uvMetricsInfo: UVMetrics;
        /**
         * The high resolution millisecond timestamp at which the V8 platform was
         * initialized.
         * @since v8.5.0
         */
        readonly v8Start: number;
    }
    interface EventLoopUtilization {
        idle: number;
        active: number;
        utilization: number;
    }
    /**
     * @param utilization1 The result of a previous call to `eventLoopUtilization()`.
     * @param utilization2 The result of a previous call to `eventLoopUtilization()` prior to `utilization1`.
     */
    type EventLoopUtilityFunction = (
        utilization1?: EventLoopUtilization,
        utilization2?: EventLoopUtilization,
    ) => EventLoopUtilization;
    interface MarkOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown | undefined;
        /**
         * An optional timestamp to be used as the mark time.
         * @default `performance.now()`
         */
        startTime?: number | undefined;
    }
    interface MeasureOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown | undefined;
        /**
         * Duration between start and end times.
         */
        duration?: number | undefined;
        /**
         * Timestamp to be used as the end time, or a string identifying a previously recorded mark.
         */
        end?: number | string | undefined;
        /**
         * Timestamp to be used as the start time, or a string identifying a previously recorded mark.
         */
        start?: number | string | undefined;
    }
    interface TimerifyOptions {
        /**
         * A histogram object created using `perf_hooks.createHistogram()` that will record runtime
         * durations in nanoseconds.
         */
        histogram?: RecordableHistogram | undefined;
    }
    interface Performance {
        /**
         * If `name` is not provided, removes all `PerformanceMark` objects from the Performance Timeline.
         * If `name` is provided, removes only the named mark.
         * @since v8.5.0
         */
        clearMarks(name?: string): void;
        /**
         * If `name` is not provided, removes all `PerformanceMeasure` objects from the Performance Timeline.
         * If `name` is provided, removes only the named measure.
         * @since v16.7.0
         */
        clearMeasures(name?: string): void;
        /**
         * If `name` is not provided, removes all `PerformanceResourceTiming` objects from the Resource Timeline.
         * If `name` is provided, removes only the named resource.
         * @since v18.2.0, v16.17.0
         */
        clearResourceTimings(name?: string): void;
        /**
         * eventLoopUtilization is similar to CPU utilization except that it is calculated using high precision wall-clock time.
         * It represents the percentage of time the event loop has spent outside the event loop's event provider (e.g. epoll_wait).
         * No other CPU idle time is taken into consideration.
         */
        eventLoopUtilization: EventLoopUtilityFunction;
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`.
         * If you are only interested in performance entries of certain types or that have certain names, see
         * `performance.getEntriesByType()` and `performance.getEntriesByName()`.
         * @since v16.7.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.name` is equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to `type`.
         * @param name
         * @param type
         * @since v16.7.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.entryType` is equal to `type`.
         * @param type
         * @since v16.7.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
        /**
         * Creates a new `PerformanceMark` entry in the Performance Timeline.
         * A `PerformanceMark` is a subclass of `PerformanceEntry` whose `performanceEntry.entryType` is always `'mark'`,
         * and whose `performanceEntry.duration` is always `0`.
         * Performance marks are used to mark specific significant moments in the Performance Timeline.
         *
         * The created `PerformanceMark` entry is put in the global Performance Timeline and can be queried with
         * `performance.getEntries`, `performance.getEntriesByName`, and `performance.getEntriesByType`. When the observation is
         * performed, the entries should be cleared from the global Performance Timeline manually with `performance.clearMarks`.
         * @param name
         */
        mark(name: string, options?: MarkOptions): PerformanceMark;
        /**
         * Creates a new `PerformanceResourceTiming` entry in the Resource Timeline.
         * A `PerformanceResourceTiming` is a subclass of `PerformanceEntry` whose `performanceEntry.entryType` is always `'resource'`.
         * Performance resources are used to mark moments in the Resource Timeline.
         * @param timingInfo [Fetch Timing Info](https://fetch.spec.whatwg.org/#fetch-timing-info)
         * @param requestedUrl The resource url
         * @param initiatorType The initiator name, e.g: 'fetch'
         * @param global
         * @param cacheMode The cache mode must be an empty string ('') or 'local'
         * @param bodyInfo [Fetch Response Body Info](https://fetch.spec.whatwg.org/#response-body-info)
         * @param responseStatus The response's status code
         * @param deliveryType The delivery type. Default: ''.
         * @since v18.2.0, v16.17.0
         */
        markResourceTiming(
            timingInfo: object,
            requestedUrl: string,
            initiatorType: string,
            global: object,
            cacheMode: "" | "local",
            bodyInfo: object,
            responseStatus: number,
            deliveryType?: string,
        ): PerformanceResourceTiming;
        /**
         * Creates a new PerformanceMeasure entry in the Performance Timeline.
         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',
         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.
         *
         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify
         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,
         * then startMark is set to timeOrigin by default.
         *
         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp
         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.
         * @param name
         * @param startMark
         * @param endMark
         * @return The PerformanceMeasure entry that was created
         */
        measure(name: string, startMark?: string, endMark?: string): PerformanceMeasure;
        measure(name: string, options: MeasureOptions): PerformanceMeasure;
        /**
         * _This property is an extension by Node.js. It is not available in Web browsers._
         *
         * An instance of the `PerformanceNodeTiming` class that provides performance metrics for specific Node.js operational milestones.
         * @since v8.5.0
         */
        readonly nodeTiming: PerformanceNodeTiming;
        /**
         * Returns the current high resolution millisecond timestamp, where 0 represents the start of the current `node` process.
         * @since v8.5.0
         */
        now(): number;
        /**
         * Sets the global performance resource timing buffer size to the specified number of "resource" type performance entry objects.
         *
         * By default the max buffer size is set to 250.
         * @since v18.8.0
         */
        setResourceTimingBufferSize(maxSize: number): void;
        /**
         * The [`timeOrigin`](https://w3c.github.io/hr-time/#dom-performance-timeorigin) specifies the high resolution millisecond timestamp
         * at which the current `node` process began, measured in Unix time.
         * @since v8.5.0
         */
        readonly timeOrigin: number;
        /**
         * _This property is an extension by Node.js. It is not available in Web browsers._
         *
         * Wraps a function within a new function that measures the running time of the wrapped function.
         * A `PerformanceObserver` must be subscribed to the `'function'` event type in order for the timing details to be accessed.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * function someFunction() {
         *   console.log('hello world');
         * }
         *
         * const wrapped = performance.timerify(someFunction);
         *
         * const obs = new PerformanceObserver((list) => {
         *   console.log(list.getEntries()[0].duration);
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   obs.disconnect();
         * });
         * obs.observe({ entryTypes: ['function'] });
         *
         * // A performance timeline entry will be created
         * wrapped();
         * ```
         *
         * If the wrapped function returns a promise, a finally handler will be attached to the promise and the duration will be reported
         * once the finally handler is invoked.
         * @param fn
         */
        timerify<T extends (...params: any[]) => any>(fn: T, options?: TimerifyOptions): T;
        /**
         * An object which is JSON representation of the performance object. It is similar to
         * [`window.performance.toJSON`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/toJSON) in browsers.
         * @since v16.1.0
         */
        toJSON(): any;
    }
    class PerformanceObserverEntryList {
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntries());
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 81.465639,
         *    *     duration: 0,
         *    *     detail: null
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 81.860064,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.name` is
         * equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to`type`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByName('meow'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 98.545991,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('nope')); // []
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 63.518931,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'measure')); // []
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ entryTypes: ['mark', 'measure'] });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.entryType` is equal to `type`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByType('mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 55.897834,
         *    *     duration: 0,
         *    *     detail: null
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 56.350146,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
    }
    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;
    /**
     * @since v8.5.0
     */
    class PerformanceObserver extends AsyncResource {
        constructor(callback: PerformanceObserverCallback);
        /**
         * Disconnects the `PerformanceObserver` instance from all notifications.
         * @since v8.5.0
         */
        disconnect(): void;
        /**
         * Subscribes the `PerformanceObserver` instance to notifications of new `PerformanceEntry` instances identified either by `options.entryTypes` or `options.type`:
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((list, observer) => {
         *   // Called once asynchronously. `list` contains three items.
         * });
         * obs.observe({ type: 'mark' });
         *
         * for (let n = 0; n < 3; n++)
         *   performance.mark(`test${n}`);
         * ```
         * @since v8.5.0
         */
        observe(
            options:
                | {
                    entryTypes: readonly EntryType[];
                    buffered?: boolean | undefined;
                }
                | {
                    type: EntryType;
                    buffered?: boolean | undefined;
                },
        ): void;
        /**
         * @since v16.0.0
         * @returns Current list of entries stored in the performance observer, emptying it out.
         */
        takeRecords(): PerformanceEntry[];
    }
    /**
     * Provides detailed network timing data regarding the loading of an application's resources.
     *
     * The constructor of this class is not exposed to users directly.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceResourceTiming extends PerformanceEntry {
        readonly entryType: "resource";
        protected constructor();
        /**
         * The high resolution millisecond timestamp at immediately before dispatching the `fetch`
         * request. If the resource is not intercepted by a worker the property will always return 0.
         * @since v18.2.0, v16.17.0
         */
        readonly workerStart: number;
        /**
         * The high resolution millisecond timestamp that represents the start time of the fetch which
         * initiates the redirect.
         * @since v18.2.0, v16.17.0
         */
        readonly redirectStart: number;
        /**
         * The high resolution millisecond timestamp that will be created immediately after receiving
         * the last byte of the response of the last redirect.
         * @since v18.2.0, v16.17.0
         */
        readonly redirectEnd: number;
        /**
         * The high resolution millisecond timestamp immediately before the Node.js starts to fetch the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly fetchStart: number;
        /**
         * The high resolution millisecond timestamp immediately before the Node.js starts the domain name lookup
         * for the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly domainLookupStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after the Node.js finished
         * the domain name lookup for the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly domainLookupEnd: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js starts to
         * establish the connection to the server to retrieve the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly connectStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after Node.js finishes
         * establishing the connection to the server to retrieve the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly connectEnd: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js starts the
         * handshake process to secure the current connection.
         * @since v18.2.0, v16.17.0
         */
        readonly secureConnectionStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js receives the
         * first byte of the response from the server.
         * @since v18.2.0, v16.17.0
         */
        readonly requestStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after Node.js receives the
         * last byte of the resource or immediately before the transport connection is closed, whichever comes first.
         * @since v18.2.0, v16.17.0
         */
        readonly responseEnd: number;
        /**
         * A number representing the size (in octets) of the fetched resource. The size includes the response header
         * fields plus the response payload body.
         * @since v18.2.0, v16.17.0
         */
        readonly transferSize: number;
        /**
         * A number representing the size (in octets) received from the fetch (HTTP or cache), of the payload body, before
         * removing any applied content-codings.
         * @since v18.2.0, v16.17.0
         */
        readonly encodedBodySize: number;
        /**
         * A number representing the size (in octets) received from the fetch (HTTP or cache), of the message body, after
         * removing any applied content-codings.
         * @since v18.2.0, v16.17.0
         */
        readonly decodedBodySize: number;
        /**
         * Returns a `object` that is the JSON representation of the `PerformanceResourceTiming` object
         * @since v18.2.0, v16.17.0
         */
        toJSON(): any;
    }
    namespace constants {
        const NODE_PERFORMANCE_GC_MAJOR: number;
        const NODE_PERFORMANCE_GC_MINOR: number;
        const NODE_PERFORMANCE_GC_INCREMENTAL: number;
        const NODE_PERFORMANCE_GC_WEAKCB: number;
        const NODE_PERFORMANCE_GC_FLAGS_NO: number;
        const NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: number;
        const NODE_PERFORMANCE_GC_FLAGS_FORCED: number;
        const NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: number;
        const NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: number;
    }
    const performance: Performance;
    interface EventLoopMonitorOptions {
        /**
         * The sampling rate in milliseconds.
         * Must be greater than zero.
         * @default 10
         */
        resolution?: number | undefined;
    }
    interface Histogram {
        /**
         * The number of samples recorded by the histogram.
         * @since v17.4.0, v16.14.0
         */
        readonly count: number;
        /**
         * The number of samples recorded by the histogram.
         * v17.4.0, v16.14.0
         */
        readonly countBigInt: bigint;
        /**
         * The number of times the event loop delay exceeded the maximum 1 hour event
         * loop delay threshold.
         * @since v11.10.0
         */
        readonly exceeds: number;
        /**
         * The number of times the event loop delay exceeded the maximum 1 hour event loop delay threshold.
         * @since v17.4.0, v16.14.0
         */
        readonly exceedsBigInt: bigint;
        /**
         * The maximum recorded event loop delay.
         * @since v11.10.0
         */
        readonly max: number;
        /**
         * The maximum recorded event loop delay.
         * v17.4.0, v16.14.0
         */
        readonly maxBigInt: number;
        /**
         * The mean of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly mean: number;
        /**
         * The minimum recorded event loop delay.
         * @since v11.10.0
         */
        readonly min: number;
        /**
         * The minimum recorded event loop delay.
         * v17.4.0, v16.14.0
         */
        readonly minBigInt: bigint;
        /**
         * Returns the value at the given percentile.
         * @since v11.10.0
         * @param percentile A percentile value in the range (0, 100].
         */
        percentile(percentile: number): number;
        /**
         * Returns the value at the given percentile.
         * @since v17.4.0, v16.14.0
         * @param percentile A percentile value in the range (0, 100].
         */
        percentileBigInt(percentile: number): bigint;
        /**
         * Returns a `Map` object detailing the accumulated percentile distribution.
         * @since v11.10.0
         */
        readonly percentiles: Map<number, number>;
        /**
         * Returns a `Map` object detailing the accumulated percentile distribution.
         * @since v17.4.0, v16.14.0
         */
        readonly percentilesBigInt: Map<bigint, bigint>;
        /**
         * Resets the collected histogram data.
         * @since v11.10.0
         */
        reset(): void;
        /**
         * The standard deviation of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly stddev: number;
    }
    interface IntervalHistogram extends Histogram {
        /**
         * Enables the update interval timer. Returns `true` if the timer was
         * started, `false` if it was already started.
         * @since v11.10.0
         */
        enable(): boolean;
        /**
         * Disables the update interval timer. Returns `true` if the timer was
         * stopped, `false` if it was already stopped.
         * @since v11.10.0
         */
        disable(): boolean;
    }
    interface RecordableHistogram extends Histogram {
        /**
         * @since v15.9.0, v14.18.0
         * @param val The amount to record in the histogram.
         */
        record(val: number | bigint): void;
        /**
         * Calculates the amount of time (in nanoseconds) that has passed since the
         * previous call to `recordDelta()` and records that amount in the histogram.
         * @since v15.9.0, v14.18.0
         */
        recordDelta(): void;
        /**
         * Adds the values from `other` to this histogram.
         * @since v17.4.0, v16.14.0
         */
        add(other: RecordableHistogram): void;
    }
    /**
     * _This property is an extension by Node.js. It is not available in Web browsers._
     *
     * Creates an `IntervalHistogram` object that samples and reports the event loop
     * delay over time. The delays will be reported in nanoseconds.
     *
     * Using a timer to detect approximate event loop delay works because the
     * execution of timers is tied specifically to the lifecycle of the libuv
     * event loop. That is, a delay in the loop will cause a delay in the execution
     * of the timer, and those delays are specifically what this API is intended to
     * detect.
     *
     * ```js
     * import { monitorEventLoopDelay } from 'node:perf_hooks';
     * const h = monitorEventLoopDelay({ resolution: 20 });
     * h.enable();
     * // Do something.
     * h.disable();
     * console.log(h.min);
     * console.log(h.max);
     * console.log(h.mean);
     * console.log(h.stddev);
     * console.log(h.percentiles);
     * console.log(h.percentile(50));
     * console.log(h.percentile(99));
     * ```
     * @since v11.10.0
     */
    function monitorEventLoopDelay(options?: EventLoopMonitorOptions): IntervalHistogram;
    interface CreateHistogramOptions {
        /**
         * The minimum recordable value. Must be an integer value greater than 0.
         * @default 1
         */
        lowest?: number | bigint | undefined;
        /**
         * The maximum recordable value. Must be an integer value greater than min.
         * @default Number.MAX_SAFE_INTEGER
         */
        highest?: number | bigint | undefined;
        /**
         * The number of accuracy digits. Must be a number between 1 and 5.
         * @default 3
         */
        figures?: number | undefined;
    }
    /**
     * Returns a `RecordableHistogram`.
     * @since v15.9.0, v14.18.0
     */
    function createHistogram(options?: CreateHistogramOptions): RecordableHistogram;
    import {
        performance as _performance,
        PerformanceEntry as _PerformanceEntry,
        PerformanceMark as _PerformanceMark,
        PerformanceMeasure as _PerformanceMeasure,
        PerformanceObserver as _PerformanceObserver,
        PerformanceObserverEntryList as _PerformanceObserverEntryList,
        PerformanceResourceTiming as _PerformanceResourceTiming,
    } from "perf_hooks";
    global {
        /**
         * `PerformanceEntry` is a global reference for `import { PerformanceEntry } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performanceentry
         * @since v19.0.0
         */
        var PerformanceEntry: typeof globalThis extends {
            onmessage: any;
            PerformanceEntry: infer T;
        } ? T
            : typeof _PerformanceEntry;
        /**
         * `PerformanceMark` is a global reference for `import { PerformanceMark } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performancemark
         * @since v19.0.0
         */
        var PerformanceMark: typeof globalThis extends {
            onmessage: any;
            PerformanceMark: infer T;
        } ? T
            : typeof _PerformanceMark;
        /**
         * `PerformanceMeasure` is a global reference for `import { PerformanceMeasure } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performancemeasure
         * @since v19.0.0
         */
        var PerformanceMeasure: typeof globalThis extends {
            onmessage: any;
            PerformanceMeasure: infer T;
        } ? T
            : typeof _PerformanceMeasure;
        /**
         * `PerformanceObserver` is a global reference for `import { PerformanceObserver } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performanceobserver
         * @since v19.0.0
         */
        var PerformanceObserver: typeof globalThis extends {
            onmessage: any;
            PerformanceObserver: infer T;
        } ? T
            : typeof _PerformanceObserver;
        /**
         * `PerformanceObserverEntryList` is a global reference for `import { PerformanceObserverEntryList } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performanceobserverentrylist
         * @since v19.0.0
         */
        var PerformanceObserverEntryList: typeof globalThis extends {
            onmessage: any;
            PerformanceObserverEntryList: infer T;
        } ? T
            : typeof _PerformanceObserverEntryList;
        /**
         * `PerformanceResourceTiming` is a global reference for `import { PerformanceResourceTiming } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performanceresourcetiming
         * @since v19.0.0
         */
        var PerformanceResourceTiming: typeof globalThis extends {
            onmessage: any;
            PerformanceResourceTiming: infer T;
        } ? T
            : typeof _PerformanceResourceTiming;
        /**
         * `performance` is a global reference for `import { performance } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v24.x/api/globals.html#performance
         * @since v16.0.0
         */
        var performance: typeof globalThis extends {
            onmessage: any;
            performance: infer T;
        } ? T
            : typeof _performance;
    }
}
declare module "node:perf_hooks" {
    export * from "perf_hooks";
}


---

File name: node_modules\@types\node\process.d.ts

Code:
declare module "process" {
    import * as tty from "node:tty";
    import { Worker } from "node:worker_threads";

    interface BuiltInModule {
        "assert": typeof import("assert");
        "node:assert": typeof import("node:assert");
        "assert/strict": typeof import("assert/strict");
        "node:assert/strict": typeof import("node:assert/strict");
        "async_hooks": typeof import("async_hooks");
        "node:async_hooks": typeof import("node:async_hooks");
        "buffer": typeof import("buffer");
        "node:buffer": typeof import("node:buffer");
        "child_process": typeof import("child_process");
        "node:child_process": typeof import("node:child_process");
        "cluster": typeof import("cluster");
        "node:cluster": typeof import("node:cluster");
        "console": typeof import("console");
        "node:console": typeof import("node:console");
        "constants": typeof import("constants");
        "node:constants": typeof import("node:constants");
        "crypto": typeof import("crypto");
        "node:crypto": typeof import("node:crypto");
        "dgram": typeof import("dgram");
        "node:dgram": typeof import("node:dgram");
        "diagnostics_channel": typeof import("diagnostics_channel");
        "node:diagnostics_channel": typeof import("node:diagnostics_channel");
        "dns": typeof import("dns");
        "node:dns": typeof import("node:dns");
        "dns/promises": typeof import("dns/promises");
        "node:dns/promises": typeof import("node:dns/promises");
        "domain": typeof import("domain");
        "node:domain": typeof import("node:domain");
        "events": typeof import("events");
        "node:events": typeof import("node:events");
        "fs": typeof import("fs");
        "node:fs": typeof import("node:fs");
        "fs/promises": typeof import("fs/promises");
        "node:fs/promises": typeof import("node:fs/promises");
        "http": typeof import("http");
        "node:http": typeof import("node:http");
        "http2": typeof import("http2");
        "node:http2": typeof import("node:http2");
        "https": typeof import("https");
        "node:https": typeof import("node:https");
        "inspector": typeof import("inspector");
        "node:inspector": typeof import("node:inspector");
        "inspector/promises": typeof import("inspector/promises");
        "node:inspector/promises": typeof import("node:inspector/promises");
        "module": typeof import("module");
        "node:module": typeof import("node:module");
        "net": typeof import("net");
        "node:net": typeof import("node:net");
        "os": typeof import("os");
        "node:os": typeof import("node:os");
        "path": typeof import("path");
        "node:path": typeof import("node:path");
        "path/posix": typeof import("path/posix");
        "node:path/posix": typeof import("node:path/posix");
        "path/win32": typeof import("path/win32");
        "node:path/win32": typeof import("node:path/win32");
        "perf_hooks": typeof import("perf_hooks");
        "node:perf_hooks": typeof import("node:perf_hooks");
        "process": typeof import("process");
        "node:process": typeof import("node:process");
        "punycode": typeof import("punycode");
        "node:punycode": typeof import("node:punycode");
        "querystring": typeof import("querystring");
        "node:querystring": typeof import("node:querystring");
        "readline": typeof import("readline");
        "node:readline": typeof import("node:readline");
        "readline/promises": typeof import("readline/promises");
        "node:readline/promises": typeof import("node:readline/promises");
        "repl": typeof import("repl");
        "node:repl": typeof import("node:repl");
        "node:sea": typeof import("node:sea");
        "node:sqlite": typeof import("node:sqlite");
        "stream": typeof import("stream");
        "node:stream": typeof import("node:stream");
        "stream/consumers": typeof import("stream/consumers");
        "node:stream/consumers": typeof import("node:stream/consumers");
        "stream/promises": typeof import("stream/promises");
        "node:stream/promises": typeof import("node:stream/promises");
        "stream/web": typeof import("stream/web");
        "node:stream/web": typeof import("node:stream/web");
        "string_decoder": typeof import("string_decoder");
        "node:string_decoder": typeof import("node:string_decoder");
        "node:test": typeof import("node:test");
        "node:test/reporters": typeof import("node:test/reporters");
        "timers": typeof import("timers");
        "node:timers": typeof import("node:timers");
        "timers/promises": typeof import("timers/promises");
        "node:timers/promises": typeof import("node:timers/promises");
        "tls": typeof import("tls");
        "node:tls": typeof import("node:tls");
        "trace_events": typeof import("trace_events");
        "node:trace_events": typeof import("node:trace_events");
        "tty": typeof import("tty");
        "node:tty": typeof import("node:tty");
        "url": typeof import("url");
        "node:url": typeof import("node:url");
        "util": typeof import("util");
        "node:util": typeof import("node:util");
        "sys": typeof import("util");
        "node:sys": typeof import("node:util");
        "util/types": typeof import("util/types");
        "node:util/types": typeof import("node:util/types");
        "v8": typeof import("v8");
        "node:v8": typeof import("node:v8");
        "vm": typeof import("vm");
        "node:vm": typeof import("node:vm");
        "wasi": typeof import("wasi");
        "node:wasi": typeof import("node:wasi");
        "worker_threads": typeof import("worker_threads");
        "node:worker_threads": typeof import("node:worker_threads");
        "zlib": typeof import("zlib");
        "node:zlib": typeof import("node:zlib");
    }
    global {
        var process: NodeJS.Process;
        namespace NodeJS {
            // this namespace merge is here because these are specifically used
            // as the type for process.stdin, process.stdout, and process.stderr.
            // they can't live in tty.d.ts because we need to disambiguate the imported name.
            interface ReadStream extends tty.ReadStream {}
            interface WriteStream extends tty.WriteStream {}
            interface MemoryUsageFn {
                /**
                 * The `process.memoryUsage()` method iterate over each page to gather informations about memory
                 * usage which can be slow depending on the program memory allocations.
                 */
                (): MemoryUsage;
                /**
                 * method returns an integer representing the Resident Set Size (RSS) in bytes.
                 */
                rss(): number;
            }
            interface MemoryUsage {
                /**
                 * Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the
                 * process, including all C++ and JavaScript objects and code.
                 */
                rss: number;
                /**
                 * Refers to V8's memory usage.
                 */
                heapTotal: number;
                /**
                 * Refers to V8's memory usage.
                 */
                heapUsed: number;
                external: number;
                /**
                 * Refers to memory allocated for `ArrayBuffer`s and `SharedArrayBuffer`s, including all Node.js Buffers. This is also included
                 * in the external value. When Node.js is used as an embedded library, this value may be `0` because allocations for `ArrayBuffer`s
                 * may not be tracked in that case.
                 */
                arrayBuffers: number;
            }
            interface CpuUsage {
                user: number;
                system: number;
            }
            interface ProcessRelease {
                name: string;
                sourceUrl?: string | undefined;
                headersUrl?: string | undefined;
                libUrl?: string | undefined;
                lts?: string | undefined;
            }
            interface ProcessFeatures {
                /**
                 * A boolean value that is `true` if the current Node.js build is caching builtin modules.
                 * @since v12.0.0
                 */
                readonly cached_builtins: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build is a debug build.
                 * @since v0.5.5
                 */
                readonly debug: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes the inspector.
                 * @since v11.10.0
                 */
                readonly inspector: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for IPv6.
                 *
                 * Since all Node.js builds have IPv6 support, this value is always `true`.
                 * @since v0.5.3
                 * @deprecated This property is always true, and any checks based on it are redundant.
                 */
                readonly ipv6: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build supports
                 * [loading ECMAScript modules using `require()`](https://nodejs.org/docs/latest-v24.x/api/modules.md#loading-ecmascript-modules-using-require).
                 * @since v22.10.0
                 */
                readonly require_module: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for TLS.
                 * @since v0.5.3
                 */
                readonly tls: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for ALPN in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional ALPN support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v4.8.0
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_alpn: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for OCSP in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional OCSP support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v0.11.13
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_ocsp: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for SNI in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional SNI support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v0.5.3
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_sni: boolean;
                /**
                 * A value that is `"strip"` by default,
                 * `"transform"` if Node.js is run with `--experimental-transform-types`, and `false` if
                 * Node.js is run with `--no-experimental-strip-types`.
                 * @since v22.10.0
                 */
                readonly typescript: "strip" | "transform" | false;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for libuv.
                 *
                 * Since it's not possible to build Node.js without libuv, this value is always `true`.
                 * @since v0.5.3
                 * @deprecated This property is always true, and any checks based on it are redundant.
                 */
                readonly uv: boolean;
            }
            interface ProcessVersions extends Dict<string> {
                http_parser: string;
                node: string;
                v8: string;
                ares: string;
                uv: string;
                zlib: string;
                modules: string;
                openssl: string;
            }
            type Platform =
                | "aix"
                | "android"
                | "darwin"
                | "freebsd"
                | "haiku"
                | "linux"
                | "openbsd"
                | "sunos"
                | "win32"
                | "cygwin"
                | "netbsd";
            type Architecture =
                | "arm"
                | "arm64"
                | "ia32"
                | "loong64"
                | "mips"
                | "mipsel"
                | "ppc64"
                | "riscv64"
                | "s390x"
                | "x64";
            type Signals =
                | "SIGABRT"
                | "SIGALRM"
                | "SIGBUS"
                | "SIGCHLD"
                | "SIGCONT"
                | "SIGFPE"
                | "SIGHUP"
                | "SIGILL"
                | "SIGINT"
                | "SIGIO"
                | "SIGIOT"
                | "SIGKILL"
                | "SIGPIPE"
                | "SIGPOLL"
                | "SIGPROF"
                | "SIGPWR"
                | "SIGQUIT"
                | "SIGSEGV"
                | "SIGSTKFLT"
                | "SIGSTOP"
                | "SIGSYS"
                | "SIGTERM"
                | "SIGTRAP"
                | "SIGTSTP"
                | "SIGTTIN"
                | "SIGTTOU"
                | "SIGUNUSED"
                | "SIGURG"
                | "SIGUSR1"
                | "SIGUSR2"
                | "SIGVTALRM"
                | "SIGWINCH"
                | "SIGXCPU"
                | "SIGXFSZ"
                | "SIGBREAK"
                | "SIGLOST"
                | "SIGINFO";
            type UncaughtExceptionOrigin = "uncaughtException" | "unhandledRejection";
            type MultipleResolveType = "resolve" | "reject";
            type BeforeExitListener = (code: number) => void;
            type DisconnectListener = () => void;
            type ExitListener = (code: number) => void;
            type RejectionHandledListener = (promise: Promise<unknown>) => void;
            type UncaughtExceptionListener = (error: Error, origin: UncaughtExceptionOrigin) => void;
            /**
             * Most of the time the unhandledRejection will be an Error, but this should not be relied upon
             * as *anything* can be thrown/rejected, it is therefore unsafe to assume that the value is an Error.
             */
            type UnhandledRejectionListener = (reason: unknown, promise: Promise<unknown>) => void;
            type WarningListener = (warning: Error) => void;
            type MessageListener = (message: unknown, sendHandle: unknown) => void;
            type SignalsListener = (signal: Signals) => void;
            type MultipleResolveListener = (
                type: MultipleResolveType,
                promise: Promise<unknown>,
                value: unknown,
            ) => void;
            type WorkerListener = (worker: Worker) => void;
            interface Socket extends ReadWriteStream {
                isTTY?: true | undefined;
            }
            // Alias for compatibility
            interface ProcessEnv extends Dict<string> {
                /**
                 * Can be used to change the default timezone at runtime
                 */
                TZ?: string;
            }
            interface HRTime {
                /**
                 * This is the legacy version of {@link process.hrtime.bigint()}
                 * before bigint was introduced in JavaScript.
                 *
                 * The `process.hrtime()` method returns the current high-resolution real time in a `[seconds, nanoseconds]` tuple `Array`,
                 * where `nanoseconds` is the remaining part of the real time that can't be represented in second precision.
                 *
                 * `time` is an optional parameter that must be the result of a previous `process.hrtime()` call to diff with the current time.
                 * If the parameter passed in is not a tuple `Array`, a TypeError will be thrown.
                 * Passing in a user-defined array instead of the result of a previous call to `process.hrtime()` will lead to undefined behavior.
                 *
                 * These times are relative to an arbitrary time in the past,
                 * and not related to the time of day and therefore not subject to clock drift.
                 * The primary use is for measuring performance between intervals:
                 * ```js
                 * const { hrtime } = require('node:process');
                 * const NS_PER_SEC = 1e9;
                 * const time = hrtime();
                 * // [ 1800216, 25 ]
                 *
                 * setTimeout(() => {
                 *   const diff = hrtime(time);
                 *   // [ 1, 552 ]
                 *
                 *   console.log(`Benchmark took ${diff[0] * NS_PER_SEC + diff[1]} nanoseconds`);
                 *   // Benchmark took 1000000552 nanoseconds
                 * }, 1000);
                 * ```
                 * @since 0.7.6
                 * @legacy Use {@link process.hrtime.bigint()} instead.
                 * @param time The result of a previous call to `process.hrtime()`
                 */
                (time?: [number, number]): [number, number];
                /**
                 * The `bigint` version of the {@link process.hrtime()} method returning the current high-resolution real time in nanoseconds as a `bigint`.
                 *
                 * Unlike {@link process.hrtime()}, it does not support an additional time argument since the difference can just be computed directly by subtraction of the two `bigint`s.
                 * ```js
                 * import { hrtime } from 'node:process';
                 *
                 * const start = hrtime.bigint();
                 * // 191051479007711n
                 *
                 * setTimeout(() => {
                 *   const end = hrtime.bigint();
                 *   // 191052633396993n
                 *
                 *   console.log(`Benchmark took ${end - start} nanoseconds`);
                 *   // Benchmark took 1154389282 nanoseconds
                 * }, 1000);
                 * ```
                 * @since v10.7.0
                 */
                bigint(): bigint;
            }
            interface ProcessPermission {
                /**
                 * Verifies that the process is able to access the given scope and reference.
                 * If no reference is provided, a global scope is assumed, for instance, `process.permission.has('fs.read')`
                 * will check if the process has ALL file system read permissions.
                 *
                 * The reference has a meaning based on the provided scope. For example, the reference when the scope is File System means files and folders.
                 *
                 * The available scopes are:
                 *
                 * * `fs` - All File System
                 * * `fs.read` - File System read operations
                 * * `fs.write` - File System write operations
                 * * `child` - Child process spawning operations
                 * * `worker` - Worker thread spawning operation
                 *
                 * ```js
                 * // Check if the process has permission to read the README file
                 * process.permission.has('fs.read', './README.md');
                 * // Check if the process has read permission operations
                 * process.permission.has('fs.read');
                 * ```
                 * @since v20.0.0
                 */
                has(scope: string, reference?: string): boolean;
            }
            interface ProcessReport {
                /**
                 * Write reports in a compact format, single-line JSON, more easily consumable by log processing systems
                 * than the default multi-line format designed for human consumption.
                 * @since v13.12.0, v12.17.0
                 */
                compact: boolean;
                /**
                 * Directory where the report is written.
                 * The default value is the empty string, indicating that reports are written to the current
                 * working directory of the Node.js process.
                 */
                directory: string;
                /**
                 * Filename where the report is written. If set to the empty string, the output filename will be comprised
                 * of a timestamp, PID, and sequence number. The default value is the empty string.
                 */
                filename: string;
                /**
                 * Returns a JavaScript Object representation of a diagnostic report for the running process.
                 * The report's JavaScript stack trace is taken from `err`, if present.
                 */
                getReport(err?: Error): object;
                /**
                 * If true, a diagnostic report is generated on fatal errors,
                 * such as out of memory errors or failed C++ assertions.
                 * @default false
                 */
                reportOnFatalError: boolean;
                /**
                 * If true, a diagnostic report is generated when the process
                 * receives the signal specified by process.report.signal.
                 * @default false
                 */
                reportOnSignal: boolean;
                /**
                 * If true, a diagnostic report is generated on uncaught exception.
                 * @default false
                 */
                reportOnUncaughtException: boolean;
                /**
                 * The signal used to trigger the creation of a diagnostic report.
                 * @default 'SIGUSR2'
                 */
                signal: Signals;
                /**
                 * Writes a diagnostic report to a file. If filename is not provided, the default filename
                 * includes the date, time, PID, and a sequence number.
                 * The report's JavaScript stack trace is taken from `err`, if present.
                 *
                 * If the value of filename is set to `'stdout'` or `'stderr'`, the report is written
                 * to the stdout or stderr of the process respectively.
                 * @param fileName Name of the file where the report is written.
                 * This should be a relative path, that will be appended to the directory specified in
                 * `process.report.directory`, or the current working directory of the Node.js process,
                 * if unspecified.
                 * @param err A custom error used for reporting the JavaScript stack.
                 * @return Filename of the generated report.
                 */
                writeReport(fileName?: string, err?: Error): string;
                writeReport(err?: Error): string;
            }
            interface ResourceUsage {
                fsRead: number;
                fsWrite: number;
                involuntaryContextSwitches: number;
                ipcReceived: number;
                ipcSent: number;
                majorPageFault: number;
                maxRSS: number;
                minorPageFault: number;
                sharedMemorySize: number;
                signalsCount: number;
                swappedOut: number;
                systemCPUTime: number;
                unsharedDataSize: number;
                unsharedStackSize: number;
                userCPUTime: number;
                voluntaryContextSwitches: number;
            }
            interface EmitWarningOptions {
                /**
                 * When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted.
                 *
                 * @default 'Warning'
                 */
                type?: string | undefined;
                /**
                 * A unique identifier for the warning instance being emitted.
                 */
                code?: string | undefined;
                /**
                 * When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace.
                 *
                 * @default process.emitWarning
                 */
                ctor?: Function | undefined;
                /**
                 * Additional text to include with the error.
                 */
                detail?: string | undefined;
            }
            interface ProcessConfig {
                readonly target_defaults: {
                    readonly cflags: any[];
                    readonly default_configuration: string;
                    readonly defines: string[];
                    readonly include_dirs: string[];
                    readonly libraries: string[];
                };
                readonly variables: {
                    readonly clang: number;
                    readonly host_arch: string;
                    readonly node_install_npm: boolean;
                    readonly node_install_waf: boolean;
                    readonly node_prefix: string;
                    readonly node_shared_openssl: boolean;
                    readonly node_shared_v8: boolean;
                    readonly node_shared_zlib: boolean;
                    readonly node_use_dtrace: boolean;
                    readonly node_use_etw: boolean;
                    readonly node_use_openssl: boolean;
                    readonly target_arch: string;
                    readonly v8_no_strict_aliasing: number;
                    readonly v8_use_snapshot: boolean;
                    readonly visibility: string;
                };
            }
            interface Process extends EventEmitter {
                /**
                 * The `process.stdout` property returns a stream connected to`stdout` (fd `1`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `1` refers to a file, in which case it is
                 * a `Writable` stream.
                 *
                 * For example, to copy `process.stdin` to `process.stdout`:
                 *
                 * ```js
                 * import { stdin, stdout } from 'node:process';
                 *
                 * stdin.pipe(stdout);
                 * ```
                 *
                 * `process.stdout` differs from other Node.js streams in important ways. See `note on process I/O` for more information.
                 */
                stdout: WriteStream & {
                    fd: 1;
                };
                /**
                 * The `process.stderr` property returns a stream connected to`stderr` (fd `2`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `2` refers to a file, in which case it is
                 * a `Writable` stream.
                 *
                 * `process.stderr` differs from other Node.js streams in important ways. See `note on process I/O` for more information.
                 */
                stderr: WriteStream & {
                    fd: 2;
                };
                /**
                 * The `process.stdin` property returns a stream connected to`stdin` (fd `0`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `0` refers to a file, in which case it is
                 * a `Readable` stream.
                 *
                 * For details of how to read from `stdin` see `readable.read()`.
                 *
                 * As a `Duplex` stream, `process.stdin` can also be used in "old" mode that
                 * is compatible with scripts written for Node.js prior to v0.10\.
                 * For more information see `Stream compatibility`.
                 *
                 * In "old" streams mode the `stdin` stream is paused by default, so one
                 * must call `process.stdin.resume()` to read from it. Note also that calling `process.stdin.resume()` itself would switch stream to "old" mode.
                 */
                stdin: ReadStream & {
                    fd: 0;
                };
                /**
                 * The `process.argv` property returns an array containing the command-line
                 * arguments passed when the Node.js process was launched. The first element will
                 * be {@link execPath}. See `process.argv0` if access to the original value
                 * of `argv[0]` is needed. The second element will be the path to the JavaScript
                 * file being executed. The remaining elements will be any additional command-line
                 * arguments.
                 *
                 * For example, assuming the following script for `process-args.js`:
                 *
                 * ```js
                 * import { argv } from 'node:process';
                 *
                 * // print process.argv
                 * argv.forEach((val, index) => {
                 *   console.log(`${index}: ${val}`);
                 * });
                 * ```
                 *
                 * Launching the Node.js process as:
                 *
                 * ```bash
                 * node process-args.js one two=three four
                 * ```
                 *
                 * Would generate the output:
                 *
                 * ```text
                 * 0: /usr/local/bin/node
                 * 1: /Users/mjr/work/node/process-args.js
                 * 2: one
                 * 3: two=three
                 * 4: four
                 * ```
                 * @since v0.1.27
                 */
                argv: string[];
                /**
                 * The `process.argv0` property stores a read-only copy of the original value of`argv[0]` passed when Node.js starts.
                 *
                 * ```console
                 * $ bash -c 'exec -a customArgv0 ./node'
                 * > process.argv[0]
                 * '/Volumes/code/external/node/out/Release/node'
                 * > process.argv0
                 * 'customArgv0'
                 * ```
                 * @since v6.4.0
                 */
                argv0: string;
                /**
                 * The `process.execArgv` property returns the set of Node.js-specific command-line
                 * options passed when the Node.js process was launched. These options do not
                 * appear in the array returned by the {@link argv} property, and do not
                 * include the Node.js executable, the name of the script, or any options following
                 * the script name. These options are useful in order to spawn child processes with
                 * the same execution environment as the parent.
                 *
                 * ```bash
                 * node --icu-data-dir=./foo --require ./bar.js script.js --version
                 * ```
                 *
                 * Results in `process.execArgv`:
                 *
                 * ```js
                 * ["--icu-data-dir=./foo", "--require", "./bar.js"]
                 * ```
                 *
                 * And `process.argv`:
                 *
                 * ```js
                 * ['/usr/local/bin/node', 'script.js', '--version']
                 * ```
                 *
                 * Refer to `Worker constructor` for the detailed behavior of worker
                 * threads with this property.
                 * @since v0.7.7
                 */
                execArgv: string[];
                /**
                 * The `process.execPath` property returns the absolute pathname of the executable
                 * that started the Node.js process. Symbolic links, if any, are resolved.
                 *
                 * ```js
                 * '/usr/local/bin/node'
                 * ```
                 * @since v0.1.100
                 */
                execPath: string;
                /**
                 * The `process.abort()` method causes the Node.js process to exit immediately and
                 * generate a core file.
                 *
                 * This feature is not available in `Worker` threads.
                 * @since v0.7.0
                 */
                abort(): never;
                /**
                 * The `process.chdir()` method changes the current working directory of the
                 * Node.js process or throws an exception if doing so fails (for instance, if
                 * the specified `directory` does not exist).
                 *
                 * ```js
                 * import { chdir, cwd } from 'node:process';
                 *
                 * console.log(`Starting directory: ${cwd()}`);
                 * try {
                 *   chdir('/tmp');
                 *   console.log(`New directory: ${cwd()}`);
                 * } catch (err) {
                 *   console.error(`chdir: ${err}`);
                 * }
                 * ```
                 *
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.17
                 */
                chdir(directory: string): void;
                /**
                 * The `process.cwd()` method returns the current working directory of the Node.js
                 * process.
                 *
                 * ```js
                 * import { cwd } from 'node:process';
                 *
                 * console.log(`Current directory: ${cwd()}`);
                 * ```
                 * @since v0.1.8
                 */
                cwd(): string;
                /**
                 * The port used by the Node.js debugger when enabled.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * process.debugPort = 5858;
                 * ```
                 * @since v0.7.2
                 */
                debugPort: number;
                /**
                 * The `process.dlopen()` method allows dynamically loading shared objects. It is primarily used by `require()` to load C++ Addons, and
                 * should not be used directly, except in special cases. In other words, `require()` should be preferred over `process.dlopen()`
                 * unless there are specific reasons such as custom dlopen flags or loading from ES modules.
                 *
                 * The `flags` argument is an integer that allows to specify dlopen behavior. See the `[os.constants.dlopen](https://nodejs.org/docs/latest-v24.x/api/os.html#dlopen-constants)`
                 * documentation for details.
                 *
                 * An important requirement when calling `process.dlopen()` is that the `module` instance must be passed. Functions exported by the C++ Addon
                 * are then accessible via `module.exports`.
                 *
                 * The example below shows how to load a C++ Addon, named `local.node`, that exports a `foo` function. All the symbols are loaded before the call returns, by passing the `RTLD_NOW` constant.
                 * In this example the constant is assumed to be available.
                 *
                 * ```js
                 * import { dlopen } from 'node:process';
                 * import { constants } from 'node:os';
                 * import { fileURLToPath } from 'node:url';
                 *
                 * const module = { exports: {} };
                 * dlopen(module, fileURLToPath(new URL('local.node', import.meta.url)),
                 *        constants.dlopen.RTLD_NOW);
                 * module.exports.foo();
                 * ```
                 */
                dlopen(module: object, filename: string, flags?: number): void;
                /**
                 * The `process.emitWarning()` method can be used to emit custom or application
                 * specific process warnings. These can be listened for by adding a handler to the `'warning'` event.
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using a string.
                 * emitWarning('Something happened!');
                 * // Emits: (node: 56338) Warning: Something happened!
                 * ```
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using a string and a type.
                 * emitWarning('Something Happened!', 'CustomWarning');
                 * // Emits: (node:56338) CustomWarning: Something Happened!
                 * ```
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * emitWarning('Something happened!', 'CustomWarning', 'WARN001');
                 * // Emits: (node:56338) [WARN001] CustomWarning: Something happened!
                 * ```js
                 *
                 * In each of the previous examples, an `Error` object is generated internally by `process.emitWarning()` and passed through to the `'warning'` handler.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * process.on('warning', (warning) => {
                 *   console.warn(warning.name);    // 'Warning'
                 *   console.warn(warning.message); // 'Something happened!'
                 *   console.warn(warning.code);    // 'MY_WARNING'
                 *   console.warn(warning.stack);   // Stack trace
                 *   console.warn(warning.detail);  // 'This is some additional information'
                 * });
                 * ```
                 *
                 * If `warning` is passed as an `Error` object, it will be passed through to the `'warning'` event handler
                 * unmodified (and the optional `type`, `code` and `ctor` arguments will be ignored):
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using an Error object.
                 * const myWarning = new Error('Something happened!');
                 * // Use the Error name property to specify the type name
                 * myWarning.name = 'CustomWarning';
                 * myWarning.code = 'WARN001';
                 *
                 * emitWarning(myWarning);
                 * // Emits: (node:56338) [WARN001] CustomWarning: Something happened!
                 * ```
                 *
                 * A `TypeError` is thrown if `warning` is anything other than a string or `Error` object.
                 *
                 * While process warnings use `Error` objects, the process warning mechanism is not a replacement for normal error handling mechanisms.
                 *
                 * The following additional handling is implemented if the warning `type` is `'DeprecationWarning'`:
                 * * If the `--throw-deprecation` command-line flag is used, the deprecation warning is thrown as an exception rather than being emitted as an event.
                 * * If the `--no-deprecation` command-line flag is used, the deprecation warning is suppressed.
                 * * If the `--trace-deprecation` command-line flag is used, the deprecation warning is printed to `stderr` along with the full stack trace.
                 * @since v8.0.0
                 * @param warning The warning to emit.
                 */
                emitWarning(warning: string | Error, ctor?: Function): void;
                emitWarning(warning: string | Error, type?: string, ctor?: Function): void;
                emitWarning(warning: string | Error, type?: string, code?: string, ctor?: Function): void;
                emitWarning(warning: string | Error, options?: EmitWarningOptions): void;
                /**
                 * The `process.env` property returns an object containing the user environment.
                 * See [`environ(7)`](http://man7.org/linux/man-pages/man7/environ.7.html).
                 *
                 * An example of this object looks like:
                 *
                 * ```js
                 * {
                 *   TERM: 'xterm-256color',
                 *   SHELL: '/usr/local/bin/bash',
                 *   USER: 'maciej',
                 *   PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
                 *   PWD: '/Users/maciej',
                 *   EDITOR: 'vim',
                 *   SHLVL: '1',
                 *   HOME: '/Users/maciej',
                 *   LOGNAME: 'maciej',
                 *   _: '/usr/local/bin/node'
                 * }
                 * ```
                 *
                 * It is possible to modify this object, but such modifications will not be
                 * reflected outside the Node.js process, or (unless explicitly requested)
                 * to other `Worker` threads.
                 * In other words, the following example would not work:
                 *
                 * ```bash
                 * node -e 'process.env.foo = "bar"' &#x26;&#x26; echo $foo
                 * ```
                 *
                 * While the following will:
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.foo = 'bar';
                 * console.log(env.foo);
                 * ```
                 *
                 * Assigning a property on `process.env` will implicitly convert the value
                 * to a string. **This behavior is deprecated.** Future versions of Node.js may
                 * throw an error when the value is not a string, number, or boolean.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.test = null;
                 * console.log(env.test);
                 * // => 'null'
                 * env.test = undefined;
                 * console.log(env.test);
                 * // => 'undefined'
                 * ```
                 *
                 * Use `delete` to delete a property from `process.env`.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.TEST = 1;
                 * delete env.TEST;
                 * console.log(env.TEST);
                 * // => undefined
                 * ```
                 *
                 * On Windows operating systems, environment variables are case-insensitive.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.TEST = 1;
                 * console.log(env.test);
                 * // => 1
                 * ```
                 *
                 * Unless explicitly specified when creating a `Worker` instance,
                 * each `Worker` thread has its own copy of `process.env`, based on its
                 * parent thread's `process.env`, or whatever was specified as the `env` option
                 * to the `Worker` constructor. Changes to `process.env` will not be visible
                 * across `Worker` threads, and only the main thread can make changes that
                 * are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner
                 * unlike the main thread.
                 * @since v0.1.27
                 */
                env: ProcessEnv;
                /**
                 * The `process.exit()` method instructs Node.js to terminate the process
                 * synchronously with an exit status of `code`. If `code` is omitted, exit uses
                 * either the 'success' code `0` or the value of `process.exitCode` if it has been
                 * set. Node.js will not terminate until all the `'exit'` event listeners are
                 * called.
                 *
                 * To exit with a 'failure' code:
                 *
                 * ```js
                 * import { exit } from 'node:process';
                 *
                 * exit(1);
                 * ```
                 *
                 * The shell that executed Node.js should see the exit code as `1`.
                 *
                 * Calling `process.exit()` will force the process to exit as quickly as possible
                 * even if there are still asynchronous operations pending that have not yet
                 * completed fully, including I/O operations to `process.stdout` and `process.stderr`.
                 *
                 * In most situations, it is not actually necessary to call `process.exit()` explicitly. The Node.js process will exit on its own _if there is no additional_
                 * _work pending_ in the event loop. The `process.exitCode` property can be set to
                 * tell the process which exit code to use when the process exits gracefully.
                 *
                 * For instance, the following example illustrates a _misuse_ of the `process.exit()` method that could lead to data printed to stdout being
                 * truncated and lost:
                 *
                 * ```js
                 * import { exit } from 'node:process';
                 *
                 * // This is an example of what *not* to do:
                 * if (someConditionNotMet()) {
                 *   printUsageToStdout();
                 *   exit(1);
                 * }
                 * ```
                 *
                 * The reason this is problematic is because writes to `process.stdout` in Node.js
                 * are sometimes _asynchronous_ and may occur over multiple ticks of the Node.js
                 * event loop. Calling `process.exit()`, however, forces the process to exit _before_ those additional writes to `stdout` can be performed.
                 *
                 * Rather than calling `process.exit()` directly, the code _should_ set the `process.exitCode` and allow the process to exit naturally by avoiding
                 * scheduling any additional work for the event loop:
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * // How to properly set the exit code while letting
                 * // the process exit gracefully.
                 * if (someConditionNotMet()) {
                 *   printUsageToStdout();
                 *   process.exitCode = 1;
                 * }
                 * ```
                 *
                 * If it is necessary to terminate the Node.js process due to an error condition,
                 * throwing an _uncaught_ error and allowing the process to terminate accordingly
                 * is safer than calling `process.exit()`.
                 *
                 * In `Worker` threads, this function stops the current thread rather
                 * than the current process.
                 * @since v0.1.13
                 * @param [code=0] The exit code. For string type, only integer strings (e.g.,'1') are allowed.
                 */
                exit(code?: number | string | null | undefined): never;
                /**
                 * A number which will be the process exit code, when the process either
                 * exits gracefully, or is exited via {@link exit} without specifying
                 * a code.
                 *
                 * Specifying a code to {@link exit} will override any
                 * previous setting of `process.exitCode`.
                 * @default undefined
                 * @since v0.11.8
                 */
                exitCode?: number | string | number | undefined;
                finalization: {
                    /**
                     * This function registers a callback to be called when the process emits the `exit` event if the `ref` object was not garbage collected.
                     * If the object `ref` was garbage collected before the `exit` event is emitted, the callback will be removed from the finalization registry, and it will not be called on process exit.
                     *
                     * Inside the callback you can release the resources allocated by the `ref` object.
                     * Be aware that all limitations applied to the `beforeExit` event are also applied to the callback function,
                     * this means that there is a possibility that the callback will not be called under special circumstances.
                     *
                     * The idea of this function is to help you free up resources when the starts process exiting, but also let the object be garbage collected if it is no longer being used.
                     * @param ref The reference to the resource that is being tracked.
                     * @param callback The callback function to be called when the resource is finalized.
                     * @since v22.5.0
                     * @experimental
                     */
                    register<T extends object>(ref: T, callback: (ref: T, event: "exit") => void): void;
                    /**
                     * This function behaves exactly like the `register`, except that the callback will be called when the process emits the `beforeExit` event if `ref` object was not garbage collected.
                     *
                     * Be aware that all limitations applied to the `beforeExit` event are also applied to the callback function, this means that there is a possibility that the callback will not be called under special circumstances.
                     * @param ref The reference to the resource that is being tracked.
                     * @param callback The callback function to be called when the resource is finalized.
                     * @since v22.5.0
                     * @experimental
                     */
                    registerBeforeExit<T extends object>(ref: T, callback: (ref: T, event: "beforeExit") => void): void;
                    /**
                     * This function remove the register of the object from the finalization registry, so the callback will not be called anymore.
                     * @param ref The reference to the resource that was registered previously.
                     * @since v22.5.0
                     * @experimental
                     */
                    unregister(ref: object): void;
                };
                /**
                 * The `process.getActiveResourcesInfo()` method returns an array of strings containing
                 * the types of the active resources that are currently keeping the event loop alive.
                 *
                 * ```js
                 * import { getActiveResourcesInfo } from 'node:process';
                 * import { setTimeout } from 'node:timers';

                 * console.log('Before:', getActiveResourcesInfo());
                 * setTimeout(() => {}, 1000);
                 * console.log('After:', getActiveResourcesInfo());
                 * // Prints:
                 * //   Before: [ 'TTYWrap', 'TTYWrap', 'TTYWrap' ]
                 * //   After: [ 'TTYWrap', 'TTYWrap', 'TTYWrap', 'Timeout' ]
                 * ```
                 * @since v17.3.0, v16.14.0
                 */
                getActiveResourcesInfo(): string[];
                /**
                 * Provides a way to load built-in modules in a globally available function.
                 * @param id ID of the built-in module being requested.
                 */
                getBuiltinModule<ID extends keyof BuiltInModule>(id: ID): BuiltInModule[ID];
                getBuiltinModule(id: string): object | undefined;
                /**
                 * The `process.getgid()` method returns the numerical group identity of the
                 * process. (See [`getgid(2)`](http://man7.org/linux/man-pages/man2/getgid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgid) {
                 *   console.log(`Current gid: ${process.getgid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.1.31
                 */
                getgid?: () => number;
                /**
                 * The `process.setgid()` method sets the group identity of the process. (See [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html).) The `id` can be passed as either a
                 * numeric ID or a group name
                 * string. If a group name is specified, this method blocks while resolving the
                 * associated numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgid &#x26;&#x26; process.setgid) {
                 *   console.log(`Current gid: ${process.getgid()}`);
                 *   try {
                 *     process.setgid(501);
                 *     console.log(`New gid: ${process.getgid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set gid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.31
                 * @param id The group name or ID
                 */
                setgid?: (id: number | string) => void;
                /**
                 * The `process.getuid()` method returns the numeric user identity of the process.
                 * (See [`getuid(2)`](http://man7.org/linux/man-pages/man2/getuid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getuid) {
                 *   console.log(`Current uid: ${process.getuid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.1.28
                 */
                getuid?: () => number;
                /**
                 * The `process.setuid(id)` method sets the user identity of the process. (See [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html).) The `id` can be passed as either a
                 * numeric ID or a username string.
                 * If a username is specified, the method blocks while resolving the associated
                 * numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getuid &#x26;&#x26; process.setuid) {
                 *   console.log(`Current uid: ${process.getuid()}`);
                 *   try {
                 *     process.setuid(501);
                 *     console.log(`New uid: ${process.getuid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set uid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.28
                 */
                setuid?: (id: number | string) => void;
                /**
                 * The `process.geteuid()` method returns the numerical effective user identity of
                 * the process. (See [`geteuid(2)`](http://man7.org/linux/man-pages/man2/geteuid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.geteuid) {
                 *   console.log(`Current uid: ${process.geteuid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v2.0.0
                 */
                geteuid?: () => number;
                /**
                 * The `process.seteuid()` method sets the effective user identity of the process.
                 * (See [`seteuid(2)`](http://man7.org/linux/man-pages/man2/seteuid.2.html).) The `id` can be passed as either a numeric ID or a username
                 * string. If a username is specified, the method blocks while resolving the
                 * associated numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.geteuid &#x26;&#x26; process.seteuid) {
                 *   console.log(`Current uid: ${process.geteuid()}`);
                 *   try {
                 *     process.seteuid(501);
                 *     console.log(`New uid: ${process.geteuid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set uid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v2.0.0
                 * @param id A user name or ID
                 */
                seteuid?: (id: number | string) => void;
                /**
                 * The `process.getegid()` method returns the numerical effective group identity
                 * of the Node.js process. (See [`getegid(2)`](http://man7.org/linux/man-pages/man2/getegid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getegid) {
                 *   console.log(`Current gid: ${process.getegid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v2.0.0
                 */
                getegid?: () => number;
                /**
                 * The `process.setegid()` method sets the effective group identity of the process.
                 * (See [`setegid(2)`](http://man7.org/linux/man-pages/man2/setegid.2.html).) The `id` can be passed as either a numeric ID or a group
                 * name string. If a group name is specified, this method blocks while resolving
                 * the associated a numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getegid &#x26;&#x26; process.setegid) {
                 *   console.log(`Current gid: ${process.getegid()}`);
                 *   try {
                 *     process.setegid(501);
                 *     console.log(`New gid: ${process.getegid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set gid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v2.0.0
                 * @param id A group name or ID
                 */
                setegid?: (id: number | string) => void;
                /**
                 * The `process.getgroups()` method returns an array with the supplementary group
                 * IDs. POSIX leaves it unspecified if the effective group ID is included but
                 * Node.js ensures it always is.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgroups) {
                 *   console.log(process.getgroups()); // [ 16, 21, 297 ]
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.9.4
                 */
                getgroups?: () => number[];
                /**
                 * The `process.setgroups()` method sets the supplementary group IDs for the
                 * Node.js process. This is a privileged operation that requires the Node.js
                 * process to have `root` or the `CAP_SETGID` capability.
                 *
                 * The `groups` array can contain numeric group IDs, group names, or both.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgroups &#x26;&#x26; process.setgroups) {
                 *   try {
                 *     process.setgroups([501]);
                 *     console.log(process.getgroups()); // new groups
                 *   } catch (err) {
                 *     console.log(`Failed to set groups: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.9.4
                 */
                setgroups?: (groups: ReadonlyArray<string | number>) => void;
                /**
                 * The `process.setUncaughtExceptionCaptureCallback()` function sets a function
                 * that will be invoked when an uncaught exception occurs, which will receive the
                 * exception value itself as its first argument.
                 *
                 * If such a function is set, the `'uncaughtException'` event will
                 * not be emitted. If `--abort-on-uncaught-exception` was passed from the
                 * command line or set through `v8.setFlagsFromString()`, the process will
                 * not abort. Actions configured to take place on exceptions such as report
                 * generations will be affected too
                 *
                 * To unset the capture function, `process.setUncaughtExceptionCaptureCallback(null)` may be used. Calling this
                 * method with a non-`null` argument while another capture function is set will
                 * throw an error.
                 *
                 * Using this function is mutually exclusive with using the deprecated `domain` built-in module.
                 * @since v9.3.0
                 */
                setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;
                /**
                 * Indicates whether a callback has been set using {@link setUncaughtExceptionCaptureCallback}.
                 * @since v9.3.0
                 */
                hasUncaughtExceptionCaptureCallback(): boolean;
                /**
                 * The `process.sourceMapsEnabled` property returns whether the [Source Map v3](https://sourcemaps.info/spec.html) support for stack traces is enabled.
                 * @since v20.7.0
                 * @experimental
                 */
                readonly sourceMapsEnabled: boolean;
                /**
                 * This function enables or disables the [Source Map v3](https://sourcemaps.info/spec.html) support for
                 * stack traces.
                 *
                 * It provides same features as launching Node.js process with commandline options `--enable-source-maps`.
                 *
                 * Only source maps in JavaScript files that are loaded after source maps has been
                 * enabled will be parsed and loaded.
                 * @since v16.6.0, v14.18.0
                 * @experimental
                 */
                setSourceMapsEnabled(value: boolean): void;
                /**
                 * The `process.version` property contains the Node.js version string.
                 *
                 * ```js
                 * import { version } from 'node:process';
                 *
                 * console.log(`Version: ${version}`);
                 * // Version: v14.8.0
                 * ```
                 *
                 * To get the version string without the prepended _v_, use`process.versions.node`.
                 * @since v0.1.3
                 */
                readonly version: string;
                /**
                 * The `process.versions` property returns an object listing the version strings of
                 * Node.js and its dependencies. `process.versions.modules` indicates the current
                 * ABI version, which is increased whenever a C++ API changes. Node.js will refuse
                 * to load modules that were compiled against a different module ABI version.
                 *
                 * ```js
                 * import { versions } from 'node:process';
                 *
                 * console.log(versions);
                 * ```
                 *
                 * Will generate an object similar to:
                 *
                 * ```console
                 * { node: '20.2.0',
                 *   acorn: '8.8.2',
                 *   ada: '2.4.0',
                 *   ares: '1.19.0',
                 *   base64: '0.5.0',
                 *   brotli: '1.0.9',
                 *   cjs_module_lexer: '1.2.2',
                 *   cldr: '43.0',
                 *   icu: '73.1',
                 *   llhttp: '8.1.0',
                 *   modules: '115',
                 *   napi: '8',
                 *   nghttp2: '1.52.0',
                 *   nghttp3: '0.7.0',
                 *   ngtcp2: '0.8.1',
                 *   openssl: '3.0.8+quic',
                 *   simdutf: '3.2.9',
                 *   tz: '2023c',
                 *   undici: '5.22.0',
                 *   unicode: '15.0',
                 *   uv: '1.44.2',
                 *   uvwasi: '0.0.16',
                 *   v8: '11.3.244.8-node.9',
                 *   zlib: '1.2.13' }
                 * ```
                 * @since v0.2.0
                 */
                readonly versions: ProcessVersions;
                /**
                 * The `process.config` property returns a frozen `Object` containing the
                 * JavaScript representation of the configure options used to compile the current
                 * Node.js executable. This is the same as the `config.gypi` file that was produced
                 * when running the `./configure` script.
                 *
                 * An example of the possible output looks like:
                 *
                 * ```js
                 * {
                 *   target_defaults:
                 *    { cflags: [],
                 *      default_configuration: 'Release',
                 *      defines: [],
                 *      include_dirs: [],
                 *      libraries: [] },
                 *   variables:
                 *    {
                 *      host_arch: 'x64',
                 *      napi_build_version: 5,
                 *      node_install_npm: 'true',
                 *      node_prefix: '',
                 *      node_shared_cares: 'false',
                 *      node_shared_http_parser: 'false',
                 *      node_shared_libuv: 'false',
                 *      node_shared_zlib: 'false',
                 *      node_use_openssl: 'true',
                 *      node_shared_openssl: 'false',
                 *      strict_aliasing: 'true',
                 *      target_arch: 'x64',
                 *      v8_use_snapshot: 1
                 *    }
                 * }
                 * ```
                 * @since v0.7.7
                 */
                readonly config: ProcessConfig;
                /**
                 * The `process.kill()` method sends the `signal` to the process identified by`pid`.
                 *
                 * Signal names are strings such as `'SIGINT'` or `'SIGHUP'`. See `Signal Events` and [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) for more information.
                 *
                 * This method will throw an error if the target `pid` does not exist. As a special
                 * case, a signal of `0` can be used to test for the existence of a process.
                 * Windows platforms will throw an error if the `pid` is used to kill a process
                 * group.
                 *
                 * Even though the name of this function is `process.kill()`, it is really just a
                 * signal sender, like the `kill` system call. The signal sent may do something
                 * other than kill the target process.
                 *
                 * ```js
                 * import process, { kill } from 'node:process';
                 *
                 * process.on('SIGHUP', () => {
                 *   console.log('Got SIGHUP signal.');
                 * });
                 *
                 * setTimeout(() => {
                 *   console.log('Exiting.');
                 *   process.exit(0);
                 * }, 100);
                 *
                 * kill(process.pid, 'SIGHUP');
                 * ```
                 *
                 * When `SIGUSR1` is received by a Node.js process, Node.js will start the
                 * debugger. See `Signal Events`.
                 * @since v0.0.6
                 * @param pid A process ID
                 * @param [signal='SIGTERM'] The signal to send, either as a string or number.
                 */
                kill(pid: number, signal?: string | number): true;
                /**
                 * Loads the environment configuration from a `.env` file into `process.env`. If
                 * the file is not found, error will be thrown.
                 *
                 * To load a specific .env file by specifying its path, use the following code:
                 *
                 * ```js
                 * import { loadEnvFile } from 'node:process';
                 *
                 * loadEnvFile('./development.env')
                 * ```
                 * @since v20.12.0
                 * @param path The path to the .env file
                 */
                loadEnvFile(path?: string | URL | Buffer): void;
                /**
                 * The `process.pid` property returns the PID of the process.
                 *
                 * ```js
                 * import { pid } from 'node:process';
                 *
                 * console.log(`This process is pid ${pid}`);
                 * ```
                 * @since v0.1.15
                 */
                readonly pid: number;
                /**
                 * The `process.ppid` property returns the PID of the parent of the
                 * current process.
                 *
                 * ```js
                 * import { ppid } from 'node:process';
                 *
                 * console.log(`The parent process is pid ${ppid}`);
                 * ```
                 * @since v9.2.0, v8.10.0, v6.13.0
                 */
                readonly ppid: number;
                /**
                 * The `process.threadCpuUsage()` method returns the user and system CPU time usage of
                 * the current worker thread, in an object with properties `user` and `system`, whose
                 * values are microsecond values (millionth of a second).
                 *
                 * The result of a previous call to `process.threadCpuUsage()` can be passed as the
                 * argument to the function, to get a diff reading.
                 * @since v23.9.0
                 * @param previousValue A previous return value from calling
                 * `process.threadCpuUsage()`
                 */
                threadCpuUsage(previousValue?: CpuUsage): CpuUsage;
                /**
                 * The `process.title` property returns the current process title (i.e. returns
                 * the current value of `ps`). Assigning a new value to `process.title` modifies
                 * the current value of `ps`.
                 *
                 * When a new value is assigned, different platforms will impose different maximum
                 * length restrictions on the title. Usually such restrictions are quite limited.
                 * For instance, on Linux and macOS, `process.title` is limited to the size of the
                 * binary name plus the length of the command-line arguments because setting the `process.title` overwrites the `argv` memory of the process. Node.js v0.8
                 * allowed for longer process title strings by also overwriting the `environ` memory but that was potentially insecure and confusing in some (rather obscure)
                 * cases.
                 *
                 * Assigning a value to `process.title` might not result in an accurate label
                 * within process manager applications such as macOS Activity Monitor or Windows
                 * Services Manager.
                 * @since v0.1.104
                 */
                title: string;
                /**
                 * The operating system CPU architecture for which the Node.js binary was compiled.
                 * Possible values are: `'arm'`, `'arm64'`, `'ia32'`, `'loong64'`, `'mips'`,
                 * `'mipsel'`, `'ppc64'`, `'riscv64'`, `'s390x'`, and `'x64'`.
                 *
                 * ```js
                 * import { arch } from 'node:process';
                 *
                 * console.log(`This processor architecture is ${arch}`);
                 * ```
                 * @since v0.5.0
                 */
                readonly arch: Architecture;
                /**
                 * The `process.platform` property returns a string identifying the operating
                 * system platform for which the Node.js binary was compiled.
                 *
                 * Currently possible values are:
                 *
                 * * `'aix'`
                 * * `'darwin'`
                 * * `'freebsd'`
                 * * `'linux'`
                 * * `'openbsd'`
                 * * `'sunos'`
                 * * `'win32'`
                 *
                 * ```js
                 * import { platform } from 'node:process';
                 *
                 * console.log(`This platform is ${platform}`);
                 * ```
                 *
                 * The value `'android'` may also be returned if the Node.js is built on the
                 * Android operating system. However, Android support in Node.js [is experimental](https://github.com/nodejs/node/blob/HEAD/BUILDING.md#androidandroid-based-devices-eg-firefox-os).
                 * @since v0.1.16
                 */
                readonly platform: Platform;
                /**
                 * The `process.mainModule` property provides an alternative way of retrieving `require.main`. The difference is that if the main module changes at
                 * runtime, `require.main` may still refer to the original main module in
                 * modules that were required before the change occurred. Generally, it's
                 * safe to assume that the two refer to the same module.
                 *
                 * As with `require.main`, `process.mainModule` will be `undefined` if there
                 * is no entry script.
                 * @since v0.1.17
                 * @deprecated Since v14.0.0 - Use `main` instead.
                 */
                mainModule?: Module | undefined;
                memoryUsage: MemoryUsageFn;
                /**
                 * Gets the amount of memory available to the process (in bytes) based on
                 * limits imposed by the OS. If there is no such constraint, or the constraint
                 * is unknown, `0` is returned.
                 *
                 * See [`uv_get_constrained_memory`](https://docs.libuv.org/en/v1.x/misc.html#c.uv_get_constrained_memory) for more
                 * information.
                 * @since v19.6.0, v18.15.0
                 */
                constrainedMemory(): number;
                /**
                 * Gets the amount of free memory that is still available to the process (in bytes).
                 * See [`uv_get_available_memory`](https://nodejs.org/docs/latest-v24.x/api/process.html#processavailablememory) for more information.
                 * @since v20.13.0
                 */
                availableMemory(): number;
                /**
                 * The `process.cpuUsage()` method returns the user and system CPU time usage of
                 * the current process, in an object with properties `user` and `system`, whose
                 * values are microsecond values (millionth of a second). These values measure time
                 * spent in user and system code respectively, and may end up being greater than
                 * actual elapsed time if multiple CPU cores are performing work for this process.
                 *
                 * The result of a previous call to `process.cpuUsage()` can be passed as the
                 * argument to the function, to get a diff reading.
                 *
                 * ```js
                 * import { cpuUsage } from 'node:process';
                 *
                 * const startUsage = cpuUsage();
                 * // { user: 38579, system: 6986 }
                 *
                 * // spin the CPU for 500 milliseconds
                 * const now = Date.now();
                 * while (Date.now() - now < 500);
                 *
                 * console.log(cpuUsage(startUsage));
                 * // { user: 514883, system: 11226 }
                 * ```
                 * @since v6.1.0
                 * @param previousValue A previous return value from calling `process.cpuUsage()`
                 */
                cpuUsage(previousValue?: CpuUsage): CpuUsage;
                /**
                 * `process.nextTick()` adds `callback` to the "next tick queue". This queue is
                 * fully drained after the current operation on the JavaScript stack runs to
                 * completion and before the event loop is allowed to continue. It's possible to
                 * create an infinite loop if one were to recursively call `process.nextTick()`.
                 * See the [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick) guide for more background.
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * console.log('start');
                 * nextTick(() => {
                 *   console.log('nextTick callback');
                 * });
                 * console.log('scheduled');
                 * // Output:
                 * // start
                 * // scheduled
                 * // nextTick callback
                 * ```
                 *
                 * This is important when developing APIs in order to give users the opportunity
                 * to assign event handlers _after_ an object has been constructed but before any
                 * I/O has occurred:
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * function MyThing(options) {
                 *   this.setupOptions(options);
                 *
                 *   nextTick(() => {
                 *     this.startDoingStuff();
                 *   });
                 * }
                 *
                 * const thing = new MyThing();
                 * thing.getReadyForStuff();
                 *
                 * // thing.startDoingStuff() gets called now, not before.
                 * ```
                 *
                 * It is very important for APIs to be either 100% synchronous or 100%
                 * asynchronous. Consider this example:
                 *
                 * ```js
                 * // WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!
                 * function maybeSync(arg, cb) {
                 *   if (arg) {
                 *     cb();
                 *     return;
                 *   }
                 *
                 *   fs.stat('file', cb);
                 * }
                 * ```
                 *
                 * This API is hazardous because in the following case:
                 *
                 * ```js
                 * const maybeTrue = Math.random() > 0.5;
                 *
                 * maybeSync(maybeTrue, () => {
                 *   foo();
                 * });
                 *
                 * bar();
                 * ```
                 *
                 * It is not clear whether `foo()` or `bar()` will be called first.
                 *
                 * The following approach is much better:
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * function definitelyAsync(arg, cb) {
                 *   if (arg) {
                 *     nextTick(cb);
                 *     return;
                 *   }
                 *
                 *   fs.stat('file', cb);
                 * }
                 * ```
                 * @since v0.1.26
                 * @param args Additional arguments to pass when invoking the `callback`
                 */
                nextTick(callback: Function, ...args: any[]): void;
                /**
                 * This API is available through the [--permission](https://nodejs.org/api/cli.html#--permission) flag.
                 *
                 * `process.permission` is an object whose methods are used to manage permissions for the current process.
                 * Additional documentation is available in the [Permission Model](https://nodejs.org/api/permissions.html#permission-model).
                 * @since v20.0.0
                 */
                permission: ProcessPermission;
                /**
                 * The `process.release` property returns an `Object` containing metadata related
                 * to the current release, including URLs for the source tarball and headers-only
                 * tarball.
                 *
                 * `process.release` contains the following properties:
                 *
                 * ```js
                 * {
                 *   name: 'node',
                 *   lts: 'Hydrogen',
                 *   sourceUrl: 'https://nodejs.org/download/release/v18.12.0/node-v18.12.0.tar.gz',
                 *   headersUrl: 'https://nodejs.org/download/release/v18.12.0/node-v18.12.0-headers.tar.gz',
                 *   libUrl: 'https://nodejs.org/download/release/v18.12.0/win-x64/node.lib'
                 * }
                 * ```
                 *
                 * In custom builds from non-release versions of the source tree, only the `name` property may be present. The additional properties should not be
                 * relied upon to exist.
                 * @since v3.0.0
                 */
                readonly release: ProcessRelease;
                readonly features: ProcessFeatures;
                /**
                 * `process.umask()` returns the Node.js process's file mode creation mask. Child
                 * processes inherit the mask from the parent process.
                 * @since v0.1.19
                 * @deprecated Calling `process.umask()` with no argument causes the process-wide umask to be written twice. This introduces a race condition between threads, and is a potential
                 * security vulnerability. There is no safe, cross-platform alternative API.
                 */
                umask(): number;
                /**
                 * Can only be set if not in worker thread.
                 */
                umask(mask: string | number): number;
                /**
                 * The `process.uptime()` method returns the number of seconds the current Node.js
                 * process has been running.
                 *
                 * The return value includes fractions of a second. Use `Math.floor()` to get whole
                 * seconds.
                 * @since v0.5.0
                 */
                uptime(): number;
                hrtime: HRTime;
                /**
                 * If the Node.js process was spawned with an IPC channel, the process.channel property is a reference to the IPC channel.
                 * If no IPC channel exists, this property is undefined.
                 * @since v7.1.0
                 */
                channel?: {
                    /**
                     * This method makes the IPC channel keep the event loop of the process running if .unref() has been called before.
                     * @since v7.1.0
                     */
                    ref(): void;
                    /**
                     * This method makes the IPC channel not keep the event loop of the process running, and lets it finish even while the channel is open.
                     * @since v7.1.0
                     */
                    unref(): void;
                };
                /**
                 * If Node.js is spawned with an IPC channel, the `process.send()` method can be
                 * used to send messages to the parent process. Messages will be received as a `'message'` event on the parent's `ChildProcess` object.
                 *
                 * If Node.js was not spawned with an IPC channel, `process.send` will be `undefined`.
                 *
                 * The message goes through serialization and parsing. The resulting message might
                 * not be the same as what is originally sent.
                 * @since v0.5.9
                 * @param options used to parameterize the sending of certain types of handles. `options` supports the following properties:
                 */
                send?(
                    message: any,
                    sendHandle?: any,
                    options?: {
                        keepOpen?: boolean | undefined;
                    },
                    callback?: (error: Error | null) => void,
                ): boolean;
                /**
                 * If the Node.js process is spawned with an IPC channel (see the `Child Process` and `Cluster` documentation), the `process.disconnect()` method will close the
                 * IPC channel to the parent process, allowing the child process to exit gracefully
                 * once there are no other connections keeping it alive.
                 *
                 * The effect of calling `process.disconnect()` is the same as calling `ChildProcess.disconnect()` from the parent process.
                 *
                 * If the Node.js process was not spawned with an IPC channel, `process.disconnect()` will be `undefined`.
                 * @since v0.7.2
                 */
                disconnect(): void;
                /**
                 * If the Node.js process is spawned with an IPC channel (see the `Child Process` and `Cluster` documentation), the `process.connected` property will return `true` so long as the IPC
                 * channel is connected and will return `false` after `process.disconnect()` is called.
                 *
                 * Once `process.connected` is `false`, it is no longer possible to send messages
                 * over the IPC channel using `process.send()`.
                 * @since v0.7.2
                 */
                connected: boolean;
                /**
                 * The `process.allowedNodeEnvironmentFlags` property is a special,
                 * read-only `Set` of flags allowable within the `NODE_OPTIONS` environment variable.
                 *
                 * `process.allowedNodeEnvironmentFlags` extends `Set`, but overrides `Set.prototype.has` to recognize several different possible flag
                 * representations. `process.allowedNodeEnvironmentFlags.has()` will
                 * return `true` in the following cases:
                 *
                 * * Flags may omit leading single (`-`) or double (`--`) dashes; e.g., `inspect-brk` for `--inspect-brk`, or `r` for `-r`.
                 * * Flags passed through to V8 (as listed in `--v8-options`) may replace
                 * one or more _non-leading_ dashes for an underscore, or vice-versa;
                 * e.g., `--perf_basic_prof`, `--perf-basic-prof`, `--perf_basic-prof`,
                 * etc.
                 * * Flags may contain one or more equals (`=`) characters; all
                 * characters after and including the first equals will be ignored;
                 * e.g., `--stack-trace-limit=100`.
                 * * Flags _must_ be allowable within `NODE_OPTIONS`.
                 *
                 * When iterating over `process.allowedNodeEnvironmentFlags`, flags will
                 * appear only _once_; each will begin with one or more dashes. Flags
                 * passed through to V8 will contain underscores instead of non-leading
                 * dashes:
                 *
                 * ```js
                 * import { allowedNodeEnvironmentFlags } from 'node:process';
                 *
                 * allowedNodeEnvironmentFlags.forEach((flag) => {
                 *   // -r
                 *   // --inspect-brk
                 *   // --abort_on_uncaught_exception
                 *   // ...
                 * });
                 * ```
                 *
                 * The methods `add()`, `clear()`, and `delete()` of`process.allowedNodeEnvironmentFlags` do nothing, and will fail
                 * silently.
                 *
                 * If Node.js was compiled _without_ `NODE_OPTIONS` support (shown in {@link config}), `process.allowedNodeEnvironmentFlags` will
                 * contain what _would have_ been allowable.
                 * @since v10.10.0
                 */
                allowedNodeEnvironmentFlags: ReadonlySet<string>;
                /**
                 * `process.report` is an object whose methods are used to generate diagnostic reports for the current process.
                 * Additional documentation is available in the [report documentation](https://nodejs.org/docs/latest-v24.x/api/report.html).
                 * @since v11.8.0
                 */
                report: ProcessReport;
                /**
                 * ```js
                 * import { resourceUsage } from 'node:process';
                 *
                 * console.log(resourceUsage());
                 * /*
                 *   Will output:
                 *   {
                 *     userCPUTime: 82872,
                 *     systemCPUTime: 4143,
                 *     maxRSS: 33164,
                 *     sharedMemorySize: 0,
                 *     unsharedDataSize: 0,
                 *     unsharedStackSize: 0,
                 *     minorPageFault: 2469,
                 *     majorPageFault: 0,
                 *     swappedOut: 0,
                 *     fsRead: 0,
                 *     fsWrite: 8,
                 *     ipcSent: 0,
                 *     ipcReceived: 0,
                 *     signalsCount: 0,
                 *     voluntaryContextSwitches: 79,
                 *     involuntaryContextSwitches: 1
                 *   }
                 *
                 * ```
                 * @since v12.6.0
                 * @return the resource usage for the current process. All of these values come from the `uv_getrusage` call which returns a [`uv_rusage_t` struct][uv_rusage_t].
                 */
                resourceUsage(): ResourceUsage;
                /**
                 * The initial value of `process.throwDeprecation` indicates whether the `--throw-deprecation` flag is set on the current Node.js process. `process.throwDeprecation`
                 * is mutable, so whether or not deprecation warnings result in errors may be altered at runtime. See the documentation for the 'warning' event and the emitWarning()
                 * method for more information.
                 *
                 * ```bash
                 * $ node --throw-deprecation -p "process.throwDeprecation"
                 * true
                 * $ node -p "process.throwDeprecation"
                 * undefined
                 * $ node
                 * > process.emitWarning('test', 'DeprecationWarning');
                 * undefined
                 * > (node:26598) DeprecationWarning: test
                 * > process.throwDeprecation = true;
                 * true
                 * > process.emitWarning('test', 'DeprecationWarning');
                 * Thrown:
                 * [DeprecationWarning: test] { name: 'DeprecationWarning' }
                 * ```
                 * @since v0.9.12
                 */
                throwDeprecation: boolean;
                /**
                 * The `process.traceDeprecation` property indicates whether the `--trace-deprecation` flag is set on the current Node.js process. See the
                 * documentation for the `'warning' event` and the `emitWarning() method` for more information about this
                 * flag's behavior.
                 * @since v0.8.0
                 */
                traceDeprecation: boolean;
                /**
                 * An object is "refable" if it implements the Node.js "Refable protocol".
                 * Specifically, this means that the object implements the `Symbol.for('nodejs.ref')`
                 * and `Symbol.for('nodejs.unref')` methods. "Ref'd" objects will keep the Node.js
                 * event loop alive, while "unref'd" objects will not. Historically, this was
                 * implemented by using `ref()` and `unref()` methods directly on the objects.
                 * This pattern, however, is being deprecated in favor of the "Refable protocol"
                 * in order to better support Web Platform API types whose APIs cannot be modified
                 * to add `ref()` and `unref()` methods but still need to support that behavior.
                 * @since v22.14.0
                 * @experimental
                 * @param maybeRefable An object that may be "refable".
                 */
                ref(maybeRefable: any): void;
                /**
                 * An object is "unrefable" if it implements the Node.js "Refable protocol".
                 * Specifically, this means that the object implements the `Symbol.for('nodejs.ref')`
                 * and `Symbol.for('nodejs.unref')` methods. "Ref'd" objects will keep the Node.js
                 * event loop alive, while "unref'd" objects will not. Historically, this was
                 * implemented by using `ref()` and `unref()` methods directly on the objects.
                 * This pattern, however, is being deprecated in favor of the "Refable protocol"
                 * in order to better support Web Platform API types whose APIs cannot be modified
                 * to add `ref()` and `unref()` methods but still need to support that behavior.
                 * @since v22.14.0
                 * @experimental
                 * @param maybeRefable An object that may be "unref'd".
                 */
                unref(maybeRefable: any): void;
                /**
                 * Replaces the current process with a new process.
                 *
                 * This is achieved by using the `execve` POSIX function and therefore no memory or other
                 * resources from the current process are preserved, except for the standard input,
                 * standard output and standard error file descriptor.
                 *
                 * All other resources are discarded by the system when the processes are swapped, without triggering
                 * any exit or close events and without running any cleanup handler.
                 *
                 * This function will never return, unless an error occurred.
                 *
                 * This function is not available on Windows or IBM i.
                 * @since v22.15.0
                 * @experimental
                 * @param file The name or path of the executable file to run.
                 * @param args List of string arguments. No argument can contain a null-byte (`\u0000`).
                 * @param env Environment key-value pairs.
                 * No key or value can contain a null-byte (`\u0000`).
                 * **Default:** `process.env`.
                 */
                execve?(file: string, args?: readonly string[], env?: ProcessEnv): never;
                /* EventEmitter */
                addListener(event: "beforeExit", listener: BeforeExitListener): this;
                addListener(event: "disconnect", listener: DisconnectListener): this;
                addListener(event: "exit", listener: ExitListener): this;
                addListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                addListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                addListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                addListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                addListener(event: "warning", listener: WarningListener): this;
                addListener(event: "message", listener: MessageListener): this;
                addListener(event: Signals, listener: SignalsListener): this;
                addListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                addListener(event: "worker", listener: WorkerListener): this;
                emit(event: "beforeExit", code: number): boolean;
                emit(event: "disconnect"): boolean;
                emit(event: "exit", code: number): boolean;
                emit(event: "rejectionHandled", promise: Promise<unknown>): boolean;
                emit(event: "uncaughtException", error: Error): boolean;
                emit(event: "uncaughtExceptionMonitor", error: Error): boolean;
                emit(event: "unhandledRejection", reason: unknown, promise: Promise<unknown>): boolean;
                emit(event: "warning", warning: Error): boolean;
                emit(event: "message", message: unknown, sendHandle: unknown): this;
                emit(event: Signals, signal?: Signals): boolean;
                emit(
                    event: "multipleResolves",
                    type: MultipleResolveType,
                    promise: Promise<unknown>,
                    value: unknown,
                ): this;
                emit(event: "worker", listener: WorkerListener): this;
                on(event: "beforeExit", listener: BeforeExitListener): this;
                on(event: "disconnect", listener: DisconnectListener): this;
                on(event: "exit", listener: ExitListener): this;
                on(event: "rejectionHandled", listener: RejectionHandledListener): this;
                on(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                on(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                on(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                on(event: "warning", listener: WarningListener): this;
                on(event: "message", listener: MessageListener): this;
                on(event: Signals, listener: SignalsListener): this;
                on(event: "multipleResolves", listener: MultipleResolveListener): this;
                on(event: "worker", listener: WorkerListener): this;
                on(event: string | symbol, listener: (...args: any[]) => void): this;
                once(event: "beforeExit", listener: BeforeExitListener): this;
                once(event: "disconnect", listener: DisconnectListener): this;
                once(event: "exit", listener: ExitListener): this;
                once(event: "rejectionHandled", listener: RejectionHandledListener): this;
                once(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                once(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                once(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                once(event: "warning", listener: WarningListener): this;
                once(event: "message", listener: MessageListener): this;
                once(event: Signals, listener: SignalsListener): this;
                once(event: "multipleResolves", listener: MultipleResolveListener): this;
                once(event: "worker", listener: WorkerListener): this;
                once(event: string | symbol, listener: (...args: any[]) => void): this;
                prependListener(event: "beforeExit", listener: BeforeExitListener): this;
                prependListener(event: "disconnect", listener: DisconnectListener): this;
                prependListener(event: "exit", listener: ExitListener): this;
                prependListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                prependListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                prependListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                prependListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                prependListener(event: "warning", listener: WarningListener): this;
                prependListener(event: "message", listener: MessageListener): this;
                prependListener(event: Signals, listener: SignalsListener): this;
                prependListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                prependListener(event: "worker", listener: WorkerListener): this;
                prependOnceListener(event: "beforeExit", listener: BeforeExitListener): this;
                prependOnceListener(event: "disconnect", listener: DisconnectListener): this;
                prependOnceListener(event: "exit", listener: ExitListener): this;
                prependOnceListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                prependOnceListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                prependOnceListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                prependOnceListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                prependOnceListener(event: "warning", listener: WarningListener): this;
                prependOnceListener(event: "message", listener: MessageListener): this;
                prependOnceListener(event: Signals, listener: SignalsListener): this;
                prependOnceListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                prependOnceListener(event: "worker", listener: WorkerListener): this;
                listeners(event: "beforeExit"): BeforeExitListener[];
                listeners(event: "disconnect"): DisconnectListener[];
                listeners(event: "exit"): ExitListener[];
                listeners(event: "rejectionHandled"): RejectionHandledListener[];
                listeners(event: "uncaughtException"): UncaughtExceptionListener[];
                listeners(event: "uncaughtExceptionMonitor"): UncaughtExceptionListener[];
                listeners(event: "unhandledRejection"): UnhandledRejectionListener[];
                listeners(event: "warning"): WarningListener[];
                listeners(event: "message"): MessageListener[];
                listeners(event: Signals): SignalsListener[];
                listeners(event: "multipleResolves"): MultipleResolveListener[];
                listeners(event: "worker"): WorkerListener[];
            }
        }
    }
    export = process;
}
declare module "node:process" {
    import process = require("process");
    export = process;
}


---

File name: node_modules\@types\node\punycode.d.ts

Code:
/**
 * **The version of the punycode module bundled in Node.js is being deprecated. **In a future major version of Node.js this module will be removed. Users
 * currently depending on the `punycode` module should switch to using the
 * userland-provided [Punycode.js](https://github.com/bestiejs/punycode.js) module instead. For punycode-based URL
 * encoding, see `url.domainToASCII` or, more generally, the `WHATWG URL API`.
 *
 * The `punycode` module is a bundled version of the [Punycode.js](https://github.com/bestiejs/punycode.js) module. It
 * can be accessed using:
 *
 * ```js
 * import punycode from 'node:punycode';
 * ```
 *
 * [Punycode](https://tools.ietf.org/html/rfc3492) is a character encoding scheme defined by RFC 3492 that is
 * primarily intended for use in Internationalized Domain Names. Because host
 * names in URLs are limited to ASCII characters only, Domain Names that contain
 * non-ASCII characters must be converted into ASCII using the Punycode scheme.
 * For instance, the Japanese character that translates into the English word, `'example'` is `''`. The Internationalized Domain Name, `'.com'` (equivalent
 * to `'example.com'`) is represented by Punycode as the ASCII string `'xn--fsq.com'`.
 *
 * The `punycode` module provides a simple implementation of the Punycode standard.
 *
 * The `punycode` module is a third-party dependency used by Node.js and
 * made available to developers as a convenience. Fixes or other modifications to
 * the module must be directed to the [Punycode.js](https://github.com/bestiejs/punycode.js) project.
 * @deprecated Since v7.0.0 - Deprecated
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/punycode.js)
 */
declare module "punycode" {
    /**
     * The `punycode.decode()` method converts a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only
     * characters to the equivalent string of Unicode codepoints.
     *
     * ```js
     * punycode.decode('maana-pta'); // 'maana'
     * punycode.decode('--dqo34k'); // '-'
     * ```
     * @since v0.5.1
     */
    function decode(string: string): string;
    /**
     * The `punycode.encode()` method converts a string of Unicode codepoints to a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only characters.
     *
     * ```js
     * punycode.encode('maana'); // 'maana-pta'
     * punycode.encode('-'); // '--dqo34k'
     * ```
     * @since v0.5.1
     */
    function encode(string: string): string;
    /**
     * The `punycode.toUnicode()` method converts a string representing a domain name
     * containing [Punycode](https://tools.ietf.org/html/rfc3492) encoded characters into Unicode. Only the [Punycode](https://tools.ietf.org/html/rfc3492) encoded parts of the domain name are be
     * converted.
     *
     * ```js
     * // decode domain names
     * punycode.toUnicode('xn--maana-pta.com'); // 'maana.com'
     * punycode.toUnicode('xn----dqo34k.com');  // '-.com'
     * punycode.toUnicode('example.com');       // 'example.com'
     * ```
     * @since v0.6.1
     */
    function toUnicode(domain: string): string;
    /**
     * The `punycode.toASCII()` method converts a Unicode string representing an
     * Internationalized Domain Name to [Punycode](https://tools.ietf.org/html/rfc3492). Only the non-ASCII parts of the
     * domain name will be converted. Calling `punycode.toASCII()` on a string that
     * already only contains ASCII characters will have no effect.
     *
     * ```js
     * // encode domain names
     * punycode.toASCII('maana.com');  // 'xn--maana-pta.com'
     * punycode.toASCII('-.com');   // 'xn----dqo34k.com'
     * punycode.toASCII('example.com'); // 'example.com'
     * ```
     * @since v0.6.1
     */
    function toASCII(domain: string): string;
    /**
     * @deprecated since v7.0.0
     * The version of the punycode module bundled in Node.js is being deprecated.
     * In a future major version of Node.js this module will be removed.
     * Users currently depending on the punycode module should switch to using
     * the userland-provided Punycode.js module instead.
     */
    const ucs2: ucs2;
    interface ucs2 {
        /**
         * @deprecated since v7.0.0
         * The version of the punycode module bundled in Node.js is being deprecated.
         * In a future major version of Node.js this module will be removed.
         * Users currently depending on the punycode module should switch to using
         * the userland-provided Punycode.js module instead.
         */
        decode(string: string): number[];
        /**
         * @deprecated since v7.0.0
         * The version of the punycode module bundled in Node.js is being deprecated.
         * In a future major version of Node.js this module will be removed.
         * Users currently depending on the punycode module should switch to using
         * the userland-provided Punycode.js module instead.
         */
        encode(codePoints: readonly number[]): string;
    }
    /**
     * @deprecated since v7.0.0
     * The version of the punycode module bundled in Node.js is being deprecated.
     * In a future major version of Node.js this module will be removed.
     * Users currently depending on the punycode module should switch to using
     * the userland-provided Punycode.js module instead.
     */
    const version: string;
}
declare module "node:punycode" {
    export * from "punycode";
}


---

File name: node_modules\@types\node\querystring.d.ts

Code:
/**
 * The `node:querystring` module provides utilities for parsing and formatting URL
 * query strings. It can be accessed using:
 *
 * ```js
 * import querystring from 'node:querystring';
 * ```
 *
 * `querystring` is more performant than `URLSearchParams` but is not a
 * standardized API. Use `URLSearchParams` when performance is not critical or
 * when compatibility with browser code is desirable.
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/querystring.js)
 */
declare module "querystring" {
    interface StringifyOptions {
        /**
         * The function to use when converting URL-unsafe characters to percent-encoding in the query string.
         * @default `querystring.escape()`
         */
        encodeURIComponent?: ((str: string) => string) | undefined;
    }
    interface ParseOptions {
        /**
         * Specifies the maximum number of keys to parse. Specify `0` to remove key counting limitations.
         * @default 1000
         */
        maxKeys?: number | undefined;
        /**
         * The function to use when decoding percent-encoded characters in the query string.
         * @default `querystring.unescape()`
         */
        decodeURIComponent?: ((str: string) => string) | undefined;
    }
    interface ParsedUrlQuery extends NodeJS.Dict<string | string[]> {}
    interface ParsedUrlQueryInput extends
        NodeJS.Dict<
            | string
            | number
            | boolean
            | bigint
            | ReadonlyArray<string | number | boolean | bigint>
            | null
        >
    {}
    /**
     * The `querystring.stringify()` method produces a URL query string from a
     * given `obj` by iterating through the object's "own properties".
     *
     * It serializes the following types of values passed in `obj`: [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |
     * [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |
     * [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) |
     * [string\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |
     * [number\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |
     * [bigint\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |
     * [boolean\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) The numeric values must be finite. Any other input values will be coerced to
     * empty strings.
     *
     * ```js
     * querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
     * // Returns 'foo=bar&#x26;baz=qux&#x26;baz=quux&#x26;corge='
     *
     * querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');
     * // Returns 'foo:bar;baz:qux'
     * ```
     *
     * By default, characters requiring percent-encoding within the query string will
     * be encoded as UTF-8\. If an alternative encoding is required, then an alternative `encodeURIComponent` option will need to be specified:
     *
     * ```js
     * // Assuming gbkEncodeURIComponent function already exists,
     *
     * querystring.stringify({ w: '', foo: 'bar' }, null, null,
     *                       { encodeURIComponent: gbkEncodeURIComponent });
     * ```
     * @since v0.1.25
     * @param obj The object to serialize into a URL query string
     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.
     * @param [eq='='] . The substring used to delimit keys and values in the query string.
     */
    function stringify(obj?: ParsedUrlQueryInput, sep?: string, eq?: string, options?: StringifyOptions): string;
    /**
     * The `querystring.parse()` method parses a URL query string (`str`) into a
     * collection of key and value pairs.
     *
     * For example, the query string `'foo=bar&#x26;abc=xyz&#x26;abc=123'` is parsed into:
     *
     * ```json
     * {
     *   "foo": "bar",
     *   "abc": ["xyz", "123"]
     * }
     * ```
     *
     * The object returned by the `querystring.parse()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
     * `obj.hasOwnProperty()`, and others
     * are not defined and _will not work_.
     *
     * By default, percent-encoded characters within the query string will be assumed
     * to use UTF-8 encoding. If an alternative character encoding is used, then an
     * alternative `decodeURIComponent` option will need to be specified:
     *
     * ```js
     * // Assuming gbkDecodeURIComponent function already exists...
     *
     * querystring.parse('w=%D6%D0%CE%C4&#x26;foo=bar', null, null,
     *                   { decodeURIComponent: gbkDecodeURIComponent });
     * ```
     * @since v0.1.25
     * @param str The URL query string to parse
     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.
     * @param [eq='='] The substring used to delimit keys and values in the query string.
     */
    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;
    /**
     * The querystring.encode() function is an alias for querystring.stringify().
     */
    const encode: typeof stringify;
    /**
     * The querystring.decode() function is an alias for querystring.parse().
     */
    const decode: typeof parse;
    /**
     * The `querystring.escape()` method performs URL percent-encoding on the given `str` in a manner that is optimized for the specific requirements of URL
     * query strings.
     *
     * The `querystring.escape()` method is used by `querystring.stringify()` and is
     * generally not expected to be used directly. It is exported primarily to allow
     * application code to provide a replacement percent-encoding implementation if
     * necessary by assigning `querystring.escape` to an alternative function.
     * @since v0.1.25
     */
    function escape(str: string): string;
    /**
     * The `querystring.unescape()` method performs decoding of URL percent-encoded
     * characters on the given `str`.
     *
     * The `querystring.unescape()` method is used by `querystring.parse()` and is
     * generally not expected to be used directly. It is exported primarily to allow
     * application code to provide a replacement decoding implementation if
     * necessary by assigning `querystring.unescape` to an alternative function.
     *
     * By default, the `querystring.unescape()` method will attempt to use the
     * JavaScript built-in `decodeURIComponent()` method to decode. If that fails,
     * a safer equivalent that does not throw on malformed URLs will be used.
     * @since v0.1.25
     */
    function unescape(str: string): string;
}
declare module "node:querystring" {
    export * from "querystring";
}


---

File name: node_modules\@types\node\readline\promises.d.ts

Code:
/**
 * @since v17.0.0
 */
declare module "readline/promises" {
    import { Abortable } from "node:events";
    import {
        CompleterResult,
        Direction,
        Interface as _Interface,
        ReadLineOptions as _ReadLineOptions,
    } from "node:readline";
    /**
     * Instances of the `readlinePromises.Interface` class are constructed using the `readlinePromises.createInterface()` method. Every instance is associated with a
     * single `input` `Readable` stream and a single `output` `Writable` stream.
     * The `output` stream is used to print prompts for user input that arrives on,
     * and is read from, the `input` stream.
     * @since v17.0.0
     */
    class Interface extends _Interface {
        /**
         * The `rl.question()` method displays the `query` by writing it to the `output`,
         * waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.
         *
         * When called, `rl.question()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.
         *
         * If the question is called after `rl.close()`, it returns a rejected promise.
         *
         * Example usage:
         *
         * ```js
         * const answer = await rl.question('What is your favorite food? ');
         * console.log(`Oh, so your favorite food is ${answer}`);
         * ```
         *
         * Using an `AbortSignal` to cancel a question.
         *
         * ```js
         * const signal = AbortSignal.timeout(10_000);
         *
         * signal.addEventListener('abort', () => {
         *   console.log('The food question timed out');
         * }, { once: true });
         *
         * const answer = await rl.question('What is your favorite food? ', { signal });
         * console.log(`Oh, so your favorite food is ${answer}`);
         * ```
         * @since v17.0.0
         * @param query A statement or query to write to `output`, prepended to the prompt.
         * @return A promise that is fulfilled with the user's input in response to the `query`.
         */
        question(query: string): Promise<string>;
        question(query: string, options: Abortable): Promise<string>;
    }
    /**
     * @since v17.0.0
     */
    class Readline {
        /**
         * @param stream A TTY stream.
         */
        constructor(
            stream: NodeJS.WritableStream,
            options?: {
                autoCommit?: boolean;
            },
        );
        /**
         * The `rl.clearLine()` method adds to the internal list of pending action an
         * action that clears current line of the associated `stream` in a specified
         * direction identified by `dir`.
         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.
         * @since v17.0.0
         * @return this
         */
        clearLine(dir: Direction): this;
        /**
         * The `rl.clearScreenDown()` method adds to the internal list of pending action an
         * action that clears the associated stream from the current position of the
         * cursor down.
         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.
         * @since v17.0.0
         * @return this
         */
        clearScreenDown(): this;
        /**
         * The `rl.commit()` method sends all the pending actions to the associated `stream` and clears the internal list of pending actions.
         * @since v17.0.0
         */
        commit(): Promise<void>;
        /**
         * The `rl.cursorTo()` method adds to the internal list of pending action an action
         * that moves cursor to the specified position in the associated `stream`.
         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.
         * @since v17.0.0
         * @return this
         */
        cursorTo(x: number, y?: number): this;
        /**
         * The `rl.moveCursor()` method adds to the internal list of pending action an
         * action that moves the cursor _relative_ to its current position in the
         * associated `stream`.
         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.
         * @since v17.0.0
         * @return this
         */
        moveCursor(dx: number, dy: number): this;
        /**
         * The `rl.rollback` methods clears the internal list of pending actions without
         * sending it to the associated `stream`.
         * @since v17.0.0
         * @return this
         */
        rollback(): this;
    }
    type Completer = (line: string) => CompleterResult | Promise<CompleterResult>;
    interface ReadLineOptions extends Omit<_ReadLineOptions, "completer"> {
        /**
         * An optional function used for Tab autocompletion.
         */
        completer?: Completer | undefined;
    }
    /**
     * The `readlinePromises.createInterface()` method creates a new `readlinePromises.Interface` instance.
     *
     * ```js
     * import readlinePromises from 'node:readline/promises';
     * const rl = readlinePromises.createInterface({
     *   input: process.stdin,
     *   output: process.stdout,
     * });
     * ```
     *
     * Once the `readlinePromises.Interface` instance is created, the most common case
     * is to listen for the `'line'` event:
     *
     * ```js
     * rl.on('line', (line) => {
     *   console.log(`Received: ${line}`);
     * });
     * ```
     *
     * If `terminal` is `true` for this instance then the `output` stream will get
     * the best compatibility if it defines an `output.columns` property and emits
     * a `'resize'` event on the `output` if or when the columns ever change
     * (`process.stdout` does this automatically when it is a TTY).
     * @since v17.0.0
     */
    function createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer,
        terminal?: boolean,
    ): Interface;
    function createInterface(options: ReadLineOptions): Interface;
}
declare module "node:readline/promises" {
    export * from "readline/promises";
}


---

File name: node_modules\@types\node\readline.d.ts

Code:
/**
 * The `node:readline` module provides an interface for reading data from a [Readable](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream
 * (such as [`process.stdin`](https://nodejs.org/docs/latest-v24.x/api/process.html#processstdin)) one line at a time.
 *
 * To use the promise-based APIs:
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * ```
 *
 * To use the callback and sync APIs:
 *
 * ```js
 * import * as readline from 'node:readline';
 * ```
 *
 * The following simple example illustrates the basic use of the `node:readline` module.
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * import { stdin as input, stdout as output } from 'node:process';
 *
 * const rl = readline.createInterface({ input, output });
 *
 * const answer = await rl.question('What do you think of Node.js? ');
 *
 * console.log(`Thank you for your valuable feedback: ${answer}`);
 *
 * rl.close();
 * ```
 *
 * Once this code is invoked, the Node.js application will not terminate until the `readline.Interface` is closed because the interface waits for data to be
 * received on the `input` stream.
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/readline.js)
 */
declare module "readline" {
    import { Abortable, EventEmitter } from "node:events";
    import * as promises from "node:readline/promises";
    export { promises };
    export interface Key {
        sequence?: string | undefined;
        name?: string | undefined;
        ctrl?: boolean | undefined;
        meta?: boolean | undefined;
        shift?: boolean | undefined;
    }
    /**
     * Instances of the `readline.Interface` class are constructed using the `readline.createInterface()` method. Every instance is associated with a
     * single `input` [Readable](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream and a single `output` [Writable](https://nodejs.org/docs/latest-v24.x/api/stream.html#writable-streams) stream.
     * The `output` stream is used to print prompts for user input that arrives on,
     * and is read from, the `input` stream.
     * @since v0.1.104
     */
    export class Interface extends EventEmitter implements Disposable {
        readonly terminal: boolean;
        /**
         * The current input data being processed by node.
         *
         * This can be used when collecting input from a TTY stream to retrieve the
         * current value that has been processed thus far, prior to the `line` event
         * being emitted. Once the `line` event has been emitted, this property will
         * be an empty string.
         *
         * Be aware that modifying the value during the instance runtime may have
         * unintended consequences if `rl.cursor` is not also controlled.
         *
         * **If not using a TTY stream for input, use the `'line'` event.**
         *
         * One possible use case would be as follows:
         *
         * ```js
         * const values = ['lorem ipsum', 'dolor sit amet'];
         * const rl = readline.createInterface(process.stdin);
         * const showResults = debounce(() => {
         *   console.log(
         *     '\n',
         *     values.filter((val) => val.startsWith(rl.line)).join(' '),
         *   );
         * }, 300);
         * process.stdin.on('keypress', (c, k) => {
         *   showResults();
         * });
         * ```
         * @since v0.1.98
         */
        readonly line: string;
        /**
         * The cursor position relative to `rl.line`.
         *
         * This will track where the current cursor lands in the input string, when
         * reading input from a TTY stream. The position of cursor determines the
         * portion of the input string that will be modified as input is processed,
         * as well as the column where the terminal caret will be rendered.
         * @since v0.1.98
         */
        readonly cursor: number;
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/readline.html#class-interfaceconstructor
         */
        protected constructor(
            input: NodeJS.ReadableStream,
            output?: NodeJS.WritableStream,
            completer?: Completer | AsyncCompleter,
            terminal?: boolean,
        );
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/readline.html#class-interfaceconstructor
         */
        protected constructor(options: ReadLineOptions);
        /**
         * The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`.
         * @since v15.3.0, v14.17.0
         * @return the current prompt string
         */
        getPrompt(): string;
        /**
         * The `rl.setPrompt()` method sets the prompt that will be written to `output` whenever `rl.prompt()` is called.
         * @since v0.1.98
         */
        setPrompt(prompt: string): void;
        /**
         * The `rl.prompt()` method writes the `Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new
         * location at which to provide input.
         *
         * When called, `rl.prompt()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the prompt is not written.
         * @since v0.1.98
         * @param preserveCursor If `true`, prevents the cursor placement from being reset to `0`.
         */
        prompt(preserveCursor?: boolean): void;
        /**
         * The `rl.question()` method displays the `query` by writing it to the `output`,
         * waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.
         *
         * When called, `rl.question()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.
         *
         * The `callback` function passed to `rl.question()` does not follow the typical
         * pattern of accepting an `Error` object or `null` as the first argument.
         * The `callback` is called with the provided answer as the only argument.
         *
         * An error will be thrown if calling `rl.question()` after `rl.close()`.
         *
         * Example usage:
         *
         * ```js
         * rl.question('What is your favorite food? ', (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         * ```
         *
         * Using an `AbortController` to cancel a question.
         *
         * ```js
         * const ac = new AbortController();
         * const signal = ac.signal;
         *
         * rl.question('What is your favorite food? ', { signal }, (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         *
         * signal.addEventListener('abort', () => {
         *   console.log('The food question timed out');
         * }, { once: true });
         *
         * setTimeout(() => ac.abort(), 10000);
         * ```
         * @since v0.3.3
         * @param query A statement or query to write to `output`, prepended to the prompt.
         * @param callback A callback function that is invoked with the user's input in response to the `query`.
         */
        question(query: string, callback: (answer: string) => void): void;
        question(query: string, options: Abortable, callback: (answer: string) => void): void;
        /**
         * The `rl.pause()` method pauses the `input` stream, allowing it to be resumed
         * later if necessary.
         *
         * Calling `rl.pause()` does not immediately pause other events (including `'line'`) from being emitted by the `Interface` instance.
         * @since v0.3.4
         */
        pause(): this;
        /**
         * The `rl.resume()` method resumes the `input` stream if it has been paused.
         * @since v0.3.4
         */
        resume(): this;
        /**
         * The `rl.close()` method closes the `Interface` instance and
         * relinquishes control over the `input` and `output` streams. When called,
         * the `'close'` event will be emitted.
         *
         * Calling `rl.close()` does not immediately stop other events (including `'line'`)
         * from being emitted by the `Interface` instance.
         * @since v0.1.98
         */
        close(): void;
        /**
         * Alias for `rl.close()`.
         * @since v22.15.0
         */
        [Symbol.dispose](): void;
        /**
         * The `rl.write()` method will write either `data` or a key sequence identified
         * by `key` to the `output`. The `key` argument is supported only if `output` is
         * a `TTY` text terminal. See `TTY keybindings` for a list of key
         * combinations.
         *
         * If `key` is specified, `data` is ignored.
         *
         * When called, `rl.write()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the `data` and `key` are not written.
         *
         * ```js
         * rl.write('Delete this!');
         * // Simulate Ctrl+U to delete the line written previously
         * rl.write(null, { ctrl: true, name: 'u' });
         * ```
         *
         * The `rl.write()` method will write the data to the `readline` `Interface`'s `input` _as if it were provided by the user_.
         * @since v0.1.98
         */
        write(data: string | Buffer, key?: Key): void;
        write(data: undefined | null | string | Buffer, key: Key): void;
        /**
         * Returns the real position of the cursor in relation to the input
         * prompt + string. Long input (wrapping) strings, as well as multiple
         * line prompts are included in the calculations.
         * @since v13.5.0, v12.16.0
         */
        getCursorPos(): CursorPos;
        /**
         * events.EventEmitter
         * 1. close
         * 2. line
         * 3. pause
         * 4. resume
         * 5. SIGCONT
         * 6. SIGINT
         * 7. SIGTSTP
         * 8. history
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "history", listener: (history: string[]) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "history", history: string[]): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "history", listener: (history: string[]) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "history", listener: (history: string[]) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "history", listener: (history: string[]) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "history", listener: (history: string[]) => void): this;
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<string>;
    }
    export type ReadLine = Interface; // type forwarded for backwards compatibility
    export type Completer = (line: string) => CompleterResult;
    export type AsyncCompleter = (
        line: string,
        callback: (err?: null | Error, result?: CompleterResult) => void,
    ) => void;
    export type CompleterResult = [string[], string];
    export interface ReadLineOptions {
        /**
         * The [`Readable`](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream to listen to
         */
        input: NodeJS.ReadableStream;
        /**
         * The [`Writable`](https://nodejs.org/docs/latest-v24.x/api/stream.html#writable-streams) stream to write readline data to.
         */
        output?: NodeJS.WritableStream | undefined;
        /**
         * An optional function used for Tab autocompletion.
         */
        completer?: Completer | AsyncCompleter | undefined;
        /**
         * `true` if the `input` and `output` streams should be treated like a TTY,
         * and have ANSI/VT100 escape codes written to it.
         * Default: checking `isTTY` on the `output` stream upon instantiation.
         */
        terminal?: boolean | undefined;
        /**
         * Initial list of history lines.
         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
         * otherwise the history caching mechanism is not initialized at all.
         * @default []
         */
        history?: string[] | undefined;
        /**
         * Maximum number of history lines retained.
         * To disable the history set this value to `0`.
         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
         * otherwise the history caching mechanism is not initialized at all.
         * @default 30
         */
        historySize?: number | undefined;
        /**
         * If `true`, when a new input line added to the history list duplicates an older one,
         * this removes the older line from the list.
         * @default false
         */
        removeHistoryDuplicates?: boolean | undefined;
        /**
         * The prompt string to use.
         * @default "> "
         */
        prompt?: string | undefined;
        /**
         * If the delay between `\r` and `\n` exceeds `crlfDelay` milliseconds,
         * both `\r` and `\n` will be treated as separate end-of-line input.
         * `crlfDelay` will be coerced to a number no less than `100`.
         * It can be set to `Infinity`, in which case
         * `\r` followed by `\n` will always be considered a single newline
         * (which may be reasonable for [reading files](https://nodejs.org/docs/latest-v24.x/api/readline.html#example-read-file-stream-line-by-line) with `\r\n` line delimiter).
         * @default 100
         */
        crlfDelay?: number | undefined;
        /**
         * The duration `readline` will wait for a character
         * (when reading an ambiguous key sequence in milliseconds
         * one that can both form a complete key sequence using the input read so far
         * and can take additional input to complete a longer key sequence).
         * @default 500
         */
        escapeCodeTimeout?: number | undefined;
        /**
         * The number of spaces a tab is equal to (minimum 1).
         * @default 8
         */
        tabSize?: number | undefined;
        /**
         * Allows closing the interface using an AbortSignal.
         * Aborting the signal will internally call `close` on the interface.
         */
        signal?: AbortSignal | undefined;
    }
    /**
     * The `readline.createInterface()` method creates a new `readline.Interface` instance.
     *
     * ```js
     * import readline from 'node:readline';
     * const rl = readline.createInterface({
     *   input: process.stdin,
     *   output: process.stdout,
     * });
     * ```
     *
     * Once the `readline.Interface` instance is created, the most common case is to
     * listen for the `'line'` event:
     *
     * ```js
     * rl.on('line', (line) => {
     *   console.log(`Received: ${line}`);
     * });
     * ```
     *
     * If `terminal` is `true` for this instance then the `output` stream will get
     * the best compatibility if it defines an `output.columns` property and emits
     * a `'resize'` event on the `output` if or when the columns ever change
     * (`process.stdout` does this automatically when it is a TTY).
     *
     * When creating a `readline.Interface` using `stdin` as input, the program
     * will not terminate until it receives an [EOF character](https://en.wikipedia.org/wiki/End-of-file#EOF_character). To exit without
     * waiting for user input, call `process.stdin.unref()`.
     * @since v0.1.98
     */
    export function createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer | AsyncCompleter,
        terminal?: boolean,
    ): Interface;
    export function createInterface(options: ReadLineOptions): Interface;
    /**
     * The `readline.emitKeypressEvents()` method causes the given `Readable` stream to begin emitting `'keypress'` events corresponding to received input.
     *
     * Optionally, `interface` specifies a `readline.Interface` instance for which
     * autocompletion is disabled when copy-pasted input is detected.
     *
     * If the `stream` is a `TTY`, then it must be in raw mode.
     *
     * This is automatically called by any readline instance on its `input` if the `input` is a terminal. Closing the `readline` instance does not stop
     * the `input` from emitting `'keypress'` events.
     *
     * ```js
     * readline.emitKeypressEvents(process.stdin);
     * if (process.stdin.isTTY)
     *   process.stdin.setRawMode(true);
     * ```
     *
     * ## Example: Tiny CLI
     *
     * The following example illustrates the use of `readline.Interface` class to
     * implement a small command-line interface:
     *
     * ```js
     * import readline from 'node:readline';
     * const rl = readline.createInterface({
     *   input: process.stdin,
     *   output: process.stdout,
     *   prompt: 'OHAI> ',
     * });
     *
     * rl.prompt();
     *
     * rl.on('line', (line) => {
     *   switch (line.trim()) {
     *     case 'hello':
     *       console.log('world!');
     *       break;
     *     default:
     *       console.log(`Say what? I might have heard '${line.trim()}'`);
     *       break;
     *   }
     *   rl.prompt();
     * }).on('close', () => {
     *   console.log('Have a great day!');
     *   process.exit(0);
     * });
     * ```
     *
     * ## Example: Read file stream line-by-Line
     *
     * A common use case for `readline` is to consume an input file one line at a
     * time. The easiest way to do so is leveraging the `fs.ReadStream` API as
     * well as a `for await...of` loop:
     *
     * ```js
     * import fs from 'node:fs';
     * import readline from 'node:readline';
     *
     * async function processLineByLine() {
     *   const fileStream = fs.createReadStream('input.txt');
     *
     *   const rl = readline.createInterface({
     *     input: fileStream,
     *     crlfDelay: Infinity,
     *   });
     *   // Note: we use the crlfDelay option to recognize all instances of CR LF
     *   // ('\r\n') in input.txt as a single line break.
     *
     *   for await (const line of rl) {
     *     // Each line in input.txt will be successively available here as `line`.
     *     console.log(`Line from file: ${line}`);
     *   }
     * }
     *
     * processLineByLine();
     * ```
     *
     * Alternatively, one could use the `'line'` event:
     *
     * ```js
     * import fs from 'node:fs';
     * import readline from 'node:readline';
     *
     * const rl = readline.createInterface({
     *   input: fs.createReadStream('sample.txt'),
     *   crlfDelay: Infinity,
     * });
     *
     * rl.on('line', (line) => {
     *   console.log(`Line from file: ${line}`);
     * });
     * ```
     *
     * Currently, `for await...of` loop can be a bit slower. If `async` / `await` flow and speed are both essential, a mixed approach can be applied:
     *
     * ```js
     * import { once } from 'node:events';
     * import { createReadStream } from 'node:fs';
     * import { createInterface } from 'node:readline';
     *
     * (async function processLineByLine() {
     *   try {
     *     const rl = createInterface({
     *       input: createReadStream('big-file.txt'),
     *       crlfDelay: Infinity,
     *     });
     *
     *     rl.on('line', (line) => {
     *       // Process the line.
     *     });
     *
     *     await once(rl, 'close');
     *
     *     console.log('File processed.');
     *   } catch (err) {
     *     console.error(err);
     *   }
     * })();
     * ```
     * @since v0.7.7
     */
    export function emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;
    export type Direction = -1 | 0 | 1;
    export interface CursorPos {
        rows: number;
        cols: number;
    }
    /**
     * The `readline.clearLine()` method clears current line of given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) stream
     * in a specified direction identified by `dir`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;
    /**
     * The `readline.clearScreenDown()` method clears the given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) stream from
     * the current position of the cursor down.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;
    /**
     * The `readline.cursorTo()` method moves cursor to the specified position in a
     * given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) `stream`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;
    /**
     * The `readline.moveCursor()` method moves the cursor _relative_ to its current
     * position in a given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) `stream`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;
}
declare module "node:readline" {
    export * from "readline";
}


---

File name: node_modules\@types\node\README.md

Code:
# Installation
> `npm install --save @types/node`

# Summary
This package contains type definitions for node (https://nodejs.org/).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node.

### Additional Details
 * Last updated: Mon, 30 Jun 2025 21:02:16 GMT
 * Dependencies: [undici-types](https://npmjs.com/package/undici-types)

# Credits
These definitions were written by [Microsoft TypeScript](https://github.com/Microsoft), [Alberto Schiabel](https://github.com/jkomyno), [Alvis HT Tang](https://github.com/alvis), [Andrew Makarov](https://github.com/r3nya), [Benjamin Toueg](https://github.com/btoueg), [Chigozirim C.](https://github.com/smac89), [David Junger](https://github.com/touffy), [Deividas Bakanas](https://github.com/DeividasBakanas), [Eugene Y. Q. Shen](https://github.com/eyqs), [Hannes Magnusson](https://github.com/Hannes-Magnusson-CK), [Huw](https://github.com/hoo29), [Kelvin Jin](https://github.com/kjin), [Klaus Meinhardt](https://github.com/ajafff), [Lishude](https://github.com/islishude), [Mariusz Wiktorczyk](https://github.com/mwiktorczyk), [Mohsen Azimi](https://github.com/mohsen1), [Nikita Galkin](https://github.com/galkin), [Parambir Singh](https://github.com/parambirs), [Sebastian Silbermann](https://github.com/eps1lon), [Thomas den Hollander](https://github.com/ThomasdenH), [Wilco Bakker](https://github.com/WilcoBakker), [wwwy3y3](https://github.com/wwwy3y3), [Samuel Ainsworth](https://github.com/samuela), [Kyle Uehlein](https://github.com/kuehlein), [Thanik Bhongbhibhat](https://github.com/bhongy), [Marcin Kopacz](https://github.com/chyzwar), [Trivikram Kamat](https://github.com/trivikr), [Junxiao Shi](https://github.com/yoursunny), [Ilia Baryshnikov](https://github.com/qwelias), [ExE Boss](https://github.com/ExE-Boss), [Piotr Baejewicz](https://github.com/peterblazejewicz), [Anna Henningsen](https://github.com/addaleax), [Victor Perin](https://github.com/victorperin), [NodeJS Contributors](https://github.com/NodeJS), [Linus Unnebck](https://github.com/LinusU), [wafuwafu13](https://github.com/wafuwafu13), [Matteo Collina](https://github.com/mcollina), [Dmitry Semigradsky](https://github.com/Semigradsky), [Ren](https://github.com/Renegade334), and [Yagiz Nizipli](https://github.com/anonrig).


---

File name: node_modules\@types\node\repl.d.ts

Code:
/**
 * The `node:repl` module provides a Read-Eval-Print-Loop (REPL) implementation
 * that is available both as a standalone program or includible in other
 * applications. It can be accessed using:
 *
 * ```js
 * import repl from 'node:repl';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/repl.js)
 */
declare module "repl" {
    import { AsyncCompleter, Completer, Interface } from "node:readline";
    import { Context } from "node:vm";
    import { InspectOptions } from "node:util";
    interface ReplOptions {
        /**
         * The input prompt to display.
         * @default "> "
         */
        prompt?: string | undefined;
        /**
         * The `Readable` stream from which REPL input will be read.
         * @default process.stdin
         */
        input?: NodeJS.ReadableStream | undefined;
        /**
         * The `Writable` stream to which REPL output will be written.
         * @default process.stdout
         */
        output?: NodeJS.WritableStream | undefined;
        /**
         * If `true`, specifies that the output should be treated as a TTY terminal, and have
         * ANSI/VT100 escape codes written to it.
         * Default: checking the value of the `isTTY` property on the output stream upon
         * instantiation.
         */
        terminal?: boolean | undefined;
        /**
         * The function to be used when evaluating each given line of input.
         * **Default:** an async wrapper for the JavaScript `eval()` function. An `eval` function can
         * error with `repl.Recoverable` to indicate the input was incomplete and prompt for
         * additional lines. See the [custom evaluation functions](https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#custom-evaluation-functions)
         * section for more details.
         */
        eval?: REPLEval | undefined;
        /**
         * Defines if the repl prints output previews or not.
         * @default `true` Always `false` in case `terminal` is falsy.
         */
        preview?: boolean | undefined;
        /**
         * If `true`, specifies that the default `writer` function should include ANSI color
         * styling to REPL output. If a custom `writer` function is provided then this has no
         * effect.
         * @default the REPL instance's `terminal` value
         */
        useColors?: boolean | undefined;
        /**
         * If `true`, specifies that the default evaluation function will use the JavaScript
         * `global` as the context as opposed to creating a new separate context for the REPL
         * instance. The node CLI REPL sets this value to `true`.
         * @default false
         */
        useGlobal?: boolean | undefined;
        /**
         * If `true`, specifies that the default writer will not output the return value of a
         * command if it evaluates to `undefined`.
         * @default false
         */
        ignoreUndefined?: boolean | undefined;
        /**
         * The function to invoke to format the output of each command before writing to `output`.
         * @default a wrapper for `util.inspect`
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_customizing_repl_output
         */
        writer?: REPLWriter | undefined;
        /**
         * An optional function used for custom Tab auto completion.
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/readline.html#readline_use_of_the_completer_function
         */
        completer?: Completer | AsyncCompleter | undefined;
        /**
         * A flag that specifies whether the default evaluator executes all JavaScript commands in
         * strict mode or default (sloppy) mode.
         * Accepted values are:
         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
         *   prefacing every repl statement with `'use strict'`.
         */
        replMode?: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT | undefined;
        /**
         * Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is
         * pressed. This cannot be used together with a custom `eval` function.
         * @default false
         */
        breakEvalOnSigint?: boolean | undefined;
    }
    type REPLEval = (
        this: REPLServer,
        evalCmd: string,
        context: Context,
        file: string,
        cb: (err: Error | null, result: any) => void,
    ) => void;
    type REPLWriter = (this: REPLServer, obj: any) => string;
    /**
     * This is the default "writer" value, if none is passed in the REPL options,
     * and it can be overridden by custom print functions.
     */
    const writer: REPLWriter & {
        options: InspectOptions;
    };
    type REPLCommandAction = (this: REPLServer, text: string) => void;
    interface REPLCommand {
        /**
         * Help text to be displayed when `.help` is entered.
         */
        help?: string | undefined;
        /**
         * The function to execute, optionally accepting a single string argument.
         */
        action: REPLCommandAction;
    }
    /**
     * Instances of `repl.REPLServer` are created using the {@link start} method
     * or directly using the JavaScript `new` keyword.
     *
     * ```js
     * import repl from 'node:repl';
     *
     * const options = { useColors: true };
     *
     * const firstInstance = repl.start(options);
     * const secondInstance = new repl.REPLServer(options);
     * ```
     * @since v0.1.91
     */
    class REPLServer extends Interface {
        /**
         * The `vm.Context` provided to the `eval` function to be used for JavaScript
         * evaluation.
         */
        readonly context: Context;
        /**
         * @deprecated since v14.3.0 - Use `input` instead.
         */
        readonly inputStream: NodeJS.ReadableStream;
        /**
         * @deprecated since v14.3.0 - Use `output` instead.
         */
        readonly outputStream: NodeJS.WritableStream;
        /**
         * The `Readable` stream from which REPL input will be read.
         */
        readonly input: NodeJS.ReadableStream;
        /**
         * The `Writable` stream to which REPL output will be written.
         */
        readonly output: NodeJS.WritableStream;
        /**
         * The commands registered via `replServer.defineCommand()`.
         */
        readonly commands: NodeJS.ReadOnlyDict<REPLCommand>;
        /**
         * A value indicating whether the REPL is currently in "editor mode".
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_commands_and_special_keys
         */
        readonly editorMode: boolean;
        /**
         * A value indicating whether the `_` variable has been assigned.
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly underscoreAssigned: boolean;
        /**
         * The last evaluation result from the REPL (assigned to the `_` variable inside of the REPL).
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly last: any;
        /**
         * A value indicating whether the `_error` variable has been assigned.
         *
         * @since v9.8.0
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly underscoreErrAssigned: boolean;
        /**
         * The last error raised inside the REPL (assigned to the `_error` variable inside of the REPL).
         *
         * @since v9.8.0
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly lastError: any;
        /**
         * Specified in the REPL options, this is the function to be used when evaluating each
         * given line of input. If not specified in the REPL options, this is an async wrapper
         * for the JavaScript `eval()` function.
         */
        readonly eval: REPLEval;
        /**
         * Specified in the REPL options, this is a value indicating whether the default
         * `writer` function should include ANSI color styling to REPL output.
         */
        readonly useColors: boolean;
        /**
         * Specified in the REPL options, this is a value indicating whether the default `eval`
         * function will use the JavaScript `global` as the context as opposed to creating a new
         * separate context for the REPL instance.
         */
        readonly useGlobal: boolean;
        /**
         * Specified in the REPL options, this is a value indicating whether the default `writer`
         * function should output the result of a command if it evaluates to `undefined`.
         */
        readonly ignoreUndefined: boolean;
        /**
         * Specified in the REPL options, this is the function to invoke to format the output of
         * each command before writing to `outputStream`. If not specified in the REPL options,
         * this will be a wrapper for `util.inspect`.
         */
        readonly writer: REPLWriter;
        /**
         * Specified in the REPL options, this is the function to use for custom Tab auto-completion.
         */
        readonly completer: Completer | AsyncCompleter;
        /**
         * Specified in the REPL options, this is a flag that specifies whether the default `eval`
         * function should execute all JavaScript commands in strict mode or default (sloppy) mode.
         * Possible values are:
         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
         *    prefacing every repl statement with `'use strict'`.
         */
        readonly replMode: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of `repl.REPLServer` are created using the `repl.start()` method and
         * > _should not_ be created directly using the JavaScript `new` keyword.
         *
         * `REPLServer` cannot be subclassed due to implementation specifics in NodeJS.
         *
         * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_class_replserver
         */
        private constructor();
        /**
         * The `replServer.defineCommand()` method is used to add new `.`\-prefixed commands
         * to the REPL instance. Such commands are invoked by typing a `.` followed by the `keyword`. The `cmd` is either a `Function` or an `Object` with the following
         * properties:
         *
         * The following example shows two new commands added to the REPL instance:
         *
         * ```js
         * import repl from 'node:repl';
         *
         * const replServer = repl.start({ prompt: '> ' });
         * replServer.defineCommand('sayhello', {
         *   help: 'Say hello',
         *   action(name) {
         *     this.clearBufferedCommand();
         *     console.log(`Hello, ${name}!`);
         *     this.displayPrompt();
         *   },
         * });
         * replServer.defineCommand('saybye', function saybye() {
         *   console.log('Goodbye!');
         *   this.close();
         * });
         * ```
         *
         * The new commands can then be used from within the REPL instance:
         *
         * ```console
         * > .sayhello Node.js User
         * Hello, Node.js User!
         * > .saybye
         * Goodbye!
         * ```
         * @since v0.3.0
         * @param keyword The command keyword (_without_ a leading `.` character).
         * @param cmd The function to invoke when the command is processed.
         */
        defineCommand(keyword: string, cmd: REPLCommandAction | REPLCommand): void;
        /**
         * The `replServer.displayPrompt()` method readies the REPL instance for input
         * from the user, printing the configured `prompt` to a new line in the `output` and resuming the `input` to accept new input.
         *
         * When multi-line input is being entered, a pipe `'|'` is printed rather than the
         * 'prompt'.
         *
         * When `preserveCursor` is `true`, the cursor placement will not be reset to `0`.
         *
         * The `replServer.displayPrompt` method is primarily intended to be called from
         * within the action function for commands registered using the `replServer.defineCommand()` method.
         * @since v0.1.91
         */
        displayPrompt(preserveCursor?: boolean): void;
        /**
         * The `replServer.clearBufferedCommand()` method clears any command that has been
         * buffered but not yet executed. This method is primarily intended to be
         * called from within the action function for commands registered using the `replServer.defineCommand()` method.
         * @since v9.0.0
         */
        clearBufferedCommand(): void;
        /**
         * Initializes a history log file for the REPL instance. When executing the
         * Node.js binary and using the command-line REPL, a history file is initialized
         * by default. However, this is not the case when creating a REPL
         * programmatically. Use this method to initialize a history log file when working
         * with REPL instances programmatically.
         * @since v11.10.0
         * @param historyPath the path to the history file
         * @param callback called when history writes are ready or upon error
         */
        setupHistory(path: string, callback: (err: Error | null, repl: this) => void): void;
        /**
         * events.EventEmitter
         * 1. close - inherited from `readline.Interface`
         * 2. line - inherited from `readline.Interface`
         * 3. pause - inherited from `readline.Interface`
         * 4. resume - inherited from `readline.Interface`
         * 5. SIGCONT - inherited from `readline.Interface`
         * 6. SIGINT - inherited from `readline.Interface`
         * 7. SIGTSTP - inherited from `readline.Interface`
         * 8. exit
         * 9. reset
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "exit", listener: () => void): this;
        addListener(event: "reset", listener: (context: Context) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "exit"): boolean;
        emit(event: "reset", context: Context): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "exit", listener: () => void): this;
        on(event: "reset", listener: (context: Context) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "exit", listener: () => void): this;
        once(event: "reset", listener: (context: Context) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "exit", listener: () => void): this;
        prependListener(event: "reset", listener: (context: Context) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "exit", listener: () => void): this;
        prependOnceListener(event: "reset", listener: (context: Context) => void): this;
    }
    /**
     * A flag passed in the REPL options. Evaluates expressions in sloppy mode.
     */
    const REPL_MODE_SLOPPY: unique symbol;
    /**
     * A flag passed in the REPL options. Evaluates expressions in strict mode.
     * This is equivalent to prefacing every repl statement with `'use strict'`.
     */
    const REPL_MODE_STRICT: unique symbol;
    /**
     * The `repl.start()` method creates and starts a {@link REPLServer} instance.
     *
     * If `options` is a string, then it specifies the input prompt:
     *
     * ```js
     * import repl from 'node:repl';
     *
     * // a Unix style prompt
     * repl.start('$ ');
     * ```
     * @since v0.1.91
     */
    function start(options?: string | ReplOptions): REPLServer;
    /**
     * Indicates a recoverable error that a `REPLServer` can use to support multi-line input.
     *
     * @see https://nodejs.org/dist/latest-v24.x/docs/api/repl.html#repl_recoverable_errors
     */
    class Recoverable extends SyntaxError {
        err: Error;
        constructor(err: Error);
    }
}
declare module "node:repl" {
    export * from "repl";
}


---

File name: node_modules\@types\node\sea.d.ts

Code:
/**
 * This feature allows the distribution of a Node.js application conveniently to a
 * system that does not have Node.js installed.
 *
 * Node.js supports the creation of [single executable applications](https://github.com/nodejs/single-executable) by allowing
 * the injection of a blob prepared by Node.js, which can contain a bundled script,
 * into the `node` binary. During start up, the program checks if anything has been
 * injected. If the blob is found, it executes the script in the blob. Otherwise
 * Node.js operates as it normally does.
 *
 * The single executable application feature currently only supports running a
 * single embedded script using the `CommonJS` module system.
 *
 * Users can create a single executable application from their bundled script
 * with the `node` binary itself and any tool which can inject resources into the
 * binary.
 *
 * Here are the steps for creating a single executable application using one such
 * tool, [postject](https://github.com/nodejs/postject):
 *
 * 1. Create a JavaScript file:
 * ```bash
 * echo 'console.log(`Hello, ${process.argv[2]}!`);' > hello.js
 * ```
 * 2. Create a configuration file building a blob that can be injected into the
 * single executable application (see `Generating single executable preparation blobs` for details):
 * ```bash
 * echo '{ "main": "hello.js", "output": "sea-prep.blob" }' > sea-config.json
 * ```
 * 3. Generate the blob to be injected:
 * ```bash
 * node --experimental-sea-config sea-config.json
 * ```
 * 4. Create a copy of the `node` executable and name it according to your needs:
 *    * On systems other than Windows:
 * ```bash
 * cp $(command -v node) hello
 * ```
 *    * On Windows:
 * ```text
 * node -e "require('fs').copyFileSync(process.execPath, 'hello.exe')"
 * ```
 * The `.exe` extension is necessary.
 * 5. Remove the signature of the binary (macOS and Windows only):
 *    * On macOS:
 * ```bash
 * codesign --remove-signature hello
 * ```
 *    * On Windows (optional):
 * [signtool](https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool) can be used from the installed [Windows SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/).
 * If this step is
 * skipped, ignore any signature-related warning from postject.
 * ```powershell
 * signtool remove /s hello.exe
 * ```
 * 6. Inject the blob into the copied binary by running `postject` with
 * the following options:
 *    * `hello` / `hello.exe` \- The name of the copy of the `node` executable
 *    created in step 4.
 *    * `NODE_SEA_BLOB` \- The name of the resource / note / section in the binary
 *    where the contents of the blob will be stored.
 *    * `sea-prep.blob` \- The name of the blob created in step 1.
 *    * `--sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2` \- The [fuse](https://www.electronjs.org/docs/latest/tutorial/fuses) used by the Node.js project to detect if a file has been
 * injected.
 *    * `--macho-segment-name NODE_SEA` (only needed on macOS) - The name of the
 *    segment in the binary where the contents of the blob will be
 *    stored.
 * To summarize, here is the required command for each platform:
 *    * On Linux:
 *    ```bash
 *    npx postject hello NODE_SEA_BLOB sea-prep.blob \
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On Windows - PowerShell:
 *    ```powershell
 *    npx postject hello.exe NODE_SEA_BLOB sea-prep.blob `
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On Windows - Command Prompt:
 *    ```text
 *    npx postject hello.exe NODE_SEA_BLOB sea-prep.blob ^
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On macOS:
 *    ```bash
 *    npx postject hello NODE_SEA_BLOB sea-prep.blob \
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2 \
 *        --macho-segment-name NODE_SEA
 *    ```
 * 7. Sign the binary (macOS and Windows only):
 *    * On macOS:
 * ```bash
 * codesign --sign - hello
 * ```
 *    * On Windows (optional):
 * A certificate needs to be present for this to work. However, the unsigned
 * binary would still be runnable.
 * ```powershell
 * signtool sign /fd SHA256 hello.exe
 * ```
 * 8. Run the binary:
 *    * On systems other than Windows
 * ```console
 * $ ./hello world
 * Hello, world!
 * ```
 *    * On Windows
 * ```console
 * $ .\hello.exe world
 * Hello, world!
 * ```
 * @since v19.7.0, v18.16.0
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v24.x/src/node_sea.cc)
 */
declare module "node:sea" {
    type AssetKey = string;
    /**
     * @since v20.12.0
     * @return Whether this script is running inside a single-executable application.
     */
    function isSea(): boolean;
    /**
     * This method can be used to retrieve the assets configured to be bundled into the
     * single-executable application at build time.
     * An error is thrown when no matching asset can be found.
     * @since v20.12.0
     */
    function getAsset(key: AssetKey): ArrayBuffer;
    function getAsset(key: AssetKey, encoding: string): string;
    /**
     * Similar to `sea.getAsset()`, but returns the result in a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).
     * An error is thrown when no matching asset can be found.
     * @since v20.12.0
     */
    function getAssetAsBlob(key: AssetKey, options?: {
        type: string;
    }): Blob;
    /**
     * This method can be used to retrieve the assets configured to be bundled into the
     * single-executable application at build time.
     * An error is thrown when no matching asset can be found.
     *
     * Unlike `sea.getRawAsset()` or `sea.getAssetAsBlob()`, this method does not
     * return a copy. Instead, it returns the raw asset bundled inside the executable.
     *
     * For now, users should avoid writing to the returned array buffer. If the
     * injected section is not marked as writable or not aligned properly,
     * writes to the returned array buffer is likely to result in a crash.
     * @since v20.12.0
     */
    function getRawAsset(key: AssetKey): ArrayBuffer;
}


---

File name: node_modules\@types\node\sqlite.d.ts

Code:
/**
 * The `node:sqlite` module facilitates working with SQLite databases.
 * To access it:
 *
 * ```js
 * import sqlite from 'node:sqlite';
 * ```
 *
 * This module is only available under the `node:` scheme. The following will not
 * work:
 *
 * ```js
 * import sqlite from 'sqlite';
 * ```
 *
 * The following example shows the basic usage of the `node:sqlite` module to open
 * an in-memory database, write data to the database, and then read the data back.
 *
 * ```js
 * import { DatabaseSync } from 'node:sqlite';
 * const database = new DatabaseSync(':memory:');
 *
 * // Execute SQL statements from strings.
 * database.exec(`
 *   CREATE TABLE data(
 *     key INTEGER PRIMARY KEY,
 *     value TEXT
 *   ) STRICT
 * `);
 * // Create a prepared statement to insert data into the database.
 * const insert = database.prepare('INSERT INTO data (key, value) VALUES (?, ?)');
 * // Execute the prepared statement with bound values.
 * insert.run(1, 'hello');
 * insert.run(2, 'world');
 * // Create a prepared statement to read data from the database.
 * const query = database.prepare('SELECT * FROM data ORDER BY key');
 * // Execute the prepared statement and log the result set.
 * console.log(query.all());
 * // Prints: [ { key: 1, value: 'hello' }, { key: 2, value: 'world' } ]
 * ```
 * @since v22.5.0
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/sqlite.js)
 */
declare module "node:sqlite" {
    type SQLInputValue = null | number | bigint | string | NodeJS.ArrayBufferView;
    type SQLOutputValue = null | number | bigint | string | Uint8Array;
    /** @deprecated Use `SQLInputValue` or `SQLOutputValue` instead. */
    type SupportedValueType = SQLOutputValue;
    interface DatabaseSyncOptions {
        /**
         * If `true`, the database is opened by the constructor. When
         * this value is `false`, the database must be opened via the `open()` method.
         * @since v22.5.0
         * @default true
         */
        open?: boolean | undefined;
        /**
         * If `true`, foreign key constraints
         * are enabled. This is recommended but can be disabled for compatibility with
         * legacy database schemas. The enforcement of foreign key constraints can be
         * enabled and disabled after opening the database using
         * [`PRAGMA foreign_keys`](https://www.sqlite.org/pragma.html#pragma_foreign_keys).
         * @since v22.10.0
         * @default true
         */
        enableForeignKeyConstraints?: boolean | undefined;
        /**
         * If `true`, SQLite will accept
         * [double-quoted string literals](https://www.sqlite.org/quirks.html#dblquote).
         * This is not recommended but can be
         * enabled for compatibility with legacy database schemas.
         * @since v22.10.0
         * @default false
         */
        enableDoubleQuotedStringLiterals?: boolean | undefined;
        /**
         * If `true`, the database is opened in read-only mode.
         * If the database does not exist, opening it will fail.
         * @since v22.12.0
         * @default false
         */
        readOnly?: boolean | undefined;
        /**
         * If `true`, the `loadExtension` SQL function
         * and the `loadExtension()` method are enabled.
         * You can call `enableLoadExtension(false)` later to disable this feature.
         * @since v22.13.0
         * @default false
         */
        allowExtension?: boolean | undefined;
        /**
         * The [busy timeout](https://sqlite.org/c3ref/busy_timeout.html) in milliseconds. This is the maximum amount of
         * time that SQLite will wait for a database lock to be released before
         * returning an error.
         * @since v24.0.0
         * @default 0
         */
        timeout?: number | undefined;
    }
    interface CreateSessionOptions {
        /**
         * A specific table to track changes for. By default, changes to all tables are tracked.
         * @since v22.12.0
         */
        table?: string | undefined;
        /**
         * Name of the database to track. This is useful when multiple databases have been added using
         * [`ATTACH DATABASE`](https://www.sqlite.org/lang_attach.html).
         * @since v22.12.0
         * @default 'main'
         */
        db?: string | undefined;
    }
    interface ApplyChangesetOptions {
        /**
         * Skip changes that, when targeted table name is supplied to this function, return a truthy value.
         * By default, all changes are attempted.
         * @since v22.12.0
         */
        filter?: ((tableName: string) => boolean) | undefined;
        /**
         * A function that determines how to handle conflicts. The function receives one argument,
         * which can be one of the following values:
         *
         * * `SQLITE_CHANGESET_DATA`: A `DELETE` or `UPDATE` change does not contain the expected "before" values.
         * * `SQLITE_CHANGESET_NOTFOUND`: A row matching the primary key of the `DELETE` or `UPDATE` change does not exist.
         * * `SQLITE_CHANGESET_CONFLICT`: An `INSERT` change results in a duplicate primary key.
         * * `SQLITE_CHANGESET_FOREIGN_KEY`: Applying a change would result in a foreign key violation.
         * * `SQLITE_CHANGESET_CONSTRAINT`: Applying a change results in a `UNIQUE`, `CHECK`, or `NOT NULL` constraint
         * violation.
         *
         * The function should return one of the following values:
         *
         * * `SQLITE_CHANGESET_OMIT`: Omit conflicting changes.
         * * `SQLITE_CHANGESET_REPLACE`: Replace existing values with conflicting changes (only valid with
             `SQLITE_CHANGESET_DATA` or `SQLITE_CHANGESET_CONFLICT` conflicts).
         * * `SQLITE_CHANGESET_ABORT`: Abort on conflict and roll back the database.
         *
         * When an error is thrown in the conflict handler or when any other value is returned from the handler,
         * applying the changeset is aborted and the database is rolled back.
         *
         * **Default**: A function that returns `SQLITE_CHANGESET_ABORT`.
         * @since v22.12.0
         */
        onConflict?: ((conflictType: number) => number) | undefined;
    }
    interface FunctionOptions {
        /**
         * If `true`, the [`SQLITE_DETERMINISTIC`](https://www.sqlite.org/c3ref/c_deterministic.html) flag is
         * set on the created function.
         * @default false
         */
        deterministic?: boolean | undefined;
        /**
         * If `true`, the [`SQLITE_DIRECTONLY`](https://www.sqlite.org/c3ref/c_directonly.html) flag is set on
         * the created function.
         * @default false
         */
        directOnly?: boolean | undefined;
        /**
         * If `true`, integer arguments to `function`
         * are converted to `BigInt`s. If `false`, integer arguments are passed as
         * JavaScript numbers.
         * @default false
         */
        useBigIntArguments?: boolean | undefined;
        /**
         * If `true`, `function` may be invoked with any number of
         * arguments (between zero and
         * [`SQLITE_MAX_FUNCTION_ARG`](https://www.sqlite.org/limits.html#max_function_arg)). If `false`,
         * `function` must be invoked with exactly `function.length` arguments.
         * @default false
         */
        varargs?: boolean | undefined;
    }
    interface AggregateOptions<T extends SQLInputValue = SQLInputValue> extends FunctionOptions {
        /**
         * The identity value for the aggregation function. This value is used when the aggregation
         * function is initialized. When a `Function` is passed the identity will be its return value.
         */
        start: T | (() => T);
        /**
         * The function to call for each row in the aggregation. The
         * function receives the current state and the row value. The return value of
         * this function should be the new state.
         */
        step: (accumulator: T, ...args: SQLOutputValue[]) => T;
        /**
         * The function to call to get the result of the
         * aggregation. The function receives the final state and should return the
         * result of the aggregation.
         */
        result?: ((accumulator: T) => SQLInputValue) | undefined;
        /**
         * When this function is provided, the `aggregate` method will work as a window function.
         * The function receives the current state and the dropped row value. The return value of this function should be the
         * new state.
         */
        inverse?: ((accumulator: T, ...args: SQLOutputValue[]) => T) | undefined;
    }
    /**
     * This class represents a single [connection](https://www.sqlite.org/c3ref/sqlite3.html) to a SQLite database. All APIs
     * exposed by this class execute synchronously.
     * @since v22.5.0
     */
    class DatabaseSync implements Disposable {
        /**
         * Constructs a new `DatabaseSync` instance.
         * @param path The path of the database.
         * A SQLite database can be stored in a file or completely [in memory](https://www.sqlite.org/inmemorydb.html).
         * To use a file-backed database, the path should be a file path.
         * To use an in-memory database, the path should be the special name `':memory:'`.
         * @param options Configuration options for the database connection.
         */
        constructor(path: string | Buffer | URL, options?: DatabaseSyncOptions);
        /**
         * Registers a new aggregate function with the SQLite database. This method is a wrapper around
         * [`sqlite3_create_window_function()`](https://www.sqlite.org/c3ref/create_function.html).
         *
         * When used as a window function, the `result` function will be called multiple times.
         *
         * ```js
         * import { DatabaseSync } from 'node:sqlite';
         *
         * const db = new DatabaseSync(':memory:');
         * db.exec(`
         *   CREATE TABLE t3(x, y);
         *   INSERT INTO t3 VALUES ('a', 4),
         *                         ('b', 5),
         *                         ('c', 3),
         *                         ('d', 8),
         *                         ('e', 1);
         * `);
         *
         * db.aggregate('sumint', {
         *   start: 0,
         *   step: (acc, value) => acc + value,
         * });
         *
         * db.prepare('SELECT sumint(y) as total FROM t3').get(); // { total: 21 }
         * ```
         * @since v24.0.0
         * @param name The name of the SQLite function to create.
         * @param options Function configuration settings.
         */
        aggregate(name: string, options: AggregateOptions): void;
        aggregate<T extends SQLInputValue>(name: string, options: AggregateOptions<T>): void;
        /**
         * Closes the database connection. An exception is thrown if the database is not
         * open. This method is a wrapper around [`sqlite3_close_v2()`](https://www.sqlite.org/c3ref/close.html).
         * @since v22.5.0
         */
        close(): void;
        /**
         * Loads a shared library into the database connection. This method is a wrapper
         * around [`sqlite3_load_extension()`](https://www.sqlite.org/c3ref/load_extension.html). It is required to enable the
         * `allowExtension` option when constructing the `DatabaseSync` instance.
         * @since v22.13.0
         * @param path The path to the shared library to load.
         */
        loadExtension(path: string): void;
        /**
         * Enables or disables the `loadExtension` SQL function, and the `loadExtension()`
         * method. When `allowExtension` is `false` when constructing, you cannot enable
         * loading extensions for security reasons.
         * @since v22.13.0
         * @param allow Whether to allow loading extensions.
         */
        enableLoadExtension(allow: boolean): void;
        /**
         * This method is a wrapper around [`sqlite3_db_filename()`](https://sqlite.org/c3ref/db_filename.html)
         * @since v24.0.0
         * @param dbName Name of the database. This can be `'main'` (the default primary database) or any other
         * database that has been added with [`ATTACH DATABASE`](https://www.sqlite.org/lang_attach.html) **Default:** `'main'`.
         * @returns The location of the database file. When using an in-memory database,
         * this method returns null.
         */
        location(dbName?: string): string | null;
        /**
         * This method allows one or more SQL statements to be executed without returning
         * any results. This method is useful when executing SQL statements read from a
         * file. This method is a wrapper around [`sqlite3_exec()`](https://www.sqlite.org/c3ref/exec.html).
         * @since v22.5.0
         * @param sql A SQL string to execute.
         */
        exec(sql: string): void;
        /**
         * This method is used to create SQLite user-defined functions. This method is a
         * wrapper around [`sqlite3_create_function_v2()`](https://www.sqlite.org/c3ref/create_function.html).
         * @since v22.13.0
         * @param name The name of the SQLite function to create.
         * @param options Optional configuration settings for the function.
         * @param func The JavaScript function to call when the SQLite
         * function is invoked. The return value of this function should be a valid
         * SQLite data type: see
         * [Type conversion between JavaScript and SQLite](https://nodejs.org/docs/latest-v24.x/api/sqlite.html#type-conversion-between-javascript-and-sqlite).
         * The result defaults to `NULL` if the return value is `undefined`.
         */
        function(
            name: string,
            options: FunctionOptions,
            func: (...args: SQLOutputValue[]) => SQLInputValue,
        ): void;
        function(name: string, func: (...args: SQLOutputValue[]) => SQLInputValue): void;
        /**
         * Whether the database is currently open or not.
         * @since v22.15.0
         */
        readonly isOpen: boolean;
        /**
         * Whether the database is currently within a transaction. This method
         * is a wrapper around [`sqlite3_get_autocommit()`](https://sqlite.org/c3ref/get_autocommit.html).
         * @since v24.0.0
         */
        readonly isTransaction: boolean;
        /**
         * Opens the database specified in the `path` argument of the `DatabaseSync`constructor. This method should only be used when the database is not opened via
         * the constructor. An exception is thrown if the database is already open.
         * @since v22.5.0
         */
        open(): void;
        /**
         * Compiles a SQL statement into a [prepared statement](https://www.sqlite.org/c3ref/stmt.html). This method is a wrapper
         * around [`sqlite3_prepare_v2()`](https://www.sqlite.org/c3ref/prepare.html).
         * @since v22.5.0
         * @param sql A SQL string to compile to a prepared statement.
         * @return The prepared statement.
         */
        prepare(sql: string): StatementSync;
        /**
         * Creates and attaches a session to the database. This method is a wrapper around
         * [`sqlite3session_create()`](https://www.sqlite.org/session/sqlite3session_create.html) and
         * [`sqlite3session_attach()`](https://www.sqlite.org/session/sqlite3session_attach.html).
         * @param options The configuration options for the session.
         * @returns A session handle.
         * @since v22.12.0
         */
        createSession(options?: CreateSessionOptions): Session;
        /**
         * An exception is thrown if the database is not
         * open. This method is a wrapper around
         * [`sqlite3changeset_apply()`](https://www.sqlite.org/session/sqlite3changeset_apply.html).
         *
         * ```js
         * const sourceDb = new DatabaseSync(':memory:');
         * const targetDb = new DatabaseSync(':memory:');
         *
         * sourceDb.exec('CREATE TABLE data(key INTEGER PRIMARY KEY, value TEXT)');
         * targetDb.exec('CREATE TABLE data(key INTEGER PRIMARY KEY, value TEXT)');
         *
         * const session = sourceDb.createSession();
         *
         * const insert = sourceDb.prepare('INSERT INTO data (key, value) VALUES (?, ?)');
         * insert.run(1, 'hello');
         * insert.run(2, 'world');
         *
         * const changeset = session.changeset();
         * targetDb.applyChangeset(changeset);
         * // Now that the changeset has been applied, targetDb contains the same data as sourceDb.
         * ```
         * @param changeset A binary changeset or patchset.
         * @param options The configuration options for how the changes will be applied.
         * @returns Whether the changeset was applied successfully without being aborted.
         * @since v22.12.0
         */
        applyChangeset(changeset: Uint8Array, options?: ApplyChangesetOptions): boolean;
        /**
         * Closes the database connection. If the database connection is already closed
         * then this is a no-op.
         * @since v22.15.0
         * @experimental
         */
        [Symbol.dispose](): void;
    }
    /**
     * @since v22.12.0
     */
    interface Session {
        /**
         * Retrieves a changeset containing all changes since the changeset was created. Can be called multiple times.
         * An exception is thrown if the database or the session is not open. This method is a wrapper around
         * [`sqlite3session_changeset()`](https://www.sqlite.org/session/sqlite3session_changeset.html).
         * @returns Binary changeset that can be applied to other databases.
         * @since v22.12.0
         */
        changeset(): Uint8Array;
        /**
         * Similar to the method above, but generates a more compact patchset. See
         * [Changesets and Patchsets](https://www.sqlite.org/sessionintro.html#changesets_and_patchsets)
         * in the documentation of SQLite. An exception is thrown if the database or the session is not open. This method is a
         * wrapper around
         * [`sqlite3session_patchset()`](https://www.sqlite.org/session/sqlite3session_patchset.html).
         * @returns Binary patchset that can be applied to other databases.
         * @since v22.12.0
         */
        patchset(): Uint8Array;
        /**
         * Closes the session. An exception is thrown if the database or the session is not open. This method is a
         * wrapper around
         * [`sqlite3session_delete()`](https://www.sqlite.org/session/sqlite3session_delete.html).
         */
        close(): void;
    }
    interface StatementColumnMetadata {
        /**
         * The unaliased name of the column in the origin
         * table, or `null` if the column is the result of an expression or subquery.
         * This property is the result of [`sqlite3_column_origin_name()`](https://www.sqlite.org/c3ref/column_database_name.html).
         */
        column: string | null;
        /**
         * The unaliased name of the origin database, or
         * `null` if the column is the result of an expression or subquery. This
         * property is the result of [`sqlite3_column_database_name()`](https://www.sqlite.org/c3ref/column_database_name.html).
         */
        database: string | null;
        /**
         * The name assigned to the column in the result set of a
         * `SELECT` statement. This property is the result of
         * [`sqlite3_column_name()`](https://www.sqlite.org/c3ref/column_name.html).
         */
        name: string;
        /**
         * The unaliased name of the origin table, or `null` if
         * the column is the result of an expression or subquery. This property is the
         * result of [`sqlite3_column_table_name()`](https://www.sqlite.org/c3ref/column_database_name.html).
         */
        table: string | null;
        /**
         * The declared data type of the column, or `null` if the
         * column is the result of an expression or subquery. This property is the
         * result of [`sqlite3_column_decltype()`](https://www.sqlite.org/c3ref/column_decltype.html).
         */
        type: string | null;
    }
    interface StatementResultingChanges {
        /**
         * The number of rows modified, inserted, or deleted by the most recently completed `INSERT`, `UPDATE`, or `DELETE` statement.
         * This field is either a number or a `BigInt` depending on the prepared statement's configuration.
         * This property is the result of [`sqlite3_changes64()`](https://www.sqlite.org/c3ref/changes.html).
         */
        changes: number | bigint;
        /**
         * The most recently inserted rowid.
         * This field is either a number or a `BigInt` depending on the prepared statement's configuration.
         * This property is the result of [`sqlite3_last_insert_rowid()`](https://www.sqlite.org/c3ref/last_insert_rowid.html).
         */
        lastInsertRowid: number | bigint;
    }
    /**
     * This class represents a single [prepared statement](https://www.sqlite.org/c3ref/stmt.html). This class cannot be
     * instantiated via its constructor. Instead, instances are created via the`database.prepare()` method. All APIs exposed by this class execute
     * synchronously.
     *
     * A prepared statement is an efficient binary representation of the SQL used to
     * create it. Prepared statements are parameterizable, and can be invoked multiple
     * times with different bound values. Parameters also offer protection against [SQL injection](https://en.wikipedia.org/wiki/SQL_injection) attacks. For these reasons, prepared statements are
     * preferred
     * over hand-crafted SQL strings when handling user input.
     * @since v22.5.0
     */
    class StatementSync {
        private constructor();
        /**
         * This method executes a prepared statement and returns all results as an array of
         * objects. If the prepared statement does not return any results, this method
         * returns an empty array. The prepared statement [parameters are bound](https://www.sqlite.org/c3ref/bind_blob.html) using
         * the values in `namedParameters` and `anonymousParameters`.
         * @since v22.5.0
         * @param namedParameters An optional object used to bind named parameters. The keys of this object are used to configure the mapping.
         * @param anonymousParameters Zero or more values to bind to anonymous parameters.
         * @return An array of objects. Each object corresponds to a row returned by executing the prepared statement. The keys and values of each object correspond to the column names and values of
         * the row.
         */
        all(...anonymousParameters: SQLInputValue[]): Record<string, SQLOutputValue>[];
        all(
            namedParameters: Record<string, SQLInputValue>,
            ...anonymousParameters: SQLInputValue[]
        ): Record<string, SQLOutputValue>[];
        /**
         * This method is used to retrieve information about the columns returned by the
         * prepared statement.
         * @since v23.11.0
         * @returns An array of objects. Each object corresponds to a column
         * in the prepared statement, and contains the following properties:
         */
        columns(): StatementColumnMetadata[];
        /**
         * The source SQL text of the prepared statement with parameter
         * placeholders replaced by the values that were used during the most recent
         * execution of this prepared statement. This property is a wrapper around
         * [`sqlite3_expanded_sql()`](https://www.sqlite.org/c3ref/expanded_sql.html).
         * @since v22.5.0
         */
        readonly expandedSQL: string;
        /**
         * This method executes a prepared statement and returns the first result as an
         * object. If the prepared statement does not return any results, this method
         * returns `undefined`. The prepared statement [parameters are bound](https://www.sqlite.org/c3ref/bind_blob.html) using the
         * values in `namedParameters` and `anonymousParameters`.
         * @since v22.5.0
         * @param namedParameters An optional object used to bind named parameters. The keys of this object are used to configure the mapping.
         * @param anonymousParameters Zero or more values to bind to anonymous parameters.
         * @return An object corresponding to the first row returned by executing the prepared statement. The keys and values of the object correspond to the column names and values of the row. If no
         * rows were returned from the database then this method returns `undefined`.
         */
        get(...anonymousParameters: SQLInputValue[]): Record<string, SQLOutputValue> | undefined;
        get(
            namedParameters: Record<string, SQLInputValue>,
            ...anonymousParameters: SQLInputValue[]
        ): Record<string, SQLOutputValue> | undefined;
        /**
         * This method executes a prepared statement and returns an iterator of
         * objects. If the prepared statement does not return any results, this method
         * returns an empty iterator. The prepared statement [parameters are bound](https://www.sqlite.org/c3ref/bind_blob.html) using
         * the values in `namedParameters` and `anonymousParameters`.
         * @since v22.13.0
         * @param namedParameters An optional object used to bind named parameters.
         * The keys of this object are used to configure the mapping.
         * @param anonymousParameters Zero or more values to bind to anonymous parameters.
         * @returns An iterable iterator of objects. Each object corresponds to a row
         * returned by executing the prepared statement. The keys and values of each
         * object correspond to the column names and values of the row.
         */
        iterate(...anonymousParameters: SQLInputValue[]): NodeJS.Iterator<Record<string, SQLOutputValue>>;
        iterate(
            namedParameters: Record<string, SQLInputValue>,
            ...anonymousParameters: SQLInputValue[]
        ): NodeJS.Iterator<Record<string, SQLOutputValue>>;
        /**
         * This method executes a prepared statement and returns an object summarizing the
         * resulting changes. The prepared statement [parameters are bound](https://www.sqlite.org/c3ref/bind_blob.html) using the
         * values in `namedParameters` and `anonymousParameters`.
         * @since v22.5.0
         * @param namedParameters An optional object used to bind named parameters. The keys of this object are used to configure the mapping.
         * @param anonymousParameters Zero or more values to bind to anonymous parameters.
         */
        run(...anonymousParameters: SQLInputValue[]): StatementResultingChanges;
        run(
            namedParameters: Record<string, SQLInputValue>,
            ...anonymousParameters: SQLInputValue[]
        ): StatementResultingChanges;
        /**
         * The names of SQLite parameters begin with a prefix character. By default,`node:sqlite` requires that this prefix character is present when binding
         * parameters. However, with the exception of dollar sign character, these
         * prefix characters also require extra quoting when used in object keys.
         *
         * To improve ergonomics, this method can be used to also allow bare named
         * parameters, which do not require the prefix character in JavaScript code. There
         * are several caveats to be aware of when enabling bare named parameters:
         *
         * * The prefix character is still required in SQL.
         * * The prefix character is still allowed in JavaScript. In fact, prefixed names
         * will have slightly better binding performance.
         * * Using ambiguous named parameters, such as `$k` and `@k`, in the same prepared
         * statement will result in an exception as it cannot be determined how to bind
         * a bare name.
         * @since v22.5.0
         * @param enabled Enables or disables support for binding named parameters without the prefix character.
         */
        setAllowBareNamedParameters(enabled: boolean): void;
        /**
         * By default, if an unknown name is encountered while binding parameters, an
         * exception is thrown. This method allows unknown named parameters to be ignored.
         * @since v22.15.0
         * @param enabled Enables or disables support for unknown named parameters.
         */
        setAllowUnknownNamedParameters(enabled: boolean): void;
        /**
         * When reading from the database, SQLite `INTEGER`s are mapped to JavaScript
         * numbers by default. However, SQLite `INTEGER`s can store values larger than
         * JavaScript numbers are capable of representing. In such cases, this method can
         * be used to read `INTEGER` data using JavaScript `BigInt`s. This method has no
         * impact on database write operations where numbers and `BigInt`s are both
         * supported at all times.
         * @since v22.5.0
         * @param enabled Enables or disables the use of `BigInt`s when reading `INTEGER` fields from the database.
         */
        setReadBigInts(enabled: boolean): void;
        /**
         * The source SQL text of the prepared statement. This property is a
         * wrapper around [`sqlite3_sql()`](https://www.sqlite.org/c3ref/expanded_sql.html).
         * @since v22.5.0
         */
        readonly sourceSQL: string;
    }
    interface BackupOptions {
        /**
         * Name of the source database. This can be `'main'` (the default primary database) or any other
         * database that have been added with [`ATTACH DATABASE`](https://www.sqlite.org/lang_attach.html)
         * @default 'main'
         */
        source?: string | undefined;
        /**
         * Name of the target database. This can be `'main'` (the default primary database) or any other
         * database that have been added with [`ATTACH DATABASE`](https://www.sqlite.org/lang_attach.html)
         * @default 'main'
         */
        target?: string | undefined;
        /**
         * Number of pages to be transmitted in each batch of the backup.
         * @default 100
         */
        rate?: number | undefined;
        /**
         * Callback function that will be called with the number of pages copied and the total number of
         * pages.
         */
        progress?: ((progressInfo: BackupProgressInfo) => void) | undefined;
    }
    interface BackupProgressInfo {
        totalPages: number;
        remainingPages: number;
    }
    /**
     * This method makes a database backup. This method abstracts the
     * [`sqlite3_backup_init()`](https://www.sqlite.org/c3ref/backup_finish.html#sqlite3backupinit),
     * [`sqlite3_backup_step()`](https://www.sqlite.org/c3ref/backup_finish.html#sqlite3backupstep)
     * and [`sqlite3_backup_finish()`](https://www.sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish) functions.
     *
     * The backed-up database can be used normally during the backup process. Mutations coming from the same connection - same
     * `DatabaseSync` - object will be reflected in the backup right away. However, mutations from other connections will cause
     * the backup process to restart.
     *
     * ```js
     * import { backup, DatabaseSync } from 'node:sqlite';
     *
     * const sourceDb = new DatabaseSync('source.db');
     * const totalPagesTransferred = await backup(sourceDb, 'backup.db', {
     *   rate: 1, // Copy one page at a time.
     *   progress: ({ totalPages, remainingPages }) => {
     *     console.log('Backup in progress', { totalPages, remainingPages });
     *   },
     * });
     *
     * console.log('Backup completed', totalPagesTransferred);
     * ```
     * @since v23.8.0
     * @param sourceDb The database to backup. The source database must be open.
     * @param path The path where the backup will be created. If the file already exists,
     * the contents will be overwritten.
     * @param options Optional configuration for the backup. The
     * following properties are supported:
     * @returns A promise that resolves when the backup is completed and rejects if an error occurs.
     */
    function backup(sourceDb: DatabaseSync, path: string | Buffer | URL, options?: BackupOptions): Promise<void>;
    /**
     * @since v22.13.0
     */
    namespace constants {
        /**
         * The conflict handler is invoked with this constant when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected "before" values.
         * @since v22.14.0
         */
        const SQLITE_CHANGESET_DATA: number;
        /**
         * The conflict handler is invoked with this constant when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.
         * @since v22.14.0
         */
        const SQLITE_CHANGESET_NOTFOUND: number;
        /**
         * This constant is passed to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.
         * @since v22.14.0
         */
        const SQLITE_CHANGESET_CONFLICT: number;
        /**
         * If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with this constant exactly once before the changeset is committed. If the conflict handler returns `SQLITE_CHANGESET_OMIT`, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns `SQLITE_CHANGESET_ABORT`, the changeset is rolled back.
         * @since v22.14.0
         */
        const SQLITE_CHANGESET_FOREIGN_KEY: number;
        /**
         * Conflicting changes are omitted.
         * @since v22.12.0
         */
        const SQLITE_CHANGESET_OMIT: number;
        /**
         * Conflicting changes replace existing values. Note that this value can only be returned when the type of conflict is either `SQLITE_CHANGESET_DATA` or `SQLITE_CHANGESET_CONFLICT`.
         * @since v22.12.0
         */
        const SQLITE_CHANGESET_REPLACE: number;
        /**
         * Abort when a change encounters a conflict and roll back database.
         * @since v22.12.0
         */
        const SQLITE_CHANGESET_ABORT: number;
    }
}


---

File name: node_modules\@types\node\stream\consumers.d.ts

Code:
/**
 * The utility consumer functions provide common options for consuming
 * streams.
 * @since v16.7.0
 */
declare module "stream/consumers" {
    import { Blob as NodeBlob } from "node:buffer";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    /**
     * @since v16.7.0
     * @returns Fulfills with an `ArrayBuffer` containing the full contents of the stream.
     */
    function arrayBuffer(stream: WebReadableStream | NodeJS.ReadableStream | AsyncIterable<any>): Promise<ArrayBuffer>;
    /**
     * @since v16.7.0
     * @returns Fulfills with a `Blob` containing the full contents of the stream.
     */
    function blob(stream: WebReadableStream | NodeJS.ReadableStream | AsyncIterable<any>): Promise<NodeBlob>;
    /**
     * @since v16.7.0
     * @returns Fulfills with a `Buffer` containing the full contents of the stream.
     */
    function buffer(stream: WebReadableStream | NodeJS.ReadableStream | AsyncIterable<any>): Promise<Buffer>;
    /**
     * @since v16.7.0
     * @returns Fulfills with the contents of the stream parsed as a
     * UTF-8 encoded string that is then passed through `JSON.parse()`.
     */
    function json(stream: WebReadableStream | NodeJS.ReadableStream | AsyncIterable<any>): Promise<unknown>;
    /**
     * @since v16.7.0
     * @returns Fulfills with the contents of the stream parsed as a UTF-8 encoded string.
     */
    function text(stream: WebReadableStream | NodeJS.ReadableStream | AsyncIterable<any>): Promise<string>;
}
declare module "node:stream/consumers" {
    export * from "stream/consumers";
}


---

File name: node_modules\@types\node\stream\promises.d.ts

Code:
declare module "stream/promises" {
    import {
        FinishedOptions as _FinishedOptions,
        PipelineDestination,
        PipelineOptions,
        PipelinePromise,
        PipelineSource,
        PipelineTransform,
    } from "node:stream";
    interface FinishedOptions extends _FinishedOptions {
        /**
         * If true, removes the listeners registered by this function before the promise is fulfilled.
         * @default false
         */
        cleanup?: boolean | undefined;
    }
    function finished(
        stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,
        options?: FinishedOptions,
    ): Promise<void>;
    function pipeline<A extends PipelineSource<any>, B extends PipelineDestination<A, any>>(
        source: A,
        destination: B,
        options?: PipelineOptions,
    ): PipelinePromise<B>;
    function pipeline<
        A extends PipelineSource<any>,
        T1 extends PipelineTransform<A, any>,
        B extends PipelineDestination<T1, any>,
    >(
        source: A,
        transform1: T1,
        destination: B,
        options?: PipelineOptions,
    ): PipelinePromise<B>;
    function pipeline<
        A extends PipelineSource<any>,
        T1 extends PipelineTransform<A, any>,
        T2 extends PipelineTransform<T1, any>,
        B extends PipelineDestination<T2, any>,
    >(
        source: A,
        transform1: T1,
        transform2: T2,
        destination: B,
        options?: PipelineOptions,
    ): PipelinePromise<B>;
    function pipeline<
        A extends PipelineSource<any>,
        T1 extends PipelineTransform<A, any>,
        T2 extends PipelineTransform<T1, any>,
        T3 extends PipelineTransform<T2, any>,
        B extends PipelineDestination<T3, any>,
    >(
        source: A,
        transform1: T1,
        transform2: T2,
        transform3: T3,
        destination: B,
        options?: PipelineOptions,
    ): PipelinePromise<B>;
    function pipeline<
        A extends PipelineSource<any>,
        T1 extends PipelineTransform<A, any>,
        T2 extends PipelineTransform<T1, any>,
        T3 extends PipelineTransform<T2, any>,
        T4 extends PipelineTransform<T3, any>,
        B extends PipelineDestination<T4, any>,
    >(
        source: A,
        transform1: T1,
        transform2: T2,
        transform3: T3,
        transform4: T4,
        destination: B,
        options?: PipelineOptions,
    ): PipelinePromise<B>;
    function pipeline(
        streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,
        options?: PipelineOptions,
    ): Promise<void>;
    function pipeline(
        stream1: NodeJS.ReadableStream,
        stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,
        ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | PipelineOptions>
    ): Promise<void>;
}
declare module "node:stream/promises" {
    export * from "stream/promises";
}


---

File name: node_modules\@types\node\stream\web.d.ts

Code:
type _ByteLengthQueuingStrategy = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ByteLengthQueuingStrategy;
type _CompressionStream = typeof globalThis extends { onmessage: any; ReportingObserver: any } ? {}
    : import("stream/web").CompressionStream;
type _CountQueuingStrategy = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").CountQueuingStrategy;
type _DecompressionStream = typeof globalThis extends { onmessage: any; ReportingObserver: any } ? {}
    : import("stream/web").DecompressionStream;
type _ReadableByteStreamController = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableByteStreamController;
type _ReadableStream<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStream<R>;
type _ReadableStreamBYOBReader = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamBYOBReader;
type _ReadableStreamBYOBRequest = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamBYOBRequest;
type _ReadableStreamDefaultController<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamDefaultController<R>;
type _ReadableStreamDefaultReader<R = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").ReadableStreamDefaultReader<R>;
type _TextDecoderStream = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TextDecoderStream;
type _TextEncoderStream = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TextEncoderStream;
type _TransformStream<I = any, O = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TransformStream<I, O>;
type _TransformStreamDefaultController<O = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").TransformStreamDefaultController<O>;
type _WritableStream<W = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStream<W>;
type _WritableStreamDefaultController = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStreamDefaultController;
type _WritableStreamDefaultWriter<W = any> = typeof globalThis extends { onmessage: any } ? {}
    : import("stream/web").WritableStreamDefaultWriter<W>;

declare module "stream/web" {
    // stub module, pending copy&paste from .d.ts or manual impl
    // copy from lib.dom.d.ts
    interface ReadableWritablePair<R = any, W = any> {
        readable: ReadableStream<R>;
        /**
         * Provides a convenient, chainable way of piping this readable stream
         * through a transform stream (or any other { writable, readable }
         * pair). It simply pipes the stream into the writable side of the
         * supplied pair, and returns the readable side for further use.
         *
         * Piping a stream will lock it for the duration of the pipe, preventing
         * any other consumer from acquiring a reader.
         */
        writable: WritableStream<W>;
    }
    interface StreamPipeOptions {
        preventAbort?: boolean;
        preventCancel?: boolean;
        /**
         * Pipes this readable stream to a given writable stream destination.
         * The way in which the piping process behaves under various error
         * conditions can be customized with a number of passed options. It
         * returns a promise that fulfills when the piping process completes
         * successfully, or rejects if any errors were encountered.
         *
         * Piping a stream will lock it for the duration of the pipe, preventing
         * any other consumer from acquiring a reader.
         *
         * Errors and closures of the source and destination streams propagate
         * as follows:
         *
         * An error in this source readable stream will abort destination,
         * unless preventAbort is truthy. The returned promise will be rejected
         * with the source's error, or with any error that occurs during
         * aborting the destination.
         *
         * An error in destination will cancel this source readable stream,
         * unless preventCancel is truthy. The returned promise will be rejected
         * with the destination's error, or with any error that occurs during
         * canceling the source.
         *
         * When this source readable stream closes, destination will be closed,
         * unless preventClose is truthy. The returned promise will be fulfilled
         * once this process completes, unless an error is encountered while
         * closing the destination, in which case it will be rejected with that
         * error.
         *
         * If destination starts out closed or closing, this source readable
         * stream will be canceled, unless preventCancel is true. The returned
         * promise will be rejected with an error indicating piping to a closed
         * stream failed, or with any error that occurs during canceling the
         * source.
         *
         * The signal option can be set to an AbortSignal to allow aborting an
         * ongoing pipe operation via the corresponding AbortController. In this
         * case, this source readable stream will be canceled, and destination
         * aborted, unless the respective options preventCancel or preventAbort
         * are set.
         */
        preventClose?: boolean;
        signal?: AbortSignal;
    }
    interface ReadableStreamGenericReader {
        readonly closed: Promise<void>;
        cancel(reason?: any): Promise<void>;
    }
    type ReadableStreamController<T> = ReadableStreamDefaultController<T>;
    interface ReadableStreamReadValueResult<T> {
        done: false;
        value: T;
    }
    interface ReadableStreamReadDoneResult<T> {
        done: true;
        value?: T;
    }
    type ReadableStreamReadResult<T> = ReadableStreamReadValueResult<T> | ReadableStreamReadDoneResult<T>;
    interface ReadableByteStreamControllerCallback {
        (controller: ReadableByteStreamController): void | PromiseLike<void>;
    }
    interface UnderlyingSinkAbortCallback {
        (reason?: any): void | PromiseLike<void>;
    }
    interface UnderlyingSinkCloseCallback {
        (): void | PromiseLike<void>;
    }
    interface UnderlyingSinkStartCallback {
        (controller: WritableStreamDefaultController): any;
    }
    interface UnderlyingSinkWriteCallback<W> {
        (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>;
    }
    interface UnderlyingSourceCancelCallback {
        (reason?: any): void | PromiseLike<void>;
    }
    interface UnderlyingSourcePullCallback<R> {
        (controller: ReadableStreamController<R>): void | PromiseLike<void>;
    }
    interface UnderlyingSourceStartCallback<R> {
        (controller: ReadableStreamController<R>): any;
    }
    interface TransformerFlushCallback<O> {
        (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
    }
    interface TransformerStartCallback<O> {
        (controller: TransformStreamDefaultController<O>): any;
    }
    interface TransformerTransformCallback<I, O> {
        (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
    }
    interface UnderlyingByteSource {
        autoAllocateChunkSize?: number;
        cancel?: ReadableStreamErrorCallback;
        pull?: ReadableByteStreamControllerCallback;
        start?: ReadableByteStreamControllerCallback;
        type: "bytes";
    }
    interface UnderlyingSource<R = any> {
        cancel?: UnderlyingSourceCancelCallback;
        pull?: UnderlyingSourcePullCallback<R>;
        start?: UnderlyingSourceStartCallback<R>;
        type?: undefined;
    }
    interface UnderlyingSink<W = any> {
        abort?: UnderlyingSinkAbortCallback;
        close?: UnderlyingSinkCloseCallback;
        start?: UnderlyingSinkStartCallback;
        type?: undefined;
        write?: UnderlyingSinkWriteCallback<W>;
    }
    interface ReadableStreamErrorCallback {
        (reason: any): void | PromiseLike<void>;
    }
    interface ReadableStreamAsyncIterator<T> extends NodeJS.AsyncIterator<T, NodeJS.BuiltinIteratorReturn, unknown> {
        [Symbol.asyncIterator](): ReadableStreamAsyncIterator<T>;
    }
    /** This Streams API interface represents a readable stream of byte data. */
    interface ReadableStream<R = any> {
        readonly locked: boolean;
        cancel(reason?: any): Promise<void>;
        getReader(options: { mode: "byob" }): ReadableStreamBYOBReader;
        getReader(): ReadableStreamDefaultReader<R>;
        getReader(options?: ReadableStreamGetReaderOptions): ReadableStreamReader<R>;
        pipeThrough<T>(transform: ReadableWritablePair<T, R>, options?: StreamPipeOptions): ReadableStream<T>;
        pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;
        tee(): [ReadableStream<R>, ReadableStream<R>];
        values(options?: { preventCancel?: boolean }): ReadableStreamAsyncIterator<R>;
        [Symbol.asyncIterator](): ReadableStreamAsyncIterator<R>;
    }
    const ReadableStream: {
        prototype: ReadableStream;
        from<T>(iterable: Iterable<T> | AsyncIterable<T>): ReadableStream<T>;
        new(underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy<Uint8Array>): ReadableStream<Uint8Array>;
        new<R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;
    };
    type ReadableStreamReaderMode = "byob";
    interface ReadableStreamGetReaderOptions {
        /**
         * Creates a ReadableStreamBYOBReader and locks the stream to the new reader.
         *
         * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle "bring your own buffer" reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.
         */
        mode?: ReadableStreamReaderMode;
    }
    type ReadableStreamReader<T> = ReadableStreamDefaultReader<T> | ReadableStreamBYOBReader;
    interface ReadableStreamDefaultReader<R = any> extends ReadableStreamGenericReader {
        read(): Promise<ReadableStreamReadResult<R>>;
        releaseLock(): void;
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */
    interface ReadableStreamBYOBReader extends ReadableStreamGenericReader {
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */
        read<T extends ArrayBufferView>(
            view: T,
            options?: {
                min?: number;
            },
        ): Promise<ReadableStreamReadResult<T>>;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */
        releaseLock(): void;
    }
    const ReadableStreamDefaultReader: {
        prototype: ReadableStreamDefaultReader;
        new<R = any>(stream: ReadableStream<R>): ReadableStreamDefaultReader<R>;
    };
    const ReadableStreamBYOBReader: {
        prototype: ReadableStreamBYOBReader;
        new(stream: ReadableStream): ReadableStreamBYOBReader;
    };
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */
    interface ReadableStreamBYOBRequest {
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */
        readonly view: ArrayBufferView | null;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */
        respond(bytesWritten: number): void;
        /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */
        respondWithNewView(view: ArrayBufferView): void;
    }
    const ReadableStreamBYOBRequest: {
        prototype: ReadableStreamBYOBRequest;
        new(): ReadableStreamBYOBRequest;
    };
    interface ReadableByteStreamController {
        readonly byobRequest: undefined;
        readonly desiredSize: number | null;
        close(): void;
        enqueue(chunk: ArrayBufferView): void;
        error(error?: any): void;
    }
    const ReadableByteStreamController: {
        prototype: ReadableByteStreamController;
        new(): ReadableByteStreamController;
    };
    interface ReadableStreamDefaultController<R = any> {
        readonly desiredSize: number | null;
        close(): void;
        enqueue(chunk?: R): void;
        error(e?: any): void;
    }
    const ReadableStreamDefaultController: {
        prototype: ReadableStreamDefaultController;
        new(): ReadableStreamDefaultController;
    };
    interface Transformer<I = any, O = any> {
        flush?: TransformerFlushCallback<O>;
        readableType?: undefined;
        start?: TransformerStartCallback<O>;
        transform?: TransformerTransformCallback<I, O>;
        writableType?: undefined;
    }
    interface TransformStream<I = any, O = any> {
        readonly readable: ReadableStream<O>;
        readonly writable: WritableStream<I>;
    }
    const TransformStream: {
        prototype: TransformStream;
        new<I = any, O = any>(
            transformer?: Transformer<I, O>,
            writableStrategy?: QueuingStrategy<I>,
            readableStrategy?: QueuingStrategy<O>,
        ): TransformStream<I, O>;
    };
    interface TransformStreamDefaultController<O = any> {
        readonly desiredSize: number | null;
        enqueue(chunk?: O): void;
        error(reason?: any): void;
        terminate(): void;
    }
    const TransformStreamDefaultController: {
        prototype: TransformStreamDefaultController;
        new(): TransformStreamDefaultController;
    };
    /**
     * This Streams API interface provides a standard abstraction for writing
     * streaming data to a destination, known as a sink. This object comes with
     * built-in back pressure and queuing.
     */
    interface WritableStream<W = any> {
        readonly locked: boolean;
        abort(reason?: any): Promise<void>;
        close(): Promise<void>;
        getWriter(): WritableStreamDefaultWriter<W>;
    }
    const WritableStream: {
        prototype: WritableStream;
        new<W = any>(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>): WritableStream<W>;
    };
    /**
     * This Streams API interface is the object returned by
     * WritableStream.getWriter() and once created locks the < writer to the
     * WritableStream ensuring that no other streams can write to the underlying
     * sink.
     */
    interface WritableStreamDefaultWriter<W = any> {
        readonly closed: Promise<void>;
        readonly desiredSize: number | null;
        readonly ready: Promise<void>;
        abort(reason?: any): Promise<void>;
        close(): Promise<void>;
        releaseLock(): void;
        write(chunk?: W): Promise<void>;
    }
    const WritableStreamDefaultWriter: {
        prototype: WritableStreamDefaultWriter;
        new<W = any>(stream: WritableStream<W>): WritableStreamDefaultWriter<W>;
    };
    /**
     * This Streams API interface represents a controller allowing control of a
     * WritableStream's state. When constructing a WritableStream, the
     * underlying sink is given a corresponding WritableStreamDefaultController
     * instance to manipulate.
     */
    interface WritableStreamDefaultController {
        error(e?: any): void;
    }
    const WritableStreamDefaultController: {
        prototype: WritableStreamDefaultController;
        new(): WritableStreamDefaultController;
    };
    interface QueuingStrategy<T = any> {
        highWaterMark?: number;
        size?: QueuingStrategySize<T>;
    }
    interface QueuingStrategySize<T = any> {
        (chunk?: T): number;
    }
    interface QueuingStrategyInit {
        /**
         * Creates a new ByteLengthQueuingStrategy with the provided high water
         * mark.
         *
         * Note that the provided high water mark will not be validated ahead of
         * time. Instead, if it is negative, NaN, or not a number, the resulting
         * ByteLengthQueuingStrategy will cause the corresponding stream
         * constructor to throw.
         */
        highWaterMark: number;
    }
    /**
     * This Streams API interface provides a built-in byte length queuing
     * strategy that can be used when constructing streams.
     */
    interface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView> {
        readonly highWaterMark: number;
        readonly size: QueuingStrategySize<ArrayBufferView>;
    }
    const ByteLengthQueuingStrategy: {
        prototype: ByteLengthQueuingStrategy;
        new(init: QueuingStrategyInit): ByteLengthQueuingStrategy;
    };
    /**
     * This Streams API interface provides a built-in byte length queuing
     * strategy that can be used when constructing streams.
     */
    interface CountQueuingStrategy extends QueuingStrategy {
        readonly highWaterMark: number;
        readonly size: QueuingStrategySize;
    }
    const CountQueuingStrategy: {
        prototype: CountQueuingStrategy;
        new(init: QueuingStrategyInit): CountQueuingStrategy;
    };
    interface TextEncoderStream {
        /** Returns "utf-8". */
        readonly encoding: "utf-8";
        readonly readable: ReadableStream<Uint8Array>;
        readonly writable: WritableStream<string>;
        readonly [Symbol.toStringTag]: string;
    }
    const TextEncoderStream: {
        prototype: TextEncoderStream;
        new(): TextEncoderStream;
    };
    interface TextDecoderOptions {
        fatal?: boolean;
        ignoreBOM?: boolean;
    }
    type BufferSource = ArrayBufferView | ArrayBuffer;
    interface TextDecoderStream {
        /** Returns encoding's name, lower cased. */
        readonly encoding: string;
        /** Returns `true` if error mode is "fatal", and `false` otherwise. */
        readonly fatal: boolean;
        /** Returns `true` if ignore BOM flag is set, and `false` otherwise. */
        readonly ignoreBOM: boolean;
        readonly readable: ReadableStream<string>;
        readonly writable: WritableStream<BufferSource>;
        readonly [Symbol.toStringTag]: string;
    }
    const TextDecoderStream: {
        prototype: TextDecoderStream;
        new(encoding?: string, options?: TextDecoderOptions): TextDecoderStream;
    };
    interface CompressionStream {
        readonly readable: ReadableStream;
        readonly writable: WritableStream;
    }
    const CompressionStream: {
        prototype: CompressionStream;
        new(format: "deflate" | "deflate-raw" | "gzip"): CompressionStream;
    };
    interface DecompressionStream {
        readonly writable: WritableStream;
        readonly readable: ReadableStream;
    }
    const DecompressionStream: {
        prototype: DecompressionStream;
        new(format: "deflate" | "deflate-raw" | "gzip"): DecompressionStream;
    };

    global {
        interface ByteLengthQueuingStrategy extends _ByteLengthQueuingStrategy {}
        /**
         * `ByteLengthQueuingStrategy` class is a global reference for `import { ByteLengthQueuingStrategy } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-bytelengthqueuingstrategy
         * @since v18.0.0
         */
        var ByteLengthQueuingStrategy: typeof globalThis extends { onmessage: any; ByteLengthQueuingStrategy: infer T }
            ? T
            : typeof import("stream/web").ByteLengthQueuingStrategy;

        interface CompressionStream extends _CompressionStream {}
        /**
         * `CompressionStream` class is a global reference for `import { CompressionStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-compressionstream
         * @since v18.0.0
         */
        var CompressionStream: typeof globalThis extends {
            onmessage: any;
            // CompressionStream, DecompressionStream and ReportingObserver was introduced in the same commit.
            // If ReportingObserver check is removed, the type here will form a circular reference in TS5.0+lib.dom.d.ts
            ReportingObserver: any;
            CompressionStream: infer T;
        } ? T
            // TS 4.8, 4.9, 5.0
            : typeof globalThis extends { onmessage: any; TransformStream: { prototype: infer T } } ? {
                    prototype: T;
                    new(format: "deflate" | "deflate-raw" | "gzip"): T;
                }
            : typeof import("stream/web").CompressionStream;

        interface CountQueuingStrategy extends _CountQueuingStrategy {}
        /**
         * `CountQueuingStrategy` class is a global reference for `import { CountQueuingStrategy } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-countqueuingstrategy
         * @since v18.0.0
         */
        var CountQueuingStrategy: typeof globalThis extends { onmessage: any; CountQueuingStrategy: infer T } ? T
            : typeof import("stream/web").CountQueuingStrategy;

        interface DecompressionStream extends _DecompressionStream {}
        /**
         * `DecompressionStream` class is a global reference for `import { DecompressionStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-decompressionstream
         * @since v18.0.0
         */
        var DecompressionStream: typeof globalThis extends {
            onmessage: any;
            // CompressionStream, DecompressionStream and ReportingObserver was introduced in the same commit.
            // If ReportingObserver check is removed, the type here will form a circular reference in TS5.0+lib.dom.d.ts
            ReportingObserver: any;
            DecompressionStream: infer T extends object;
        } ? T
            // TS 4.8, 4.9, 5.0
            : typeof globalThis extends { onmessage: any; TransformStream: { prototype: infer T } } ? {
                    prototype: T;
                    new(format: "deflate" | "deflate-raw" | "gzip"): T;
                }
            : typeof import("stream/web").DecompressionStream;

        interface ReadableByteStreamController extends _ReadableByteStreamController {}
        /**
         * `ReadableByteStreamController` class is a global reference for `import { ReadableByteStreamController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablebytestreamcontroller
         * @since v18.0.0
         */
        var ReadableByteStreamController: typeof globalThis extends
            { onmessage: any; ReadableByteStreamController: infer T } ? T
            : typeof import("stream/web").ReadableByteStreamController;

        interface ReadableStream<R = any> extends _ReadableStream<R> {}
        /**
         * `ReadableStream` class is a global reference for `import { ReadableStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestream
         * @since v18.0.0
         */
        var ReadableStream: typeof globalThis extends { onmessage: any; ReadableStream: infer T } ? T
            : typeof import("stream/web").ReadableStream;

        interface ReadableStreamBYOBReader extends _ReadableStreamBYOBReader {}
        /**
         * `ReadableStreamBYOBReader` class is a global reference for `import { ReadableStreamBYOBReader } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreambyobreader
         * @since v18.0.0
         */
        var ReadableStreamBYOBReader: typeof globalThis extends { onmessage: any; ReadableStreamBYOBReader: infer T }
            ? T
            : typeof import("stream/web").ReadableStreamBYOBReader;

        interface ReadableStreamBYOBRequest extends _ReadableStreamBYOBRequest {}
        /**
         * `ReadableStreamBYOBRequest` class is a global reference for `import { ReadableStreamBYOBRequest } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreambyobrequest
         * @since v18.0.0
         */
        var ReadableStreamBYOBRequest: typeof globalThis extends { onmessage: any; ReadableStreamBYOBRequest: infer T }
            ? T
            : typeof import("stream/web").ReadableStreamBYOBRequest;

        interface ReadableStreamDefaultController<R = any> extends _ReadableStreamDefaultController<R> {}
        /**
         * `ReadableStreamDefaultController` class is a global reference for `import { ReadableStreamDefaultController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreamdefaultcontroller
         * @since v18.0.0
         */
        var ReadableStreamDefaultController: typeof globalThis extends
            { onmessage: any; ReadableStreamDefaultController: infer T } ? T
            : typeof import("stream/web").ReadableStreamDefaultController;

        interface ReadableStreamDefaultReader<R = any> extends _ReadableStreamDefaultReader<R> {}
        /**
         * `ReadableStreamDefaultReader` class is a global reference for `import { ReadableStreamDefaultReader } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-readablestreamdefaultreader
         * @since v18.0.0
         */
        var ReadableStreamDefaultReader: typeof globalThis extends
            { onmessage: any; ReadableStreamDefaultReader: infer T } ? T
            : typeof import("stream/web").ReadableStreamDefaultReader;

        interface TextDecoderStream extends _TextDecoderStream {}
        /**
         * `TextDecoderStream` class is a global reference for `import { TextDecoderStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-textdecoderstream
         * @since v18.0.0
         */
        var TextDecoderStream: typeof globalThis extends { onmessage: any; TextDecoderStream: infer T } ? T
            : typeof import("stream/web").TextDecoderStream;

        interface TextEncoderStream extends _TextEncoderStream {}
        /**
         * `TextEncoderStream` class is a global reference for `import { TextEncoderStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-textencoderstream
         * @since v18.0.0
         */
        var TextEncoderStream: typeof globalThis extends { onmessage: any; TextEncoderStream: infer T } ? T
            : typeof import("stream/web").TextEncoderStream;

        interface TransformStream<I = any, O = any> extends _TransformStream<I, O> {}
        /**
         * `TransformStream` class is a global reference for `import { TransformStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-transformstream
         * @since v18.0.0
         */
        var TransformStream: typeof globalThis extends { onmessage: any; TransformStream: infer T } ? T
            : typeof import("stream/web").TransformStream;

        interface TransformStreamDefaultController<O = any> extends _TransformStreamDefaultController<O> {}
        /**
         * `TransformStreamDefaultController` class is a global reference for `import { TransformStreamDefaultController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-transformstreamdefaultcontroller
         * @since v18.0.0
         */
        var TransformStreamDefaultController: typeof globalThis extends
            { onmessage: any; TransformStreamDefaultController: infer T } ? T
            : typeof import("stream/web").TransformStreamDefaultController;

        interface WritableStream<W = any> extends _WritableStream<W> {}
        /**
         * `WritableStream` class is a global reference for `import { WritableStream } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-writablestream
         * @since v18.0.0
         */
        var WritableStream: typeof globalThis extends { onmessage: any; WritableStream: infer T } ? T
            : typeof import("stream/web").WritableStream;

        interface WritableStreamDefaultController extends _WritableStreamDefaultController {}
        /**
         * `WritableStreamDefaultController` class is a global reference for `import { WritableStreamDefaultController } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-writablestreamdefaultcontroller
         * @since v18.0.0
         */
        var WritableStreamDefaultController: typeof globalThis extends
            { onmessage: any; WritableStreamDefaultController: infer T } ? T
            : typeof import("stream/web").WritableStreamDefaultController;

        interface WritableStreamDefaultWriter<W = any> extends _WritableStreamDefaultWriter<W> {}
        /**
         * `WritableStreamDefaultWriter` class is a global reference for `import { WritableStreamDefaultWriter } from 'node:stream/web'`.
         * https://nodejs.org/api/globals.html#class-writablestreamdefaultwriter
         * @since v18.0.0
         */
        var WritableStreamDefaultWriter: typeof globalThis extends
            { onmessage: any; WritableStreamDefaultWriter: infer T } ? T
            : typeof import("stream/web").WritableStreamDefaultWriter;
    }
}
declare module "node:stream/web" {
    export * from "stream/web";
}


---

File name: node_modules\@types\node\stream.d.ts

Code:
/**
 * A stream is an abstract interface for working with streaming data in Node.js.
 * The `node:stream` module provides an API for implementing the stream interface.
 *
 * There are many stream objects provided by Node.js. For instance, a [request to an HTTP server](https://nodejs.org/docs/latest-v24.x/api/http.html#class-httpincomingmessage)
 * and [`process.stdout`](https://nodejs.org/docs/latest-v24.x/api/process.html#processstdout) are both stream instances.
 *
 * Streams can be readable, writable, or both. All streams are instances of [`EventEmitter`](https://nodejs.org/docs/latest-v24.x/api/events.html#class-eventemitter).
 *
 * To access the `node:stream` module:
 *
 * ```js
 * import stream from 'node:stream';
 * ```
 *
 * The `node:stream` module is useful for creating new types of stream instances.
 * It is usually not necessary to use the `node:stream` module to consume streams.
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/stream.js)
 */
declare module "stream" {
    import { Abortable, EventEmitter } from "node:events";
    import { Blob as NodeBlob } from "node:buffer";
    import * as streamPromises from "node:stream/promises";
    import * as streamWeb from "node:stream/web";

    type ComposeFnParam = (source: any) => void;

    class Stream extends EventEmitter {
        pipe<T extends NodeJS.WritableStream>(
            destination: T,
            options?: {
                end?: boolean | undefined;
            },
        ): T;
        compose<T extends NodeJS.ReadableStream>(
            stream: T | ComposeFnParam | Iterable<T> | AsyncIterable<T>,
            options?: { signal: AbortSignal },
        ): T;
    }
    namespace Stream {
        export { Stream, streamPromises as promises };
    }
    namespace Stream {
        interface StreamOptions<T extends Stream> extends Abortable {
            emitClose?: boolean | undefined;
            highWaterMark?: number | undefined;
            objectMode?: boolean | undefined;
            construct?(this: T, callback: (error?: Error | null) => void): void;
            destroy?(this: T, error: Error | null, callback: (error?: Error | null) => void): void;
            autoDestroy?: boolean | undefined;
        }
        interface ReadableOptions<T extends Readable = Readable> extends StreamOptions<T> {
            encoding?: BufferEncoding | undefined;
            read?(this: T, size: number): void;
        }
        interface ArrayOptions {
            /**
             * The maximum concurrent invocations of `fn` to call on the stream at once.
             * @default 1
             */
            concurrency?: number;
            /** Allows destroying the stream if the signal is aborted. */
            signal?: AbortSignal;
        }
        /**
         * @since v0.9.4
         */
        class Readable extends Stream implements NodeJS.ReadableStream {
            /**
             * A utility method for creating Readable Streams out of iterators.
             * @since v12.3.0, v10.17.0
             * @param iterable Object implementing the `Symbol.asyncIterator` or `Symbol.iterator` iterable protocol. Emits an 'error' event if a null value is passed.
             * @param options Options provided to `new stream.Readable([options])`. By default, `Readable.from()` will set `options.objectMode` to `true`, unless this is explicitly opted out by setting `options.objectMode` to `false`.
             */
            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;
            /**
             * A utility method for creating a `Readable` from a web `ReadableStream`.
             * @since v17.0.0
             */
            static fromWeb(
                readableStream: streamWeb.ReadableStream,
                options?: Pick<ReadableOptions, "encoding" | "highWaterMark" | "objectMode" | "signal">,
            ): Readable;
            /**
             * A utility method for creating a web `ReadableStream` from a `Readable`.
             * @since v17.0.0
             */
            static toWeb(
                streamReadable: Readable,
                options?: {
                    strategy?: streamWeb.QueuingStrategy | undefined;
                },
            ): streamWeb.ReadableStream;
            /**
             * Returns whether the stream has been read from or cancelled.
             * @since v16.8.0
             */
            static isDisturbed(stream: Readable | NodeJS.ReadableStream): boolean;
            /**
             * Returns whether the stream was destroyed or errored before emitting `'end'`.
             * @since v16.8.0
             */
            readonly readableAborted: boolean;
            /**
             * Is `true` if it is safe to call {@link read}, which means
             * the stream has not been destroyed or emitted `'error'` or `'end'`.
             * @since v11.4.0
             */
            readable: boolean;
            /**
             * Returns whether `'data'` has been emitted.
             * @since v16.7.0, v14.18.0
             */
            readonly readableDidRead: boolean;
            /**
             * Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method.
             * @since v12.7.0
             */
            readonly readableEncoding: BufferEncoding | null;
            /**
             * Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v24.x/api/stream.html#event-end) event is emitted.
             * @since v12.9.0
             */
            readonly readableEnded: boolean;
            /**
             * This property reflects the current state of a `Readable` stream as described
             * in the [Three states](https://nodejs.org/docs/latest-v24.x/api/stream.html#three-states) section.
             * @since v9.4.0
             */
            readonly readableFlowing: boolean | null;
            /**
             * Returns the value of `highWaterMark` passed when creating this `Readable`.
             * @since v9.3.0
             */
            readonly readableHighWaterMark: number;
            /**
             * This property contains the number of bytes (or objects) in the queue
             * ready to be read. The value provides introspection data regarding
             * the status of the `highWaterMark`.
             * @since v9.4.0
             */
            readonly readableLength: number;
            /**
             * Getter for the property `objectMode` of a given `Readable` stream.
             * @since v12.3.0
             */
            readonly readableObjectMode: boolean;
            /**
             * Is `true` after `readable.destroy()` has been called.
             * @since v8.0.0
             */
            destroyed: boolean;
            /**
             * Is `true` after `'close'` has been emitted.
             * @since v18.0.0
             */
            readonly closed: boolean;
            /**
             * Returns error if the stream has been destroyed with an error.
             * @since v18.0.0
             */
            readonly errored: Error | null;
            constructor(opts?: ReadableOptions);
            _construct?(callback: (error?: Error | null) => void): void;
            _read(size: number): void;
            /**
             * The `readable.read()` method reads data out of the internal buffer and
             * returns it. If no data is available to be read, `null` is returned. By default,
             * the data is returned as a `Buffer` object unless an encoding has been
             * specified using the `readable.setEncoding()` method or the stream is operating
             * in object mode.
             *
             * The optional `size` argument specifies a specific number of bytes to read. If
             * `size` bytes are not available to be read, `null` will be returned _unless_ the
             * stream has ended, in which case all of the data remaining in the internal buffer
             * will be returned.
             *
             * If the `size` argument is not specified, all of the data contained in the
             * internal buffer will be returned.
             *
             * The `size` argument must be less than or equal to 1 GiB.
             *
             * The `readable.read()` method should only be called on `Readable` streams
             * operating in paused mode. In flowing mode, `readable.read()` is called
             * automatically until the internal buffer is fully drained.
             *
             * ```js
             * const readable = getReadableStreamSomehow();
             *
             * // 'readable' may be triggered multiple times as data is buffered in
             * readable.on('readable', () => {
             *   let chunk;
             *   console.log('Stream is readable (new data received in buffer)');
             *   // Use a loop to make sure we read all currently available data
             *   while (null !== (chunk = readable.read())) {
             *     console.log(`Read ${chunk.length} bytes of data...`);
             *   }
             * });
             *
             * // 'end' will be triggered once when there is no more data available
             * readable.on('end', () => {
             *   console.log('Reached end of stream.');
             * });
             * ```
             *
             * Each call to `readable.read()` returns a chunk of data, or `null`. The chunks
             * are not concatenated. A `while` loop is necessary to consume all data
             * currently in the buffer. When reading a large file `.read()` may return `null`,
             * having consumed all buffered content so far, but there is still more data to
             * come not yet buffered. In this case a new `'readable'` event will be emitted
             * when there is more data in the buffer. Finally the `'end'` event will be
             * emitted when there is no more data to come.
             *
             * Therefore to read a file's whole contents from a `readable`, it is necessary
             * to collect chunks across multiple `'readable'` events:
             *
             * ```js
             * const chunks = [];
             *
             * readable.on('readable', () => {
             *   let chunk;
             *   while (null !== (chunk = readable.read())) {
             *     chunks.push(chunk);
             *   }
             * });
             *
             * readable.on('end', () => {
             *   const content = chunks.join('');
             * });
             * ```
             *
             * A `Readable` stream in object mode will always return a single item from
             * a call to `readable.read(size)`, regardless of the value of the `size` argument.
             *
             * If the `readable.read()` method returns a chunk of data, a `'data'` event will
             * also be emitted.
             *
             * Calling {@link read} after the `'end'` event has
             * been emitted will return `null`. No runtime error will be raised.
             * @since v0.9.4
             * @param size Optional argument to specify how much data to read.
             */
            read(size?: number): any;
            /**
             * The `readable.setEncoding()` method sets the character encoding for
             * data read from the `Readable` stream.
             *
             * By default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data
             * to be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the
             * output data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal
             * string format.
             *
             * The `Readable` stream will properly handle multi-byte characters delivered
             * through the stream that would otherwise become improperly decoded if simply
             * pulled from the stream as `Buffer` objects.
             *
             * ```js
             * const readable = getReadableStreamSomehow();
             * readable.setEncoding('utf8');
             * readable.on('data', (chunk) => {
             *   assert.equal(typeof chunk, 'string');
             *   console.log('Got %d characters of string data:', chunk.length);
             * });
             * ```
             * @since v0.9.4
             * @param encoding The encoding to use.
             */
            setEncoding(encoding: BufferEncoding): this;
            /**
             * The `readable.pause()` method will cause a stream in flowing mode to stop
             * emitting `'data'` events, switching out of flowing mode. Any data that
             * becomes available will remain in the internal buffer.
             *
             * ```js
             * const readable = getReadableStreamSomehow();
             * readable.on('data', (chunk) => {
             *   console.log(`Received ${chunk.length} bytes of data.`);
             *   readable.pause();
             *   console.log('There will be no additional data for 1 second.');
             *   setTimeout(() => {
             *     console.log('Now data will start flowing again.');
             *     readable.resume();
             *   }, 1000);
             * });
             * ```
             *
             * The `readable.pause()` method has no effect if there is a `'readable'` event listener.
             * @since v0.9.4
             */
            pause(): this;
            /**
             * The `readable.resume()` method causes an explicitly paused `Readable` stream to
             * resume emitting `'data'` events, switching the stream into flowing mode.
             *
             * The `readable.resume()` method can be used to fully consume the data from a
             * stream without actually processing any of that data:
             *
             * ```js
             * getReadableStreamSomehow()
             *   .resume()
             *   .on('end', () => {
             *     console.log('Reached the end, but did not read anything.');
             *   });
             * ```
             *
             * The `readable.resume()` method has no effect if there is a `'readable'` event listener.
             * @since v0.9.4
             */
            resume(): this;
            /**
             * The `readable.isPaused()` method returns the current operating state of the `Readable`.
             * This is used primarily by the mechanism that underlies the `readable.pipe()` method.
             * In most typical cases, there will be no reason to use this method directly.
             *
             * ```js
             * const readable = new stream.Readable();
             *
             * readable.isPaused(); // === false
             * readable.pause();
             * readable.isPaused(); // === true
             * readable.resume();
             * readable.isPaused(); // === false
             * ```
             * @since v0.11.14
             */
            isPaused(): boolean;
            /**
             * The `readable.unpipe()` method detaches a `Writable` stream previously attached
             * using the {@link pipe} method.
             *
             * If the `destination` is not specified, then _all_ pipes are detached.
             *
             * If the `destination` is specified, but no pipe is set up for it, then
             * the method does nothing.
             *
             * ```js
             * import fs from 'node:fs';
             * const readable = getReadableStreamSomehow();
             * const writable = fs.createWriteStream('file.txt');
             * // All the data from readable goes into 'file.txt',
             * // but only for the first second.
             * readable.pipe(writable);
             * setTimeout(() => {
             *   console.log('Stop writing to file.txt.');
             *   readable.unpipe(writable);
             *   console.log('Manually close the file stream.');
             *   writable.end();
             * }, 1000);
             * ```
             * @since v0.9.4
             * @param destination Optional specific stream to unpipe
             */
            unpipe(destination?: NodeJS.WritableStream): this;
            /**
             * Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the
             * same as `readable.push(null)`, after which no more data can be written. The EOF
             * signal is put at the end of the buffer and any buffered data will still be
             * flushed.
             *
             * The `readable.unshift()` method pushes a chunk of data back into the internal
             * buffer. This is useful in certain situations where a stream is being consumed by
             * code that needs to "un-consume" some amount of data that it has optimistically
             * pulled out of the source, so that the data can be passed on to some other party.
             *
             * The `stream.unshift(chunk)` method cannot be called after the `'end'` event
             * has been emitted or a runtime error will be thrown.
             *
             * Developers using `stream.unshift()` often should consider switching to
             * use of a `Transform` stream instead. See the `API for stream implementers` section for more information.
             *
             * ```js
             * // Pull off a header delimited by \n\n.
             * // Use unshift() if we get too much.
             * // Call the callback with (error, header, stream).
             * import { StringDecoder } from 'node:string_decoder';
             * function parseHeader(stream, callback) {
             *   stream.on('error', callback);
             *   stream.on('readable', onReadable);
             *   const decoder = new StringDecoder('utf8');
             *   let header = '';
             *   function onReadable() {
             *     let chunk;
             *     while (null !== (chunk = stream.read())) {
             *       const str = decoder.write(chunk);
             *       if (str.includes('\n\n')) {
             *         // Found the header boundary.
             *         const split = str.split(/\n\n/);
             *         header += split.shift();
             *         const remaining = split.join('\n\n');
             *         const buf = Buffer.from(remaining, 'utf8');
             *         stream.removeListener('error', callback);
             *         // Remove the 'readable' listener before unshifting.
             *         stream.removeListener('readable', onReadable);
             *         if (buf.length)
             *           stream.unshift(buf);
             *         // Now the body of the message can be read from the stream.
             *         callback(null, header, stream);
             *         return;
             *       }
             *       // Still reading the header.
             *       header += str;
             *     }
             *   }
             * }
             * ```
             *
             * Unlike {@link push}, `stream.unshift(chunk)` will not
             * end the reading process by resetting the internal reading state of the stream.
             * This can cause unexpected results if `readable.unshift()` is called during a
             * read (i.e. from within a {@link _read} implementation on a
             * custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,
             * however it is best to simply avoid calling `readable.unshift()` while in the
             * process of performing a read.
             * @since v0.9.11
             * @param chunk Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must
             * be a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value.
             * @param encoding Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`.
             */
            unshift(chunk: any, encoding?: BufferEncoding): void;
            /**
             * Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more
             * information.)
             *
             * When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`
             * stream that uses
             * the old stream as its data source.
             *
             * It will rarely be necessary to use `readable.wrap()` but the method has been
             * provided as a convenience for interacting with older Node.js applications and
             * libraries.
             *
             * ```js
             * import { OldReader } from './old-api-module.js';
             * import { Readable } from 'node:stream';
             * const oreader = new OldReader();
             * const myReader = new Readable().wrap(oreader);
             *
             * myReader.on('readable', () => {
             *   myReader.read(); // etc.
             * });
             * ```
             * @since v0.9.4
             * @param stream An "old style" readable stream
             */
            wrap(stream: NodeJS.ReadableStream): this;
            push(chunk: any, encoding?: BufferEncoding): boolean;
            /**
             * The iterator created by this method gives users the option to cancel the destruction
             * of the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,
             * or if the iterator should destroy the stream if the stream emitted an error during iteration.
             * @since v16.3.0
             * @param options.destroyOnReturn When set to `false`, calling `return` on the async iterator,
             * or exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.
             * **Default: `true`**.
             */
            iterator(options?: { destroyOnReturn?: boolean }): NodeJS.AsyncIterator<any>;
            /**
             * This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.
             * If the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.
             * @since v17.4.0, v16.14.0
             * @param fn a function to map over every chunk in the stream. Async or not.
             * @returns a stream mapped with the function *fn*.
             */
            map(fn: (data: any, options?: Pick<ArrayOptions, "signal">) => any, options?: ArrayOptions): Readable;
            /**
             * This method allows filtering the stream. For each chunk in the stream the *fn* function will be called
             * and if it returns a truthy value, the chunk will be passed to the result stream.
             * If the *fn* function returns a promise - that promise will be `await`ed.
             * @since v17.4.0, v16.14.0
             * @param fn a function to filter chunks from the stream. Async or not.
             * @returns a stream filtered with the predicate *fn*.
             */
            filter(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,
                options?: ArrayOptions,
            ): Readable;
            /**
             * This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.
             * If the *fn* function returns a promise - that promise will be `await`ed.
             *
             * This method is different from `for await...of` loops in that it can optionally process chunks concurrently.
             * In addition, a `forEach` iteration can only be stopped by having passed a `signal` option
             * and aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.
             * In either case the stream will be destroyed.
             *
             * This method is different from listening to the `'data'` event in that it uses the `readable` event
             * in the underlying machinary and can limit the number of concurrent *fn* calls.
             * @since v17.5.0
             * @param fn a function to call on each chunk of the stream. Async or not.
             * @returns a promise for when the stream has finished.
             */
            forEach(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => void | Promise<void>,
                options?: ArrayOptions,
            ): Promise<void>;
            /**
             * This method allows easily obtaining the contents of a stream.
             *
             * As this method reads the entire stream into memory, it negates the benefits of streams. It's intended
             * for interoperability and convenience, not as the primary way to consume streams.
             * @since v17.5.0
             * @returns a promise containing an array with the contents of the stream.
             */
            toArray(options?: Pick<ArrayOptions, "signal">): Promise<any[]>;
            /**
             * This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream
             * until the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk
             * `await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.
             * If none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.
             * @since v17.5.0
             * @param fn a function to call on each chunk of the stream. Async or not.
             * @returns a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.
             */
            some(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,
                options?: ArrayOptions,
            ): Promise<boolean>;
            /**
             * This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream
             * to find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,
             * the stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.
             * If all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.
             * @since v17.5.0
             * @param fn a function to call on each chunk of the stream. Async or not.
             * @returns a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,
             * or `undefined` if no element was found.
             */
            find<T>(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => data is T,
                options?: ArrayOptions,
            ): Promise<T | undefined>;
            find(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,
                options?: ArrayOptions,
            ): Promise<any>;
            /**
             * This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream
             * to check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk
             * `await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.
             * If all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.
             * @since v17.5.0
             * @param fn a function to call on each chunk of the stream. Async or not.
             * @returns a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.
             */
            every(
                fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,
                options?: ArrayOptions,
            ): Promise<boolean>;
            /**
             * This method returns a new stream by applying the given callback to each chunk of the stream
             * and then flattening the result.
             *
             * It is possible to return a stream or another iterable or async iterable from *fn* and the result streams
             * will be merged (flattened) into the returned stream.
             * @since v17.5.0
             * @param fn a function to map over every chunk in the stream. May be async. May be a stream or generator.
             * @returns a stream flat-mapped with the function *fn*.
             */
            flatMap(fn: (data: any, options?: Pick<ArrayOptions, "signal">) => any, options?: ArrayOptions): Readable;
            /**
             * This method returns a new stream with the first *limit* chunks dropped from the start.
             * @since v17.5.0
             * @param limit the number of chunks to drop from the readable.
             * @returns a stream with *limit* chunks dropped from the start.
             */
            drop(limit: number, options?: Pick<ArrayOptions, "signal">): Readable;
            /**
             * This method returns a new stream with the first *limit* chunks.
             * @since v17.5.0
             * @param limit the number of chunks to take from the readable.
             * @returns a stream with *limit* chunks taken.
             */
            take(limit: number, options?: Pick<ArrayOptions, "signal">): Readable;
            /**
             * This method returns a new stream with chunks of the underlying stream paired with a counter
             * in the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.
             * @since v17.5.0
             * @returns a stream of indexed pairs.
             */
            asIndexedPairs(options?: Pick<ArrayOptions, "signal">): Readable;
            /**
             * This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation
             * on the previous element. It returns a promise for the final value of the reduction.
             *
             * If no *initial* value is supplied the first chunk of the stream is used as the initial value.
             * If the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.
             *
             * The reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter
             * or parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.
             * @since v17.5.0
             * @param fn a reducer function to call over every chunk in the stream. Async or not.
             * @param initial the initial value to use in the reduction.
             * @returns a promise for the final value of the reduction.
             */
            reduce<T = any>(
                fn: (previous: any, data: any, options?: Pick<ArrayOptions, "signal">) => T,
                initial?: undefined,
                options?: Pick<ArrayOptions, "signal">,
            ): Promise<T>;
            reduce<T = any>(
                fn: (previous: T, data: any, options?: Pick<ArrayOptions, "signal">) => T,
                initial: T,
                options?: Pick<ArrayOptions, "signal">,
            ): Promise<T>;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            /**
             * Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the readable
             * stream will release any internal resources and subsequent calls to `push()` will be ignored.
             *
             * Once `destroy()` has been called any further calls will be a no-op and no
             * further errors except from `_destroy()` may be emitted as `'error'`.
             *
             * Implementors should not override this method, but instead implement `readable._destroy()`.
             * @since v8.0.0
             * @param error Error which will be passed as payload in `'error'` event
             */
            destroy(error?: Error): this;
            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. data
             * 3. end
             * 4. error
             * 5. pause
             * 6. readable
             * 7. resume
             */
            addListener(event: "close", listener: () => void): this;
            addListener(event: "data", listener: (chunk: any) => void): this;
            addListener(event: "end", listener: () => void): this;
            addListener(event: "error", listener: (err: Error) => void): this;
            addListener(event: "pause", listener: () => void): this;
            addListener(event: "readable", listener: () => void): this;
            addListener(event: "resume", listener: () => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;
            emit(event: "close"): boolean;
            emit(event: "data", chunk: any): boolean;
            emit(event: "end"): boolean;
            emit(event: "error", err: Error): boolean;
            emit(event: "pause"): boolean;
            emit(event: "readable"): boolean;
            emit(event: "resume"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;
            on(event: "close", listener: () => void): this;
            on(event: "data", listener: (chunk: any) => void): this;
            on(event: "end", listener: () => void): this;
            on(event: "error", listener: (err: Error) => void): this;
            on(event: "pause", listener: () => void): this;
            on(event: "readable", listener: () => void): this;
            on(event: "resume", listener: () => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;
            once(event: "close", listener: () => void): this;
            once(event: "data", listener: (chunk: any) => void): this;
            once(event: "end", listener: () => void): this;
            once(event: "error", listener: (err: Error) => void): this;
            once(event: "pause", listener: () => void): this;
            once(event: "readable", listener: () => void): this;
            once(event: "resume", listener: () => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;
            prependListener(event: "close", listener: () => void): this;
            prependListener(event: "data", listener: (chunk: any) => void): this;
            prependListener(event: "end", listener: () => void): this;
            prependListener(event: "error", listener: (err: Error) => void): this;
            prependListener(event: "pause", listener: () => void): this;
            prependListener(event: "readable", listener: () => void): this;
            prependListener(event: "resume", listener: () => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
            prependOnceListener(event: "close", listener: () => void): this;
            prependOnceListener(event: "data", listener: (chunk: any) => void): this;
            prependOnceListener(event: "end", listener: () => void): this;
            prependOnceListener(event: "error", listener: (err: Error) => void): this;
            prependOnceListener(event: "pause", listener: () => void): this;
            prependOnceListener(event: "readable", listener: () => void): this;
            prependOnceListener(event: "resume", listener: () => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
            removeListener(event: "close", listener: () => void): this;
            removeListener(event: "data", listener: (chunk: any) => void): this;
            removeListener(event: "end", listener: () => void): this;
            removeListener(event: "error", listener: (err: Error) => void): this;
            removeListener(event: "pause", listener: () => void): this;
            removeListener(event: "readable", listener: () => void): this;
            removeListener(event: "resume", listener: () => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
            [Symbol.asyncIterator](): NodeJS.AsyncIterator<any>;
            /**
             * Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.
             * @since v20.4.0
             */
            [Symbol.asyncDispose](): Promise<void>;
        }
        interface WritableOptions<T extends Writable = Writable> extends StreamOptions<T> {
            decodeStrings?: boolean | undefined;
            defaultEncoding?: BufferEncoding | undefined;
            write?(
                this: T,
                chunk: any,
                encoding: BufferEncoding,
                callback: (error?: Error | null) => void,
            ): void;
            writev?(
                this: T,
                chunks: Array<{
                    chunk: any;
                    encoding: BufferEncoding;
                }>,
                callback: (error?: Error | null) => void,
            ): void;
            final?(this: T, callback: (error?: Error | null) => void): void;
        }
        /**
         * @since v0.9.4
         */
        class Writable extends Stream implements NodeJS.WritableStream {
            /**
             * A utility method for creating a `Writable` from a web `WritableStream`.
             * @since v17.0.0
             */
            static fromWeb(
                writableStream: streamWeb.WritableStream,
                options?: Pick<WritableOptions, "decodeStrings" | "highWaterMark" | "objectMode" | "signal">,
            ): Writable;
            /**
             * A utility method for creating a web `WritableStream` from a `Writable`.
             * @since v17.0.0
             */
            static toWeb(streamWritable: Writable): streamWeb.WritableStream;
            /**
             * Is `true` if it is safe to call `writable.write()`, which means
             * the stream has not been destroyed, errored, or ended.
             * @since v11.4.0
             */
            readonly writable: boolean;
            /**
             * Returns whether the stream was destroyed or errored before emitting `'finish'`.
             * @since v18.0.0, v16.17.0
             */
            readonly writableAborted: boolean;
            /**
             * Is `true` after `writable.end()` has been called. This property
             * does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.
             * @since v12.9.0
             */
            readonly writableEnded: boolean;
            /**
             * Is set to `true` immediately before the `'finish'` event is emitted.
             * @since v12.6.0
             */
            readonly writableFinished: boolean;
            /**
             * Return the value of `highWaterMark` passed when creating this `Writable`.
             * @since v9.3.0
             */
            readonly writableHighWaterMark: number;
            /**
             * This property contains the number of bytes (or objects) in the queue
             * ready to be written. The value provides introspection data regarding
             * the status of the `highWaterMark`.
             * @since v9.4.0
             */
            readonly writableLength: number;
            /**
             * Getter for the property `objectMode` of a given `Writable` stream.
             * @since v12.3.0
             */
            readonly writableObjectMode: boolean;
            /**
             * Number of times `writable.uncork()` needs to be
             * called in order to fully uncork the stream.
             * @since v13.2.0, v12.16.0
             */
            readonly writableCorked: number;
            /**
             * Is `true` after `writable.destroy()` has been called.
             * @since v8.0.0
             */
            destroyed: boolean;
            /**
             * Is `true` after `'close'` has been emitted.
             * @since v18.0.0
             */
            readonly closed: boolean;
            /**
             * Returns error if the stream has been destroyed with an error.
             * @since v18.0.0
             */
            readonly errored: Error | null;
            /**
             * Is `true` if the stream's buffer has been full and stream will emit `'drain'`.
             * @since v15.2.0, v14.17.0
             */
            readonly writableNeedDrain: boolean;
            constructor(opts?: WritableOptions);
            _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;
            _writev?(
                chunks: Array<{
                    chunk: any;
                    encoding: BufferEncoding;
                }>,
                callback: (error?: Error | null) => void,
            ): void;
            _construct?(callback: (error?: Error | null) => void): void;
            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
            _final(callback: (error?: Error | null) => void): void;
            /**
             * The `writable.write()` method writes some data to the stream, and calls the
             * supplied `callback` once the data has been fully handled. If an error
             * occurs, the `callback` will be called with the error as its
             * first argument. The `callback` is called asynchronously and before `'error'` is
             * emitted.
             *
             * The return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.
             * If `false` is returned, further attempts to write data to the stream should
             * stop until the `'drain'` event is emitted.
             *
             * While a stream is not draining, calls to `write()` will buffer `chunk`, and
             * return false. Once all currently buffered chunks are drained (accepted for
             * delivery by the operating system), the `'drain'` event will be emitted.
             * Once `write()` returns false, do not write more chunks
             * until the `'drain'` event is emitted. While calling `write()` on a stream that
             * is not draining is allowed, Node.js will buffer all written chunks until
             * maximum memory usage occurs, at which point it will abort unconditionally.
             * Even before it aborts, high memory usage will cause poor garbage collector
             * performance and high RSS (which is not typically released back to the system,
             * even after the memory is no longer required). Since TCP sockets may never
             * drain if the remote peer does not read the data, writing a socket that is
             * not draining may lead to a remotely exploitable vulnerability.
             *
             * Writing data while the stream is not draining is particularly
             * problematic for a `Transform`, because the `Transform` streams are paused
             * by default until they are piped or a `'data'` or `'readable'` event handler
             * is added.
             *
             * If the data to be written can be generated or fetched on demand, it is
             * recommended to encapsulate the logic into a `Readable` and use {@link pipe}. However, if calling `write()` is preferred, it is
             * possible to respect backpressure and avoid memory issues using the `'drain'` event:
             *
             * ```js
             * function write(data, cb) {
             *   if (!stream.write(data)) {
             *     stream.once('drain', cb);
             *   } else {
             *     process.nextTick(cb);
             *   }
             * }
             *
             * // Wait for cb to be called before doing any other write.
             * write('hello', () => {
             *   console.log('Write completed, do more writes now.');
             * });
             * ```
             *
             * A `Writable` stream in object mode will always ignore the `encoding` argument.
             * @since v0.9.4
             * @param chunk Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},
             * {TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`.
             * @param [encoding='utf8'] The encoding, if `chunk` is a string.
             * @param callback Callback for when this chunk of data is flushed.
             * @return `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
             */
            write(chunk: any, callback?: (error: Error | null | undefined) => void): boolean;
            write(chunk: any, encoding: BufferEncoding, callback?: (error: Error | null | undefined) => void): boolean;
            /**
             * The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.
             * @since v0.11.15
             * @param encoding The new default encoding
             */
            setDefaultEncoding(encoding: BufferEncoding): this;
            /**
             * Calling the `writable.end()` method signals that no more data will be written
             * to the `Writable`. The optional `chunk` and `encoding` arguments allow one
             * final additional chunk of data to be written immediately before closing the
             * stream.
             *
             * Calling the {@link write} method after calling {@link end} will raise an error.
             *
             * ```js
             * // Write 'hello, ' and then end with 'world!'.
             * import fs from 'node:fs';
             * const file = fs.createWriteStream('example.txt');
             * file.write('hello, ');
             * file.end('world!');
             * // Writing more now is not allowed!
             * ```
             * @since v0.9.4
             * @param chunk Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},
             * {TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`.
             * @param encoding The encoding if `chunk` is a string
             * @param callback Callback for when the stream is finished.
             */
            end(cb?: () => void): this;
            end(chunk: any, cb?: () => void): this;
            end(chunk: any, encoding: BufferEncoding, cb?: () => void): this;
            /**
             * The `writable.cork()` method forces all written data to be buffered in memory.
             * The buffered data will be flushed when either the {@link uncork} or {@link end} methods are called.
             *
             * The primary intent of `writable.cork()` is to accommodate a situation in which
             * several small chunks are written to the stream in rapid succession. Instead of
             * immediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them
             * all to `writable._writev()`, if present. This prevents a head-of-line blocking
             * situation where data is being buffered while waiting for the first small chunk
             * to be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.
             *
             * See also: `writable.uncork()`, `writable._writev()`.
             * @since v0.11.2
             */
            cork(): void;
            /**
             * The `writable.uncork()` method flushes all data buffered since {@link cork} was called.
             *
             * When using `writable.cork()` and `writable.uncork()` to manage the buffering
             * of writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event
             * loop phase.
             *
             * ```js
             * stream.cork();
             * stream.write('some ');
             * stream.write('data ');
             * process.nextTick(() => stream.uncork());
             * ```
             *
             * If the `writable.cork()` method is called multiple times on a stream, the
             * same number of calls to `writable.uncork()` must be called to flush the buffered
             * data.
             *
             * ```js
             * stream.cork();
             * stream.write('some ');
             * stream.cork();
             * stream.write('data ');
             * process.nextTick(() => {
             *   stream.uncork();
             *   // The data will not be flushed until uncork() is called a second time.
             *   stream.uncork();
             * });
             * ```
             *
             * See also: `writable.cork()`.
             * @since v0.11.2
             */
            uncork(): void;
            /**
             * Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the writable
             * stream has ended and subsequent calls to `write()` or `end()` will result in
             * an `ERR_STREAM_DESTROYED` error.
             * This is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.
             * Use `end()` instead of destroy if data should flush before close, or wait for
             * the `'drain'` event before destroying the stream.
             *
             * Once `destroy()` has been called any further calls will be a no-op and no
             * further errors except from `_destroy()` may be emitted as `'error'`.
             *
             * Implementors should not override this method,
             * but instead implement `writable._destroy()`.
             * @since v8.0.0
             * @param error Optional, an error to emit with `'error'` event.
             */
            destroy(error?: Error): this;
            /**
             * Event emitter
             * The defined events on documents including:
             * 1. close
             * 2. drain
             * 3. error
             * 4. finish
             * 5. pipe
             * 6. unpipe
             */
            addListener(event: "close", listener: () => void): this;
            addListener(event: "drain", listener: () => void): this;
            addListener(event: "error", listener: (err: Error) => void): this;
            addListener(event: "finish", listener: () => void): this;
            addListener(event: "pipe", listener: (src: Readable) => void): this;
            addListener(event: "unpipe", listener: (src: Readable) => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;
            emit(event: "close"): boolean;
            emit(event: "drain"): boolean;
            emit(event: "error", err: Error): boolean;
            emit(event: "finish"): boolean;
            emit(event: "pipe", src: Readable): boolean;
            emit(event: "unpipe", src: Readable): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;
            on(event: "close", listener: () => void): this;
            on(event: "drain", listener: () => void): this;
            on(event: "error", listener: (err: Error) => void): this;
            on(event: "finish", listener: () => void): this;
            on(event: "pipe", listener: (src: Readable) => void): this;
            on(event: "unpipe", listener: (src: Readable) => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;
            once(event: "close", listener: () => void): this;
            once(event: "drain", listener: () => void): this;
            once(event: "error", listener: (err: Error) => void): this;
            once(event: "finish", listener: () => void): this;
            once(event: "pipe", listener: (src: Readable) => void): this;
            once(event: "unpipe", listener: (src: Readable) => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;
            prependListener(event: "close", listener: () => void): this;
            prependListener(event: "drain", listener: () => void): this;
            prependListener(event: "error", listener: (err: Error) => void): this;
            prependListener(event: "finish", listener: () => void): this;
            prependListener(event: "pipe", listener: (src: Readable) => void): this;
            prependListener(event: "unpipe", listener: (src: Readable) => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
            prependOnceListener(event: "close", listener: () => void): this;
            prependOnceListener(event: "drain", listener: () => void): this;
            prependOnceListener(event: "error", listener: (err: Error) => void): this;
            prependOnceListener(event: "finish", listener: () => void): this;
            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;
            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
            removeListener(event: "close", listener: () => void): this;
            removeListener(event: "drain", listener: () => void): this;
            removeListener(event: "error", listener: (err: Error) => void): this;
            removeListener(event: "finish", listener: () => void): this;
            removeListener(event: "pipe", listener: (src: Readable) => void): this;
            removeListener(event: "unpipe", listener: (src: Readable) => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        }
        interface DuplexOptions<T extends Duplex = Duplex> extends ReadableOptions<T>, WritableOptions<T> {
            allowHalfOpen?: boolean | undefined;
            readableObjectMode?: boolean | undefined;
            writableObjectMode?: boolean | undefined;
            readableHighWaterMark?: number | undefined;
            writableHighWaterMark?: number | undefined;
            writableCorked?: number | undefined;
        }
        /**
         * Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.
         *
         * Examples of `Duplex` streams include:
         *
         * * `TCP sockets`
         * * `zlib streams`
         * * `crypto streams`
         * @since v0.9.4
         */
        class Duplex extends Stream implements NodeJS.ReadWriteStream {
            /**
             * If `false` then the stream will automatically end the writable side when the
             * readable side ends. Set initially by the `allowHalfOpen` constructor option,
             * which defaults to `true`.
             *
             * This can be changed manually to change the half-open behavior of an existing
             * `Duplex` stream instance, but must be changed before the `'end'` event is emitted.
             * @since v0.9.4
             */
            allowHalfOpen: boolean;
            constructor(opts?: DuplexOptions);
            /**
             * A utility method for creating duplex streams.
             *
             * - `Stream` converts writable stream into writable `Duplex` and readable stream
             *   to `Duplex`.
             * - `Blob` converts into readable `Duplex`.
             * - `string` converts into readable `Duplex`.
             * - `ArrayBuffer` converts into readable `Duplex`.
             * - `AsyncIterable` converts into a readable `Duplex`. Cannot yield `null`.
             * - `AsyncGeneratorFunction` converts into a readable/writable transform
             *   `Duplex`. Must take a source `AsyncIterable` as first parameter. Cannot yield
             *   `null`.
             * - `AsyncFunction` converts into a writable `Duplex`. Must return
             *   either `null` or `undefined`
             * - `Object ({ writable, readable })` converts `readable` and
             *   `writable` into `Stream` and then combines them into `Duplex` where the
             *   `Duplex` will write to the `writable` and read from the `readable`.
             * - `Promise` converts into readable `Duplex`. Value `null` is ignored.
             *
             * @since v16.8.0
             */
            static from(
                src:
                    | Stream
                    | NodeBlob
                    | ArrayBuffer
                    | string
                    | Iterable<any>
                    | AsyncIterable<any>
                    | AsyncGeneratorFunction
                    | Promise<any>
                    | Object,
            ): Duplex;
            /**
             * A utility method for creating a web `ReadableStream` and `WritableStream` from a `Duplex`.
             * @since v17.0.0
             */
            static toWeb(streamDuplex: Duplex): {
                readable: streamWeb.ReadableStream;
                writable: streamWeb.WritableStream;
            };
            /**
             * A utility method for creating a `Duplex` from a web `ReadableStream` and `WritableStream`.
             * @since v17.0.0
             */
            static fromWeb(
                duplexStream: {
                    readable: streamWeb.ReadableStream;
                    writable: streamWeb.WritableStream;
                },
                options?: Pick<
                    DuplexOptions,
                    "allowHalfOpen" | "decodeStrings" | "encoding" | "highWaterMark" | "objectMode" | "signal"
                >,
            ): Duplex;
            /**
             * Event emitter
             * The defined events on documents including:
             * 1.  close
             * 2.  data
             * 3.  drain
             * 4.  end
             * 5.  error
             * 6.  finish
             * 7.  pause
             * 8.  pipe
             * 9.  readable
             * 10. resume
             * 11. unpipe
             */
            addListener(event: "close", listener: () => void): this;
            addListener(event: "data", listener: (chunk: any) => void): this;
            addListener(event: "drain", listener: () => void): this;
            addListener(event: "end", listener: () => void): this;
            addListener(event: "error", listener: (err: Error) => void): this;
            addListener(event: "finish", listener: () => void): this;
            addListener(event: "pause", listener: () => void): this;
            addListener(event: "pipe", listener: (src: Readable) => void): this;
            addListener(event: "readable", listener: () => void): this;
            addListener(event: "resume", listener: () => void): this;
            addListener(event: "unpipe", listener: (src: Readable) => void): this;
            addListener(event: string | symbol, listener: (...args: any[]) => void): this;
            emit(event: "close"): boolean;
            emit(event: "data", chunk: any): boolean;
            emit(event: "drain"): boolean;
            emit(event: "end"): boolean;
            emit(event: "error", err: Error): boolean;
            emit(event: "finish"): boolean;
            emit(event: "pause"): boolean;
            emit(event: "pipe", src: Readable): boolean;
            emit(event: "readable"): boolean;
            emit(event: "resume"): boolean;
            emit(event: "unpipe", src: Readable): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;
            on(event: "close", listener: () => void): this;
            on(event: "data", listener: (chunk: any) => void): this;
            on(event: "drain", listener: () => void): this;
            on(event: "end", listener: () => void): this;
            on(event: "error", listener: (err: Error) => void): this;
            on(event: "finish", listener: () => void): this;
            on(event: "pause", listener: () => void): this;
            on(event: "pipe", listener: (src: Readable) => void): this;
            on(event: "readable", listener: () => void): this;
            on(event: "resume", listener: () => void): this;
            on(event: "unpipe", listener: (src: Readable) => void): this;
            on(event: string | symbol, listener: (...args: any[]) => void): this;
            once(event: "close", listener: () => void): this;
            once(event: "data", listener: (chunk: any) => void): this;
            once(event: "drain", listener: () => void): this;
            once(event: "end", listener: () => void): this;
            once(event: "error", listener: (err: Error) => void): this;
            once(event: "finish", listener: () => void): this;
            once(event: "pause", listener: () => void): this;
            once(event: "pipe", listener: (src: Readable) => void): this;
            once(event: "readable", listener: () => void): this;
            once(event: "resume", listener: () => void): this;
            once(event: "unpipe", listener: (src: Readable) => void): this;
            once(event: string | symbol, listener: (...args: any[]) => void): this;
            prependListener(event: "close", listener: () => void): this;
            prependListener(event: "data", listener: (chunk: any) => void): this;
            prependListener(event: "drain", listener: () => void): this;
            prependListener(event: "end", listener: () => void): this;
            prependListener(event: "error", listener: (err: Error) => void): this;
            prependListener(event: "finish", listener: () => void): this;
            prependListener(event: "pause", listener: () => void): this;
            prependListener(event: "pipe", listener: (src: Readable) => void): this;
            prependListener(event: "readable", listener: () => void): this;
            prependListener(event: "resume", listener: () => void): this;
            prependListener(event: "unpipe", listener: (src: Readable) => void): this;
            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
            prependOnceListener(event: "close", listener: () => void): this;
            prependOnceListener(event: "data", listener: (chunk: any) => void): this;
            prependOnceListener(event: "drain", listener: () => void): this;
            prependOnceListener(event: "end", listener: () => void): this;
            prependOnceListener(event: "error", listener: (err: Error) => void): this;
            prependOnceListener(event: "finish", listener: () => void): this;
            prependOnceListener(event: "pause", listener: () => void): this;
            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;
            prependOnceListener(event: "readable", listener: () => void): this;
            prependOnceListener(event: "resume", listener: () => void): this;
            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;
            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
            removeListener(event: "close", listener: () => void): this;
            removeListener(event: "data", listener: (chunk: any) => void): this;
            removeListener(event: "drain", listener: () => void): this;
            removeListener(event: "end", listener: () => void): this;
            removeListener(event: "error", listener: (err: Error) => void): this;
            removeListener(event: "finish", listener: () => void): this;
            removeListener(event: "pause", listener: () => void): this;
            removeListener(event: "pipe", listener: (src: Readable) => void): this;
            removeListener(event: "readable", listener: () => void): this;
            removeListener(event: "resume", listener: () => void): this;
            removeListener(event: "unpipe", listener: (src: Readable) => void): this;
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        }
        interface Duplex extends Readable, Writable {}
        /**
         * The utility function `duplexPair` returns an Array with two items,
         * each being a `Duplex` stream connected to the other side:
         *
         * ```js
         * const [ sideA, sideB ] = duplexPair();
         * ```
         *
         * Whatever is written to one stream is made readable on the other. It provides
         * behavior analogous to a network connection, where the data written by the client
         * becomes readable by the server, and vice-versa.
         *
         * The Duplex streams are symmetrical; one or the other may be used without any
         * difference in behavior.
         * @param options A value to pass to both {@link Duplex} constructors,
         * to set options such as buffering.
         * @since v22.6.0
         */
        function duplexPair(options?: DuplexOptions): [Duplex, Duplex];
        type TransformCallback = (error?: Error | null, data?: any) => void;
        interface TransformOptions<T extends Transform = Transform> extends DuplexOptions<T> {
            transform?(this: T, chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;
            flush?(this: T, callback: TransformCallback): void;
        }
        /**
         * Transform streams are `Duplex` streams where the output is in some way
         * related to the input. Like all `Duplex` streams, `Transform` streams
         * implement both the `Readable` and `Writable` interfaces.
         *
         * Examples of `Transform` streams include:
         *
         * * `zlib streams`
         * * `crypto streams`
         * @since v0.9.4
         */
        class Transform extends Duplex {
            constructor(opts?: TransformOptions);
            _transform(chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;
            _flush(callback: TransformCallback): void;
        }
        /**
         * The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is
         * primarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams.
         */
        class PassThrough extends Transform {}
        /**
         * A stream to attach a signal to.
         *
         * Attaches an AbortSignal to a readable or writeable stream. This lets code
         * control stream destruction using an `AbortController`.
         *
         * Calling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the
         * stream, and `controller.error(new AbortError())` for webstreams.
         *
         * ```js
         * import fs from 'node:fs';
         *
         * const controller = new AbortController();
         * const read = addAbortSignal(
         *   controller.signal,
         *   fs.createReadStream(('object.json')),
         * );
         * // Later, abort the operation closing the stream
         * controller.abort();
         * ```
         *
         * Or using an `AbortSignal` with a readable stream as an async iterable:
         *
         * ```js
         * const controller = new AbortController();
         * setTimeout(() => controller.abort(), 10_000); // set a timeout
         * const stream = addAbortSignal(
         *   controller.signal,
         *   fs.createReadStream(('object.json')),
         * );
         * (async () => {
         *   try {
         *     for await (const chunk of stream) {
         *       await process(chunk);
         *     }
         *   } catch (e) {
         *     if (e.name === 'AbortError') {
         *       // The operation was cancelled
         *     } else {
         *       throw e;
         *     }
         *   }
         * })();
         * ```
         *
         * Or using an `AbortSignal` with a ReadableStream:
         *
         * ```js
         * const controller = new AbortController();
         * const rs = new ReadableStream({
         *   start(controller) {
         *     controller.enqueue('hello');
         *     controller.enqueue('world');
         *     controller.close();
         *   },
         * });
         *
         * addAbortSignal(controller.signal, rs);
         *
         * finished(rs, (err) => {
         *   if (err) {
         *     if (err.name === 'AbortError') {
         *       // The operation was cancelled
         *     }
         *   }
         * });
         *
         * const reader = rs.getReader();
         *
         * reader.read().then(({ value, done }) => {
         *   console.log(value); // hello
         *   console.log(done); // false
         *   controller.abort();
         * });
         * ```
         * @since v15.4.0
         * @param signal A signal representing possible cancellation
         * @param stream A stream to attach a signal to.
         */
        function addAbortSignal<T extends Stream>(signal: AbortSignal, stream: T): T;
        /**
         * Returns the default highWaterMark used by streams.
         * Defaults to `65536` (64 KiB), or `16` for `objectMode`.
         * @since v19.9.0
         */
        function getDefaultHighWaterMark(objectMode: boolean): number;
        /**
         * Sets the default highWaterMark used by streams.
         * @since v19.9.0
         * @param value highWaterMark value
         */
        function setDefaultHighWaterMark(objectMode: boolean, value: number): void;
        interface FinishedOptions extends Abortable {
            error?: boolean | undefined;
            readable?: boolean | undefined;
            writable?: boolean | undefined;
        }
        /**
         * A readable and/or writable stream/webstream.
         *
         * A function to get notified when a stream is no longer readable, writable
         * or has experienced an error or a premature close event.
         *
         * ```js
         * import { finished } from 'node:stream';
         * import fs from 'node:fs';
         *
         * const rs = fs.createReadStream('archive.tar');
         *
         * finished(rs, (err) => {
         *   if (err) {
         *     console.error('Stream failed.', err);
         *   } else {
         *     console.log('Stream is done reading.');
         *   }
         * });
         *
         * rs.resume(); // Drain the stream.
         * ```
         *
         * Especially useful in error handling scenarios where a stream is destroyed
         * prematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.
         *
         * The `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v24.x/api/stream.html#streamfinishedstream-options).
         *
         * `stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been
         * invoked. The reason for this is so that unexpected `'error'` events (due to
         * incorrect stream implementations) do not cause unexpected crashes.
         * If this is unwanted behavior then the returned cleanup function needs to be
         * invoked in the callback:
         *
         * ```js
         * const cleanup = finished(rs, (err) => {
         *   cleanup();
         *   // ...
         * });
         * ```
         * @since v10.0.0
         * @param stream A readable and/or writable stream.
         * @param callback A callback function that takes an optional error argument.
         * @returns A cleanup function which removes all registered listeners.
         */
        function finished(
            stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,
            options: FinishedOptions,
            callback: (err?: NodeJS.ErrnoException | null) => void,
        ): () => void;
        function finished(
            stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,
            callback: (err?: NodeJS.ErrnoException | null) => void,
        ): () => void;
        namespace finished {
            function __promisify__(
                stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,
                options?: FinishedOptions,
            ): Promise<void>;
        }
        type PipelineSourceFunction<T> = () => Iterable<T> | AsyncIterable<T>;
        type PipelineSource<T> = Iterable<T> | AsyncIterable<T> | NodeJS.ReadableStream | PipelineSourceFunction<T>;
        type PipelineTransform<S extends PipelineTransformSource<any>, U> =
            | NodeJS.ReadWriteStream
            | ((
                source: S extends (...args: any[]) => Iterable<infer ST> | AsyncIterable<infer ST> ? AsyncIterable<ST>
                    : S,
            ) => AsyncIterable<U>);
        type PipelineTransformSource<T> = PipelineSource<T> | PipelineTransform<any, T>;
        type PipelineDestinationIterableFunction<T> = (source: AsyncIterable<T>) => AsyncIterable<any>;
        type PipelineDestinationPromiseFunction<T, P> = (source: AsyncIterable<T>) => Promise<P>;
        type PipelineDestination<S extends PipelineTransformSource<any>, P> = S extends
            PipelineTransformSource<infer ST> ?
                | NodeJS.WritableStream
                | PipelineDestinationIterableFunction<ST>
                | PipelineDestinationPromiseFunction<ST, P>
            : never;
        type PipelineCallback<S extends PipelineDestination<any, any>> = S extends
            PipelineDestinationPromiseFunction<any, infer P> ? (err: NodeJS.ErrnoException | null, value: P) => void
            : (err: NodeJS.ErrnoException | null) => void;
        type PipelinePromise<S extends PipelineDestination<any, any>> = S extends
            PipelineDestinationPromiseFunction<any, infer P> ? Promise<P> : Promise<void>;
        interface PipelineOptions {
            signal?: AbortSignal | undefined;
            end?: boolean | undefined;
        }
        /**
         * A module method to pipe between streams and generators forwarding errors and
         * properly cleaning up and provide a callback when the pipeline is complete.
         *
         * ```js
         * import { pipeline } from 'node:stream';
         * import fs from 'node:fs';
         * import zlib from 'node:zlib';
         *
         * // Use the pipeline API to easily pipe a series of streams
         * // together and get notified when the pipeline is fully done.
         *
         * // A pipeline to gzip a potentially huge tar file efficiently:
         *
         * pipeline(
         *   fs.createReadStream('archive.tar'),
         *   zlib.createGzip(),
         *   fs.createWriteStream('archive.tar.gz'),
         *   (err) => {
         *     if (err) {
         *       console.error('Pipeline failed.', err);
         *     } else {
         *       console.log('Pipeline succeeded.');
         *     }
         *   },
         * );
         * ```
         *
         * The `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v24.x/api/stream.html#streampipelinesource-transforms-destination-options).
         *
         * `stream.pipeline()` will call `stream.destroy(err)` on all streams except:
         *
         * * `Readable` streams which have emitted `'end'` or `'close'`.
         * * `Writable` streams which have emitted `'finish'` or `'close'`.
         *
         * `stream.pipeline()` leaves dangling event listeners on the streams
         * after the `callback` has been invoked. In the case of reuse of streams after
         * failure, this can cause event listener leaks and swallowed errors. If the last
         * stream is readable, dangling event listeners will be removed so that the last
         * stream can be consumed later.
         *
         * `stream.pipeline()` closes all the streams when an error is raised.
         * The `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior
         * once it would destroy the socket without sending the expected response.
         * See the example below:
         *
         * ```js
         * import fs from 'node:fs';
         * import http from 'node:http';
         * import { pipeline } from 'node:stream';
         *
         * const server = http.createServer((req, res) => {
         *   const fileStream = fs.createReadStream('./fileNotExist.txt');
         *   pipeline(fileStream, res, (err) => {
         *     if (err) {
         *       console.log(err); // No such file
         *       // this message can't be sent once `pipeline` already destroyed the socket
         *       return res.end('error!!!');
         *     }
         *   });
         * });
         * ```
         * @since v10.0.0
         * @param callback Called when the pipeline is fully done.
         */
        function pipeline<A extends PipelineSource<any>, B extends PipelineDestination<A, any>>(
            source: A,
            destination: B,
            callback: PipelineCallback<B>,
        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;
        function pipeline<
            A extends PipelineSource<any>,
            T1 extends PipelineTransform<A, any>,
            B extends PipelineDestination<T1, any>,
        >(
            source: A,
            transform1: T1,
            destination: B,
            callback: PipelineCallback<B>,
        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;
        function pipeline<
            A extends PipelineSource<any>,
            T1 extends PipelineTransform<A, any>,
            T2 extends PipelineTransform<T1, any>,
            B extends PipelineDestination<T2, any>,
        >(
            source: A,
            transform1: T1,
            transform2: T2,
            destination: B,
            callback: PipelineCallback<B>,
        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;
        function pipeline<
            A extends PipelineSource<any>,
            T1 extends PipelineTransform<A, any>,
            T2 extends PipelineTransform<T1, any>,
            T3 extends PipelineTransform<T2, any>,
            B extends PipelineDestination<T3, any>,
        >(
            source: A,
            transform1: T1,
            transform2: T2,
            transform3: T3,
            destination: B,
            callback: PipelineCallback<B>,
        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;
        function pipeline<
            A extends PipelineSource<any>,
            T1 extends PipelineTransform<A, any>,
            T2 extends PipelineTransform<T1, any>,
            T3 extends PipelineTransform<T2, any>,
            T4 extends PipelineTransform<T3, any>,
            B extends PipelineDestination<T4, any>,
        >(
            source: A,
            transform1: T1,
            transform2: T2,
            transform3: T3,
            transform4: T4,
            destination: B,
            callback: PipelineCallback<B>,
        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;
        function pipeline(
            streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,
            callback: (err: NodeJS.ErrnoException | null) => void,
        ): NodeJS.WritableStream;
        function pipeline(
            stream1: NodeJS.ReadableStream,
            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,
            ...streams: Array<
                NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException | null) => void)
            >
        ): NodeJS.WritableStream;
        namespace pipeline {
            function __promisify__<A extends PipelineSource<any>, B extends PipelineDestination<A, any>>(
                source: A,
                destination: B,
                options?: PipelineOptions,
            ): PipelinePromise<B>;
            function __promisify__<
                A extends PipelineSource<any>,
                T1 extends PipelineTransform<A, any>,
                B extends PipelineDestination<T1, any>,
            >(
                source: A,
                transform1: T1,
                destination: B,
                options?: PipelineOptions,
            ): PipelinePromise<B>;
            function __promisify__<
                A extends PipelineSource<any>,
                T1 extends PipelineTransform<A, any>,
                T2 extends PipelineTransform<T1, any>,
                B extends PipelineDestination<T2, any>,
            >(
                source: A,
                transform1: T1,
                transform2: T2,
                destination: B,
                options?: PipelineOptions,
            ): PipelinePromise<B>;
            function __promisify__<
                A extends PipelineSource<any>,
                T1 extends PipelineTransform<A, any>,
                T2 extends PipelineTransform<T1, any>,
                T3 extends PipelineTransform<T2, any>,
                B extends PipelineDestination<T3, any>,
            >(
                source: A,
                transform1: T1,
                transform2: T2,
                transform3: T3,
                destination: B,
                options?: PipelineOptions,
            ): PipelinePromise<B>;
            function __promisify__<
                A extends PipelineSource<any>,
                T1 extends PipelineTransform<A, any>,
                T2 extends PipelineTransform<T1, any>,
                T3 extends PipelineTransform<T2, any>,
                T4 extends PipelineTransform<T3, any>,
                B extends PipelineDestination<T4, any>,
            >(
                source: A,
                transform1: T1,
                transform2: T2,
                transform3: T3,
                transform4: T4,
                destination: B,
                options?: PipelineOptions,
            ): PipelinePromise<B>;
            function __promisify__(
                streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,
                options?: PipelineOptions,
            ): Promise<void>;
            function __promisify__(
                stream1: NodeJS.ReadableStream,
                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,
                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | PipelineOptions>
            ): Promise<void>;
        }
        interface Pipe {
            close(): void;
            hasRef(): boolean;
            ref(): void;
            unref(): void;
        }
        /**
         * Returns whether the stream has encountered an error.
         * @since v17.3.0, v16.14.0
         */
        function isErrored(stream: Readable | Writable | NodeJS.ReadableStream | NodeJS.WritableStream): boolean;
        /**
         * Returns whether the stream is readable.
         * @since v17.4.0, v16.14.0
         */
        function isReadable(stream: Readable | NodeJS.ReadableStream): boolean;
    }
    export = Stream;
}
declare module "node:stream" {
    import stream = require("stream");
    export = stream;
}


---

File name: node_modules\@types\node\string_decoder.d.ts

Code:
/**
 * The `node:string_decoder` module provides an API for decoding `Buffer` objects
 * into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16
 * characters. It can be accessed using:
 *
 * ```js
 * import { StringDecoder } from 'node:string_decoder';
 * ```
 *
 * The following example shows the basic use of the `StringDecoder` class.
 *
 * ```js
 * import { StringDecoder } from 'node:string_decoder';
 * const decoder = new StringDecoder('utf8');
 *
 * const cent = Buffer.from([0xC2, 0xA2]);
 * console.log(decoder.write(cent)); // Prints: 
 *
 * const euro = Buffer.from([0xE2, 0x82, 0xAC]);
 * console.log(decoder.write(euro)); // Prints: 
 * ```
 *
 * When a `Buffer` instance is written to the `StringDecoder` instance, an
 * internal buffer is used to ensure that the decoded string does not contain
 * any incomplete multibyte characters. These are held in the buffer until the
 * next call to `stringDecoder.write()` or until `stringDecoder.end()` is called.
 *
 * In the following example, the three UTF-8 encoded bytes of the European Euro
 * symbol (``) are written over three separate operations:
 *
 * ```js
 * import { StringDecoder } from 'node:string_decoder';
 * const decoder = new StringDecoder('utf8');
 *
 * decoder.write(Buffer.from([0xE2]));
 * decoder.write(Buffer.from([0x82]));
 * console.log(decoder.end(Buffer.from([0xAC]))); // Prints: 
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/string_decoder.js)
 */
declare module "string_decoder" {
    class StringDecoder {
        constructor(encoding?: BufferEncoding);
        /**
         * Returns a decoded string, ensuring that any incomplete multibyte characters at
         * the end of the `Buffer`, or `TypedArray`, or `DataView` are omitted from the
         * returned string and stored in an internal buffer for the next call to `stringDecoder.write()` or `stringDecoder.end()`.
         * @since v0.1.99
         * @param buffer The bytes to decode.
         */
        write(buffer: string | Buffer | NodeJS.ArrayBufferView): string;
        /**
         * Returns any remaining input stored in the internal buffer as a string. Bytes
         * representing incomplete UTF-8 and UTF-16 characters will be replaced with
         * substitution characters appropriate for the character encoding.
         *
         * If the `buffer` argument is provided, one final call to `stringDecoder.write()` is performed before returning the remaining input.
         * After `end()` is called, the `stringDecoder` object can be reused for new input.
         * @since v0.9.3
         * @param buffer The bytes to decode.
         */
        end(buffer?: string | Buffer | NodeJS.ArrayBufferView): string;
    }
}
declare module "node:string_decoder" {
    export * from "string_decoder";
}


---

File name: node_modules\@types\node\test.d.ts

Code:
/**
 * The `node:test` module facilitates the creation of JavaScript tests.
 * To access it:
 *
 * ```js
 * import test from 'node:test';
 * ```
 *
 * This module is only available under the `node:` scheme. The following will not
 * work:
 *
 * ```js
 * import test from 'node:test';
 * ```
 *
 * Tests created via the `test` module consist of a single function that is
 * processed in one of three ways:
 *
 * 1. A synchronous function that is considered failing if it throws an exception,
 * and is considered passing otherwise.
 * 2. A function that returns a `Promise` that is considered failing if the `Promise` rejects, and is considered passing if the `Promise` fulfills.
 * 3. A function that receives a callback function. If the callback receives any
 * truthy value as its first argument, the test is considered failing. If a
 * falsy value is passed as the first argument to the callback, the test is
 * considered passing. If the test function receives a callback function and
 * also returns a `Promise`, the test will fail.
 *
 * The following example illustrates how tests are written using the `test` module.
 *
 * ```js
 * test('synchronous passing test', (t) => {
 *   // This test passes because it does not throw an exception.
 *   assert.strictEqual(1, 1);
 * });
 *
 * test('synchronous failing test', (t) => {
 *   // This test fails because it throws an exception.
 *   assert.strictEqual(1, 2);
 * });
 *
 * test('asynchronous passing test', async (t) => {
 *   // This test passes because the Promise returned by the async
 *   // function is settled and not rejected.
 *   assert.strictEqual(1, 1);
 * });
 *
 * test('asynchronous failing test', async (t) => {
 *   // This test fails because the Promise returned by the async
 *   // function is rejected.
 *   assert.strictEqual(1, 2);
 * });
 *
 * test('failing test using Promises', (t) => {
 *   // Promises can be used directly as well.
 *   return new Promise((resolve, reject) => {
 *     setImmediate(() => {
 *       reject(new Error('this will cause the test to fail'));
 *     });
 *   });
 * });
 *
 * test('callback passing test', (t, done) => {
 *   // done() is the callback function. When the setImmediate() runs, it invokes
 *   // done() with no arguments.
 *   setImmediate(done);
 * });
 *
 * test('callback failing test', (t, done) => {
 *   // When the setImmediate() runs, done() is invoked with an Error object and
 *   // the test fails.
 *   setImmediate(() => {
 *     done(new Error('callback failure'));
 *   });
 * });
 * ```
 *
 * If any tests fail, the process exit code is set to `1`.
 * @since v18.0.0, v16.17.0
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/test.js)
 */
declare module "node:test" {
    import { Readable } from "node:stream";
    /**
     * **Note:** `shard` is used to horizontally parallelize test running across
     * machines or processes, ideal for large-scale executions across varied
     * environments. It's incompatible with `watch` mode, tailored for rapid
     * code iteration by automatically rerunning tests on file changes.
     *
     * ```js
     * import { tap } from 'node:test/reporters';
     * import { run } from 'node:test';
     * import process from 'node:process';
     * import path from 'node:path';
     *
     * run({ files: [path.resolve('./tests/test.js')] })
     *   .compose(tap)
     *   .pipe(process.stdout);
     * ```
     * @since v18.9.0, v16.19.0
     * @param options Configuration options for running tests.
     */
    function run(options?: RunOptions): TestsStream;
    /**
     * The `test()` function is the value imported from the `test` module. Each
     * invocation of this function results in reporting the test to the `TestsStream`.
     *
     * The `TestContext` object passed to the `fn` argument can be used to perform
     * actions related to the current test. Examples include skipping the test, adding
     * additional diagnostic information, or creating subtests.
     *
     * `test()` returns a `Promise` that fulfills once the test completes.
     * if `test()` is called within a suite, it fulfills immediately.
     * The return value can usually be discarded for top level tests.
     * However, the return value from subtests should be used to prevent the parent
     * test from finishing first and cancelling the subtest
     * as shown in the following example.
     *
     * ```js
     * test('top level test', async (t) => {
     *   // The setTimeout() in the following subtest would cause it to outlive its
     *   // parent test if 'await' is removed on the next line. Once the parent test
     *   // completes, it will cancel any outstanding subtests.
     *   await t.test('longer running subtest', async (t) => {
     *     return new Promise((resolve, reject) => {
     *       setTimeout(resolve, 1000);
     *     });
     *   });
     * });
     * ```
     *
     * The `timeout` option can be used to fail the test if it takes longer than `timeout` milliseconds to complete. However, it is not a reliable mechanism for
     * canceling tests because a running test might block the application thread and
     * thus prevent the scheduled cancellation.
     * @since v18.0.0, v16.17.0
     * @param name The name of the test, which is displayed when reporting test results.
     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.
     * @param options Configuration options for the test.
     * @param fn The function under test. The first argument to this function is a {@link TestContext} object.
     * If the test uses callbacks, the callback function is passed as the second argument.
     * @return Fulfilled with `undefined` once the test completes, or immediately if the test runs within a suite.
     */
    function test(name?: string, fn?: TestFn): Promise<void>;
    function test(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(fn?: TestFn): Promise<void>;
    namespace test {
        export {
            after,
            afterEach,
            assert,
            before,
            beforeEach,
            describe,
            it,
            mock,
            only,
            run,
            skip,
            snapshot,
            suite,
            test,
            todo,
        };
    }
    /**
     * The `suite()` function is imported from the `node:test` module.
     * @param name The name of the suite, which is displayed when reporting test results.
     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.
     * @param options Configuration options for the suite. This supports the same options as {@link test}.
     * @param fn The suite function declaring nested tests and suites. The first argument to this function is a {@link SuiteContext} object.
     * @return Immediately fulfilled with `undefined`.
     * @since v20.13.0
     */
    function suite(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function suite(name?: string, fn?: SuiteFn): Promise<void>;
    function suite(options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function suite(fn?: SuiteFn): Promise<void>;
    namespace suite {
        /**
         * Shorthand for skipping a suite. This is the same as calling {@link suite} with `options.skip` set to `true`.
         * @since v20.13.0
         */
        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(name?: string, fn?: SuiteFn): Promise<void>;
        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link suite} with `options.todo` set to `true`.
         * @since v20.13.0
         */
        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(name?: string, fn?: SuiteFn): Promise<void>;
        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `only`. This is the same as calling {@link suite} with `options.only` set to `true`.
         * @since v20.13.0
         */
        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(name?: string, fn?: SuiteFn): Promise<void>;
        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(fn?: SuiteFn): Promise<void>;
    }
    /**
     * Alias for {@link suite}.
     *
     * The `describe()` function is imported from the `node:test` module.
     */
    function describe(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function describe(name?: string, fn?: SuiteFn): Promise<void>;
    function describe(options?: TestOptions, fn?: SuiteFn): Promise<void>;
    function describe(fn?: SuiteFn): Promise<void>;
    namespace describe {
        /**
         * Shorthand for skipping a suite. This is the same as calling {@link describe} with `options.skip` set to `true`.
         * @since v18.15.0
         */
        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(name?: string, fn?: SuiteFn): Promise<void>;
        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function skip(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link describe} with `options.todo` set to `true`.
         * @since v18.15.0
         */
        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(name?: string, fn?: SuiteFn): Promise<void>;
        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function todo(fn?: SuiteFn): Promise<void>;
        /**
         * Shorthand for marking a suite as `only`. This is the same as calling {@link describe} with `options.only` set to `true`.
         * @since v18.15.0
         */
        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(name?: string, fn?: SuiteFn): Promise<void>;
        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function only(fn?: SuiteFn): Promise<void>;
    }
    /**
     * Alias for {@link test}.
     *
     * The `it()` function is imported from the `node:test` module.
     * @since v18.6.0, v16.17.0
     */
    function it(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function it(name?: string, fn?: TestFn): Promise<void>;
    function it(options?: TestOptions, fn?: TestFn): Promise<void>;
    function it(fn?: TestFn): Promise<void>;
    namespace it {
        /**
         * Shorthand for skipping a test. This is the same as calling {@link it} with `options.skip` set to `true`.
         */
        function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(name?: string, fn?: TestFn): Promise<void>;
        function skip(options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(fn?: TestFn): Promise<void>;
        /**
         * Shorthand for marking a test as `TODO`. This is the same as calling {@link it} with `options.todo` set to `true`.
         */
        function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(name?: string, fn?: TestFn): Promise<void>;
        function todo(options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(fn?: TestFn): Promise<void>;
        /**
         * Shorthand for marking a test as `only`. This is the same as calling {@link it} with `options.only` set to `true`.
         * @since v18.15.0
         */
        function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(name?: string, fn?: TestFn): Promise<void>;
        function only(options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(fn?: TestFn): Promise<void>;
    }
    /**
     * Shorthand for skipping a test. This is the same as calling {@link test} with `options.skip` set to `true`.
     * @since v20.2.0
     */
    function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function skip(name?: string, fn?: TestFn): Promise<void>;
    function skip(options?: TestOptions, fn?: TestFn): Promise<void>;
    function skip(fn?: TestFn): Promise<void>;
    /**
     * Shorthand for marking a test as `TODO`. This is the same as calling {@link test} with `options.todo` set to `true`.
     * @since v20.2.0
     */
    function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function todo(name?: string, fn?: TestFn): Promise<void>;
    function todo(options?: TestOptions, fn?: TestFn): Promise<void>;
    function todo(fn?: TestFn): Promise<void>;
    /**
     * Shorthand for marking a test as `only`. This is the same as calling {@link test} with `options.only` set to `true`.
     * @since v20.2.0
     */
    function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function only(name?: string, fn?: TestFn): Promise<void>;
    function only(options?: TestOptions, fn?: TestFn): Promise<void>;
    function only(fn?: TestFn): Promise<void>;
    /**
     * The type of a function passed to {@link test}. The first argument to this function is a {@link TestContext} object.
     * If the test uses callbacks, the callback function is passed as the second argument.
     */
    type TestFn = (t: TestContext, done: (result?: any) => void) => void | Promise<void>;
    /**
     * The type of a suite test function. The argument to this function is a {@link SuiteContext} object.
     */
    type SuiteFn = (s: SuiteContext) => void | Promise<void>;
    interface TestShard {
        /**
         * A positive integer between 1 and `total` that specifies the index of the shard to run.
         */
        index: number;
        /**
         * A positive integer that specifies the total number of shards to split the test files to.
         */
        total: number;
    }
    interface RunOptions {
        /**
         * If a number is provided, then that many test processes would run in parallel, where each process corresponds to one test file.
         * If `true`, it would run `os.availableParallelism() - 1` test files in parallel. If `false`, it would only run one test file at a time.
         * @default false
         */
        concurrency?: number | boolean | undefined;
        /**
         * Specifies the current working directory to be used by the test runner.
         * Serves as the base path for resolving files according to the
         * [test runner execution model](https://nodejs.org/docs/latest-v24.x/api/test.html#test-runner-execution-model).
         * @since v23.0.0
         * @default process.cwd()
         */
        cwd?: string | undefined;
        /**
         * An array containing the list of files to run. If omitted, files are run according to the
         * [test runner execution model](https://nodejs.org/docs/latest-v24.x/api/test.html#test-runner-execution-model).
         */
        files?: readonly string[] | undefined;
        /**
         * Configures the test runner to exit the process once all known
         * tests have finished executing even if the event loop would
         * otherwise remain active.
         * @default false
         */
        forceExit?: boolean | undefined;
        /**
         * An array containing the list of glob patterns to match test files.
         * This option cannot be used together with `files`. If omitted, files are run according to the
         * [test runner execution model](https://nodejs.org/docs/latest-v24.x/api/test.html#test-runner-execution-model).
         * @since v22.6.0
         */
        globPatterns?: readonly string[] | undefined;
        /**
         * Sets inspector port of test child process.
         * This can be a number, or a function that takes no arguments and returns a
         * number. If a nullish value is provided, each process gets its own port,
         * incremented from the primary's `process.debugPort`. This option is ignored
         * if the `isolation` option is set to `'none'` as no child processes are
         * spawned.
         * @default undefined
         */
        inspectPort?: number | (() => number) | undefined;
        /**
         * Configures the type of test isolation. If set to
         * `'process'`, each test file is run in a separate child process. If set to
         * `'none'`, all test files run in the current process.
         * @default 'process'
         * @since v22.8.0
         */
        isolation?: "process" | "none" | undefined;
        /**
         * If truthy, the test context will only run tests that have the `only` option set
         */
        only?: boolean | undefined;
        /**
         * A function that accepts the `TestsStream` instance and can be used to setup listeners before any tests are run.
         * @default undefined
         */
        setup?: ((reporter: TestsStream) => void | Promise<void>) | undefined;
        /**
         * An array of CLI flags to pass to the `node` executable when
         * spawning the subprocesses. This option has no effect when `isolation` is `'none`'.
         * @since v22.10.0
         * @default []
         */
        execArgv?: readonly string[] | undefined;
        /**
         * An array of CLI flags to pass to each test file when spawning the
         * subprocesses. This option has no effect when `isolation` is `'none'`.
         * @since v22.10.0
         * @default []
         */
        argv?: readonly string[] | undefined;
        /**
         * Allows aborting an in-progress test execution.
         */
        signal?: AbortSignal | undefined;
        /**
         * If provided, only run tests whose name matches the provided pattern.
         * Strings are interpreted as JavaScript regular expressions.
         * @default undefined
         */
        testNamePatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
        /**
         * A String, RegExp or a RegExp Array, that can be used to exclude running tests whose
         * name matches the provided pattern. Test name patterns are interpreted as JavaScript
         * regular expressions. For each test that is executed, any corresponding test hooks,
         * such as `beforeEach()`, are also run.
         * @default undefined
         * @since v22.1.0
         */
        testSkipPatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
        /**
         * The number of milliseconds after which the test execution will fail.
         * If unspecified, subtests inherit this value from their parent.
         * @default Infinity
         */
        timeout?: number | undefined;
        /**
         * Whether to run in watch mode or not.
         * @default false
         */
        watch?: boolean | undefined;
        /**
         * Running tests in a specific shard.
         * @default undefined
         */
        shard?: TestShard | undefined;
        /**
         * enable [code coverage](https://nodejs.org/docs/latest-v24.x/api/test.html#collecting-code-coverage) collection.
         * @since v22.10.0
         * @default false
         */
        coverage?: boolean | undefined;
        /**
         * Excludes specific files from code coverage
         * using a glob pattern, which can match both absolute and relative file paths.
         * This property is only applicable when `coverage` was set to `true`.
         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,
         * files must meet **both** criteria to be included in the coverage report.
         * @since v22.10.0
         * @default undefined
         */
        coverageExcludeGlobs?: string | readonly string[] | undefined;
        /**
         * Includes specific files in code coverage
         * using a glob pattern, which can match both absolute and relative file paths.
         * This property is only applicable when `coverage` was set to `true`.
         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,
         * files must meet **both** criteria to be included in the coverage report.
         * @since v22.10.0
         * @default undefined
         */
        coverageIncludeGlobs?: string | readonly string[] | undefined;
        /**
         * Require a minimum percent of covered lines. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        lineCoverage?: number | undefined;
        /**
         * Require a minimum percent of covered branches. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        branchCoverage?: number | undefined;
        /**
         * Require a minimum percent of covered functions. If code
         * coverage does not reach the threshold specified, the process will exit with code `1`.
         * @since v22.10.0
         * @default 0
         */
        functionCoverage?: number | undefined;
    }
    /**
     * A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.
     *
     * Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.
     * @since v18.9.0, v16.19.0
     */
    class TestsStream extends Readable implements NodeJS.ReadableStream {
        addListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        addListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        addListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        addListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        addListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        addListener(event: "test:fail", listener: (data: TestFail) => void): this;
        addListener(event: "test:pass", listener: (data: TestPass) => void): this;
        addListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        addListener(event: "test:start", listener: (data: TestStart) => void): this;
        addListener(event: "test:stderr", listener: (data: TestStderr) => void): this;
        addListener(event: "test:stdout", listener: (data: TestStdout) => void): this;
        addListener(event: "test:summary", listener: (data: TestSummary) => void): this;
        addListener(event: "test:watch:drained", listener: () => void): this;
        addListener(event: string, listener: (...args: any[]) => void): this;
        emit(event: "test:coverage", data: TestCoverage): boolean;
        emit(event: "test:complete", data: TestComplete): boolean;
        emit(event: "test:dequeue", data: TestDequeue): boolean;
        emit(event: "test:diagnostic", data: DiagnosticData): boolean;
        emit(event: "test:enqueue", data: TestEnqueue): boolean;
        emit(event: "test:fail", data: TestFail): boolean;
        emit(event: "test:pass", data: TestPass): boolean;
        emit(event: "test:plan", data: TestPlan): boolean;
        emit(event: "test:start", data: TestStart): boolean;
        emit(event: "test:stderr", data: TestStderr): boolean;
        emit(event: "test:stdout", data: TestStdout): boolean;
        emit(event: "test:summary", data: TestSummary): boolean;
        emit(event: "test:watch:drained"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        on(event: "test:complete", listener: (data: TestComplete) => void): this;
        on(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        on(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        on(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        on(event: "test:fail", listener: (data: TestFail) => void): this;
        on(event: "test:pass", listener: (data: TestPass) => void): this;
        on(event: "test:plan", listener: (data: TestPlan) => void): this;
        on(event: "test:start", listener: (data: TestStart) => void): this;
        on(event: "test:stderr", listener: (data: TestStderr) => void): this;
        on(event: "test:stdout", listener: (data: TestStdout) => void): this;
        on(event: "test:summary", listener: (data: TestSummary) => void): this;
        on(event: "test:watch:drained", listener: () => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        once(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        once(event: "test:complete", listener: (data: TestComplete) => void): this;
        once(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        once(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        once(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        once(event: "test:fail", listener: (data: TestFail) => void): this;
        once(event: "test:pass", listener: (data: TestPass) => void): this;
        once(event: "test:plan", listener: (data: TestPlan) => void): this;
        once(event: "test:start", listener: (data: TestStart) => void): this;
        once(event: "test:stderr", listener: (data: TestStderr) => void): this;
        once(event: "test:stdout", listener: (data: TestStdout) => void): this;
        once(event: "test:summary", listener: (data: TestSummary) => void): this;
        once(event: "test:watch:drained", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        prependListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        prependListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        prependListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        prependListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        prependListener(event: "test:fail", listener: (data: TestFail) => void): this;
        prependListener(event: "test:pass", listener: (data: TestPass) => void): this;
        prependListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        prependListener(event: "test:start", listener: (data: TestStart) => void): this;
        prependListener(event: "test:stderr", listener: (data: TestStderr) => void): this;
        prependListener(event: "test:stdout", listener: (data: TestStdout) => void): this;
        prependListener(event: "test:summary", listener: (data: TestSummary) => void): this;
        prependListener(event: "test:watch:drained", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "test:coverage", listener: (data: TestCoverage) => void): this;
        prependOnceListener(event: "test:complete", listener: (data: TestComplete) => void): this;
        prependOnceListener(event: "test:dequeue", listener: (data: TestDequeue) => void): this;
        prependOnceListener(event: "test:diagnostic", listener: (data: DiagnosticData) => void): this;
        prependOnceListener(event: "test:enqueue", listener: (data: TestEnqueue) => void): this;
        prependOnceListener(event: "test:fail", listener: (data: TestFail) => void): this;
        prependOnceListener(event: "test:pass", listener: (data: TestPass) => void): this;
        prependOnceListener(event: "test:plan", listener: (data: TestPlan) => void): this;
        prependOnceListener(event: "test:start", listener: (data: TestStart) => void): this;
        prependOnceListener(event: "test:stderr", listener: (data: TestStderr) => void): this;
        prependOnceListener(event: "test:stdout", listener: (data: TestStdout) => void): this;
        prependOnceListener(event: "test:summary", listener: (data: TestSummary) => void): this;
        prependOnceListener(event: "test:watch:drained", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
    }
    /**
     * An instance of `TestContext` is passed to each test function in order to
     * interact with the test runner. However, the `TestContext` constructor is not
     * exposed as part of the API.
     * @since v18.0.0, v16.17.0
     */
    class TestContext {
        /**
         * An object containing assertion methods bound to the test context.
         * The top-level functions from the `node:assert` module are exposed here for the purpose of creating test plans.
         *
         * **Note:** Some of the functions from `node:assert` contain type assertions. If these are called via the
         * TestContext `assert` object, then the context parameter in the test's function signature **must be explicitly typed**
         * (ie. the parameter must have a type annotation), otherwise an error will be raised by the TypeScript compiler:
         * ```ts
         * import { test, type TestContext } from 'node:test';
         *
         * // The test function's context parameter must have a type annotation.
         * test('example', (t: TestContext) => {
         *   t.assert.deepStrictEqual(actual, expected);
         * });
         *
         * // Omitting the type annotation will result in a compilation error.
         * test('example', t => {
         *   t.assert.deepStrictEqual(actual, expected); // Error: 't' needs an explicit type annotation.
         * });
         * ```
         * @since v22.2.0, v20.15.0
         */
        readonly assert: TestContextAssert;
        /**
         * This function is used to create a hook running before subtest of the current test.
         * @param fn The hook function. The first argument to this function is a `TestContext` object.
         * If the hook uses callbacks, the callback function is passed as the second argument.
         * @param options Configuration options for the hook.
         * @since v20.1.0, v18.17.0
         */
        before(fn?: TestContextHookFn, options?: HookOptions): void;
        /**
         * This function is used to create a hook running before each subtest of the current test.
         * @param fn The hook function. The first argument to this function is a `TestContext` object.
         * If the hook uses callbacks, the callback function is passed as the second argument.
         * @param options Configuration options for the hook.
         * @since v18.8.0
         */
        beforeEach(fn?: TestContextHookFn, options?: HookOptions): void;
        /**
         * This function is used to create a hook that runs after the current test finishes.
         * @param fn The hook function. The first argument to this function is a `TestContext` object.
         * If the hook uses callbacks, the callback function is passed as the second argument.
         * @param options Configuration options for the hook.
         * @since v18.13.0
         */
        after(fn?: TestContextHookFn, options?: HookOptions): void;
        /**
         * This function is used to create a hook running after each subtest of the current test.
         * @param fn The hook function. The first argument to this function is a `TestContext` object.
         * If the hook uses callbacks, the callback function is passed as the second argument.
         * @param options Configuration options for the hook.
         * @since v18.8.0
         */
        afterEach(fn?: TestContextHookFn, options?: HookOptions): void;
        /**
         * This function is used to write diagnostics to the output. Any diagnostic
         * information is included at the end of the test's results. This function does
         * not return a value.
         *
         * ```js
         * test('top level test', (t) => {
         *   t.diagnostic('A diagnostic message');
         * });
         * ```
         * @since v18.0.0, v16.17.0
         * @param message Message to be reported.
         */
        diagnostic(message: string): void;
        /**
         * The absolute path of the test file that created the current test. If a test file imports
         * additional modules that generate tests, the imported tests will return the path of the root test file.
         * @since v22.6.0
         */
        readonly filePath: string | undefined;
        /**
         * The name of the test and each of its ancestors, separated by `>`.
         * @since v22.3.0
         */
        readonly fullName: string;
        /**
         * The name of the test.
         * @since v18.8.0, v16.18.0
         */
        readonly name: string;
        /**
         * This function is used to set the number of assertions and subtests that are expected to run
         * within the test. If the number of assertions and subtests that run does not match the
         * expected count, the test will fail.
         *
         * > Note: To make sure assertions are tracked, `t.assert` must be used instead of `assert` directly.
         *
         * ```js
         * test('top level test', (t) => {
         *   t.plan(2);
         *   t.assert.ok('some relevant assertion here');
         *   t.test('subtest', () => {});
         * });
         * ```
         *
         * When working with asynchronous code, the `plan` function can be used to ensure that the
         * correct number of assertions are run:
         *
         * ```js
         * test('planning with streams', (t, done) => {
         *   function* generate() {
         *     yield 'a';
         *     yield 'b';
         *     yield 'c';
         *   }
         *   const expected = ['a', 'b', 'c'];
         *   t.plan(expected.length);
         *   const stream = Readable.from(generate());
         *   stream.on('data', (chunk) => {
         *     t.assert.strictEqual(chunk, expected.shift());
         *   });
         *
         *   stream.on('end', () => {
         *     done();
         *   });
         * });
         * ```
         *
         * When using the `wait` option, you can control how long the test will wait for the expected assertions.
         * For example, setting a maximum wait time ensures that the test will wait for asynchronous assertions
         * to complete within the specified timeframe:
         *
         * ```js
         * test('plan with wait: 2000 waits for async assertions', (t) => {
         *   t.plan(1, { wait: 2000 }); // Waits for up to 2 seconds for the assertion to complete.
         *
         *   const asyncActivity = () => {
         *     setTimeout(() => {
         *          *       t.assert.ok(true, 'Async assertion completed within the wait time');
         *     }, 1000); // Completes after 1 second, within the 2-second wait time.
         *   };
         *
         *   asyncActivity(); // The test will pass because the assertion is completed in time.
         * });
         * ```
         *
         * Note: If a `wait` timeout is specified, it begins counting down only after the test function finishes executing.
         * @since v22.2.0
         */
        plan(count: number, options?: TestContextPlanOptions): void;
        /**
         * If `shouldRunOnlyTests` is truthy, the test context will only run tests that
         * have the `only` option set. Otherwise, all tests are run. If Node.js was not
         * started with the `--test-only` command-line option, this function is a
         * no-op.
         *
         * ```js
         * test('top level test', (t) => {
         *   // The test context can be set to run subtests with the 'only' option.
         *   t.runOnly(true);
         *   return Promise.all([
         *     t.test('this subtest is now skipped'),
         *     t.test('this subtest is run', { only: true }),
         *   ]);
         * });
         * ```
         * @since v18.0.0, v16.17.0
         * @param shouldRunOnlyTests Whether or not to run `only` tests.
         */
        runOnly(shouldRunOnlyTests: boolean): void;
        /**
         * ```js
         * test('top level test', async (t) => {
         *   await fetch('some/uri', { signal: t.signal });
         * });
         * ```
         * @since v18.7.0, v16.17.0
         */
        readonly signal: AbortSignal;
        /**
         * This function causes the test's output to indicate the test as skipped. If `message` is provided, it is included in the output. Calling `skip()` does
         * not terminate execution of the test function. This function does not return a
         * value.
         *
         * ```js
         * test('top level test', (t) => {
         *   // Make sure to return here as well if the test contains additional logic.
         *   t.skip('this is skipped');
         * });
         * ```
         * @since v18.0.0, v16.17.0
         * @param message Optional skip message.
         */
        skip(message?: string): void;
        /**
         * This function adds a `TODO` directive to the test's output. If `message` is
         * provided, it is included in the output. Calling `todo()` does not terminate
         * execution of the test function. This function does not return a value.
         *
         * ```js
         * test('top level test', (t) => {
         *   // This test is marked as `TODO`
         *   t.todo('this is a todo');
         * });
         * ```
         * @since v18.0.0, v16.17.0
         * @param message Optional `TODO` message.
         */
        todo(message?: string): void;
        /**
         * This function is used to create subtests under the current test. This function behaves in
         * the same fashion as the top level {@link test} function.
         * @since v18.0.0
         * @param name The name of the test, which is displayed when reporting test results.
         * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.
         * @param options Configuration options for the test.
         * @param fn The function under test. This first argument to this function is a {@link TestContext} object.
         * If the test uses callbacks, the callback function is passed as the second argument.
         * @returns A {@link Promise} resolved with `undefined` once the test completes.
         */
        test: typeof test;
        /**
         * This method polls a `condition` function until that function either returns
         * successfully or the operation times out.
         * @since v22.14.0
         * @param condition An assertion function that is invoked
         * periodically until it completes successfully or the defined polling timeout
         * elapses. Successful completion is defined as not throwing or rejecting. This
         * function does not accept any arguments, and is allowed to return any value.
         * @param options An optional configuration object for the polling operation.
         * @returns Fulfilled with the value returned by `condition`.
         */
        waitFor<T>(condition: () => T, options?: TestContextWaitForOptions): Promise<Awaited<T>>;
        /**
         * Each test provides its own MockTracker instance.
         */
        readonly mock: MockTracker;
    }
    interface TestContextAssert extends
        Pick<
            typeof import("assert"),
            | "deepEqual"
            | "deepStrictEqual"
            | "doesNotMatch"
            | "doesNotReject"
            | "doesNotThrow"
            | "equal"
            | "fail"
            | "ifError"
            | "match"
            | "notDeepEqual"
            | "notDeepStrictEqual"
            | "notEqual"
            | "notStrictEqual"
            | "ok"
            | "partialDeepStrictEqual"
            | "rejects"
            | "strictEqual"
            | "throws"
        >
    {
        /**
         * This function serializes `value` and writes it to the file specified by `path`.
         *
         * ```js
         * test('snapshot test with default serialization', (t) => {
         *   t.assert.fileSnapshot({ value1: 1, value2: 2 }, './snapshots/snapshot.json');
         * });
         * ```
         *
         * This function differs from `context.assert.snapshot()` in the following ways:
         *
         * * The snapshot file path is explicitly provided by the user.
         * * Each snapshot file is limited to a single snapshot value.
         * * No additional escaping is performed by the test runner.
         *
         * These differences allow snapshot files to better support features such as syntax
         * highlighting.
         * @since v22.14.0
         * @param value A value to serialize to a string. If Node.js was started with
         * the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--test-update-snapshots)
         * flag, the serialized value is written to
         * `path`. Otherwise, the serialized value is compared to the contents of the
         * existing snapshot file.
         * @param path The file where the serialized `value` is written.
         * @param options Optional configuration options.
         */
        fileSnapshot(value: any, path: string, options?: AssertSnapshotOptions): void;
        /**
         * This function implements assertions for snapshot testing.
         * ```js
         * test('snapshot test with default serialization', (t) => {
         *   t.assert.snapshot({ value1: 1, value2: 2 });
         * });
         *
         * test('snapshot test with custom serialization', (t) => {
         *   t.assert.snapshot({ value3: 3, value4: 4 }, {
         *     serializers: [(value) => JSON.stringify(value)]
         *   });
         * });
         * ```
         * @since v22.3.0
         * @param value A value to serialize to a string. If Node.js was started with
         * the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--test-update-snapshots)
         * flag, the serialized value is written to
         * the snapshot file. Otherwise, the serialized value is compared to the
         * corresponding value in the existing snapshot file.
         */
        snapshot(value: any, options?: AssertSnapshotOptions): void;
        /**
         * A custom assertion function registered with `assert.register()`.
         */
        [name: string]: (...args: any[]) => void;
    }
    interface AssertSnapshotOptions {
        /**
         * An array of synchronous functions used to serialize `value` into a string.
         * `value` is passed as the only argument to the first serializer function.
         * The return value of each serializer is passed as input to the next serializer.
         * Once all serializers have run, the resulting value is coerced to a string.
         *
         * If no serializers are provided, the test runner's default serializers are used.
         */
        serializers?: ReadonlyArray<(value: any) => any> | undefined;
    }
    interface TestContextPlanOptions {
        /**
         * The wait time for the plan:
         * * If `true`, the plan waits indefinitely for all assertions and subtests to run.
         * * If `false`, the plan performs an immediate check after the test function completes,
         * without waiting for any pending assertions or subtests.
         * Any assertions or subtests that complete after this check will not be counted towards the plan.
         * * If a number, it specifies the maximum wait time in milliseconds
         * before timing out while waiting for expected assertions and subtests to be matched.
         * If the timeout is reached, the test will fail.
         * @default false
         */
        wait?: boolean | number | undefined;
    }
    interface TestContextWaitForOptions {
        /**
         * The number of milliseconds to wait after an unsuccessful
         * invocation of `condition` before trying again.
         * @default 50
         */
        interval?: number | undefined;
        /**
         * The poll timeout in milliseconds. If `condition` has not
         * succeeded by the time this elapses, an error occurs.
         * @default 1000
         */
        timeout?: number | undefined;
    }

    /**
     * An instance of `SuiteContext` is passed to each suite function in order to
     * interact with the test runner. However, the `SuiteContext` constructor is not
     * exposed as part of the API.
     * @since v18.7.0, v16.17.0
     */
    class SuiteContext {
        /**
         * The absolute path of the test file that created the current suite. If a test file imports
         * additional modules that generate suites, the imported suites will return the path of the root test file.
         * @since v22.6.0
         */
        readonly filePath: string | undefined;
        /**
         * The name of the suite.
         * @since v18.8.0, v16.18.0
         */
        readonly name: string;
        /**
         * Can be used to abort test subtasks when the test has been aborted.
         * @since v18.7.0, v16.17.0
         */
        readonly signal: AbortSignal;
    }
    interface TestOptions {
        /**
         * If a number is provided, then that many tests would run in parallel.
         * If truthy, it would run (number of cpu cores - 1) tests in parallel.
         * For subtests, it will be `Infinity` tests in parallel.
         * If falsy, it would only run one test at a time.
         * If unspecified, subtests inherit this value from their parent.
         * @default false
         */
        concurrency?: number | boolean | undefined;
        /**
         * If truthy, and the test context is configured to run `only` tests, then this test will be
         * run. Otherwise, the test is skipped.
         * @default false
         */
        only?: boolean | undefined;
        /**
         * Allows aborting an in-progress test.
         * @since v18.8.0
         */
        signal?: AbortSignal | undefined;
        /**
         * If truthy, the test is skipped. If a string is provided, that string is displayed in the
         * test results as the reason for skipping the test.
         * @default false
         */
        skip?: boolean | string | undefined;
        /**
         * A number of milliseconds the test will fail after. If unspecified, subtests inherit this
         * value from their parent.
         * @default Infinity
         * @since v18.7.0
         */
        timeout?: number | undefined;
        /**
         * If truthy, the test marked as `TODO`. If a string is provided, that string is displayed in
         * the test results as the reason why the test is `TODO`.
         * @default false
         */
        todo?: boolean | string | undefined;
        /**
         * The number of assertions and subtests expected to be run in the test.
         * If the number of assertions run in the test does not match the number
         * specified in the plan, the test will fail.
         * @default undefined
         * @since v22.2.0
         */
        plan?: number | undefined;
    }
    /**
     * This function creates a hook that runs before executing a suite.
     *
     * ```js
     * describe('tests', async () => {
     *   before(() => console.log('about to run some test'));
     *   it('is a subtest', () => {
     *     assert.ok('some relevant assertion here');
     *   });
     * });
     * ```
     * @since v18.8.0, v16.18.0
     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.
     * @param options Configuration options for the hook.
     */
    function before(fn?: HookFn, options?: HookOptions): void;
    /**
     * This function creates a hook that runs after executing a suite.
     *
     * ```js
     * describe('tests', async () => {
     *   after(() => console.log('finished running tests'));
     *   it('is a subtest', () => {
     *     assert.ok('some relevant assertion here');
     *   });
     * });
     * ```
     * @since v18.8.0, v16.18.0
     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.
     * @param options Configuration options for the hook.
     */
    function after(fn?: HookFn, options?: HookOptions): void;
    /**
     * This function creates a hook that runs before each test in the current suite.
     *
     * ```js
     * describe('tests', async () => {
     *   beforeEach(() => console.log('about to run a test'));
     *   it('is a subtest', () => {
     *     assert.ok('some relevant assertion here');
     *   });
     * });
     * ```
     * @since v18.8.0, v16.18.0
     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.
     * @param options Configuration options for the hook.
     */
    function beforeEach(fn?: HookFn, options?: HookOptions): void;
    /**
     * This function creates a hook that runs after each test in the current suite.
     * The `afterEach()` hook is run even if the test fails.
     *
     * ```js
     * describe('tests', async () => {
     *   afterEach(() => console.log('finished running a test'));
     *   it('is a subtest', () => {
     *     assert.ok('some relevant assertion here');
     *   });
     * });
     * ```
     * @since v18.8.0, v16.18.0
     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.
     * @param options Configuration options for the hook.
     */
    function afterEach(fn?: HookFn, options?: HookOptions): void;
    /**
     * The hook function. The first argument is the context in which the hook is called.
     * If the hook uses callbacks, the callback function is passed as the second argument.
     */
    type HookFn = (c: TestContext | SuiteContext, done: (result?: any) => void) => any;
    /**
     * The hook function. The first argument is a `TestContext` object.
     * If the hook uses callbacks, the callback function is passed as the second argument.
     */
    type TestContextHookFn = (t: TestContext, done: (result?: any) => void) => any;
    /**
     * Configuration options for hooks.
     * @since v18.8.0
     */
    interface HookOptions {
        /**
         * Allows aborting an in-progress hook.
         */
        signal?: AbortSignal | undefined;
        /**
         * A number of milliseconds the hook will fail after. If unspecified, subtests inherit this
         * value from their parent.
         * @default Infinity
         */
        timeout?: number | undefined;
    }
    interface MockFunctionOptions {
        /**
         * The number of times that the mock will use the behavior of `implementation`.
         * Once the mock function has been called `times` times,
         * it will automatically restore the behavior of `original`.
         * This value must be an integer greater than zero.
         * @default Infinity
         */
        times?: number | undefined;
    }
    interface MockMethodOptions extends MockFunctionOptions {
        /**
         * If `true`, `object[methodName]` is treated as a getter.
         * This option cannot be used with the `setter` option.
         */
        getter?: boolean | undefined;
        /**
         * If `true`, `object[methodName]` is treated as a setter.
         * This option cannot be used with the `getter` option.
         */
        setter?: boolean | undefined;
    }
    type Mock<F extends Function> = F & {
        mock: MockFunctionContext<F>;
    };
    type NoOpFunction = (...args: any[]) => undefined;
    type FunctionPropertyNames<T> = {
        [K in keyof T]: T[K] extends Function ? K : never;
    }[keyof T];
    interface MockModuleOptions {
        /**
         * If false, each call to `require()` or `import()` generates a new mock module.
         * If true, subsequent calls will return the same module mock, and the mock module is inserted into the CommonJS cache.
         * @default false
         */
        cache?: boolean | undefined;
        /**
         * The value to use as the mocked module's default export.
         *
         * If this value is not provided, ESM mocks do not include a default export.
         * If the mock is a CommonJS or builtin module, this setting is used as the value of `module.exports`.
         * If this value is not provided, CJS and builtin mocks use an empty object as the value of `module.exports`.
         */
        defaultExport?: any;
        /**
         * An object whose keys and values are used to create the named exports of the mock module.
         *
         * If the mock is a CommonJS or builtin module, these values are copied onto `module.exports`.
         * Therefore, if a mock is created with both named exports and a non-object default export,
         * the mock will throw an exception when used as a CJS or builtin module.
         */
        namedExports?: object | undefined;
    }
    /**
     * The `MockTracker` class is used to manage mocking functionality. The test runner
     * module provides a top level `mock` export which is a `MockTracker` instance.
     * Each test also provides its own `MockTracker` instance via the test context's `mock` property.
     * @since v19.1.0, v18.13.0
     */
    class MockTracker {
        /**
         * This function is used to create a mock function.
         *
         * The following example creates a mock function that increments a counter by one
         * on each invocation. The `times` option is used to modify the mock behavior such
         * that the first two invocations add two to the counter instead of one.
         *
         * ```js
         * test('mocks a counting function', (t) => {
         *   let cnt = 0;
         *
         *   function addOne() {
         *     cnt++;
         *     return cnt;
         *   }
         *
         *   function addTwo() {
         *     cnt += 2;
         *     return cnt;
         *   }
         *
         *   const fn = t.mock.fn(addOne, addTwo, { times: 2 });
         *
         *   assert.strictEqual(fn(), 2);
         *   assert.strictEqual(fn(), 4);
         *   assert.strictEqual(fn(), 5);
         *   assert.strictEqual(fn(), 6);
         * });
         * ```
         * @since v19.1.0, v18.13.0
         * @param original An optional function to create a mock on.
         * @param implementation An optional function used as the mock implementation for `original`. This is useful for creating mocks that exhibit one behavior for a specified number of calls and
         * then restore the behavior of `original`.
         * @param options Optional configuration options for the mock function.
         * @return The mocked function. The mocked function contains a special `mock` property, which is an instance of {@link MockFunctionContext}, and can be used for inspecting and changing the
         * behavior of the mocked function.
         */
        fn<F extends Function = NoOpFunction>(original?: F, options?: MockFunctionOptions): Mock<F>;
        fn<F extends Function = NoOpFunction, Implementation extends Function = F>(
            original?: F,
            implementation?: Implementation,
            options?: MockFunctionOptions,
        ): Mock<F | Implementation>;
        /**
         * This function is used to create a mock on an existing object method. The
         * following example demonstrates how a mock is created on an existing object
         * method.
         *
         * ```js
         * test('spies on an object method', (t) => {
         *   const number = {
         *     value: 5,
         *     subtract(a) {
         *       return this.value - a;
         *     },
         *   };
         *
         *   t.mock.method(number, 'subtract');
         *   assert.strictEqual(number.subtract.mock.calls.length, 0);
         *   assert.strictEqual(number.subtract(3), 2);
         *   assert.strictEqual(number.subtract.mock.calls.length, 1);
         *
         *   const call = number.subtract.mock.calls[0];
         *
         *   assert.deepStrictEqual(call.arguments, [3]);
         *   assert.strictEqual(call.result, 2);
         *   assert.strictEqual(call.error, undefined);
         *   assert.strictEqual(call.target, undefined);
         *   assert.strictEqual(call.this, number);
         * });
         * ```
         * @since v19.1.0, v18.13.0
         * @param object The object whose method is being mocked.
         * @param methodName The identifier of the method on `object` to mock. If `object[methodName]` is not a function, an error is thrown.
         * @param implementation An optional function used as the mock implementation for `object[methodName]`.
         * @param options Optional configuration options for the mock method.
         * @return The mocked method. The mocked method contains a special `mock` property, which is an instance of {@link MockFunctionContext}, and can be used for inspecting and changing the
         * behavior of the mocked method.
         */
        method<
            MockedObject extends object,
            MethodName extends FunctionPropertyNames<MockedObject>,
        >(
            object: MockedObject,
            methodName: MethodName,
            options?: MockFunctionOptions,
        ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName]>
            : never;
        method<
            MockedObject extends object,
            MethodName extends FunctionPropertyNames<MockedObject>,
            Implementation extends Function,
        >(
            object: MockedObject,
            methodName: MethodName,
            implementation: Implementation,
            options?: MockFunctionOptions,
        ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName] | Implementation>
            : never;
        method<MockedObject extends object>(
            object: MockedObject,
            methodName: keyof MockedObject,
            options: MockMethodOptions,
        ): Mock<Function>;
        method<MockedObject extends object>(
            object: MockedObject,
            methodName: keyof MockedObject,
            implementation: Function,
            options: MockMethodOptions,
        ): Mock<Function>;

        /**
         * This function is syntax sugar for `MockTracker.method` with `options.getter` set to `true`.
         * @since v19.3.0, v18.13.0
         */
        getter<
            MockedObject extends object,
            MethodName extends keyof MockedObject,
        >(
            object: MockedObject,
            methodName: MethodName,
            options?: MockFunctionOptions,
        ): Mock<() => MockedObject[MethodName]>;
        getter<
            MockedObject extends object,
            MethodName extends keyof MockedObject,
            Implementation extends Function,
        >(
            object: MockedObject,
            methodName: MethodName,
            implementation?: Implementation,
            options?: MockFunctionOptions,
        ): Mock<(() => MockedObject[MethodName]) | Implementation>;
        /**
         * This function is syntax sugar for `MockTracker.method` with `options.setter` set to `true`.
         * @since v19.3.0, v18.13.0
         */
        setter<
            MockedObject extends object,
            MethodName extends keyof MockedObject,
        >(
            object: MockedObject,
            methodName: MethodName,
            options?: MockFunctionOptions,
        ): Mock<(value: MockedObject[MethodName]) => void>;
        setter<
            MockedObject extends object,
            MethodName extends keyof MockedObject,
            Implementation extends Function,
        >(
            object: MockedObject,
            methodName: MethodName,
            implementation?: Implementation,
            options?: MockFunctionOptions,
        ): Mock<((value: MockedObject[MethodName]) => void) | Implementation>;

        /**
         * This function is used to mock the exports of ECMAScript modules, CommonJS modules, JSON modules, and
         * Node.js builtin modules. Any references to the original module prior to mocking are not impacted. In
         * order to enable module mocking, Node.js must be started with the
         * [`--experimental-test-module-mocks`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--experimental-test-module-mocks)
         * command-line flag.
         *
         * The following example demonstrates how a mock is created for a module.
         *
         * ```js
         * test('mocks a builtin module in both module systems', async (t) => {
         *   // Create a mock of 'node:readline' with a named export named 'fn', which
         *   // does not exist in the original 'node:readline' module.
         *   const mock = t.mock.module('node:readline', {
         *     namedExports: { fn() { return 42; } },
         *   });
         *
         *   let esmImpl = await import('node:readline');
         *   let cjsImpl = require('node:readline');
         *
         *   // cursorTo() is an export of the original 'node:readline' module.
         *   assert.strictEqual(esmImpl.cursorTo, undefined);
         *   assert.strictEqual(cjsImpl.cursorTo, undefined);
         *   assert.strictEqual(esmImpl.fn(), 42);
         *   assert.strictEqual(cjsImpl.fn(), 42);
         *
         *   mock.restore();
         *
         *   // The mock is restored, so the original builtin module is returned.
         *   esmImpl = await import('node:readline');
         *   cjsImpl = require('node:readline');
         *
         *   assert.strictEqual(typeof esmImpl.cursorTo, 'function');
         *   assert.strictEqual(typeof cjsImpl.cursorTo, 'function');
         *   assert.strictEqual(esmImpl.fn, undefined);
         *   assert.strictEqual(cjsImpl.fn, undefined);
         * });
         * ```
         * @since v22.3.0
         * @experimental
         * @param specifier A string identifying the module to mock.
         * @param options Optional configuration options for the mock module.
         */
        module(specifier: string, options?: MockModuleOptions): MockModuleContext;

        /**
         * This function restores the default behavior of all mocks that were previously
         * created by this `MockTracker` and disassociates the mocks from the `MockTracker` instance. Once disassociated, the mocks can still be used, but the `MockTracker` instance can no longer be
         * used to reset their behavior or
         * otherwise interact with them.
         *
         * After each test completes, this function is called on the test context's `MockTracker`. If the global `MockTracker` is used extensively, calling this
         * function manually is recommended.
         * @since v19.1.0, v18.13.0
         */
        reset(): void;
        /**
         * This function restores the default behavior of all mocks that were previously
         * created by this `MockTracker`. Unlike `mock.reset()`, `mock.restoreAll()` does
         * not disassociate the mocks from the `MockTracker` instance.
         * @since v19.1.0, v18.13.0
         */
        restoreAll(): void;

        timers: MockTimers;
    }
    const mock: MockTracker;
    interface MockFunctionCall<
        F extends Function,
        ReturnType = F extends (...args: any) => infer T ? T
            : F extends abstract new(...args: any) => infer T ? T
            : unknown,
        Args = F extends (...args: infer Y) => any ? Y
            : F extends abstract new(...args: infer Y) => any ? Y
            : unknown[],
    > {
        /**
         * An array of the arguments passed to the mock function.
         */
        arguments: Args;
        /**
         * If the mocked function threw then this property contains the thrown value.
         */
        error: unknown | undefined;
        /**
         * The value returned by the mocked function.
         *
         * If the mocked function threw, it will be `undefined`.
         */
        result: ReturnType | undefined;
        /**
         * An `Error` object whose stack can be used to determine the callsite of the mocked function invocation.
         */
        stack: Error;
        /**
         * If the mocked function is a constructor, this field contains the class being constructed.
         * Otherwise this will be `undefined`.
         */
        target: F extends abstract new(...args: any) => any ? F : undefined;
        /**
         * The mocked function's `this` value.
         */
        this: unknown;
    }
    /**
     * The `MockFunctionContext` class is used to inspect or manipulate the behavior of
     * mocks created via the `MockTracker` APIs.
     * @since v19.1.0, v18.13.0
     */
    class MockFunctionContext<F extends Function> {
        /**
         * A getter that returns a copy of the internal array used to track calls to the
         * mock. Each entry in the array is an object with the following properties.
         * @since v19.1.0, v18.13.0
         */
        readonly calls: Array<MockFunctionCall<F>>;
        /**
         * This function returns the number of times that this mock has been invoked. This
         * function is more efficient than checking `ctx.calls.length` because `ctx.calls` is a getter that creates a copy of the internal call tracking array.
         * @since v19.1.0, v18.13.0
         * @return The number of times that this mock has been invoked.
         */
        callCount(): number;
        /**
         * This function is used to change the behavior of an existing mock.
         *
         * The following example creates a mock function using `t.mock.fn()`, calls the
         * mock function, and then changes the mock implementation to a different function.
         *
         * ```js
         * test('changes a mock behavior', (t) => {
         *   let cnt = 0;
         *
         *   function addOne() {
         *     cnt++;
         *     return cnt;
         *   }
         *
         *   function addTwo() {
         *     cnt += 2;
         *     return cnt;
         *   }
         *
         *   const fn = t.mock.fn(addOne);
         *
         *   assert.strictEqual(fn(), 1);
         *   fn.mock.mockImplementation(addTwo);
         *   assert.strictEqual(fn(), 3);
         *   assert.strictEqual(fn(), 5);
         * });
         * ```
         * @since v19.1.0, v18.13.0
         * @param implementation The function to be used as the mock's new implementation.
         */
        mockImplementation(implementation: F): void;
        /**
         * This function is used to change the behavior of an existing mock for a single
         * invocation. Once invocation `onCall` has occurred, the mock will revert to
         * whatever behavior it would have used had `mockImplementationOnce()` not been
         * called.
         *
         * The following example creates a mock function using `t.mock.fn()`, calls the
         * mock function, changes the mock implementation to a different function for the
         * next invocation, and then resumes its previous behavior.
         *
         * ```js
         * test('changes a mock behavior once', (t) => {
         *   let cnt = 0;
         *
         *   function addOne() {
         *     cnt++;
         *     return cnt;
         *   }
         *
         *   function addTwo() {
         *     cnt += 2;
         *     return cnt;
         *   }
         *
         *   const fn = t.mock.fn(addOne);
         *
         *   assert.strictEqual(fn(), 1);
         *   fn.mock.mockImplementationOnce(addTwo);
         *   assert.strictEqual(fn(), 3);
         *   assert.strictEqual(fn(), 4);
         * });
         * ```
         * @since v19.1.0, v18.13.0
         * @param implementation The function to be used as the mock's implementation for the invocation number specified by `onCall`.
         * @param onCall The invocation number that will use `implementation`. If the specified invocation has already occurred then an exception is thrown.
         */
        mockImplementationOnce(implementation: F, onCall?: number): void;
        /**
         * Resets the call history of the mock function.
         * @since v19.3.0, v18.13.0
         */
        resetCalls(): void;
        /**
         * Resets the implementation of the mock function to its original behavior. The
         * mock can still be used after calling this function.
         * @since v19.1.0, v18.13.0
         */
        restore(): void;
    }
    /**
     * @since v22.3.0
     * @experimental
     */
    class MockModuleContext {
        /**
         * Resets the implementation of the mock module.
         * @since v22.3.0
         */
        restore(): void;
    }

    type Timer = "setInterval" | "setTimeout" | "setImmediate" | "Date";
    interface MockTimersOptions {
        apis: Timer[];
        now?: number | Date | undefined;
    }
    /**
     * Mocking timers is a technique commonly used in software testing to simulate and
     * control the behavior of timers, such as `setInterval` and `setTimeout`,
     * without actually waiting for the specified time intervals.
     *
     * The MockTimers API also allows for mocking of the `Date` constructor and
     * `setImmediate`/`clearImmediate` functions.
     *
     * The `MockTracker` provides a top-level `timers` export
     * which is a `MockTimers` instance.
     * @since v20.4.0
     */
    class MockTimers {
        /**
         * Enables timer mocking for the specified timers.
         *
         * **Note:** When you enable mocking for a specific timer, its associated
         * clear function will also be implicitly mocked.
         *
         * **Note:** Mocking `Date` will affect the behavior of the mocked timers
         * as they use the same internal clock.
         *
         * Example usage without setting initial time:
         *
         * ```js
         * import { mock } from 'node:test';
         * mock.timers.enable({ apis: ['setInterval', 'Date'], now: 1234 });
         * ```
         *
         * The above example enables mocking for the `Date` constructor, `setInterval` timer and
         * implicitly mocks the `clearInterval` function. Only the `Date` constructor from `globalThis`,
         * `setInterval` and `clearInterval` functions from `node:timers`, `node:timers/promises`, and `globalThis` will be mocked.
         *
         * Example usage with initial time set
         *
         * ```js
         * import { mock } from 'node:test';
         * mock.timers.enable({ apis: ['Date'], now: 1000 });
         * ```
         *
         * Example usage with initial Date object as time set
         *
         * ```js
         * import { mock } from 'node:test';
         * mock.timers.enable({ apis: ['Date'], now: new Date() });
         * ```
         *
         * Alternatively, if you call `mock.timers.enable()` without any parameters:
         *
         * All timers (`'setInterval'`, `'clearInterval'`, `'Date'`, `'setImmediate'`, `'clearImmediate'`, `'setTimeout'`, and `'clearTimeout'`)
         * will be mocked.
         *
         * The `setInterval`, `clearInterval`, `setTimeout`, and `clearTimeout` functions from `node:timers`, `node:timers/promises`,
         * and `globalThis` will be mocked.
         * The `Date` constructor from `globalThis` will be mocked.
         *
         * If there is no initial epoch set, the initial date will be based on 0 in the Unix epoch. This is `January 1st, 1970, 00:00:00 UTC`. You can
         * set an initial date by passing a now property to the `.enable()` method. This value will be used as the initial date for the mocked Date
         * object. It can either be a positive integer, or another Date object.
         * @since v20.4.0
         */
        enable(options?: MockTimersOptions): void;
        /**
         * You can use the `.setTime()` method to manually move the mocked date to another time. This method only accepts a positive integer.
         * Note: This method will execute any mocked timers that are in the past from the new time.
         * In the below example we are setting a new time for the mocked date.
         * ```js
         * import assert from 'node:assert';
         * import { test } from 'node:test';
         * test('sets the time of a date object', (context) => {
         *   // Optionally choose what to mock
         *   context.mock.timers.enable({ apis: ['Date'], now: 100 });
         *   assert.strictEqual(Date.now(), 100);
         *   // Advance in time will also advance the date
         *   context.mock.timers.setTime(1000);
         *   context.mock.timers.tick(200);
         *   assert.strictEqual(Date.now(), 1200);
         * });
         * ```
         */
        setTime(time: number): void;
        /**
         * This function restores the default behavior of all mocks that were previously
         * created by this `MockTimers` instance and disassociates the mocks
         * from the `MockTracker` instance.
         *
         * **Note:** After each test completes, this function is called on
         * the test context's `MockTracker`.
         *
         * ```js
         * import { mock } from 'node:test';
         * mock.timers.reset();
         * ```
         * @since v20.4.0
         */
        reset(): void;
        /**
         * Advances time for all mocked timers.
         *
         * **Note:** This diverges from how `setTimeout` in Node.js behaves and accepts
         * only positive numbers. In Node.js, `setTimeout` with negative numbers is
         * only supported for web compatibility reasons.
         *
         * The following example mocks a `setTimeout` function and
         * by using `.tick` advances in
         * time triggering all pending timers.
         *
         * ```js
         * import assert from 'node:assert';
         * import { test } from 'node:test';
         *
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {
         *   const fn = context.mock.fn();
         *
         *   context.mock.timers.enable({ apis: ['setTimeout'] });
         *
         *   setTimeout(fn, 9999);
         *
         *   assert.strictEqual(fn.mock.callCount(), 0);
         *
         *   // Advance in time
         *   context.mock.timers.tick(9999);
         *
         *   assert.strictEqual(fn.mock.callCount(), 1);
         * });
         * ```
         *
         * Alternativelly, the `.tick` function can be called many times
         *
         * ```js
         * import assert from 'node:assert';
         * import { test } from 'node:test';
         *
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {
         *   const fn = context.mock.fn();
         *   context.mock.timers.enable({ apis: ['setTimeout'] });
         *   const nineSecs = 9000;
         *   setTimeout(fn, nineSecs);
         *
         *   const twoSeconds = 3000;
         *   context.mock.timers.tick(twoSeconds);
         *   context.mock.timers.tick(twoSeconds);
         *   context.mock.timers.tick(twoSeconds);
         *
         *   assert.strictEqual(fn.mock.callCount(), 1);
         * });
         * ```
         *
         * Advancing time using `.tick` will also advance the time for any `Date` object
         * created after the mock was enabled (if `Date` was also set to be mocked).
         *
         * ```js
         * import assert from 'node:assert';
         * import { test } from 'node:test';
         *
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {
         *   const fn = context.mock.fn();
         *
         *   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });
         *   setTimeout(fn, 9999);
         *
         *   assert.strictEqual(fn.mock.callCount(), 0);
         *   assert.strictEqual(Date.now(), 0);
         *
         *   // Advance in time
         *   context.mock.timers.tick(9999);
         *   assert.strictEqual(fn.mock.callCount(), 1);
         *   assert.strictEqual(Date.now(), 9999);
         * });
         * ```
         * @since v20.4.0
         */
        tick(milliseconds: number): void;
        /**
         * Triggers all pending mocked timers immediately. If the `Date` object is also
         * mocked, it will also advance the `Date` object to the furthest timer's time.
         *
         * The example below triggers all pending timers immediately,
         * causing them to execute without any delay.
         *
         * ```js
         * import assert from 'node:assert';
         * import { test } from 'node:test';
         *
         * test('runAll functions following the given order', (context) => {
         *   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });
         *   const results = [];
         *   setTimeout(() => results.push(1), 9999);
         *
         *   // Notice that if both timers have the same timeout,
         *   // the order of execution is guaranteed
         *   setTimeout(() => results.push(3), 8888);
         *   setTimeout(() => results.push(2), 8888);
         *
         *   assert.deepStrictEqual(results, []);
         *
         *   context.mock.timers.runAll();
         *   assert.deepStrictEqual(results, [3, 2, 1]);
         *   // The Date object is also advanced to the furthest timer's time
         *   assert.strictEqual(Date.now(), 9999);
         * });
         * ```
         *
         * **Note:** The `runAll()` function is specifically designed for
         * triggering timers in the context of timer mocking.
         * It does not have any effect on real-time system
         * clocks or actual timers outside of the mocking environment.
         * @since v20.4.0
         */
        runAll(): void;
        /**
         * Calls {@link MockTimers.reset()}.
         */
        [Symbol.dispose](): void;
    }
    /**
     * An object whose methods are used to configure available assertions on the
     * `TestContext` objects in the current process. The methods from `node:assert`
     * and snapshot testing functions are available by default.
     *
     * It is possible to apply the same configuration to all files by placing common
     * configuration code in a module
     * preloaded with `--require` or `--import`.
     * @since v22.14.0
     */
    namespace assert {
        /**
         * Defines a new assertion function with the provided name and function. If an
         * assertion already exists with the same name, it is overwritten.
         * @since v22.14.0
         */
        function register(name: string, fn: (this: TestContext, ...args: any[]) => void): void;
    }
    /**
     * @since v22.3.0
     */
    namespace snapshot {
        /**
         * This function is used to customize the default serialization mechanism used by the test runner.
         *
         * By default, the test runner performs serialization by calling `JSON.stringify(value, null, 2)` on the provided value.
         * `JSON.stringify()` does have limitations regarding circular structures and supported data types.
         * If a more robust serialization mechanism is required, this function should be used to specify a list of custom serializers.
         *
         * Serializers are called in order, with the output of the previous serializer passed as input to the next.
         * The final result must be a string value.
         * @since v22.3.0
         * @param serializers An array of synchronous functions used as the default serializers for snapshot tests.
         */
        function setDefaultSnapshotSerializers(serializers: ReadonlyArray<(value: any) => any>): void;
        /**
         * This function is used to set a custom resolver for the location of the snapshot file used for snapshot testing.
         * By default, the snapshot filename is the same as the entry point filename with `.snapshot` appended.
         * @since v22.3.0
         * @param fn A function used to compute the location of the snapshot file.
         * The function receives the path of the test file as its only argument. If the
         * test is not associated with a file (for example in the REPL), the input is
         * undefined. `fn()` must return a string specifying the location of the snapshot file.
         */
        function setResolveSnapshotPath(fn: (path: string | undefined) => string): void;
    }
    export {
        after,
        afterEach,
        assert,
        before,
        beforeEach,
        describe,
        it,
        Mock,
        mock,
        only,
        run,
        skip,
        snapshot,
        suite,
        SuiteContext,
        test,
        test as default,
        TestContext,
        TestContextAssert,
        todo,
    };
}

interface TestError extends Error {
    cause: Error;
}
interface TestLocationInfo {
    /**
     * The column number where the test is defined, or
     * `undefined` if the test was run through the REPL.
     */
    column?: number;
    /**
     * The path of the test file, `undefined` if test was run through the REPL.
     */
    file?: string;
    /**
     * The line number where the test is defined, or `undefined` if the test was run through the REPL.
     */
    line?: number;
}
interface DiagnosticData extends TestLocationInfo {
    /**
     * The diagnostic message.
     */
    message: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
}
interface TestCoverage {
    /**
     * An object containing the coverage report.
     */
    summary: {
        /**
         * An array of coverage reports for individual files.
         */
        files: Array<{
            /**
             * The absolute path of the file.
             */
            path: string;
            /**
             * The total number of lines.
             */
            totalLineCount: number;
            /**
             * The total number of branches.
             */
            totalBranchCount: number;
            /**
             * The total number of functions.
             */
            totalFunctionCount: number;
            /**
             * The number of covered lines.
             */
            coveredLineCount: number;
            /**
             * The number of covered branches.
             */
            coveredBranchCount: number;
            /**
             * The number of covered functions.
             */
            coveredFunctionCount: number;
            /**
             * The percentage of lines covered.
             */
            coveredLinePercent: number;
            /**
             * The percentage of branches covered.
             */
            coveredBranchPercent: number;
            /**
             * The percentage of functions covered.
             */
            coveredFunctionPercent: number;
            /**
             * An array of functions representing function coverage.
             */
            functions: Array<{
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * The line number where the function is defined.
                 */
                line: number;
                /**
                 * The number of times the function was called.
                 */
                count: number;
            }>;
            /**
             * An array of branches representing branch coverage.
             */
            branches: Array<{
                /**
                 * The line number where the branch is defined.
                 */
                line: number;
                /**
                 * The number of times the branch was taken.
                 */
                count: number;
            }>;
            /**
             * An array of lines representing line numbers and the number of times they were covered.
             */
            lines: Array<{
                /**
                 * The line number.
                 */
                line: number;
                /**
                 * The number of times the line was covered.
                 */
                count: number;
            }>;
        }>;
        /**
         * An object containing whether or not the coverage for
         * each coverage type.
         * @since v22.9.0
         */
        thresholds: {
            /**
             * The function coverage threshold.
             */
            function: number;
            /**
             * The branch coverage threshold.
             */
            branch: number;
            /**
             * The line coverage threshold.
             */
            line: number;
        };
        /**
         * An object containing a summary of coverage for all files.
         */
        totals: {
            /**
             * The total number of lines.
             */
            totalLineCount: number;
            /**
             * The total number of branches.
             */
            totalBranchCount: number;
            /**
             * The total number of functions.
             */
            totalFunctionCount: number;
            /**
             * The number of covered lines.
             */
            coveredLineCount: number;
            /**
             * The number of covered branches.
             */
            coveredBranchCount: number;
            /**
             * The number of covered functions.
             */
            coveredFunctionCount: number;
            /**
             * The percentage of lines covered.
             */
            coveredLinePercent: number;
            /**
             * The percentage of branches covered.
             */
            coveredBranchPercent: number;
            /**
             * The percentage of functions covered.
             */
            coveredFunctionPercent: number;
        };
        /**
         * The working directory when code coverage began. This
         * is useful for displaying relative path names in case
         * the tests changed the working directory of the Node.js process.
         */
        workingDirectory: string;
    };
    /**
     * The nesting level of the test.
     */
    nesting: number;
}
interface TestComplete extends TestLocationInfo {
    /**
     * Additional execution metadata.
     */
    details: {
        /**
         * Whether the test passed or not.
         */
        passed: boolean;
        /**
         * The duration of the test in milliseconds.
         */
        duration_ms: number;
        /**
         * An error wrapping the error thrown by the test if it did not pass.
         */
        error?: TestError;
        /**
         * The type of the test, used to denote whether this is a suite.
         */
        type?: "suite";
    };
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The ordinal number of the test.
     */
    testNumber: number;
    /**
     * Present if `context.todo` is called.
     */
    todo?: string | boolean;
    /**
     * Present if `context.skip` is called.
     */
    skip?: string | boolean;
}
interface TestDequeue extends TestLocationInfo {
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The test type. Either `'suite'` or `'test'`.
     * @since v22.15.0
     */
    type: "suite" | "test";
}
interface TestEnqueue extends TestLocationInfo {
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The test type. Either `'suite'` or `'test'`.
     * @since v22.15.0
     */
    type: "suite" | "test";
}
interface TestFail extends TestLocationInfo {
    /**
     * Additional execution metadata.
     */
    details: {
        /**
         * The duration of the test in milliseconds.
         */
        duration_ms: number;
        /**
         * An error wrapping the error thrown by the test.
         */
        error: TestError;
        /**
         * The type of the test, used to denote whether this is a suite.
         * @since v20.0.0, v19.9.0, v18.17.0
         */
        type?: "suite";
    };
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The ordinal number of the test.
     */
    testNumber: number;
    /**
     * Present if `context.todo` is called.
     */
    todo?: string | boolean;
    /**
     * Present if `context.skip` is called.
     */
    skip?: string | boolean;
}
interface TestPass extends TestLocationInfo {
    /**
     * Additional execution metadata.
     */
    details: {
        /**
         * The duration of the test in milliseconds.
         */
        duration_ms: number;
        /**
         * The type of the test, used to denote whether this is a suite.
         * @since 20.0.0, 19.9.0, 18.17.0
         */
        type?: "suite";
    };
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The ordinal number of the test.
     */
    testNumber: number;
    /**
     * Present if `context.todo` is called.
     */
    todo?: string | boolean;
    /**
     * Present if `context.skip` is called.
     */
    skip?: string | boolean;
}
interface TestPlan extends TestLocationInfo {
    /**
     * The nesting level of the test.
     */
    nesting: number;
    /**
     * The number of subtests that have ran.
     */
    count: number;
}
interface TestStart extends TestLocationInfo {
    /**
     * The test name.
     */
    name: string;
    /**
     * The nesting level of the test.
     */
    nesting: number;
}
interface TestStderr {
    /**
     * The path of the test file.
     */
    file: string;
    /**
     * The message written to `stderr`.
     */
    message: string;
}
interface TestStdout {
    /**
     * The path of the test file.
     */
    file: string;
    /**
     * The message written to `stdout`.
     */
    message: string;
}
interface TestSummary {
    /**
     * An object containing the counts of various test results.
     */
    counts: {
        /**
         * The total number of cancelled tests.
         */
        cancelled: number;
        /**
         * The total number of passed tests.
         */
        passed: number;
        /**
         * The total number of skipped tests.
         */
        skipped: number;
        /**
         * The total number of suites run.
         */
        suites: number;
        /**
         * The total number of tests run, excluding suites.
         */
        tests: number;
        /**
         * The total number of TODO tests.
         */
        todo: number;
        /**
         * The total number of top level tests and suites.
         */
        topLevel: number;
    };
    /**
     * The duration of the test run in milliseconds.
     */
    duration_ms: number;
    /**
     * The path of the test file that generated the
     * summary. If the summary corresponds to multiple files, this value is
     * `undefined`.
     */
    file: string | undefined;
    /**
     * Indicates whether or not the test run is considered
     * successful or not. If any error condition occurs, such as a failing test or
     * unmet coverage threshold, this value will be set to `false`.
     */
    success: boolean;
}

/**
 * The `node:test/reporters` module exposes the builtin-reporters for `node:test`.
 * To access it:
 *
 * ```js
 * import test from 'node:test/reporters';
 * ```
 *
 * This module is only available under the `node:` scheme. The following will not
 * work:
 *
 * ```js
 * import test from 'node:test/reporters';
 * ```
 * @since v19.9.0
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/test/reporters.js)
 */
declare module "node:test/reporters" {
    import { Transform, TransformOptions } from "node:stream";

    type TestEvent =
        | { type: "test:coverage"; data: TestCoverage }
        | { type: "test:complete"; data: TestComplete }
        | { type: "test:dequeue"; data: TestDequeue }
        | { type: "test:diagnostic"; data: DiagnosticData }
        | { type: "test:enqueue"; data: TestEnqueue }
        | { type: "test:fail"; data: TestFail }
        | { type: "test:pass"; data: TestPass }
        | { type: "test:plan"; data: TestPlan }
        | { type: "test:start"; data: TestStart }
        | { type: "test:stderr"; data: TestStderr }
        | { type: "test:stdout"; data: TestStdout }
        | { type: "test:summary"; data: TestSummary }
        | { type: "test:watch:drained"; data: undefined };
    type TestEventGenerator = AsyncGenerator<TestEvent, void>;

    interface ReporterConstructorWrapper<T extends new(...args: any[]) => Transform> {
        new(...args: ConstructorParameters<T>): InstanceType<T>;
        (...args: ConstructorParameters<T>): InstanceType<T>;
    }

    /**
     * The `dot` reporter outputs the test results in a compact format,
     * where each passing test is represented by a `.`,
     * and each failing test is represented by a `X`.
     * @since v20.0.0
     */
    function dot(source: TestEventGenerator): AsyncGenerator<"\n" | "." | "X", void>;
    /**
     * The `tap` reporter outputs the test results in the [TAP](https://testanything.org/) format.
     * @since v20.0.0
     */
    function tap(source: TestEventGenerator): AsyncGenerator<string, void>;
    class SpecReporter extends Transform {
        constructor();
    }
    /**
     * The `spec` reporter outputs the test results in a human-readable format.
     * @since v20.0.0
     */
    const spec: ReporterConstructorWrapper<typeof SpecReporter>;
    /**
     * The `junit` reporter outputs test results in a jUnit XML format.
     * @since v21.0.0
     */
    function junit(source: TestEventGenerator): AsyncGenerator<string, void>;
    class LcovReporter extends Transform {
        constructor(opts?: Omit<TransformOptions, "writableObjectMode">);
    }
    /**
     * The `lcov` reporter outputs test coverage when used with the
     * [`--experimental-test-coverage`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--experimental-test-coverage) flag.
     * @since v22.0.0
     */
    const lcov: ReporterConstructorWrapper<typeof LcovReporter>;

    export { dot, junit, lcov, spec, tap, TestEvent };
}


---

File name: node_modules\@types\node\timers\promises.d.ts

Code:
/**
 * The `timers/promises` API provides an alternative set of timer functions
 * that return `Promise` objects. The API is accessible via
 * `require('node:timers/promises')`.
 *
 * ```js
 * import {
 *   setTimeout,
 *   setImmediate,
 *   setInterval,
 * } from 'node:timers/promises';
 * ```
 * @since v15.0.0
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/timers/promises.js)
 */
declare module "timers/promises" {
    import { TimerOptions } from "node:timers";
    /**
     * ```js
     * import {
     *   setTimeout,
     * } from 'node:timers/promises';
     *
     * const res = await setTimeout(100, 'result');
     *
     * console.log(res);  // Prints 'result'
     * ```
     * @since v15.0.0
     * @param delay The number of milliseconds to wait before fulfilling the
     * promise. **Default:** `1`.
     * @param value A value with which the promise is fulfilled.
     */
    function setTimeout<T = void>(delay?: number, value?: T, options?: TimerOptions): Promise<T>;
    /**
     * ```js
     * import {
     *   setImmediate,
     * } from 'node:timers/promises';
     *
     * const res = await setImmediate('result');
     *
     * console.log(res);  // Prints 'result'
     * ```
     * @since v15.0.0
     * @param value A value with which the promise is fulfilled.
     */
    function setImmediate<T = void>(value?: T, options?: TimerOptions): Promise<T>;
    /**
     * Returns an async iterator that generates values in an interval of `delay` ms.
     * If `ref` is `true`, you need to call `next()` of async iterator explicitly
     * or implicitly to keep the event loop alive.
     *
     * ```js
     * import {
     *   setInterval,
     * } from 'node:timers/promises';
     *
     * const interval = 100;
     * for await (const startTime of setInterval(interval, Date.now())) {
     *   const now = Date.now();
     *   console.log(now);
     *   if ((now - startTime) > 1000)
     *     break;
     * }
     * console.log(Date.now());
     * ```
     * @since v15.9.0
     * @param delay The number of milliseconds to wait between iterations.
     * **Default:** `1`.
     * @param value A value with which the iterator returns.
     */
    function setInterval<T = void>(delay?: number, value?: T, options?: TimerOptions): NodeJS.AsyncIterator<T>;
    interface Scheduler {
        /**
         * An experimental API defined by the [Scheduling APIs](https://github.com/WICG/scheduling-apis) draft specification
         * being developed as a standard Web Platform API.
         *
         * Calling `timersPromises.scheduler.wait(delay, options)` is roughly equivalent
         * to calling `timersPromises.setTimeout(delay, undefined, options)` except that
         * the `ref` option is not supported.
         *
         * ```js
         * import { scheduler } from 'node:timers/promises';
         *
         * await scheduler.wait(1000); // Wait one second before continuing
         * ```
         * @since v17.3.0, v16.14.0
         * @experimental
         * @param delay The number of milliseconds to wait before resolving the
         * promise.
         */
        wait(delay: number, options?: { signal?: AbortSignal }): Promise<void>;
        /**
         * An experimental API defined by the [Scheduling APIs](https://github.com/WICG/scheduling-apis) draft specification
         * being developed as a standard Web Platform API.
         *
         * Calling `timersPromises.scheduler.yield()` is equivalent to calling
         * `timersPromises.setImmediate()` with no arguments.
         * @since v17.3.0, v16.14.0
         * @experimental
         */
        yield(): Promise<void>;
    }
    const scheduler: Scheduler;
}
declare module "node:timers/promises" {
    export * from "timers/promises";
}


---

File name: node_modules\@types\node\timers.d.ts

Code:
/**
 * The `timer` module exposes a global API for scheduling functions to
 * be called at some future period of time. Because the timer functions are
 * globals, there is no need to import `node:timers` to use the API.
 *
 * The timer functions within Node.js implement a similar API as the timers API
 * provided by Web Browsers but use a different internal implementation that is
 * built around the Node.js [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout).
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/timers.js)
 */
declare module "timers" {
    import { Abortable } from "node:events";
    import * as promises from "node:timers/promises";
    export interface TimerOptions extends Abortable {
        /**
         * Set to `false` to indicate that the scheduled `Timeout`
         * should not require the Node.js event loop to remain active.
         * @default true
         */
        ref?: boolean | undefined;
    }
    global {
        namespace NodeJS {
            /**
             * This object is created internally and is returned from `setImmediate()`. It
             * can be passed to `clearImmediate()` in order to cancel the scheduled
             * actions.
             *
             * By default, when an immediate is scheduled, the Node.js event loop will continue
             * running as long as the immediate is active. The `Immediate` object returned by
             * `setImmediate()` exports both `immediate.ref()` and `immediate.unref()`
             * functions that can be used to control this default behavior.
             */
            interface Immediate extends RefCounted, Disposable {
                /**
                 * If true, the `Immediate` object will keep the Node.js event loop active.
                 * @since v11.0.0
                 */
                hasRef(): boolean;
                /**
                 * When called, requests that the Node.js event loop _not_ exit so long as the
                 * `Immediate` is active. Calling `immediate.ref()` multiple times will have no
                 * effect.
                 *
                 * By default, all `Immediate` objects are "ref'ed", making it normally unnecessary
                 * to call `immediate.ref()` unless `immediate.unref()` had been called previously.
                 * @since v9.7.0
                 * @returns a reference to `immediate`
                 */
                ref(): this;
                /**
                 * When called, the active `Immediate` object will not require the Node.js event
                 * loop to remain active. If there is no other activity keeping the event loop
                 * running, the process may exit before the `Immediate` object's callback is
                 * invoked. Calling `immediate.unref()` multiple times will have no effect.
                 * @since v9.7.0
                 * @returns a reference to `immediate`
                 */
                unref(): this;
                /**
                 * Cancels the immediate. This is similar to calling `clearImmediate()`.
                 * @since v20.5.0, v18.18.0
                 * @experimental
                 */
                [Symbol.dispose](): void;
                _onImmediate(...args: any[]): void;
            }
            // Legacy interface used in Node.js v9 and prior
            // TODO: remove in a future major version bump
            /** @deprecated Use `NodeJS.Timeout` instead. */
            interface Timer extends RefCounted {
                hasRef(): boolean;
                refresh(): this;
                [Symbol.toPrimitive](): number;
            }
            /**
             * This object is created internally and is returned from `setTimeout()` and
             * `setInterval()`. It can be passed to either `clearTimeout()` or
             * `clearInterval()` in order to cancel the scheduled actions.
             *
             * By default, when a timer is scheduled using either `setTimeout()` or
             * `setInterval()`, the Node.js event loop will continue running as long as the
             * timer is active. Each of the `Timeout` objects returned by these functions
             * export both `timeout.ref()` and `timeout.unref()` functions that can be used to
             * control this default behavior.
             */
            interface Timeout extends RefCounted, Disposable, Timer {
                /**
                 * Cancels the timeout.
                 * @since v0.9.1
                 * @legacy Use `clearTimeout()` instead.
                 * @returns a reference to `timeout`
                 */
                close(): this;
                /**
                 * If true, the `Timeout` object will keep the Node.js event loop active.
                 * @since v11.0.0
                 */
                hasRef(): boolean;
                /**
                 * When called, requests that the Node.js event loop _not_ exit so long as the
                 * `Timeout` is active. Calling `timeout.ref()` multiple times will have no effect.
                 *
                 * By default, all `Timeout` objects are "ref'ed", making it normally unnecessary
                 * to call `timeout.ref()` unless `timeout.unref()` had been called previously.
                 * @since v0.9.1
                 * @returns a reference to `timeout`
                 */
                ref(): this;
                /**
                 * Sets the timer's start time to the current time, and reschedules the timer to
                 * call its callback at the previously specified duration adjusted to the current
                 * time. This is useful for refreshing a timer without allocating a new
                 * JavaScript object.
                 *
                 * Using this on a timer that has already called its callback will reactivate the
                 * timer.
                 * @since v10.2.0
                 * @returns a reference to `timeout`
                 */
                refresh(): this;
                /**
                 * When called, the active `Timeout` object will not require the Node.js event loop
                 * to remain active. If there is no other activity keeping the event loop running,
                 * the process may exit before the `Timeout` object's callback is invoked. Calling
                 * `timeout.unref()` multiple times will have no effect.
                 * @since v0.9.1
                 * @returns a reference to `timeout`
                 */
                unref(): this;
                /**
                 * Coerce a `Timeout` to a primitive. The primitive can be used to
                 * clear the `Timeout`. The primitive can only be used in the
                 * same thread where the timeout was created. Therefore, to use it
                 * across `worker_threads` it must first be passed to the correct
                 * thread. This allows enhanced compatibility with browser
                 * `setTimeout()` and `setInterval()` implementations.
                 * @since v14.9.0, v12.19.0
                 */
                [Symbol.toPrimitive](): number;
                /**
                 * Cancels the timeout.
                 * @since v20.5.0, v18.18.0
                 * @experimental
                 */
                [Symbol.dispose](): void;
                _onTimeout(...args: any[]): void;
            }
        }
        /**
         * Schedules the "immediate" execution of the `callback` after I/O events'
         * callbacks.
         *
         * When multiple calls to `setImmediate()` are made, the `callback` functions are
         * queued for execution in the order in which they are created. The entire callback
         * queue is processed every event loop iteration. If an immediate timer is queued
         * from inside an executing callback, that timer will not be triggered until the
         * next event loop iteration.
         *
         * If `callback` is not a function, a `TypeError` will be thrown.
         *
         * This method has a custom variant for promises that is available using
         * `timersPromises.setImmediate()`.
         * @since v0.9.1
         * @param callback The function to call at the end of this turn of
         * the Node.js [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout)
         * @param args Optional arguments to pass when the `callback` is called.
         * @returns for use with `clearImmediate()`
         */
        function setImmediate<TArgs extends any[]>(
            callback: (...args: TArgs) => void,
            ...args: TArgs
        ): NodeJS.Immediate;
        // Allow a single void-accepting argument to be optional in arguments lists.
        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        function setImmediate(callback: (_: void) => void): NodeJS.Immediate;
        namespace setImmediate {
            import __promisify__ = promises.setImmediate;
            export { __promisify__ };
        }
        /**
         * Schedules repeated execution of `callback` every `delay` milliseconds.
         *
         * When `delay` is larger than `2147483647` or less than `1` or `NaN`, the `delay`
         * will be set to `1`. Non-integer delays are truncated to an integer.
         *
         * If `callback` is not a function, a `TypeError` will be thrown.
         *
         * This method has a custom variant for promises that is available using
         * `timersPromises.setInterval()`.
         * @since v0.0.1
         * @param callback The function to call when the timer elapses.
         * @param delay The number of milliseconds to wait before calling the
         * `callback`. **Default:** `1`.
         * @param args Optional arguments to pass when the `callback` is called.
         * @returns for use with `clearInterval()`
         */
        function setInterval<TArgs extends any[]>(
            callback: (...args: TArgs) => void,
            delay?: number,
            ...args: TArgs
        ): NodeJS.Timeout;
        // Allow a single void-accepting argument to be optional in arguments lists.
        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        function setInterval(callback: (_: void) => void, delay?: number): NodeJS.Timeout;
        /**
         * Schedules execution of a one-time `callback` after `delay` milliseconds.
         *
         * The `callback` will likely not be invoked in precisely `delay` milliseconds.
         * Node.js makes no guarantees about the exact timing of when callbacks will fire,
         * nor of their ordering. The callback will be called as close as possible to the
         * time specified.
         *
         * When `delay` is larger than `2147483647` or less than `1` or `NaN`, the `delay`
         * will be set to `1`. Non-integer delays are truncated to an integer.
         *
         * If `callback` is not a function, a `TypeError` will be thrown.
         *
         * This method has a custom variant for promises that is available using
         * `timersPromises.setTimeout()`.
         * @since v0.0.1
         * @param callback The function to call when the timer elapses.
         * @param delay The number of milliseconds to wait before calling the
         * `callback`. **Default:** `1`.
         * @param args Optional arguments to pass when the `callback` is called.
         * @returns for use with `clearTimeout()`
         */
        function setTimeout<TArgs extends any[]>(
            callback: (...args: TArgs) => void,
            delay?: number,
            ...args: TArgs
        ): NodeJS.Timeout;
        // Allow a single void-accepting argument to be optional in arguments lists.
        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        function setTimeout(callback: (_: void) => void, delay?: number): NodeJS.Timeout;
        namespace setTimeout {
            import __promisify__ = promises.setTimeout;
            export { __promisify__ };
        }
        /**
         * Cancels an `Immediate` object created by `setImmediate()`.
         * @since v0.9.1
         * @param immediate An `Immediate` object as returned by `setImmediate()`.
         */
        function clearImmediate(immediate: NodeJS.Immediate | undefined): void;
        /**
         * Cancels a `Timeout` object created by `setInterval()`.
         * @since v0.0.1
         * @param timeout A `Timeout` object as returned by `setInterval()`
         * or the primitive of the `Timeout` object as a string or a number.
         */
        function clearInterval(timeout: NodeJS.Timeout | string | number | undefined): void;
        /**
         * Cancels a `Timeout` object created by `setTimeout()`.
         * @since v0.0.1
         * @param timeout A `Timeout` object as returned by `setTimeout()`
         * or the primitive of the `Timeout` object as a string or a number.
         */
        function clearTimeout(timeout: NodeJS.Timeout | string | number | undefined): void;
        /**
         * The `queueMicrotask()` method queues a microtask to invoke `callback`. If
         * `callback` throws an exception, the `process` object `'uncaughtException'`
         * event will be emitted.
         *
         * The microtask queue is managed by V8 and may be used in a similar manner to
         * the `process.nextTick()` queue, which is managed by Node.js. The
         * `process.nextTick()` queue is always processed before the microtask queue
         * within each turn of the Node.js event loop.
         * @since v11.0.0
         * @param callback Function to be queued.
         */
        function queueMicrotask(callback: () => void): void;
    }
    import clearImmediate = globalThis.clearImmediate;
    import clearInterval = globalThis.clearInterval;
    import clearTimeout = globalThis.clearTimeout;
    import setImmediate = globalThis.setImmediate;
    import setInterval = globalThis.setInterval;
    import setTimeout = globalThis.setTimeout;
    export { clearImmediate, clearInterval, clearTimeout, promises, setImmediate, setInterval, setTimeout };
}
declare module "node:timers" {
    export * from "timers";
}


---

