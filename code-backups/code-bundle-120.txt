File name: node_modules\babel-jest\node_modules\@jest\schemas\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {
  Static,
  TArray,
  TBoolean,
  TInteger,
  TIntersect,
  TLiteral,
  TNull,
  TNumber,
  TObject,
  TOptional,
  TRecord,
  TString,
  TTuple,
  TUnion,
  TUnknown,
  TUnsafe,
} from '@sinclair/typebox';

export declare const FakeTimers: TIntersect<
  [
    TObject<{
      enableGlobally: TOptional<TBoolean>;
    }>,
    TUnion<
      [
        TObject<{
          advanceTimers: TOptional<TUnion<[TBoolean, TNumber]>>;
          doNotFake: TOptional<
            TArray<
              TUnion<
                [
                  TLiteral<'Date'>,
                  TLiteral<'hrtime'>,
                  TLiteral<'nextTick'>,
                  TLiteral<'performance'>,
                  TLiteral<'queueMicrotask'>,
                  TLiteral<'requestAnimationFrame'>,
                  TLiteral<'cancelAnimationFrame'>,
                  TLiteral<'requestIdleCallback'>,
                  TLiteral<'cancelIdleCallback'>,
                  TLiteral<'setImmediate'>,
                  TLiteral<'clearImmediate'>,
                  TLiteral<'setInterval'>,
                  TLiteral<'clearInterval'>,
                  TLiteral<'setTimeout'>,
                  TLiteral<'clearTimeout'>,
                ]
              >
            >
          >;
          now: TOptional<TInteger>;
          timerLimit: TOptional<TNumber>;
          legacyFakeTimers: TOptional<TLiteral<false>>;
        }>,
        TObject<{
          legacyFakeTimers: TOptional<TLiteral<true>>;
        }>,
      ]
    >,
  ]
>;

export declare type FakeTimers = Static<typeof FakeTimers>;

export declare const InitialOptions: TObject<{
  automock: TOptional<TBoolean>;
  bail: TOptional<TUnion<[TBoolean, TNumber]>>;
  cache: TOptional<TBoolean>;
  cacheDirectory: TOptional<TString>;
  ci: TOptional<TBoolean>;
  clearMocks: TOptional<TBoolean>;
  changedFilesWithAncestor: TOptional<TBoolean>;
  changedSince: TOptional<TString>;
  collectCoverage: TOptional<TBoolean>;
  collectCoverageFrom: TOptional<TArray<TString>>;
  coverageDirectory: TOptional<TString>;
  coveragePathIgnorePatterns: TOptional<TArray<TString>>;
  coverageProvider: TOptional<TUnion<[TLiteral<'babel'>, TLiteral<'v8'>]>>;
  coverageReporters: TOptional<
    TArray<
      TUnion<
        [
          TUnion<
            [
              TLiteral<'clover'>,
              TLiteral<'cobertura'>,
              TLiteral<'html-spa'>,
              TLiteral<'html'>,
              TLiteral<'json'>,
              TLiteral<'json-summary'>,
              TLiteral<'lcov'>,
              TLiteral<'lcovonly'>,
              TLiteral<'none'>,
              TLiteral<'teamcity'>,
              TLiteral<'text'>,
              TLiteral<'text-lcov'>,
              TLiteral<'text-summary'>,
            ]
          >,
          TTuple<
            [
              TUnion<
                [
                  TLiteral<'clover'>,
                  TLiteral<'cobertura'>,
                  TLiteral<'html-spa'>,
                  TLiteral<'html'>,
                  TLiteral<'json'>,
                  TLiteral<'json-summary'>,
                  TLiteral<'lcov'>,
                  TLiteral<'lcovonly'>,
                  TLiteral<'none'>,
                  TLiteral<'teamcity'>,
                  TLiteral<'text'>,
                  TLiteral<'text-lcov'>,
                  TLiteral<'text-summary'>,
                ]
              >,
              TRecord<TString, TUnknown>,
            ]
          >,
        ]
      >
    >
  >;
  coverageThreshold: TOptional<
    TUnsafe<{
      [path: string]: {
        branches?: number | undefined;
        functions?: number | undefined;
        lines?: number | undefined;
        statements?: number | undefined;
      };
      global: Static<
        TObject<{
          branches: TOptional<TNumber>;
          functions: TOptional<TNumber>;
          lines: TOptional<TNumber>;
          statements: TOptional<TNumber>;
        }>
      >;
    }>
  >;
  dependencyExtractor: TOptional<TString>;
  detectLeaks: TOptional<TBoolean>;
  detectOpenHandles: TOptional<TBoolean>;
  displayName: TOptional<
    TUnion<
      [
        TString,
        TObject<{
          name: TString;
          color: TUnion<
            [
              TLiteral<'black'>,
              TLiteral<'red'>,
              TLiteral<'green'>,
              TLiteral<'yellow'>,
              TLiteral<'blue'>,
              TLiteral<'magenta'>,
              TLiteral<'cyan'>,
              TLiteral<'white'>,
              TLiteral<'gray'>,
              TLiteral<'grey'>,
              TLiteral<'blackBright'>,
              TLiteral<'redBright'>,
              TLiteral<'greenBright'>,
              TLiteral<'yellowBright'>,
              TLiteral<'blueBright'>,
              TLiteral<'magentaBright'>,
              TLiteral<'cyanBright'>,
              TLiteral<'whiteBright'>,
            ]
          >;
        }>,
      ]
    >
  >;
  expand: TOptional<TBoolean>;
  extensionsToTreatAsEsm: TOptional<TArray<TString>>;
  fakeTimers: TOptional<
    TIntersect<
      [
        TObject<{
          enableGlobally: TOptional<TBoolean>;
        }>,
        TUnion<
          [
            TObject<{
              advanceTimers: TOptional<TUnion<[TBoolean, TNumber]>>;
              doNotFake: TOptional<
                TArray<
                  TUnion<
                    [
                      TLiteral<'Date'>,
                      TLiteral<'hrtime'>,
                      TLiteral<'nextTick'>,
                      TLiteral<'performance'>,
                      TLiteral<'queueMicrotask'>,
                      TLiteral<'requestAnimationFrame'>,
                      TLiteral<'cancelAnimationFrame'>,
                      TLiteral<'requestIdleCallback'>,
                      TLiteral<'cancelIdleCallback'>,
                      TLiteral<'setImmediate'>,
                      TLiteral<'clearImmediate'>,
                      TLiteral<'setInterval'>,
                      TLiteral<'clearInterval'>,
                      TLiteral<'setTimeout'>,
                      TLiteral<'clearTimeout'>,
                    ]
                  >
                >
              >;
              now: TOptional<TInteger>;
              timerLimit: TOptional<TNumber>;
              legacyFakeTimers: TOptional<TLiteral<false>>;
            }>,
            TObject<{
              legacyFakeTimers: TOptional<TLiteral<true>>;
            }>,
          ]
        >,
      ]
    >
  >;
  filter: TOptional<TString>;
  findRelatedTests: TOptional<TBoolean>;
  forceCoverageMatch: TOptional<TArray<TString>>;
  forceExit: TOptional<TBoolean>;
  json: TOptional<TBoolean>;
  globals: TOptional<TRecord<TString, TUnknown>>;
  globalSetup: TOptional<TUnion<[TString, TNull]>>;
  globalTeardown: TOptional<TUnion<[TString, TNull]>>;
  haste: TOptional<
    TObject<{
      computeSha1: TOptional<TBoolean>;
      defaultPlatform: TOptional<TUnion<[TString, TNull]>>;
      forceNodeFilesystemAPI: TOptional<TBoolean>;
      enableSymlinks: TOptional<TBoolean>;
      hasteImplModulePath: TOptional<TString>;
      platforms: TOptional<TArray<TString>>;
      throwOnModuleCollision: TOptional<TBoolean>;
      hasteMapModulePath: TOptional<TString>;
      retainAllFiles: TOptional<TBoolean>;
    }>
  >;
  id: TOptional<TString>;
  injectGlobals: TOptional<TBoolean>;
  reporters: TOptional<
    TArray<TUnion<[TString, TTuple<[TString, TRecord<TString, TUnknown>]>]>>
  >;
  logHeapUsage: TOptional<TBoolean>;
  lastCommit: TOptional<TBoolean>;
  listTests: TOptional<TBoolean>;
  maxConcurrency: TOptional<TInteger>;
  maxWorkers: TOptional<TUnion<[TString, TInteger]>>;
  moduleDirectories: TOptional<TArray<TString>>;
  moduleFileExtensions: TOptional<TArray<TString>>;
  moduleNameMapper: TOptional<
    TRecord<TString, TUnion<[TString, TArray<TString>]>>
  >;
  modulePathIgnorePatterns: TOptional<TArray<TString>>;
  modulePaths: TOptional<TArray<TString>>;
  noStackTrace: TOptional<TBoolean>;
  notify: TOptional<TBoolean>;
  notifyMode: TOptional<TString>;
  onlyChanged: TOptional<TBoolean>;
  onlyFailures: TOptional<TBoolean>;
  openHandlesTimeout: TOptional<TNumber>;
  outputFile: TOptional<TString>;
  passWithNoTests: TOptional<TBoolean>;
  preset: TOptional<TUnion<[TString, TNull]>>;
  prettierPath: TOptional<TUnion<[TString, TNull]>>;
  projects: TOptional<TArray<TUnion<[TString, TRecord<TString, TUnknown>]>>>;
  randomize: TOptional<TBoolean>;
  replname: TOptional<TUnion<[TString, TNull]>>;
  resetMocks: TOptional<TBoolean>;
  resetModules: TOptional<TBoolean>;
  resolver: TOptional<TUnion<[TString, TNull]>>;
  restoreMocks: TOptional<TBoolean>;
  rootDir: TOptional<TString>;
  roots: TOptional<TArray<TString>>;
  runner: TOptional<TString>;
  runTestsByPath: TOptional<TBoolean>;
  runtime: TOptional<TString>;
  sandboxInjectedGlobals: TOptional<TArray<TString>>;
  setupFiles: TOptional<TArray<TString>>;
  setupFilesAfterEnv: TOptional<TArray<TString>>;
  showSeed: TOptional<TBoolean>;
  silent: TOptional<TBoolean>;
  skipFilter: TOptional<TBoolean>;
  skipNodeResolution: TOptional<TBoolean>;
  slowTestThreshold: TOptional<TNumber>;
  snapshotResolver: TOptional<TString>;
  snapshotSerializers: TOptional<TArray<TString>>;
  snapshotFormat: TOptional<
    TObject<{
      callToJSON: TOptional<TBoolean>;
      compareKeys: TOptional<TNull>;
      escapeRegex: TOptional<TBoolean>;
      escapeString: TOptional<TBoolean>;
      highlight: TOptional<TBoolean>;
      indent: TOptional<TInteger>;
      maxDepth: TOptional<TInteger>;
      maxWidth: TOptional<TInteger>;
      min: TOptional<TBoolean>;
      printBasicPrototype: TOptional<TBoolean>;
      printFunctionName: TOptional<TBoolean>;
      theme: TOptional<
        TObject<{
          comment: TOptional<TString>;
          content: TOptional<TString>;
          prop: TOptional<TString>;
          tag: TOptional<TString>;
          value: TOptional<TString>;
        }>
      >;
    }>
  >;
  errorOnDeprecated: TOptional<TBoolean>;
  testEnvironment: TOptional<TString>;
  testEnvironmentOptions: TOptional<TRecord<TString, TUnknown>>;
  testFailureExitCode: TOptional<TInteger>;
  testLocationInResults: TOptional<TBoolean>;
  testMatch: TOptional<TArray<TString>>;
  testNamePattern: TOptional<TString>;
  testPathIgnorePatterns: TOptional<TArray<TString>>;
  testRegex: TOptional<TUnion<[TString, TArray<TString>]>>;
  testResultsProcessor: TOptional<TString>;
  testRunner: TOptional<TString>;
  testSequencer: TOptional<TString>;
  testTimeout: TOptional<TNumber>;
  transform: TOptional<
    TRecord<TString, TUnion<[TString, TTuple<[TString, TUnknown]>]>>
  >;
  transformIgnorePatterns: TOptional<TArray<TString>>;
  watchPathIgnorePatterns: TOptional<TArray<TString>>;
  unmockedModulePathPatterns: TOptional<TArray<TString>>;
  updateSnapshot: TOptional<TBoolean>;
  useStderr: TOptional<TBoolean>;
  verbose: TOptional<TBoolean>;
  waitForUnhandledRejections: TOptional<TBoolean>;
  watch: TOptional<TBoolean>;
  watchAll: TOptional<TBoolean>;
  watchman: TOptional<TBoolean>;
  watchPlugins: TOptional<
    TArray<TUnion<[TString, TTuple<[TString, TUnknown]>]>>
  >;
  workerIdleMemoryLimit: TOptional<TUnion<[TNumber, TString]>>;
  workerThreads: TOptional<TBoolean>;
}>;

export declare type InitialOptions = Static<typeof InitialOptions>;

export declare const SnapshotFormat: TObject<{
  callToJSON: TOptional<TBoolean>;
  compareKeys: TOptional<TNull>;
  escapeRegex: TOptional<TBoolean>;
  escapeString: TOptional<TBoolean>;
  highlight: TOptional<TBoolean>;
  indent: TOptional<TInteger>;
  maxDepth: TOptional<TInteger>;
  maxWidth: TOptional<TInteger>;
  min: TOptional<TBoolean>;
  printBasicPrototype: TOptional<TBoolean>;
  printFunctionName: TOptional<TBoolean>;
  theme: TOptional<
    TObject<{
      comment: TOptional<TString>;
      content: TOptional<TString>;
      prop: TOptional<TString>;
      tag: TOptional<TString>;
      value: TOptional<TString>;
    }>
  >;
}>;

export declare type SnapshotFormat = Static<typeof SnapshotFormat>;

export {};


---

File name: node_modules\babel-jest\node_modules\@jest\schemas\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/raw-types.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SnapshotFormat = exports.InitialOptions = exports.FakeTimers = exports.CoverageReporterNames = exports.ChalkForegroundColors = void 0;
function _typebox() {
  const data = require("@sinclair/typebox");
  _typebox = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint-disable sort-keys */

const SnapshotFormat = exports.SnapshotFormat = _typebox().Type.Partial(_typebox().Type.Object({
  callToJSON: _typebox().Type.Boolean(),
  compareKeys: _typebox().Type.Null(),
  escapeRegex: _typebox().Type.Boolean(),
  escapeString: _typebox().Type.Boolean(),
  highlight: _typebox().Type.Boolean(),
  indent: _typebox().Type.Integer({
    minimum: 0
  }),
  maxDepth: _typebox().Type.Integer({
    minimum: 0
  }),
  maxWidth: _typebox().Type.Integer({
    minimum: 0
  }),
  min: _typebox().Type.Boolean(),
  printBasicPrototype: _typebox().Type.Boolean(),
  printFunctionName: _typebox().Type.Boolean(),
  theme: _typebox().Type.Partial(_typebox().Type.Object({
    comment: _typebox().Type.String(),
    content: _typebox().Type.String(),
    prop: _typebox().Type.String(),
    tag: _typebox().Type.String(),
    value: _typebox().Type.String()
  }))
}));
const CoverageProvider = _typebox().Type.Union([_typebox().Type.Literal('babel'), _typebox().Type.Literal('v8')]);
const CoverageThresholdValue = _typebox().Type.Partial(_typebox().Type.Object({
  branches: _typebox().Type.Number({
    minimum: 0,
    maximum: 100
  }),
  functions: _typebox().Type.Number({
    minimum: 0,
    maximum: 100
  }),
  lines: _typebox().Type.Number({
    minimum: 0,
    maximum: 100
  }),
  statements: _typebox().Type.Number({
    minimum: 0,
    maximum: 100
  })
}));
const CoverageThresholdBase = _typebox().Type.Object({
  global: CoverageThresholdValue
}, {
  additionalProperties: CoverageThresholdValue
});
const CoverageThreshold = _typebox().Type.Unsafe(CoverageThresholdBase);

// TODO: add type test that these are all the colors available in chalk.ForegroundColor
const ChalkForegroundColors = exports.ChalkForegroundColors = _typebox().Type.Union([_typebox().Type.Literal('black'), _typebox().Type.Literal('red'), _typebox().Type.Literal('green'), _typebox().Type.Literal('yellow'), _typebox().Type.Literal('blue'), _typebox().Type.Literal('magenta'), _typebox().Type.Literal('cyan'), _typebox().Type.Literal('white'), _typebox().Type.Literal('gray'), _typebox().Type.Literal('grey'), _typebox().Type.Literal('blackBright'), _typebox().Type.Literal('redBright'), _typebox().Type.Literal('greenBright'), _typebox().Type.Literal('yellowBright'), _typebox().Type.Literal('blueBright'), _typebox().Type.Literal('magentaBright'), _typebox().Type.Literal('cyanBright'), _typebox().Type.Literal('whiteBright')]);
const DisplayName = _typebox().Type.Object({
  name: _typebox().Type.String(),
  color: ChalkForegroundColors
});

// TODO: verify these are the names of istanbulReport.ReportOptions
const CoverageReporterNames = exports.CoverageReporterNames = _typebox().Type.Union([_typebox().Type.Literal('clover'), _typebox().Type.Literal('cobertura'), _typebox().Type.Literal('html-spa'), _typebox().Type.Literal('html'), _typebox().Type.Literal('json'), _typebox().Type.Literal('json-summary'), _typebox().Type.Literal('lcov'), _typebox().Type.Literal('lcovonly'), _typebox().Type.Literal('none'), _typebox().Type.Literal('teamcity'), _typebox().Type.Literal('text'), _typebox().Type.Literal('text-lcov'), _typebox().Type.Literal('text-summary')]);
const CoverageReporters = _typebox().Type.Array(_typebox().Type.Union([CoverageReporterNames, _typebox().Type.Tuple([CoverageReporterNames, _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Unknown())])]));
const GlobalFakeTimersConfig = _typebox().Type.Partial(_typebox().Type.Object({
  enableGlobally: _typebox().Type.Boolean({
    description: 'Whether fake timers should be enabled globally for all test files.',
    default: false
  })
}));
const FakeableAPI = _typebox().Type.Union([_typebox().Type.Literal('Date'), _typebox().Type.Literal('hrtime'), _typebox().Type.Literal('nextTick'), _typebox().Type.Literal('performance'), _typebox().Type.Literal('queueMicrotask'), _typebox().Type.Literal('requestAnimationFrame'), _typebox().Type.Literal('cancelAnimationFrame'), _typebox().Type.Literal('requestIdleCallback'), _typebox().Type.Literal('cancelIdleCallback'), _typebox().Type.Literal('setImmediate'), _typebox().Type.Literal('clearImmediate'), _typebox().Type.Literal('setInterval'), _typebox().Type.Literal('clearInterval'), _typebox().Type.Literal('setTimeout'), _typebox().Type.Literal('clearTimeout')]);
const FakeTimersConfig = _typebox().Type.Partial(_typebox().Type.Object({
  advanceTimers: _typebox().Type.Union([_typebox().Type.Boolean(), _typebox().Type.Number({
    minimum: 0
  })], {
    description: 'If set to `true` all timers will be advanced automatically by 20 milliseconds every 20 milliseconds. A custom ' + 'time delta may be provided by passing a number.',
    default: false
  }),
  doNotFake: _typebox().Type.Array(FakeableAPI, {
    description: 'List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`, `setTimeout()`) that should not be faked.' + '\n\nThe default is `[]`, meaning all APIs are faked.',
    default: []
  }),
  now: _typebox().Type.Integer({
    minimum: 0,
    description: 'Sets current system time to be used by fake timers.\n\nThe default is `Date.now()`.'
  }),
  timerLimit: _typebox().Type.Number({
    description: 'The maximum number of recursive timers that will be run when calling `jest.runAllTimers()`.',
    default: 100_000,
    minimum: 0
  }),
  legacyFakeTimers: _typebox().Type.Literal(false, {
    description: 'Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.',
    default: false
  })
}));
const LegacyFakeTimersConfig = _typebox().Type.Partial(_typebox().Type.Object({
  legacyFakeTimers: _typebox().Type.Literal(true, {
    description: 'Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.',
    default: true
  })
}));
const FakeTimers = exports.FakeTimers = _typebox().Type.Intersect([GlobalFakeTimersConfig, _typebox().Type.Union([FakeTimersConfig, LegacyFakeTimersConfig])]);
const HasteConfig = _typebox().Type.Partial(_typebox().Type.Object({
  computeSha1: _typebox().Type.Boolean({
    description: 'Whether to hash files using SHA-1.'
  }),
  defaultPlatform: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()], {
    description: 'The platform to use as the default, e.g. `ios`.'
  }),
  forceNodeFilesystemAPI: _typebox().Type.Boolean({
    description: "Whether to force the use of Node's `fs` API when reading files rather than shelling out to `find`."
  }),
  enableSymlinks: _typebox().Type.Boolean({
    description: 'Whether to follow symlinks when crawling for files.' + '\n\tThis options cannot be used in projects which use watchman.' + '\n\tProjects with `watchman` set to true will error if this option is set to true.'
  }),
  hasteImplModulePath: _typebox().Type.String({
    description: 'Path to a custom implementation of Haste.'
  }),
  platforms: _typebox().Type.Array(_typebox().Type.String(), {
    description: "All platforms to target, e.g ['ios', 'android']."
  }),
  throwOnModuleCollision: _typebox().Type.Boolean({
    description: 'Whether to throw an error on module collision.'
  }),
  hasteMapModulePath: _typebox().Type.String({
    description: 'Custom HasteMap module'
  }),
  retainAllFiles: _typebox().Type.Boolean({
    description: 'Whether to retain all files, allowing e.g. search for tests in `node_modules`.'
  })
}));
const InitialOptions = exports.InitialOptions = _typebox().Type.Partial(_typebox().Type.Object({
  automock: _typebox().Type.Boolean(),
  bail: _typebox().Type.Union([_typebox().Type.Boolean(), _typebox().Type.Number()]),
  cache: _typebox().Type.Boolean(),
  cacheDirectory: _typebox().Type.String(),
  ci: _typebox().Type.Boolean(),
  clearMocks: _typebox().Type.Boolean(),
  changedFilesWithAncestor: _typebox().Type.Boolean(),
  changedSince: _typebox().Type.String(),
  collectCoverage: _typebox().Type.Boolean(),
  collectCoverageFrom: _typebox().Type.Array(_typebox().Type.String()),
  coverageDirectory: _typebox().Type.String(),
  coveragePathIgnorePatterns: _typebox().Type.Array(_typebox().Type.String()),
  coverageProvider: CoverageProvider,
  coverageReporters: CoverageReporters,
  coverageThreshold: CoverageThreshold,
  dependencyExtractor: _typebox().Type.String(),
  detectLeaks: _typebox().Type.Boolean(),
  detectOpenHandles: _typebox().Type.Boolean(),
  displayName: _typebox().Type.Union([_typebox().Type.String(), DisplayName]),
  expand: _typebox().Type.Boolean(),
  extensionsToTreatAsEsm: _typebox().Type.Array(_typebox().Type.String()),
  fakeTimers: FakeTimers,
  filter: _typebox().Type.String(),
  findRelatedTests: _typebox().Type.Boolean(),
  forceCoverageMatch: _typebox().Type.Array(_typebox().Type.String()),
  forceExit: _typebox().Type.Boolean(),
  json: _typebox().Type.Boolean(),
  globals: _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Unknown()),
  globalSetup: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  globalTeardown: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  haste: HasteConfig,
  id: _typebox().Type.String(),
  injectGlobals: _typebox().Type.Boolean(),
  reporters: _typebox().Type.Array(_typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Tuple([_typebox().Type.String(), _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Unknown())])])),
  logHeapUsage: _typebox().Type.Boolean(),
  lastCommit: _typebox().Type.Boolean(),
  listTests: _typebox().Type.Boolean(),
  maxConcurrency: _typebox().Type.Integer(),
  maxWorkers: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Integer()]),
  moduleDirectories: _typebox().Type.Array(_typebox().Type.String()),
  moduleFileExtensions: _typebox().Type.Array(_typebox().Type.String()),
  moduleNameMapper: _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Array(_typebox().Type.String())])),
  modulePathIgnorePatterns: _typebox().Type.Array(_typebox().Type.String()),
  modulePaths: _typebox().Type.Array(_typebox().Type.String()),
  noStackTrace: _typebox().Type.Boolean(),
  notify: _typebox().Type.Boolean(),
  notifyMode: _typebox().Type.String(),
  onlyChanged: _typebox().Type.Boolean(),
  onlyFailures: _typebox().Type.Boolean(),
  openHandlesTimeout: _typebox().Type.Number(),
  outputFile: _typebox().Type.String(),
  passWithNoTests: _typebox().Type.Boolean(),
  preset: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  prettierPath: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  projects: _typebox().Type.Array(_typebox().Type.Union([_typebox().Type.String(),
  // TODO: Make sure to type these correctly
  _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Unknown())])),
  randomize: _typebox().Type.Boolean(),
  replname: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  resetMocks: _typebox().Type.Boolean(),
  resetModules: _typebox().Type.Boolean(),
  resolver: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Null()]),
  restoreMocks: _typebox().Type.Boolean(),
  rootDir: _typebox().Type.String(),
  roots: _typebox().Type.Array(_typebox().Type.String()),
  runner: _typebox().Type.String(),
  runTestsByPath: _typebox().Type.Boolean(),
  runtime: _typebox().Type.String(),
  sandboxInjectedGlobals: _typebox().Type.Array(_typebox().Type.String()),
  setupFiles: _typebox().Type.Array(_typebox().Type.String()),
  setupFilesAfterEnv: _typebox().Type.Array(_typebox().Type.String()),
  showSeed: _typebox().Type.Boolean(),
  silent: _typebox().Type.Boolean(),
  skipFilter: _typebox().Type.Boolean(),
  skipNodeResolution: _typebox().Type.Boolean(),
  slowTestThreshold: _typebox().Type.Number(),
  snapshotResolver: _typebox().Type.String(),
  snapshotSerializers: _typebox().Type.Array(_typebox().Type.String()),
  snapshotFormat: SnapshotFormat,
  errorOnDeprecated: _typebox().Type.Boolean(),
  testEnvironment: _typebox().Type.String(),
  testEnvironmentOptions: _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Unknown()),
  testFailureExitCode: _typebox().Type.Integer(),
  testLocationInResults: _typebox().Type.Boolean(),
  testMatch: _typebox().Type.Array(_typebox().Type.String()),
  testNamePattern: _typebox().Type.String(),
  testPathIgnorePatterns: _typebox().Type.Array(_typebox().Type.String()),
  testRegex: _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Array(_typebox().Type.String())]),
  testResultsProcessor: _typebox().Type.String(),
  testRunner: _typebox().Type.String(),
  testSequencer: _typebox().Type.String(),
  testTimeout: _typebox().Type.Number(),
  transform: _typebox().Type.Record(_typebox().Type.String(), _typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Tuple([_typebox().Type.String(), _typebox().Type.Unknown()])])),
  transformIgnorePatterns: _typebox().Type.Array(_typebox().Type.String()),
  watchPathIgnorePatterns: _typebox().Type.Array(_typebox().Type.String()),
  unmockedModulePathPatterns: _typebox().Type.Array(_typebox().Type.String()),
  updateSnapshot: _typebox().Type.Boolean(),
  useStderr: _typebox().Type.Boolean(),
  verbose: _typebox().Type.Boolean(),
  waitForUnhandledRejections: _typebox().Type.Boolean(),
  watch: _typebox().Type.Boolean(),
  watchAll: _typebox().Type.Boolean(),
  watchman: _typebox().Type.Boolean(),
  watchPlugins: _typebox().Type.Array(_typebox().Type.Union([_typebox().Type.String(), _typebox().Type.Tuple([_typebox().Type.String(), _typebox().Type.Unknown()])])),
  workerIdleMemoryLimit: _typebox().Type.Union([_typebox().Type.Number(), _typebox().Type.String()]),
  workerThreads: _typebox().Type.Boolean()
}));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SnapshotFormat = exports.InitialOptions = exports.FakeTimers = void 0;
var types = _interopRequireWildcard(__webpack_require__("./src/raw-types.ts"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const SnapshotFormat = exports.SnapshotFormat = types.SnapshotFormat;
const InitialOptions = exports.InitialOptions = types.InitialOptions;
const FakeTimers = exports.FakeTimers = types.FakeTimers;
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\@jest\schemas\package.json

Code:
{
  "name": "@jest/schemas",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-schemas"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@sinclair/typebox": "^0.34.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}


---

File name: node_modules\babel-jest\node_modules\@jest\schemas\README.md

Code:
# `@jest/schemas`

Experimental and currently incomplete module for JSON schemas for [Jest's](https://jestjs.io/) configuration.


---

File name: node_modules\babel-jest\node_modules\@jest\transform\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {EncodedSourceMap} from '@jridgewell/trace-mapping';
import {Config, TransformTypes} from '@jest/types';

export declare interface AsyncTransformer<TransformerConfig = unknown> {
  /**
   * Indicates if the transformer is capable of instrumenting the code for code coverage.
   *
   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.
   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.
   */
  canInstrument?: boolean;
  getCacheKey?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => string;
  getCacheKeyAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => Promise<string>;
  process?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => TransformedSource;
  processAsync: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => Promise<TransformedSource>;
}

export declare interface CallerTransformOptions {
  supportsDynamicImport: boolean;
  supportsExportNamespaceFrom: boolean;
  supportsStaticESM: boolean;
  supportsTopLevelAwait: boolean;
}

export declare function createScriptTransformer(
  config: Config.ProjectConfig,
  cacheFS?: StringMap,
): Promise<ScriptTransformer>;

export declare function createTranspilingRequire(
  config: Config.ProjectConfig,
): Promise<
  <TModuleType = unknown>(
    resolverPath: string,
    applyInteropRequireDefault?: boolean,
  ) => Promise<TModuleType>
>;

declare interface ErrorWithCodeFrame extends Error {
  codeFrame?: string;
}

declare interface FixedRawSourceMap extends Omit<EncodedSourceMap, 'version'> {
  version: number;
}

export declare function handlePotentialSyntaxError(
  e: ErrorWithCodeFrame,
): ErrorWithCodeFrame;

declare interface ReducedTransformOptions extends CallerTransformOptions {
  instrument: boolean;
}

declare interface RequireAndTranspileModuleOptions
  extends ReducedTransformOptions {
  applyInteropRequireDefault: boolean;
}

export declare type ScriptTransformer = ScriptTransformer_2;

declare class ScriptTransformer_2 {
  private readonly _config;
  private readonly _cacheFS;
  private readonly _cache;
  private readonly _transformCache;
  private _transformsAreLoaded;
  constructor(_config: Config.ProjectConfig, _cacheFS: StringMap);
  private _buildCacheKeyFromFileInfo;
  private _buildTransformCacheKey;
  private _getCacheKey;
  private _getCacheKeyAsync;
  private _createCachedFilename;
  private _getFileCachePath;
  private _getFileCachePathAsync;
  private _getTransformPatternAndPath;
  private _getTransformPath;
  loadTransformers(): Promise<void>;
  private _getTransformer;
  private _instrumentFile;
  private _buildTransformResult;
  transformSource(
    filepath: string,
    content: string,
    options: ReducedTransformOptions,
  ): TransformResult;
  transformSourceAsync(
    filepath: string,
    content: string,
    options: ReducedTransformOptions,
  ): Promise<TransformResult>;
  private _transformAndBuildScriptAsync;
  private _transformAndBuildScript;
  transformAsync(
    filename: string,
    options: TransformationOptions,
    fileSource?: string,
  ): Promise<TransformResult>;
  transform(
    filename: string,
    options: TransformationOptions,
    fileSource?: string,
  ): TransformResult;
  transformJson(
    filename: string,
    options: TransformationOptions,
    fileSource: string,
  ): string;
  requireAndTranspileModule<ModuleType = unknown>(
    moduleName: string,
    callback?: (module: ModuleType) => void | Promise<void>,
    options?: RequireAndTranspileModuleOptions,
  ): Promise<ModuleType>;
  shouldTransform(filename: string): boolean;
}

export declare function shouldInstrument(
  filename: string,
  options: ShouldInstrumentOptions,
  config: Config.ProjectConfig,
  loadedFilenames?: Array<string>,
): boolean;

export declare interface ShouldInstrumentOptions
  extends Pick<
    Config.GlobalConfig,
    'collectCoverage' | 'collectCoverageFrom' | 'coverageProvider'
  > {
  changedFiles?: Set<string>;
  sourcesRelatedToTestsInChangedFiles?: Set<string>;
}

declare type StringMap = Map<string, string>;

export declare interface SyncTransformer<TransformerConfig = unknown> {
  /**
   * Indicates if the transformer is capable of instrumenting the code for code coverage.
   *
   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.
   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.
   */
  canInstrument?: boolean;
  getCacheKey?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => string;
  getCacheKeyAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => Promise<string>;
  process: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => TransformedSource;
  processAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<TransformerConfig>,
  ) => Promise<TransformedSource>;
}

export declare interface TransformationOptions
  extends ShouldInstrumentOptions,
    CallerTransformOptions {
  isInternalModule?: boolean;
}

export declare type TransformedSource = {
  code: string;
  map?: FixedRawSourceMap | string | null;
};

/**
 * We have both sync (`process`) and async (`processAsync`) code transformation, which both can be provided.
 * `require` will always use `process`, and `import` will use `processAsync` if it exists, otherwise fall back to `process`.
 * Meaning, if you use `import` exclusively you do not need `process`, but in most cases supplying both makes sense:
 * Jest transpiles on demand rather than ahead of time, so the sync one needs to exist.
 *
 * For more info on the sync vs async model, see https://jestjs.io/docs/code-transformation#writing-custom-transformers
 */
declare type Transformer_2<TransformerConfig = unknown> =
  | SyncTransformer<TransformerConfig>
  | AsyncTransformer<TransformerConfig>;
export {Transformer_2 as Transformer};

export declare type TransformerCreator<
  X extends Transformer_2<TransformerConfig>,
  TransformerConfig = unknown,
> = (transformerConfig?: TransformerConfig) => X | Promise<X>;

/**
 * Instead of having your custom transformer implement the Transformer interface
 * directly, you can choose to export a factory function to dynamically create
 * transformers. This is to allow having a transformer config in your jest config.
 */
export declare type TransformerFactory<X extends Transformer_2> = {
  createTransformer: TransformerCreator<X>;
};

export declare interface TransformOptions<TransformerConfig = unknown>
  extends ReducedTransformOptions {
  /** Cached file system which is used by `jest-runtime` to improve performance. */
  cacheFS: StringMap;
  /** Jest configuration of currently running project. */
  config: Config.ProjectConfig;
  /** Stringified version of the `config` - useful in cache busting. */
  configString: string;
  /** Transformer configuration passed through `transform` option by the user. */
  transformerConfig: TransformerConfig;
}

export declare type TransformResult = TransformTypes.TransformResult;

export {};


---

File name: node_modules\babel-jest\node_modules\@jest\transform\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./package.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@jest/transform","version":"30.0.1","repository":{"type":"git","url":"https://github.com/jestjs/jest.git","directory":"packages/jest-transform"},"license":"MIT","main":"./build/index.js","types":"./build/index.d.ts","exports":{".":{"types":"./build/index.d.ts","require":"./build/index.js","import":"./build/index.mjs","default":"./build/index.js"},"./package.json":"./package.json"},"dependencies":{"@babel/core":"^7.27.4","@jest/types":"workspace:*","@jridgewell/trace-mapping":"^0.3.25","babel-plugin-istanbul":"^7.0.0","chalk":"^4.1.2","convert-source-map":"^2.0.0","fast-json-stable-stringify":"^2.1.0","graceful-fs":"^4.2.11","jest-haste-map":"workspace:*","jest-regex-util":"workspace:*","jest-util":"workspace:*","micromatch":"^4.0.8","pirates":"^4.0.7","slash":"^3.0.0","write-file-atomic":"^5.0.1"},"devDependencies":{"@jest/test-utils":"workspace:*","@types/babel__core":"^7.20.5","@types/convert-source-map":"^2.0.3","@types/graceful-fs":"^4.1.9","@types/micromatch":"^4.0.9","@types/write-file-atomic":"^4.0.3","dedent":"^1.6.0"},"engines":{"node":"^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"},"publishConfig":{"access":"public"}}');

/***/ }),

/***/ "./src/ScriptTransformer.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createScriptTransformer = createScriptTransformer;
exports.createTranspilingRequire = createTranspilingRequire;
function _crypto() {
  const data = require("crypto");
  _crypto = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _core() {
  const data = require("@babel/core");
  _core = function () {
    return data;
  };
  return data;
}
function _babelPluginIstanbul() {
  const data = _interopRequireDefault(require("babel-plugin-istanbul"));
  _babelPluginIstanbul = function () {
    return data;
  };
  return data;
}
function _convertSourceMap() {
  const data = require("convert-source-map");
  _convertSourceMap = function () {
    return data;
  };
  return data;
}
function _fastJsonStableStringify() {
  const data = _interopRequireDefault(require("fast-json-stable-stringify"));
  _fastJsonStableStringify = function () {
    return data;
  };
  return data;
}
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
function _pirates() {
  const data = require("pirates");
  _pirates = function () {
    return data;
  };
  return data;
}
function _slash() {
  const data = _interopRequireDefault(require("slash"));
  _slash = function () {
    return data;
  };
  return data;
}
function _writeFileAtomic() {
  const data = require("write-file-atomic");
  _writeFileAtomic = function () {
    return data;
  };
  return data;
}
function _jestHasteMap() {
  const data = _interopRequireDefault(require("jest-haste-map"));
  _jestHasteMap = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require("jest-util");
  _jestUtil = function () {
    return data;
  };
  return data;
}
var _enhanceUnexpectedTokenMessage = _interopRequireDefault(__webpack_require__("./src/enhanceUnexpectedTokenMessage.ts"));
var _runtimeErrorsAndWarnings = __webpack_require__("./src/runtimeErrorsAndWarnings.ts");
var _shouldInstrument = _interopRequireDefault(__webpack_require__("./src/shouldInstrument.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// @ts-expect-error: should just be `require.resolve`, but the tests mess that up

// Use `require` to avoid TS rootDir
const {
  version: VERSION
} = __webpack_require__("./package.json");
// This data structure is used to avoid recalculating some data every time that
// we need to transform a file. Since ScriptTransformer is instantiated for each
// file we need to keep this object in the local scope of this module.
const projectCaches = new Map();

// To reset the cache for specific changesets (rather than package version).
const CACHE_VERSION = '1';
async function waitForPromiseWithCleanup(promise, cleanup) {
  try {
    await promise;
  } finally {
    cleanup();
  }
}

// type predicate
function isTransformerFactory(t) {
  return typeof t.createTransformer === 'function';
}
class ScriptTransformer {
  _cache;
  _transformCache = new Map();
  _transformsAreLoaded = false;
  constructor(_config, _cacheFS) {
    this._config = _config;
    this._cacheFS = _cacheFS;
    const configString = (0, _fastJsonStableStringify().default)(this._config);
    let projectCache = projectCaches.get(configString);
    if (!projectCache) {
      projectCache = {
        configString,
        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),
        transformRegExp: calcTransformRegExp(this._config),
        transformedFiles: new Map()
      };
      projectCaches.set(configString, projectCache);
    }
    this._cache = projectCache;
  }
  _buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey) {
    if (transformerCacheKey != null) {
      return (0, _crypto().createHash)('sha1').update(transformerCacheKey).update(CACHE_VERSION).digest('hex').slice(0, 32);
    }
    return (0, _crypto().createHash)('sha1').update(fileData).update(transformOptions.configString).update(transformOptions.instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex').slice(0, 32);
  }
  _buildTransformCacheKey(pattern, filepath) {
    return pattern + filepath;
  }
  _getCacheKey(fileData, filename, options) {
    const configString = this._cache.configString;
    const {
      transformer,
      transformerConfig = {}
    } = this._getTransformer(filename) ?? {};
    let transformerCacheKey = undefined;
    const transformOptions = {
      ...options,
      cacheFS: this._cacheFS,
      config: this._config,
      configString,
      transformerConfig
    };
    if (typeof transformer?.getCacheKey === 'function') {
      transformerCacheKey = transformer.getCacheKey(fileData, filename, transformOptions);
    }
    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);
  }
  async _getCacheKeyAsync(fileData, filename, options) {
    const configString = this._cache.configString;
    const {
      transformer,
      transformerConfig = {}
    } = this._getTransformer(filename) ?? {};
    let transformerCacheKey = undefined;
    const transformOptions = {
      ...options,
      cacheFS: this._cacheFS,
      config: this._config,
      configString,
      transformerConfig
    };
    if (transformer) {
      const getCacheKey = transformer.getCacheKeyAsync ?? transformer.getCacheKey;
      if (typeof getCacheKey === 'function') {
        transformerCacheKey = await getCacheKey(fileData, filename, transformOptions);
      }
    }
    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);
  }
  _createCachedFilename(filename, cacheKey) {
    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);
    const baseCacheDir = HasteMapClass.getCacheFilePath(this._config.cacheDirectory, `jest-transform-cache-${this._config.id}`, VERSION);
    // Create sub folders based on the cacheKey to avoid creating one
    // directory with many files.
    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);
    const cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replaceAll(/\W/g, '');
    return (0, _slash().default)(path().join(cacheDir, `${cacheFilenamePrefix}_${cacheKey}`));
  }
  _getFileCachePath(filename, content, options) {
    const cacheKey = this._getCacheKey(content, filename, options);
    return this._createCachedFilename(filename, cacheKey);
  }
  async _getFileCachePathAsync(filename, content, options) {
    const cacheKey = await this._getCacheKeyAsync(content, filename, options);
    return this._createCachedFilename(filename, cacheKey);
  }
  _getTransformPatternAndPath(filename) {
    const transformEntry = this._cache.transformRegExp;
    if (transformEntry == null) {
      return undefined;
    }
    for (const item of transformEntry) {
      const [transformRegExp, transformPath] = item;
      if (transformRegExp.test(filename)) {
        return [transformRegExp.source, transformPath];
      }
    }
    return undefined;
  }
  _getTransformPath(filename) {
    const transformInfo = this._getTransformPatternAndPath(filename);
    if (!Array.isArray(transformInfo)) {
      return undefined;
    }
    return transformInfo[1];
  }
  async loadTransformers() {
    await Promise.all(this._config.transform.map(async ([transformPattern, transformPath, transformerConfig], i) => {
      let transformer = await (0, _jestUtil().requireOrImportModule)(transformPath);
      if (transformer == null) {
        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));
      }
      if (isTransformerFactory(transformer)) {
        transformer = await transformer.createTransformer(transformerConfig);
      }
      if (typeof transformer.process !== 'function' && typeof transformer.processAsync !== 'function') {
        throw new TypeError((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));
      }
      const res = {
        transformer,
        transformerConfig
      };
      const transformCacheKey = this._buildTransformCacheKey(this._cache.transformRegExp?.[i]?.[0].source ?? new RegExp(transformPattern).source, transformPath);
      this._transformCache.set(transformCacheKey, res);
    }));
    this._transformsAreLoaded = true;
  }
  _getTransformer(filename) {
    if (!this._transformsAreLoaded) {
      throw new Error('Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files');
    }
    if (this._config.transform.length === 0) {
      return null;
    }
    const transformPatternAndPath = this._getTransformPatternAndPath(filename);
    if (!Array.isArray(transformPatternAndPath)) {
      return null;
    }
    const [transformPattern, transformPath] = transformPatternAndPath;
    const transformCacheKey = this._buildTransformCacheKey(transformPattern, transformPath);
    const transformer = this._transformCache.get(transformCacheKey);
    if (transformer !== undefined) {
      return transformer;
    }
    throw new Error(`Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`);
  }
  _instrumentFile(filename, input, canMapToInput, options) {
    const inputCode = typeof input === 'string' ? input : input.code;
    const inputMap = typeof input === 'string' ? null : input.map;
    const result = (0, _core().transformSync)(inputCode, {
      auxiliaryCommentBefore: ' istanbul ignore next ',
      babelrc: false,
      caller: {
        name: '@jest/transform',
        supportsDynamicImport: options.supportsDynamicImport,
        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,
        supportsStaticESM: options.supportsStaticESM,
        supportsTopLevelAwait: options.supportsTopLevelAwait
      },
      configFile: false,
      filename,
      plugins: [[_babelPluginIstanbul().default, {
        compact: false,
        // files outside `cwd` will not be instrumented
        cwd: this._config.rootDir,
        exclude: [],
        extension: false,
        inputSourceMap: inputMap,
        useInlineSourceMaps: false
      }]],
      sourceMaps: canMapToInput ? 'both' : false
    });
    if (result?.code != null) {
      return result;
    }
    return input;
  }
  _buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath) {
    let transformed = {
      code: content,
      map: null
    };
    if (transformer && shouldCallTransform) {
      if (processed != null && typeof processed.code === 'string') {
        transformed = processed;
      } else {
        const transformPath = this._getTransformPath(filename);
        (0, _jestUtil().invariant)(transformPath);
        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)(transformPath));
      }
    }
    if (transformed.map == null || transformed.map === '') {
      try {
        //Could be a potential freeze here.
        //See: https://github.com/jestjs/jest/pull/5177#discussion_r158883570
        const inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);
        if (inlineSourceMap) {
          transformed.map = inlineSourceMap.toObject();
        }
      } catch {
        const transformPath = this._getTransformPath(filename);
        (0, _jestUtil().invariant)(transformPath);
        console.warn((0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(filename, transformPath));
      }
    }

    // That means that the transform has a custom instrumentation
    // logic and will handle it based on `config.collectCoverage` option
    const transformWillInstrument = shouldCallTransform && transformer?.canInstrument;

    // Apply instrumentation to the code if necessary, keeping the instrumented code and new map
    let map = transformed.map;
    let code;
    if (transformWillInstrument !== true && options.instrument) {
      /**
       * We can map the original source code to the instrumented code ONLY if
       * - the process of transforming the code produced a source map e.g. ts-jest
       * - we did not transform the source code
       *
       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,
       * and we should NOT emit any source maps
       *
       */
      const shouldEmitSourceMaps = transformer != null && map != null || transformer == null;
      const instrumented = this._instrumentFile(filename, transformed, shouldEmitSourceMaps, options);
      code = typeof instrumented === 'string' ? instrumented : instrumented.code;
      map = typeof instrumented === 'string' ? null : instrumented.map;
    } else {
      code = transformed.code;
    }
    if (map == null) {
      sourceMapPath = null;
    } else {
      const sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);
      (0, _jestUtil().invariant)(sourceMapPath, 'We should always have default sourceMapPath');
      writeCacheFile(sourceMapPath, sourceMapContent);
    }
    writeCodeCacheFile(cacheFilePath, code);
    return {
      code,
      originalCode: content,
      sourceMapPath
    };
  }
  transformSource(filepath, content, options) {
    const filename = (0, _jestUtil().tryRealpath)(filepath);
    const {
      transformer,
      transformerConfig = {}
    } = this._getTransformer(filename) ?? {};
    const cacheFilePath = this._getFileCachePath(filename, content, options);
    const sourceMapPath = `${cacheFilePath}.map`;
    // Ignore cache if `config.cache` is set (--no-cache)
    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;
    if (code != null) {
      // This is broken: we return the code, and a path for the source map
      // directly from the cache. But, nothing ensures the source map actually
      // matches that source code. They could have gotten out-of-sync in case
      // two separate processes write concurrently to the same cache files.
      return {
        code,
        originalCode: content,
        sourceMapPath
      };
    }
    let processed = null;
    let shouldCallTransform = false;
    if (transformer && this.shouldTransform(filename)) {
      shouldCallTransform = true;
      assertSyncTransformer(transformer, this._getTransformPath(filename));
      processed = transformer.process(content, filename, {
        ...options,
        cacheFS: this._cacheFS,
        config: this._config,
        configString: this._cache.configString,
        transformerConfig
      });
    }
    (0, _jestUtil().createDirectory)(path().dirname(cacheFilePath));
    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);
  }
  async transformSourceAsync(filepath, content, options) {
    const filename = (0, _jestUtil().tryRealpath)(filepath);
    const {
      transformer,
      transformerConfig = {}
    } = this._getTransformer(filename) ?? {};
    const cacheFilePath = await this._getFileCachePathAsync(filename, content, options);
    const sourceMapPath = `${cacheFilePath}.map`;
    // Ignore cache if `config.cache` is set (--no-cache)
    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;
    if (code != null) {
      // This is broken: we return the code, and a path for the source map
      // directly from the cache. But, nothing ensures the source map actually
      // matches that source code. They could have gotten out-of-sync in case
      // two separate processes write concurrently to the same cache files.
      return {
        code,
        originalCode: content,
        sourceMapPath
      };
    }
    let processed = null;
    let shouldCallTransform = false;
    if (transformer && this.shouldTransform(filename)) {
      shouldCallTransform = true;
      const process = transformer.processAsync ?? transformer.process;

      // This is probably dead code since `_getTransformerAsync` already asserts this
      (0, _jestUtil().invariant)(typeof process === 'function', 'A transformer must always export either a `process` or `processAsync`');
      processed = await process(content, filename, {
        ...options,
        cacheFS: this._cacheFS,
        config: this._config,
        configString: this._cache.configString,
        transformerConfig
      });
    }
    (0, _jestUtil().createDirectory)(path().dirname(cacheFilePath));
    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);
  }
  async _transformAndBuildScriptAsync(filename, options, transformOptions, fileSource) {
    const {
      isInternalModule
    } = options;
    let fileContent = fileSource ?? this._cacheFS.get(filename);
    if (fileContent == null) {
      fileContent = fs().readFileSync(filename, 'utf8');
      this._cacheFS.set(filename, fileContent);
    }
    const content = stripShebang(fileContent);
    let code = content;
    let sourceMapPath = null;
    const willTransform = isInternalModule !== true && (transformOptions.instrument || this.shouldTransform(filename));
    try {
      if (willTransform) {
        const transformedSource = await this.transformSourceAsync(filename, content, transformOptions);
        code = transformedSource.code;
        sourceMapPath = transformedSource.sourceMapPath;
      }
      return {
        code,
        originalCode: content,
        sourceMapPath
      };
    } catch (error) {
      if (!(error instanceof Error)) {
        throw error;
      }
      throw (0, _enhanceUnexpectedTokenMessage.default)(error);
    }
  }
  _transformAndBuildScript(filename, options, transformOptions, fileSource) {
    const {
      isInternalModule
    } = options;
    let fileContent = fileSource ?? this._cacheFS.get(filename);
    if (fileContent == null) {
      fileContent = fs().readFileSync(filename, 'utf8');
      this._cacheFS.set(filename, fileContent);
    }
    const content = stripShebang(fileContent);
    let code = content;
    let sourceMapPath = null;
    const willTransform = isInternalModule !== true && (transformOptions.instrument || this.shouldTransform(filename));
    try {
      if (willTransform) {
        const transformedSource = this.transformSource(filename, content, transformOptions);
        code = transformedSource.code;
        sourceMapPath = transformedSource.sourceMapPath;
      }
      return {
        code,
        originalCode: content,
        sourceMapPath
      };
    } catch (error) {
      if (!(error instanceof Error)) {
        throw error;
      }
      throw (0, _enhanceUnexpectedTokenMessage.default)(error);
    }
  }
  async transformAsync(filename, options, fileSource) {
    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);
    const scriptCacheKey = getScriptCacheKey(filename, instrument);
    let result = this._cache.transformedFiles.get(scriptCacheKey);
    if (result) {
      return result;
    }
    result = await this._transformAndBuildScriptAsync(filename, options, {
      ...options,
      instrument
    }, fileSource);
    if (scriptCacheKey) {
      this._cache.transformedFiles.set(scriptCacheKey, result);
    }
    return result;
  }
  transform(filename, options, fileSource) {
    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);
    const scriptCacheKey = getScriptCacheKey(filename, instrument);
    let result = this._cache.transformedFiles.get(scriptCacheKey);
    if (result) {
      return result;
    }
    result = this._transformAndBuildScript(filename, options, {
      ...options,
      instrument
    }, fileSource);
    if (scriptCacheKey) {
      this._cache.transformedFiles.set(scriptCacheKey, result);
    }
    return result;
  }
  transformJson(filename, options, fileSource) {
    const {
      isInternalModule
    } = options;
    const willTransform = isInternalModule !== true && this.shouldTransform(filename);
    if (willTransform) {
      const {
        code: transformedJsonSource
      } = this.transformSource(filename, fileSource, {
        ...options,
        instrument: false
      });
      return transformedJsonSource;
    }
    return fileSource;
  }
  async requireAndTranspileModule(moduleName, callback, options) {
    options = {
      applyInteropRequireDefault: true,
      instrument: false,
      supportsDynamicImport: false,
      supportsExportNamespaceFrom: false,
      supportsStaticESM: false,
      supportsTopLevelAwait: false,
      ...options
    };
    let transforming = false;
    const {
      applyInteropRequireDefault,
      ...transformOptions
    } = options;
    const revertHook = (0, _pirates().addHook)((code, filename) => {
      try {
        transforming = true;
        return this.transformSource(filename, code, transformOptions).code || code;
      } finally {
        transforming = false;
      }
    }, {
      // Exclude `mjs` extension when addHook because pirates don't support hijack es module
      exts: this._config.moduleFileExtensions.filter(ext => ext !== 'mjs').map(ext => `.${ext}`),
      ignoreNodeModules: false,
      matcher: filename => {
        if (transforming) {
          // Don't transform any dependency required by the transformer itself
          return false;
        }
        return this.shouldTransform(filename);
      }
    });
    try {
      const module = await (0, _jestUtil().requireOrImportModule)(moduleName, applyInteropRequireDefault);
      if (!callback) {
        revertHook();
        return module;
      }
      const cbResult = callback(module);
      if ((0, _jestUtil().isPromise)(cbResult)) {
        return await waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);
      }
      return module;
    } finally {
      revertHook();
    }
  }
  shouldTransform(filename) {
    const ignoreRegexp = this._cache.ignorePatternsRegExp;
    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;
    return this._config.transform.length > 0 && !isIgnored;
  }
}

// TODO: do we need to define the generics twice?
async function createTranspilingRequire(config) {
  const transformer = await createScriptTransformer(config);
  return async function requireAndTranspileModule(resolverPath, applyInteropRequireDefault = false) {
    const transpiledModule = await transformer.requireAndTranspileModule(resolverPath,
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    () => {}, {
      applyInteropRequireDefault,
      instrument: false,
      supportsDynamicImport: false,
      // this might be true, depending on node version.
      supportsExportNamespaceFrom: false,
      supportsStaticESM: false,
      supportsTopLevelAwait: false
    });
    return transpiledModule;
  };
}
const removeFile = path => {
  try {
    fs().unlinkSync(path);
  } catch {}
};
const stripShebang = content => {
  // If the file data starts with a shebang remove it. Leaves the empty line
  // to keep stack trace line numbers correct.
  if (content.startsWith('#!')) {
    return content.replace(/^#!.*/, '');
  } else {
    return content;
  }
};

/**
 * This is like `writeCacheFile` but with an additional sanity checksum. We
 * cannot use the same technique for source maps because we expose source map
 * cache file paths directly to callsites, with the expectation they can read
 * it right away. This is not a great system, because source map cache file
 * could get corrupted, out-of-sync, etc.
 */
function writeCodeCacheFile(cachePath, code) {
  const checksum = (0, _crypto().createHash)('sha1').update(code).digest('hex').slice(0, 32);
  writeCacheFile(cachePath, `${checksum}\n${code}`);
}

/**
 * Read counterpart of `writeCodeCacheFile`. We verify that the content of the
 * file matches the checksum, in case some kind of corruption happened. This
 * could happen if an older version of `jest-runtime` writes non-atomically to
 * the same cache, for example.
 */
function readCodeCacheFile(cachePath) {
  const content = readCacheFile(cachePath);
  if (content == null) {
    return null;
  }
  const code = content.slice(33);
  const checksum = (0, _crypto().createHash)('sha1').update(code).digest('hex').slice(0, 32);
  if (checksum === content.slice(0, 32)) {
    return code;
  }
  return null;
}

/**
 * Writing to the cache atomically relies on 'rename' being atomic on most
 * file systems. Doing atomic write reduces the risk of corruption by avoiding
 * two processes to write to the same file at the same time. It also reduces
 * the risk of reading a file that's being overwritten at the same time.
 */
const writeCacheFile = (cachePath, fileData) => {
  try {
    (0, _writeFileAtomic().sync)(cachePath, fileData, {
      encoding: 'utf8',
      fsync: false
    });
  } catch (error) {
    if (!(error instanceof Error)) {
      throw error;
    }
    if (cacheWriteErrorSafeToIgnore(error)) {
      return;
    }
    error.message = `jest: failed to cache transform results in: ${cachePath}\nFailure message: ${error.message}`;
    removeFile(cachePath);
    throw error;
  }
};

/**
 * On Windows, renames are not atomic, leading to EPERM exceptions when two
 * processes attempt to rename to the same target file at the same time.
 * If the target file exists we can be reasonably sure another process has
 * legitimately won a cache write race and ignore the error.
 * If the target does not exist we do not know if it is because it is still
 * being written by another process or is being overwritten by another process.
 */
const cacheWriteErrorSafeToIgnore = e => process.platform === 'win32' && e.code === 'EPERM';
const readCacheFile = cachePath => {
  if (!fs().existsSync(cachePath)) {
    return null;
  }
  let fileData;
  try {
    fileData = fs().readFileSync(cachePath, 'utf8');
  } catch (error) {
    if (!(error instanceof Error)) {
      throw error;
    }
    // on windows write-file-atomic is not atomic which can
    // result in this error
    if (error.code === 'ENOENT' && process.platform === 'win32') {
      return null;
    }
    error.message = `jest: failed to read cache file: ${cachePath}\nFailure message: ${error.message}`;
    removeFile(cachePath);
    throw error;
  }
  if (fileData == null) {
    // We must have somehow created the file but failed to write to it,
    // let's delete it and retry.
    removeFile(cachePath);
  }
  return fileData;
};
const getScriptCacheKey = (filename, instrument) => {
  const mtime = fs().statSync(filename).mtime;
  return `${filename}_${mtime.getTime()}${instrument ? '_instrumented' : ''}`;
};
const calcIgnorePatternRegExp = config => {
  if (config.transformIgnorePatterns == null || config.transformIgnorePatterns.length === 0) {
    return undefined;
  }
  return new RegExp(config.transformIgnorePatterns.join('|'));
};
const calcTransformRegExp = config => {
  if (config.transform.length === 0) {
    return undefined;
  }
  const transformRegexp = [];
  for (const item of config.transform) {
    transformRegexp.push([new RegExp(item[0]), item[1], item[2]]);
  }
  return transformRegexp;
};
function assertSyncTransformer(transformer, name) {
  (0, _jestUtil().invariant)(name);
  (0, _jestUtil().invariant)(typeof transformer.process === 'function', (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name));
}
async function createScriptTransformer(config, cacheFS = new Map()) {
  const transformer = new ScriptTransformer(config, cacheFS);
  await transformer.loadTransformers();
  return transformer;
}

/***/ }),

/***/ "./src/enhanceUnexpectedTokenMessage.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = handlePotentialSyntaxError;
exports.enhanceUnexpectedTokenMessage = enhanceUnexpectedTokenMessage;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const DOT = ' \u2022 ';
function handlePotentialSyntaxError(e) {
  if (e.codeFrame != null) {
    e.stack = `${e.message}\n${e.codeFrame}`;
  }
  if (
  // `instanceof` might come from the wrong context
  e.name === 'SyntaxError' && !e.message.includes(' expected')) {
    throw enhanceUnexpectedTokenMessage(e);
  }
  return e;
}
function enhanceUnexpectedTokenMessage(e) {
  e.stack = `${_chalk().default.bold.red('Jest encountered an unexpected token')}

Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.

Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.

By default "node_modules" folder is ignored by transformers.

Here's what you can do:
${DOT}If you are trying to use ECMAScript Modules, see ${_chalk().default.underline('https://jestjs.io/docs/ecmascript-modules')} for how to enable it.
${DOT}If you are trying to use TypeScript, see ${_chalk().default.underline('https://jestjs.io/docs/getting-started#using-typescript')}
${DOT}To have some of your "node_modules" files transformed, you can specify a custom ${_chalk().default.bold('"transformIgnorePatterns"')} in your config.
${DOT}If you need a custom transformation, specify a ${_chalk().default.bold('"transform"')} option in your config.
${DOT}If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the ${_chalk().default.bold('"moduleNameMapper"')} config option.

You'll find more details and examples of these config options in the docs:
${_chalk().default.cyan('https://jestjs.io/docs/configuration')}
For information about custom transformations, see:
${_chalk().default.cyan('https://jestjs.io/docs/code-transformation')}

${_chalk().default.bold.red('Details:')}

${e.stack ?? ''}`.trimEnd();
  return e;
}

/***/ }),

/***/ "./src/runtimeErrorsAndWarnings.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeInvalidTransformerError = exports.makeInvalidSyncTransformerError = exports.makeInvalidSourceMapWarning = exports.makeInvalidReturnValueError = void 0;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _slash() {
  const data = _interopRequireDefault(require("slash"));
  _slash = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const BULLET = '\u25CF ';
const DOCUMENTATION_NOTE = `  ${_chalk().default.bold('Code Transformation Documentation:')}
  https://jestjs.io/docs/code-transformation
`;
const UPGRADE_NOTE = `  ${_chalk().default.bold('This error may be caused by a breaking change in Jest 28:')}
  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer
`;
const makeInvalidReturnValueError = transformPath => _chalk().default.red([_chalk().default.bold(`${BULLET}Invalid return value:`), '  `process()` or/and `processAsync()` method of code transformer found at ', `  "${(0, _slash().default)(transformPath)}" `, '  should return an object or a Promise resolving to an object. The object ', '  must have `code` property with a string of processed code.', ''].join('\n') + UPGRADE_NOTE + DOCUMENTATION_NOTE);
exports.makeInvalidReturnValueError = makeInvalidReturnValueError;
const makeInvalidSourceMapWarning = (filename, transformPath) => _chalk().default.yellow([_chalk().default.bold(`${BULLET}Invalid source map:`), `  The source map for "${(0, _slash().default)(filename)}" returned by "${(0, _slash().default)(transformPath)}" is invalid.`, '  Proceeding without source mapping for that file.'].join('\n'));
exports.makeInvalidSourceMapWarning = makeInvalidSourceMapWarning;
const makeInvalidSyncTransformerError = transformPath => _chalk().default.red([_chalk().default.bold(`${BULLET}Invalid synchronous transformer module:`), `  "${(0, _slash().default)(transformPath)}" specified in the "transform" object of Jest configuration`, '  must export a `process` function.', ''].join('\n') + DOCUMENTATION_NOTE);
exports.makeInvalidSyncTransformerError = makeInvalidSyncTransformerError;
const makeInvalidTransformerError = transformPath => _chalk().default.red([_chalk().default.bold(`${BULLET}Invalid transformer module:`), `  "${(0, _slash().default)(transformPath)}" specified in the "transform" object of Jest configuration`, '  must export a `process` or `processAsync` or `createTransformer` function.', ''].join('\n') + DOCUMENTATION_NOTE);
exports.makeInvalidTransformerError = makeInvalidTransformerError;

/***/ }),

/***/ "./src/shouldInstrument.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = shouldInstrument;
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _micromatch() {
  const data = _interopRequireDefault(require("micromatch"));
  _micromatch = function () {
    return data;
  };
  return data;
}
function _jestRegexUtil() {
  const data = require("jest-regex-util");
  _jestRegexUtil = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require("jest-util");
  _jestUtil = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const MOCKS_PATTERN = new RegExp((0, _jestRegexUtil().escapePathForRegex)(`${path().sep}__mocks__${path().sep}`));
const cachedRegexes = new Map();
const getRegex = regexStr => {
  if (!cachedRegexes.has(regexStr)) {
    cachedRegexes.set(regexStr, new RegExp(regexStr));
  }
  const regex = cachedRegexes.get(regexStr);

  // prevent stateful regexes from breaking, just in case
  regex.lastIndex = 0;
  return regex;
};
function shouldInstrument(filename, options, config, loadedFilenames) {
  if (!options.collectCoverage) {
    return false;
  }
  if (config.forceCoverageMatch.length > 0 && _micromatch().default.any(filename, config.forceCoverageMatch)) {
    return true;
  }
  if (!config.testPathIgnorePatterns.some(pattern => getRegex(pattern).test(filename))) {
    if (config.testRegex.some(regex => new RegExp(regex).test(filename))) {
      return false;
    }
    if ((0, _jestUtil().globsToMatcher)(config.testMatch)((0, _jestUtil().replacePathSepForGlob)(filename))) {
      return false;
    }
  }
  if (options.collectCoverageFrom.length === 0 && loadedFilenames != null && !loadedFilenames.includes(filename)) {
    return false;
  }
  if (
  // still cover if `only` is specified
  options.collectCoverageFrom.length > 0 && !(0, _jestUtil().globsToMatcher)(options.collectCoverageFrom)((0, _jestUtil().replacePathSepForGlob)(path().relative(config.rootDir, filename)))) {
    return false;
  }
  if (config.coveragePathIgnorePatterns.some(pattern => new RegExp(pattern).test(filename))) {
    return false;
  }
  if (config.globalSetup === filename) {
    return false;
  }
  if (config.globalTeardown === filename) {
    return false;
  }
  if (config.setupFiles.includes(filename)) {
    return false;
  }
  if (config.setupFilesAfterEnv.includes(filename)) {
    return false;
  }
  if (MOCKS_PATTERN.test(filename)) {
    return false;
  }
  if (options.changedFiles && !options.changedFiles.has(filename)) {
    if (!options.sourcesRelatedToTestsInChangedFiles) {
      return false;
    }
    if (!options.sourcesRelatedToTestsInChangedFiles.has(filename)) {
      return false;
    }
  }
  if (filename.endsWith('.json')) {
    return false;
  }
  return true;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "createScriptTransformer", ({
  enumerable: true,
  get: function () {
    return _ScriptTransformer.createScriptTransformer;
  }
}));
Object.defineProperty(exports, "createTranspilingRequire", ({
  enumerable: true,
  get: function () {
    return _ScriptTransformer.createTranspilingRequire;
  }
}));
Object.defineProperty(exports, "handlePotentialSyntaxError", ({
  enumerable: true,
  get: function () {
    return _enhanceUnexpectedTokenMessage.default;
  }
}));
Object.defineProperty(exports, "shouldInstrument", ({
  enumerable: true,
  get: function () {
    return _shouldInstrument.default;
  }
}));
var _ScriptTransformer = __webpack_require__("./src/ScriptTransformer.ts");
var _shouldInstrument = _interopRequireDefault(__webpack_require__("./src/shouldInstrument.ts"));
var _enhanceUnexpectedTokenMessage = _interopRequireDefault(__webpack_require__("./src/enhanceUnexpectedTokenMessage.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\@jest\transform\package.json

Code:
{
  "name": "@jest/transform",
  "version": "30.0.2",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-transform"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@babel/core": "^7.27.4",
    "@jest/types": "30.0.1",
    "@jridgewell/trace-mapping": "^0.3.25",
    "babel-plugin-istanbul": "^7.0.0",
    "chalk": "^4.1.2",
    "convert-source-map": "^2.0.0",
    "fast-json-stable-stringify": "^2.1.0",
    "graceful-fs": "^4.2.11",
    "jest-haste-map": "30.0.2",
    "jest-regex-util": "30.0.1",
    "jest-util": "30.0.2",
    "micromatch": "^4.0.8",
    "pirates": "^4.0.7",
    "slash": "^3.0.0",
    "write-file-atomic": "^5.0.1"
  },
  "devDependencies": {
    "@jest/test-utils": "30.0.2",
    "@types/babel__core": "^7.20.5",
    "@types/convert-source-map": "^2.0.3",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "@types/write-file-atomic": "^4.0.3",
    "dedent": "^1.6.0"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "393acbfac31f64bb38dff23c89224797caded83c"
}


---

File name: node_modules\babel-jest\node_modules\@jest\types\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import * as ProcessModule from 'process';
import {ForegroundColor} from 'chalk';
import {CoverageMapData} from 'istanbul-lib-coverage';
import {ReportOptions} from 'istanbul-reports';
import {Arguments} from 'yargs';
import {TestPathPatterns} from '@jest/pattern';
import {InitialOptions, SnapshotFormat} from '@jest/schemas';

declare type Argv = Arguments<
  Partial<{
    all: boolean;
    automock: boolean;
    bail: boolean | number;
    cache: boolean;
    cacheDirectory: string;
    changedFilesWithAncestor: boolean;
    changedSince: string;
    ci: boolean;
    clearCache: boolean;
    clearMocks: boolean;
    collectCoverage: boolean;
    collectCoverageFrom: string;
    color: boolean;
    colors: boolean;
    config: string;
    coverage: boolean;
    coverageDirectory: string;
    coveragePathIgnorePatterns: Array<string>;
    coverageReporters: Array<string>;
    coverageThreshold: string;
    debug: boolean;
    env: string;
    expand: boolean;
    findRelatedTests: boolean;
    forceExit: boolean;
    globals: string;
    globalSetup: string | null | undefined;
    globalTeardown: string | null | undefined;
    haste: string;
    ignoreProjects: Array<string>;
    injectGlobals: boolean;
    json: boolean;
    lastCommit: boolean;
    logHeapUsage: boolean;
    maxWorkers: number | string;
    moduleDirectories: Array<string>;
    moduleFileExtensions: Array<string>;
    moduleNameMapper: string;
    modulePathIgnorePatterns: Array<string>;
    modulePaths: Array<string>;
    noStackTrace: boolean;
    notify: boolean;
    notifyMode: string;
    onlyChanged: boolean;
    onlyFailures: boolean;
    outputFile: string;
    preset: string | null | undefined;
    prettierPath: string | null | undefined;
    projects: Array<string>;
    randomize: boolean;
    reporters: Array<string>;
    resetMocks: boolean;
    resetModules: boolean;
    resolver: string | null | undefined;
    restoreMocks: boolean;
    rootDir: string;
    roots: Array<string>;
    runInBand: boolean;
    seed: number;
    showSeed: boolean;
    selectProjects: Array<string>;
    setupFiles: Array<string>;
    setupFilesAfterEnv: Array<string>;
    shard: string;
    showConfig: boolean;
    silent: boolean;
    snapshotSerializers: Array<string>;
    testEnvironment: string;
    testEnvironmentOptions: string;
    testFailureExitCode: string | null | undefined;
    testMatch: Array<string>;
    testNamePattern: string;
    testPathIgnorePatterns: Array<string>;
    testPathPatterns: Array<string>;
    testRegex: string | Array<string>;
    testResultsProcessor: string;
    testRunner: string;
    testSequencer: string;
    testTimeout: number | null | undefined;
    transform: string;
    transformIgnorePatterns: Array<string>;
    unmockedModulePathPatterns: Array<string> | null | undefined;
    updateSnapshot: boolean;
    useStderr: boolean;
    verbose: boolean;
    version: boolean;
    watch: boolean;
    watchAll: boolean;
    watchman: boolean;
    watchPathIgnorePatterns: Array<string>;
    workerIdleMemoryLimit: number | string;
    workerThreads: boolean;
  }>
>;

declare type ArrayTable = Table | Row;

declare type AssertionResult = {
  ancestorTitles: Array<string>;
  duration?: number | null;
  startAt?: number | null;
  /**
   * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)
   * was used.
   */
  failing?: boolean;
  /**
   * The raw values of the `function` or `symbol` types will be lost in some cases
   * because it's not possible to serialize them correctly between workers.
   * However, information about them will be available in the `failureMessages`.
   */
  failureDetails: Array<unknown>;
  failureMessages: Array<string>;
  fullName: string;
  invocations?: number;
  location?: Callsite | null;
  numPassingAsserts: number;
  retryReasons?: Array<string>;
  status: Status;
  title: string;
};

declare type AsyncEvent =
  | {
      name: 'setup';
      testNamePattern?: string;
      runtimeGlobals: JestGlobals;
      parentProcess: Process;
    }
  | {
      name: 'include_test_location_in_result';
    }
  | {
      name: 'hook_start';
      hook: Hook;
    }
  | {
      name: 'hook_success';
      describeBlock?: DescribeBlock;
      test?: TestEntry;
      hook: Hook;
    }
  | {
      name: 'hook_failure';
      error: string | Exception;
      describeBlock?: DescribeBlock;
      test?: TestEntry;
      hook: Hook;
    }
  | {
      name: 'test_fn_start';
      test: TestEntry;
    }
  | {
      name: 'test_fn_success';
      test: TestEntry;
    }
  | {
      name: 'test_fn_failure';
      error: Exception;
      test: TestEntry;
    }
  | {
      name: 'test_retry';
      test: TestEntry;
    }
  | {
      name: 'test_start';
      test: TestEntry;
    }
  | {
      name: 'test_skip';
      test: TestEntry;
    }
  | {
      name: 'test_todo';
      test: TestEntry;
    }
  | {
      name: 'test_started';
      test: TestEntry;
    }
  | {
      name: 'test_done';
      test: TestEntry;
    }
  | {
      name: 'run_describe_start';
      describeBlock: DescribeBlock;
    }
  | {
      name: 'run_describe_finish';
      describeBlock: DescribeBlock;
    }
  | {
      name: 'run_start';
    }
  | {
      name: 'run_finish';
    }
  | {
      name: 'teardown';
    };

declare type AsyncFn = TestFn_2 | HookFn_2;

declare type BlockFn = () => void;

declare type BlockFn_2 = Global_2.BlockFn;

declare type BlockMode = void | 'skip' | 'only' | 'todo';

declare type BlockName = string;

declare type BlockName_2 = Global_2.BlockName;

declare type BlockNameLike = BlockName | NameLike;

declare type BlockNameLike_2 = Global_2.BlockNameLike;

declare type Callsite = {
  column: number;
  line: number;
};

declare namespace Circus {
  export {
    DoneFn,
    BlockFn_2 as BlockFn,
    BlockName_2 as BlockName,
    BlockNameLike_2 as BlockNameLike,
    BlockMode,
    TestMode,
    TestName_2 as TestName,
    TestNameLike_2 as TestNameLike,
    TestFn_2 as TestFn,
    ConcurrentTestFn_2 as ConcurrentTestFn,
    HookFn_2 as HookFn,
    AsyncFn,
    SharedHookType,
    HookType,
    TestContext_2 as TestContext,
    Exception,
    FormattedError,
    Hook,
    EventHandler,
    Event_2 as Event,
    SyncEvent,
    AsyncEvent,
    MatcherResults,
    TestStatus,
    TestNamesPath,
    TestCaseStartInfo,
    TestResult_2 as TestResult,
    RunResult,
    TestResults,
    GlobalErrorHandlers,
    State,
    DescribeBlock,
    TestError,
    TestEntry,
  };
}
export {Circus};

declare type Col = unknown;

declare type ConcurrentTestFn = () => TestReturnValuePromise;

declare type ConcurrentTestFn_2 = Global_2.ConcurrentTestFn;

declare namespace Config {
  export {
    InitialOptions,
    FakeableAPI,
    GlobalFakeTimersConfig,
    FakeTimersConfig,
    LegacyFakeTimersConfig,
    HasteConfig,
    CoverageReporterName,
    CoverageReporterWithOptions,
    CoverageReporters,
    ReporterConfig,
    TransformerConfig,
    ConfigGlobals,
    DefaultOptions,
    DisplayName,
    InitialOptionsWithRootDir,
    InitialProjectOptions,
    SnapshotUpdateState,
    CoverageThresholdValue,
    GlobalConfig,
    ProjectConfig,
    SetupAfterEnvPerfStats,
    Argv,
  };
}
export {Config};

declare interface ConfigGlobals {
  [K: string]: unknown;
}

declare type CoverageProvider = 'babel' | 'v8';

declare type CoverageReporterName = keyof ReportOptions;

declare type CoverageReporters = Array<
  CoverageReporterName | CoverageReporterWithOptions
>;

declare type CoverageReporterWithOptions<K = CoverageReporterName> =
  K extends CoverageReporterName
    ? ReportOptions[K] extends never
      ? never
      : [K, Partial<ReportOptions[K]>]
    : never;

declare type CoverageThreshold = {
  [path: string]: CoverageThresholdValue;
  global: CoverageThresholdValue;
};

declare type CoverageThresholdValue = {
  branches?: number;
  functions?: number;
  lines?: number;
  statements?: number;
};

declare type DefaultOptions = {
  automock: boolean;
  bail: number;
  cache: boolean;
  cacheDirectory: string;
  changedFilesWithAncestor: boolean;
  ci: boolean;
  clearMocks: boolean;
  collectCoverage: boolean;
  coveragePathIgnorePatterns: Array<string>;
  coverageReporters: Array<CoverageReporterName>;
  coverageProvider: CoverageProvider;
  detectLeaks: boolean;
  detectOpenHandles: boolean;
  errorOnDeprecated: boolean;
  expand: boolean;
  extensionsToTreatAsEsm: Array<string>;
  fakeTimers: FakeTimers;
  forceCoverageMatch: Array<string>;
  globals: ConfigGlobals;
  haste: HasteConfig;
  injectGlobals: boolean;
  listTests: boolean;
  maxConcurrency: number;
  maxWorkers: number | string;
  moduleDirectories: Array<string>;
  moduleFileExtensions: Array<string>;
  moduleNameMapper: Record<string, string | Array<string>>;
  modulePathIgnorePatterns: Array<string>;
  noStackTrace: boolean;
  notify: boolean;
  notifyMode: NotifyMode;
  openHandlesTimeout: number;
  passWithNoTests: boolean;
  prettierPath: string;
  resetMocks: boolean;
  resetModules: boolean;
  restoreMocks: boolean;
  roots: Array<string>;
  runTestsByPath: boolean;
  runner: string;
  setupFiles: Array<string>;
  setupFilesAfterEnv: Array<string>;
  skipFilter: boolean;
  slowTestThreshold: number;
  snapshotFormat: SnapshotFormat;
  snapshotSerializers: Array<string>;
  testEnvironment: string;
  testEnvironmentOptions: Record<string, unknown>;
  testFailureExitCode: number;
  testLocationInResults: boolean;
  testMatch: Array<string>;
  testPathIgnorePatterns: Array<string>;
  testRegex: Array<string>;
  testRunner: string;
  testSequencer: string;
  transformIgnorePatterns: Array<string>;
  useStderr: boolean;
  waitForUnhandledRejections: boolean;
  watch: boolean;
  watchPathIgnorePatterns: Array<string>;
  watchman: boolean;
  workerThreads: boolean;
};

declare interface Describe extends DescribeBase {
  only: DescribeBase;
  skip: DescribeBase;
}

declare interface DescribeBase {
  (blockName: BlockNameLike, blockFn: BlockFn): void;
  each: Each<BlockFn>;
}

declare type DescribeBlock = {
  type: 'describeBlock';
  children: Array<DescribeBlock | TestEntry>;
  hooks: Array<Hook>;
  mode: BlockMode;
  name: BlockName_2;
  parent?: DescribeBlock;
  /** @deprecated Please get from `children` array instead */
  tests: Array<TestEntry>;
};

declare type DisplayName = {
  name: string;
  color: typeof ForegroundColor;
};

declare type DoneFn = Global_2.DoneFn;

declare type DoneFn_2 = (reason?: string | Error) => void;

declare type DoneTakingTestFn = (
  this: TestContext,
  done: DoneFn_2,
) => ValidTestReturnValues;

declare interface Each<EachFn extends TestFn | BlockFn> {
  <T extends Record<string, unknown>>(
    table: ReadonlyArray<T>,
  ): (
    name: string | NameLike,
    fn: (arg: T, done: DoneFn_2) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
  <T extends readonly [unknown, ...Array<unknown>]>(
    table: ReadonlyArray<T>,
  ): (
    name: string | NameLike,
    fn: (...args: [...T]) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
  <T extends ReadonlyArray<unknown>>(
    table: ReadonlyArray<T>,
  ): (
    name: string | NameLike,
    fn: (...args: T) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
  <T>(
    table: ReadonlyArray<T>,
  ): (
    name: string | NameLike,
    fn: (arg: T, done: DoneFn_2) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
  <T extends Array<unknown>>(
    strings: TemplateStringsArray,
    ...expressions: T
  ): (
    name: string | NameLike,
    fn: (arg: Record<string, T[number]>, done: DoneFn_2) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
  <T extends Record<string, unknown>>(
    strings: TemplateStringsArray,
    ...expressions: Array<unknown>
  ): (
    name: string | NameLike,
    fn: (arg: T, done: DoneFn_2) => ReturnType<EachFn>,
    timeout?: number,
  ) => void;
}

declare type EachTable = ArrayTable | TemplateTable;

declare type EachTestFn<EachCallback extends TestCallback> = (
  ...args: ReadonlyArray<any>
) => ReturnType<EachCallback>;

declare type Event_2 = SyncEvent | AsyncEvent;

declare interface EventHandler {
  (event: AsyncEvent, state: State): void | Promise<void>;
  (event: SyncEvent, state: State): void;
}

declare type Exception = any;

declare interface Failing<T extends TestFn> {
  (testName: TestNameLike, fn: T, timeout?: number): void;
  each: Each<T>;
}

declare type FakeableAPI =
  | 'Date'
  | 'hrtime'
  | 'nextTick'
  | 'performance'
  | 'queueMicrotask'
  | 'requestAnimationFrame'
  | 'cancelAnimationFrame'
  | 'requestIdleCallback'
  | 'cancelIdleCallback'
  | 'setImmediate'
  | 'clearImmediate'
  | 'setInterval'
  | 'clearInterval'
  | 'setTimeout'
  | 'clearTimeout';

declare type FakeTimers = GlobalFakeTimersConfig &
  (
    | (FakeTimersConfig & {
        now?: Exclude<FakeTimersConfig['now'], Date>;
      })
    | LegacyFakeTimersConfig
  );

declare type FakeTimersConfig = {
  /**
   * If set to `true` all timers will be advanced automatically
   * by 20 milliseconds every 20 milliseconds. A custom time delta
   * may be provided by passing a number.
   *
   * @defaultValue
   * The default is `false`.
   */
  advanceTimers?: boolean | number;
  /**
   * List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`,
   * `setTimeout()`) that should not be faked.
   *
   * @defaultValue
   * The default is `[]`, meaning all APIs are faked.
   */
  doNotFake?: Array<FakeableAPI>;
  /**
   * Sets current system time to be used by fake timers, in milliseconds.
   *
   * @defaultValue
   * The default is `Date.now()`.
   */
  now?: number | Date;
  /**
   * The maximum number of recursive timers that will be run when calling
   * `jest.runAllTimers()`.
   *
   * @defaultValue
   * The default is `100_000` timers.
   */
  timerLimit?: number;
  /**
   * Use the old fake timers implementation instead of one backed by
   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).
   *
   * @defaultValue
   * The default is `false`.
   */
  legacyFakeTimers?: false;
};

declare type FormattedError = string;

declare type GeneratorReturningTestFn = (
  this: TestContext,
) => TestReturnValueGenerator;

declare namespace Global_2 {
  export {
    ValidTestReturnValues,
    TestReturnValue,
    TestContext,
    DoneFn_2 as DoneFn,
    DoneTakingTestFn,
    PromiseReturningTestFn,
    GeneratorReturningTestFn,
    NameLike,
    TestName,
    TestNameLike,
    TestFn,
    ConcurrentTestFn,
    BlockFn,
    BlockName,
    BlockNameLike,
    HookFn,
    Col,
    Row,
    Table,
    ArrayTable,
    TemplateTable,
    TemplateData,
    EachTable,
    TestCallback,
    EachTestFn,
    HookBase,
    Failing,
    ItBase,
    It,
    ItConcurrentBase,
    ItConcurrentExtended,
    ItConcurrent,
    DescribeBase,
    Describe,
    TestFrameworkGlobals,
    GlobalAdditions,
    Global_3 as Global,
  };
}
export {Global_2 as Global};

declare interface Global_3
  extends GlobalAdditions,
    Omit<typeof globalThis, keyof GlobalAdditions> {
  [extras: PropertyKey]: unknown;
}

declare interface GlobalAdditions extends TestFrameworkGlobals {
  __coverage__: CoverageMapData;
}

declare type GlobalConfig = {
  bail: number;
  changedSince?: string;
  changedFilesWithAncestor: boolean;
  ci: boolean;
  collectCoverage: boolean;
  collectCoverageFrom: Array<string>;
  coverageDirectory: string;
  coveragePathIgnorePatterns?: Array<string>;
  coverageProvider: CoverageProvider;
  coverageReporters: CoverageReporters;
  coverageThreshold?: CoverageThreshold;
  detectLeaks: boolean;
  detectOpenHandles: boolean;
  expand: boolean;
  filter?: string;
  findRelatedTests: boolean;
  forceExit: boolean;
  json: boolean;
  globalSetup?: string;
  globalTeardown?: string;
  lastCommit: boolean;
  logHeapUsage: boolean;
  listTests: boolean;
  maxConcurrency: number;
  maxWorkers: number;
  noStackTrace: boolean;
  nonFlagArgs: Array<string>;
  noSCM?: boolean;
  notify: boolean;
  notifyMode: NotifyMode;
  outputFile?: string;
  onlyChanged: boolean;
  onlyFailures: boolean;
  openHandlesTimeout: number;
  passWithNoTests: boolean;
  projects: Array<string>;
  randomize?: boolean;
  replname?: string;
  reporters?: Array<ReporterConfig>;
  runInBand: boolean;
  runTestsByPath: boolean;
  rootDir: string;
  seed: number;
  showSeed?: boolean;
  shard?: ShardConfig;
  silent?: boolean;
  skipFilter: boolean;
  snapshotFormat: SnapshotFormat;
  errorOnDeprecated: boolean;
  testFailureExitCode: number;
  testNamePattern?: string;
  testPathPatterns: TestPathPatterns;
  testResultsProcessor?: string;
  testSequencer: string;
  testTimeout?: number;
  updateSnapshot: SnapshotUpdateState;
  useStderr: boolean;
  verbose?: boolean;
  waitForUnhandledRejections: boolean;
  watch: boolean;
  watchAll: boolean;
  watchman: boolean;
  watchPlugins?: Array<{
    path: string;
    config: Record<string, unknown>;
  }> | null;
  workerIdleMemoryLimit?: number;
  workerThreads?: boolean;
};

declare type GlobalErrorHandlers = {
  rejectionHandled: Array<(promise: Promise<unknown>) => void>;
  uncaughtException: Array<NodeJS.UncaughtExceptionListener>;
  unhandledRejection: Array<NodeJS.UnhandledRejectionListener>;
};

declare type GlobalFakeTimersConfig = {
  /**
   * Whether fake timers should be enabled globally for all test files.
   *
   * @defaultValue
   * The default is `false`.
   */
  enableGlobally?: boolean;
};

declare type HasteConfig = {
  /** Whether to hash files using SHA-1. */
  computeSha1?: boolean;
  /** The platform to use as the default, e.g. 'ios'. */
  defaultPlatform?: string | null;
  /** Force use of Node's `fs` APIs rather than shelling out to `find` */
  forceNodeFilesystemAPI?: boolean;
  /**
   * Whether to follow symlinks when crawling for files.
   *   This options cannot be used in projects which use watchman.
   *   Projects with `watchman` set to true will error if this option is set to true.
   */
  enableSymlinks?: boolean;
  /** string to a custom implementation of Haste. */
  hasteImplModulePath?: string;
  /** All platforms to target, e.g ['ios', 'android']. */
  platforms?: Array<string>;
  /** Whether to throw an error on module collision. */
  throwOnModuleCollision?: boolean;
  /** Custom HasteMap module */
  hasteMapModulePath?: string;
  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */
  retainAllFiles?: boolean;
};

declare type Hook = {
  asyncError: Error;
  fn: HookFn_2;
  type: HookType;
  parent: DescribeBlock;
  seenDone: boolean;
  timeout: number | undefined | null;
};

declare type HookBase = (fn: HookFn, timeout?: number) => void;

declare type HookFn = TestFn;

declare type HookFn_2 = Global_2.HookFn;

declare type HookType = SharedHookType | 'afterEach' | 'beforeEach';

declare type InitialOptionsWithRootDir = InitialOptions &
  Required<Pick<InitialOptions, 'rootDir'>>;

declare type InitialProjectOptions = Pick<
  InitialOptions & {
    cwd?: string;
  },
  keyof ProjectConfig
>;

declare interface It extends ItBase {
  only: ItBase;
  skip: ItBase;
  todo: (testName: TestNameLike) => void;
}

declare interface ItBase {
  (testName: TestNameLike, fn: TestFn, timeout?: number): void;
  each: Each<TestFn>;
  failing: Failing<TestFn>;
}

declare interface ItConcurrent extends It {
  concurrent: ItConcurrentExtended;
}

declare interface ItConcurrentBase {
  (testName: TestNameLike, testFn: ConcurrentTestFn, timeout?: number): void;
  each: Each<ConcurrentTestFn>;
  failing: Failing<ConcurrentTestFn>;
}

declare interface ItConcurrentExtended extends ItConcurrentBase {
  only: ItConcurrentBase;
  skip: ItConcurrentBase;
}

declare interface JestGlobals extends Global_2.TestFrameworkGlobals {
  expect: unknown;
}

declare type LegacyFakeTimersConfig = {
  /**
   * Use the old fake timers implementation instead of one backed by
   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).
   *
   * @defaultValue
   * The default is `false`.
   */
  legacyFakeTimers?: true;
};

declare type MatcherResults = {
  actual: unknown;
  expected: unknown;
  name: string;
  pass: boolean;
};

declare type NameLike = number | Function;

declare type NotifyMode =
  | 'always'
  | 'failure'
  | 'success'
  | 'change'
  | 'success-change'
  | 'failure-change';

declare type Process = typeof ProcessModule;

declare type ProjectConfig = {
  automock: boolean;
  cache: boolean;
  cacheDirectory: string;
  clearMocks: boolean;
  collectCoverageFrom: Array<string>;
  coverageDirectory: string;
  coveragePathIgnorePatterns: Array<string>;
  coverageReporters: CoverageReporters;
  cwd: string;
  dependencyExtractor?: string;
  detectLeaks: boolean;
  detectOpenHandles: boolean;
  displayName?: DisplayName;
  errorOnDeprecated: boolean;
  extensionsToTreatAsEsm: Array<string>;
  fakeTimers: FakeTimers;
  filter?: string;
  forceCoverageMatch: Array<string>;
  globalSetup?: string;
  globalTeardown?: string;
  globals: ConfigGlobals;
  haste: HasteConfig;
  id: string;
  injectGlobals: boolean;
  moduleDirectories: Array<string>;
  moduleFileExtensions: Array<string>;
  moduleNameMapper: Array<[string, string]>;
  modulePathIgnorePatterns: Array<string>;
  modulePaths?: Array<string>;
  openHandlesTimeout: number;
  preset?: string;
  prettierPath: string;
  reporters: Array<string | ReporterConfig>;
  resetMocks: boolean;
  resetModules: boolean;
  resolver?: string;
  restoreMocks: boolean;
  rootDir: string;
  roots: Array<string>;
  runner: string;
  runtime?: string;
  sandboxInjectedGlobals: Array<keyof typeof globalThis>;
  setupFiles: Array<string>;
  setupFilesAfterEnv: Array<string>;
  skipFilter: boolean;
  skipNodeResolution?: boolean;
  slowTestThreshold: number;
  snapshotResolver?: string;
  snapshotSerializers: Array<string>;
  snapshotFormat: SnapshotFormat;
  testEnvironment: string;
  testEnvironmentOptions: Record<string, unknown>;
  testMatch: Array<string>;
  testLocationInResults: boolean;
  testPathIgnorePatterns: Array<string>;
  testRegex: Array<string | RegExp>;
  testRunner: string;
  testTimeout: number;
  transform: Array<[string, string, Record<string, unknown>]>;
  transformIgnorePatterns: Array<string>;
  watchPathIgnorePatterns: Array<string>;
  unmockedModulePathPatterns?: Array<string>;
  waitForUnhandledRejections: boolean;
  workerIdleMemoryLimit?: number;
};

declare type PromiseReturningTestFn = (this: TestContext) => TestReturnValue;

declare type ReporterConfig = [string, Record<string, unknown>];

declare type Row = ReadonlyArray<Col>;

declare type RunResult = {
  unhandledErrors: Array<FormattedError>;
  testResults: TestResults;
};

declare type SerializableError = {
  code?: unknown;
  message: string;
  stack: string | null | undefined;
  type?: string;
};

declare type SetupAfterEnvPerfStats = {
  setupAfterEnvStart: number;
  setupAfterEnvEnd: number;
};

declare type ShardConfig = {
  shardIndex: number;
  shardCount: number;
};

declare type SharedHookType = 'afterAll' | 'beforeAll';

declare type SnapshotUpdateState = 'all' | 'new' | 'none';

declare type State = {
  currentDescribeBlock: DescribeBlock;
  currentlyRunningTest?: TestEntry | null;
  expand?: boolean;
  hasFocusedTests: boolean;
  hasStarted: boolean;
  originalGlobalErrorHandlers?: GlobalErrorHandlers;
  parentProcess: Process | null;
  randomize?: boolean;
  rootDescribeBlock: DescribeBlock;
  seed: number;
  testNamePattern?: RegExp | null;
  testTimeout: number;
  unhandledErrors: Array<Exception>;
  includeTestLocationInResult: boolean;
  maxConcurrency: number;
  unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;
};

declare type Status =
  | 'passed'
  | 'failed'
  | 'skipped'
  | 'pending'
  | 'todo'
  | 'disabled'
  | 'focused';

declare type SyncEvent =
  | {
      asyncError: Error;
      mode: BlockMode;
      name: 'start_describe_definition';
      blockName: BlockName_2;
    }
  | {
      mode: BlockMode;
      name: 'finish_describe_definition';
      blockName: BlockName_2;
    }
  | {
      asyncError: Error;
      name: 'add_hook';
      hookType: HookType;
      fn: HookFn_2;
      timeout: number | undefined;
    }
  | {
      asyncError: Error;
      name: 'add_test';
      testName: TestName_2;
      fn: TestFn_2;
      mode?: TestMode;
      concurrent: boolean;
      timeout: number | undefined;
      failing: boolean;
    }
  | {
      name: 'error';
      error: Exception;
      promise?: Promise<unknown>;
    }
  | {
      name: 'error_handled';
      promise: Promise<unknown>;
    };

declare type Table = ReadonlyArray<Row>;

declare type TemplateData = ReadonlyArray<unknown>;

declare type TemplateTable = TemplateStringsArray;

declare type TestCallback = BlockFn | TestFn | ConcurrentTestFn;

declare type TestCaseStartInfo = {
  ancestorTitles: Array<string>;
  fullName: string;
  mode: TestMode;
  title: string;
  startedAt?: number | null;
};

declare type TestContext = Record<string, unknown>;

declare type TestContext_2 = Global_2.TestContext;

declare type TestEntry = {
  type: 'test';
  asyncError: Exception;
  errors: Array<TestError>;
  retryReasons: Array<TestError>;
  fn: TestFn_2;
  invocations: number;
  mode: TestMode;
  concurrent: boolean;
  name: TestName_2;
  numPassingAsserts: number;
  parent: DescribeBlock;
  startedAt?: number | null;
  duration?: number | null;
  seenDone: boolean;
  status?: TestStatus | null;
  timeout?: number;
  failing: boolean;
  unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;
};

declare type TestError = Exception | [Exception | undefined, Exception];

declare type TestFn =
  | PromiseReturningTestFn
  | GeneratorReturningTestFn
  | DoneTakingTestFn;

declare type TestFn_2 = Global_2.TestFn;

declare interface TestFrameworkGlobals {
  it: ItConcurrent;
  test: ItConcurrent;
  fit: ItBase & {
    concurrent?: ItConcurrentBase;
  };
  xit: ItBase;
  xtest: ItBase;
  describe: Describe;
  xdescribe: DescribeBase;
  fdescribe: DescribeBase;
  beforeAll: HookBase;
  beforeEach: HookBase;
  afterEach: HookBase;
  afterAll: HookBase;
}

declare type TestMode = BlockMode;

declare type TestName = string;

declare type TestName_2 = Global_2.TestName;

declare type TestNameLike = TestName | NameLike;

declare type TestNameLike_2 = Global_2.TestNameLike;

declare type TestNamesPath = Array<TestName_2 | BlockName_2>;

declare namespace TestResult {
  export {AssertionResult, SerializableError};
}
export {TestResult};

declare type TestResult_2 = {
  duration?: number | null;
  errors: Array<FormattedError>;
  errorsDetailed: Array<MatcherResults | unknown>;
  /**
   * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)
   * was used.
   */
  failing?: boolean;
  invocations: number;
  startedAt?: number | null;
  status: TestStatus;
  location?: {
    column: number;
    line: number;
  } | null;
  numPassingAsserts: number;
  retryReasons: Array<FormattedError>;
  testPath: TestNamesPath;
};

declare type TestResults = Array<TestResult_2>;

declare type TestReturnValue = ValidTestReturnValues | TestReturnValuePromise;

declare type TestReturnValueGenerator = Generator<void, unknown, void>;

declare type TestReturnValuePromise = Promise<unknown>;

declare type TestStatus = 'skip' | 'done' | 'todo';

declare type TransformerConfig = [string, Record<string, unknown>];

declare type TransformResult = {
  code: string;
  originalCode: string;
  sourceMapPath: string | null;
};

declare namespace TransformTypes {
  export {TransformResult};
}
export {TransformTypes};

declare type ValidTestReturnValues = void | undefined;

export {};


---

File name: node_modules\babel-jest\node_modules\@jest\types\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\@jest\types\package.json

Code:
{
  "name": "@jest/types",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-types"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/pattern": "30.0.1",
    "@jest/schemas": "30.0.1",
    "@types/istanbul-lib-coverage": "^2.0.6",
    "@types/istanbul-reports": "^3.0.4",
    "@types/node": "*",
    "@types/yargs": "^17.0.33",
    "chalk": "^4.1.2"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}


---

File name: node_modules\babel-jest\node_modules\@jest\types\README.md

Code:
# @jest/types

This package contains shared types of Jest's packages.

If you are looking for types of [Jest globals](https://jestjs.io/docs/api), you can import them from `@jest/globals` package:

```ts
import {describe, expect, it} from '@jest/globals';

describe('my tests', () => {
  it('works', () => {
    expect(1).toBe(1);
  });
});
```

If you prefer to omit imports, a similar result can be achieved installing the [@types/jest](https://npmjs.com/package/@types/jest) package. Note that this is a third party library maintained at [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jest) and may not cover the latest Jest features.

Another use-case for `@types/jest` is a typed Jest config as those types are not provided by Jest out of the box:

```ts
// jest.config.ts
import type {Config} from '@jest/types';

const config: Config.InitialOptions = {
  // some typed config
};

export default config;
```


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\compiler\compiler.d.ts

Code:
import { ValueErrorIterator } from '../errors/index';
import { TypeBoxError } from '../type/error/index';
import type { TSchema } from '../type/schema/index';
import type { Static, StaticDecode, StaticEncode } from '../type/static/index';
export type CheckFunction = (value: unknown) => boolean;
export declare class TypeCheck<T extends TSchema> {
    private readonly schema;
    private readonly references;
    private readonly checkFunc;
    private readonly code;
    private readonly hasTransform;
    constructor(schema: T, references: TSchema[], checkFunc: CheckFunction, code: string);
    /** Returns the generated assertion code used to validate this type. */
    Code(): string;
    /** Returns the schema type used to validate */
    Schema(): T;
    /** Returns reference types used to validate */
    References(): TSchema[];
    /** Returns an iterator for each error in this value. */
    Errors(value: unknown): ValueErrorIterator;
    /** Returns true if the value matches the compiled type. */
    Check(value: unknown): value is Static<T>;
    /** Decodes a value or throws if error */
    Decode<Static = StaticDecode<T>, Result extends Static = Static>(value: unknown): Result;
    /** Encodes a value or throws if error */
    Encode<Static = StaticEncode<T>, Result extends Static = Static>(value: unknown): Result;
}
export declare class TypeCompilerUnknownTypeError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema);
}
export declare class TypeCompilerTypeGuardError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema);
}
export declare namespace Policy {
    function IsExactOptionalProperty(value: string, key: string, expression: string): string;
    function IsObjectLike(value: string): string;
    function IsRecordLike(value: string): string;
    function IsNumberLike(value: string): string;
    function IsVoidLike(value: string): string;
}
export type TypeCompilerLanguageOption = 'typescript' | 'javascript';
export interface TypeCompilerCodegenOptions {
    language?: TypeCompilerLanguageOption;
}
/** Compiles Types for Runtime Type Checking */
export declare namespace TypeCompiler {
    /** Generates the code used to assert this type and returns it as a string */
    function Code<T extends TSchema>(schema: T, references: TSchema[], options?: TypeCompilerCodegenOptions): string;
    /** Generates the code used to assert this type and returns it as a string */
    function Code<T extends TSchema>(schema: T, options?: TypeCompilerCodegenOptions): string;
    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */
    function Compile<T extends TSchema>(schema: T, references?: TSchema[]): TypeCheck<T>;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\compiler\compiler.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
const index_1 = require("../value/transform/index");
const index_2 = require("../errors/index");
const index_3 = require("../system/index");
const index_4 = require("../type/error/index");
const index_5 = require("../value/deref/index");
const index_6 = require("../value/hash/index");
const index_7 = require("../type/symbols/index");
const index_8 = require("../type/registry/index");
const index_9 = require("../type/keyof/index");
const extends_undefined_1 = require("../type/extends/extends-undefined");
const index_10 = require("../type/never/index");
const index_11 = require("../type/ref/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_12 = require("../value/guard/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const type_1 = require("../type/guard/type");
// ------------------------------------------------------------------
// TypeCheck
// ------------------------------------------------------------------
class TypeCheck {
    constructor(schema, references, checkFunc, code) {
        this.schema = schema;
        this.references = references;
        this.checkFunc = checkFunc;
        this.code = code;
        this.hasTransform = (0, index_1.HasTransform)(schema, references);
    }
    /** Returns the generated assertion code used to validate this type. */
    Code() {
        return this.code;
    }
    /** Returns the schema type used to validate */
    Schema() {
        return this.schema;
    }
    /** Returns reference types used to validate */
    References() {
        return this.references;
    }
    /** Returns an iterator for each error in this value. */
    Errors(value) {
        return (0, index_2.Errors)(this.schema, this.references, value);
    }
    /** Returns true if the value matches the compiled type. */
    Check(value) {
        return this.checkFunc(value);
    }
    /** Decodes a value or throws if error */
    Decode(value) {
        if (!this.checkFunc(value))
            throw new index_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
        return (this.hasTransform ? (0, index_1.TransformDecode)(this.schema, this.references, value) : value);
    }
    /** Encodes a value or throws if error */
    Encode(value) {
        const encoded = this.hasTransform ? (0, index_1.TransformEncode)(this.schema, this.references, value) : value;
        if (!this.checkFunc(encoded))
            throw new index_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
        return encoded;
    }
}
exports.TypeCheck = TypeCheck;
// ------------------------------------------------------------------
// Character
// ------------------------------------------------------------------
var Character;
(function (Character) {
    function DollarSign(code) {
        return code === 36;
    }
    Character.DollarSign = DollarSign;
    function IsUnderscore(code) {
        return code === 95;
    }
    Character.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
    }
    Character.IsAlpha = IsAlpha;
    function IsNumeric(code) {
        return code >= 48 && code <= 57;
    }
    Character.IsNumeric = IsNumeric;
})(Character || (Character = {}));
// ------------------------------------------------------------------
// MemberExpression
// ------------------------------------------------------------------
var MemberExpression;
(function (MemberExpression) {
    function IsFirstCharacterNumeric(value) {
        if (value.length === 0)
            return false;
        return Character.IsNumeric(value.charCodeAt(0));
    }
    function IsAccessor(value) {
        if (IsFirstCharacterNumeric(value))
            return false;
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
            if (!check)
                return false;
        }
        return true;
    }
    function EscapeHyphen(key) {
        return key.replace(/'/g, "\\'");
    }
    function Encode(object, key) {
        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    MemberExpression.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
// ------------------------------------------------------------------
// Identifier
// ------------------------------------------------------------------
var Identifier;
(function (Identifier) {
    function Encode($id) {
        const buffer = [];
        for (let i = 0; i < $id.length; i++) {
            const code = $id.charCodeAt(i);
            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
                buffer.push($id.charAt(i));
            }
            else {
                buffer.push(`_${code}_`);
            }
        }
        return buffer.join('').replace(/__/g, '_');
    }
    Identifier.Encode = Encode;
})(Identifier || (Identifier = {}));
// ------------------------------------------------------------------
// LiteralString
// ------------------------------------------------------------------
var LiteralString;
(function (LiteralString) {
    function Escape(content) {
        return content.replace(/'/g, "\\'");
    }
    LiteralString.Escape = Escape;
})(LiteralString || (LiteralString = {}));
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class TypeCompilerUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
        super('Unknown type');
        this.schema = schema;
    }
}
exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
class TypeCompilerTypeGuardError extends index_4.TypeBoxError {
    constructor(schema) {
        super('Preflight validation check failed to guard for the given schema');
        this.schema = schema;
    }
}
exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
// ------------------------------------------------------------------
// Policy
// ------------------------------------------------------------------
var Policy;
(function (Policy) {
    function IsExactOptionalProperty(value, key, expression) {
        return index_3.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    Policy.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
        return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
    }
    Policy.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
        return !index_3.TypeSystemPolicy.AllowArrayObject
            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`
            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    Policy.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
        return index_3.TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
    }
    Policy.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
        return index_3.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    Policy.IsVoidLike = IsVoidLike;
})(Policy || (exports.Policy = Policy = {}));
/** Compiles Types for Runtime Type Checking */
var TypeCompiler;
(function (TypeCompiler) {
    // ----------------------------------------------------------------
    // Guards
    // ----------------------------------------------------------------
    function IsAnyOrUnknown(schema) {
        return schema[index_7.Kind] === 'Any' || schema[index_7.Kind] === 'Unknown';
    }
    // ----------------------------------------------------------------
    // Types
    // ----------------------------------------------------------------
    function* FromAny(schema, references, value) {
        yield 'true';
    }
    function* FromArgument(schema, references, value) {
        yield 'true';
    }
    function* FromArray(schema, references, value) {
        yield `Array.isArray(${value})`;
        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];
        if ((0, index_12.IsNumber)(schema.maxItems))
            yield `${value}.length <= ${schema.maxItems}`;
        if ((0, index_12.IsNumber)(schema.minItems))
            yield `${value}.length >= ${schema.minItems}`;
        const elementExpression = CreateExpression(schema.items, references, 'value');
        yield `${value}.every((${parameter}) => ${elementExpression})`;
        if ((0, type_1.IsSchema)(schema.contains) || (0, index_12.IsNumber)(schema.minContains) || (0, index_12.IsNumber)(schema.maxContains)) {
            const containsSchema = (0, type_1.IsSchema)(schema.contains) ? schema.contains : (0, index_10.Never)();
            const checkExpression = CreateExpression(containsSchema, references, 'value');
            const checkMinContains = (0, index_12.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
            const checkMaxContains = (0, index_12.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');
            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
        }
        if (schema.uniqueItems === true) {
            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
            const block = `const set = new Set(); for(const element of value) { ${check} }`;
            yield `((${parameter}) => { ${block} )(${value})`;
        }
    }
    function* FromAsyncIterator(schema, references, value) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    function* FromBigInt(schema, references, value) {
        yield `(typeof ${value} === 'bigint')`;
        if ((0, index_12.IsBigInt)(schema.exclusiveMaximum))
            yield `${value} < BigInt(${schema.exclusiveMaximum})`;
        if ((0, index_12.IsBigInt)(schema.exclusiveMinimum))
            yield `${value} > BigInt(${schema.exclusiveMinimum})`;
        if ((0, index_12.IsBigInt)(schema.maximum))
            yield `${value} <= BigInt(${schema.maximum})`;
        if ((0, index_12.IsBigInt)(schema.minimum))
            yield `${value} >= BigInt(${schema.minimum})`;
        if ((0, index_12.IsBigInt)(schema.multipleOf))
            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
    }
    function* FromBoolean(schema, references, value) {
        yield `(typeof ${value} === 'boolean')`;
    }
    function* FromConstructor(schema, references, value) {
        yield* Visit(schema.returns, references, `${value}.prototype`);
    }
    function* FromDate(schema, references, value) {
        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
        if ((0, index_12.IsNumber)(schema.exclusiveMaximumTimestamp))
            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
        if ((0, index_12.IsNumber)(schema.exclusiveMinimumTimestamp))
            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
        if ((0, index_12.IsNumber)(schema.maximumTimestamp))
            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
        if ((0, index_12.IsNumber)(schema.minimumTimestamp))
            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
        if ((0, index_12.IsNumber)(schema.multipleOfTimestamp))
            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
    }
    function* FromFunction(schema, references, value) {
        yield `(typeof ${value} === 'function')`;
    }
    function* FromImport(schema, references, value) {
        const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
            return [...result, schema.$defs[key]];
        }, []);
        yield* Visit((0, index_11.Ref)(schema.$ref), [...references, ...members], value);
    }
    function* FromInteger(schema, references, value) {
        yield `Number.isInteger(${value})`;
        if ((0, index_12.IsNumber)(schema.exclusiveMaximum))
            yield `${value} < ${schema.exclusiveMaximum}`;
        if ((0, index_12.IsNumber)(schema.exclusiveMinimum))
            yield `${value} > ${schema.exclusiveMinimum}`;
        if ((0, index_12.IsNumber)(schema.maximum))
            yield `${value} <= ${schema.maximum}`;
        if ((0, index_12.IsNumber)(schema.minimum))
            yield `${value} >= ${schema.minimum}`;
        if ((0, index_12.IsNumber)(schema.multipleOf))
            yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromIntersect(schema, references, value) {
        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');
        if (schema.unevaluatedProperties === false) {
            const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
            yield `(${check1} && ${check2})`;
        }
        else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
            const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
            yield `(${check1} && ${check2})`;
        }
        else {
            yield `(${check1})`;
        }
    }
    function* FromIterator(schema, references, value) {
        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    function* FromLiteral(schema, references, value) {
        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {
            yield `(${value} === ${schema.const})`;
        }
        else {
            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
        }
    }
    function* FromNever(schema, references, value) {
        yield `false`;
    }
    function* FromNot(schema, references, value) {
        const expression = CreateExpression(schema.not, references, value);
        yield `(!${expression})`;
    }
    function* FromNull(schema, references, value) {
        yield `(${value} === null)`;
    }
    function* FromNumber(schema, references, value) {
        yield Policy.IsNumberLike(value);
        if ((0, index_12.IsNumber)(schema.exclusiveMaximum))
            yield `${value} < ${schema.exclusiveMaximum}`;
        if ((0, index_12.IsNumber)(schema.exclusiveMinimum))
            yield `${value} > ${schema.exclusiveMinimum}`;
        if ((0, index_12.IsNumber)(schema.maximum))
            yield `${value} <= ${schema.maximum}`;
        if ((0, index_12.IsNumber)(schema.minimum))
            yield `${value} >= ${schema.minimum}`;
        if ((0, index_12.IsNumber)(schema.multipleOf))
            yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromObject(schema, references, value) {
        yield Policy.IsObjectLike(value);
        if ((0, index_12.IsNumber)(schema.minProperties))
            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if ((0, index_12.IsNumber)(schema.maxProperties))
            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        for (const knownKey of knownKeys) {
            const memberExpression = MemberExpression.Encode(value, knownKey);
            const property = schema.properties[knownKey];
            if (schema.required && schema.required.includes(knownKey)) {
                yield* Visit(property, references, memberExpression);
                if ((0, extends_undefined_1.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property))
                    yield `('${knownKey}' in ${value})`;
            }
            else {
                const expression = CreateExpression(property, references, memberExpression);
                yield Policy.IsExactOptionalProperty(value, knownKey, expression);
            }
        }
        if (schema.additionalProperties === false) {
            if (schema.required && schema.required.length === knownKeys.length) {
                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
            }
            else {
                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;
                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
            }
        }
        if (typeof schema.additionalProperties === 'object') {
            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;
            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
        }
    }
    function* FromPromise(schema, references, value) {
        yield `${value} instanceof Promise`;
    }
    function* FromRecord(schema, references, value) {
        yield Policy.IsRecordLike(value);
        if ((0, index_12.IsNumber)(schema.minProperties))
            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if ((0, index_12.IsNumber)(schema.maxProperties))
            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const variable = CreateVariable(`${new RegExp(patternKey)}`);
        const check1 = CreateExpression(patternSchema, references, 'value');
        const check2 = (0, type_1.IsSchema)(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';
        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    function* FromRef(schema, references, value) {
        const target = (0, index_5.Deref)(schema, references);
        // Reference: If we have seen this reference before we can just yield and return the function call.
        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.
        if (state.functions.has(schema.$ref))
            return yield `${CreateFunctionName(schema.$ref)}(${value})`;
        yield* Visit(target, references, value);
    }
    function* FromRegExp(schema, references, value) {
        const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
        yield `(typeof ${value} === 'string')`;
        if ((0, index_12.IsNumber)(schema.maxLength))
            yield `${value}.length <= ${schema.maxLength}`;
        if ((0, index_12.IsNumber)(schema.minLength))
            yield `${value}.length >= ${schema.minLength}`;
        yield `${variable}.test(${value})`;
    }
    function* FromString(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        if ((0, index_12.IsNumber)(schema.maxLength))
            yield `${value}.length <= ${schema.maxLength}`;
        if ((0, index_12.IsNumber)(schema.minLength))
            yield `${value}.length >= ${schema.minLength}`;
        if (schema.pattern !== undefined) {
            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
            yield `${variable}.test(${value})`;
        }
        if (schema.format !== undefined) {
            yield `format('${schema.format}', ${value})`;
        }
    }
    function* FromSymbol(schema, references, value) {
        yield `(typeof ${value} === 'symbol')`;
    }
    function* FromTemplateLiteral(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
    }
    function* FromThis(schema, references, value) {
        // Note: This types are assured to be hoisted prior to this call. Just yield the function.
        yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    function* FromTuple(schema, references, value) {
        yield `Array.isArray(${value})`;
        if (schema.items === undefined)
            return yield `${value}.length === 0`;
        yield `(${value}.length === ${schema.maxItems})`;
        for (let i = 0; i < schema.items.length; i++) {
            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
            yield `${expression}`;
        }
    }
    function* FromUndefined(schema, references, value) {
        yield `${value} === undefined`;
    }
    function* FromUnion(schema, references, value) {
        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));
        yield `(${expressions.join(' || ')})`;
    }
    function* FromUint8Array(schema, references, value) {
        yield `${value} instanceof Uint8Array`;
        if ((0, index_12.IsNumber)(schema.maxByteLength))
            yield `(${value}.length <= ${schema.maxByteLength})`;
        if ((0, index_12.IsNumber)(schema.minByteLength))
            yield `(${value}.length >= ${schema.minByteLength})`;
    }
    function* FromUnknown(schema, references, value) {
        yield 'true';
    }
    function* FromVoid(schema, references, value) {
        yield Policy.IsVoidLike(value);
    }
    function* FromKind(schema, references, value) {
        const instance = state.instances.size;
        state.instances.set(instance, schema);
        yield `kind('${schema[index_7.Kind]}', ${instance}, ${value})`;
    }
    function* Visit(schema, references, value, useHoisting = true) {
        const references_ = (0, index_12.IsString)(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        // --------------------------------------------------------------
        // Hoisting
        // --------------------------------------------------------------
        if (useHoisting && (0, index_12.IsString)(schema.$id)) {
            const functionName = CreateFunctionName(schema.$id);
            if (state.functions.has(functionName)) {
                return yield `${functionName}(${value})`;
            }
            else {
                // Note: In the case of cyclic types, we need to create a 'functions' record
                // to prevent infinitely re-visiting the CreateFunction. Subsequent attempts
                // to visit will be caught by the above condition.
                state.functions.set(functionName, '<deferred>');
                const functionCode = CreateFunction(functionName, schema, references, 'value', false);
                state.functions.set(functionName, functionCode);
                return yield `${functionName}(${value})`;
            }
        }
        switch (schema_[index_7.Kind]) {
            case 'Any':
                return yield* FromAny(schema_, references_, value);
            case 'Argument':
                return yield* FromArgument(schema_, references_, value);
            case 'Array':
                return yield* FromArray(schema_, references_, value);
            case 'AsyncIterator':
                return yield* FromAsyncIterator(schema_, references_, value);
            case 'BigInt':
                return yield* FromBigInt(schema_, references_, value);
            case 'Boolean':
                return yield* FromBoolean(schema_, references_, value);
            case 'Constructor':
                return yield* FromConstructor(schema_, references_, value);
            case 'Date':
                return yield* FromDate(schema_, references_, value);
            case 'Function':
                return yield* FromFunction(schema_, references_, value);
            case 'Import':
                return yield* FromImport(schema_, references_, value);
            case 'Integer':
                return yield* FromInteger(schema_, references_, value);
            case 'Intersect':
                return yield* FromIntersect(schema_, references_, value);
            case 'Iterator':
                return yield* FromIterator(schema_, references_, value);
            case 'Literal':
                return yield* FromLiteral(schema_, references_, value);
            case 'Never':
                return yield* FromNever(schema_, references_, value);
            case 'Not':
                return yield* FromNot(schema_, references_, value);
            case 'Null':
                return yield* FromNull(schema_, references_, value);
            case 'Number':
                return yield* FromNumber(schema_, references_, value);
            case 'Object':
                return yield* FromObject(schema_, references_, value);
            case 'Promise':
                return yield* FromPromise(schema_, references_, value);
            case 'Record':
                return yield* FromRecord(schema_, references_, value);
            case 'Ref':
                return yield* FromRef(schema_, references_, value);
            case 'RegExp':
                return yield* FromRegExp(schema_, references_, value);
            case 'String':
                return yield* FromString(schema_, references_, value);
            case 'Symbol':
                return yield* FromSymbol(schema_, references_, value);
            case 'TemplateLiteral':
                return yield* FromTemplateLiteral(schema_, references_, value);
            case 'This':
                return yield* FromThis(schema_, references_, value);
            case 'Tuple':
                return yield* FromTuple(schema_, references_, value);
            case 'Undefined':
                return yield* FromUndefined(schema_, references_, value);
            case 'Union':
                return yield* FromUnion(schema_, references_, value);
            case 'Uint8Array':
                return yield* FromUint8Array(schema_, references_, value);
            case 'Unknown':
                return yield* FromUnknown(schema_, references_, value);
            case 'Void':
                return yield* FromVoid(schema_, references_, value);
            default:
                if (!index_8.TypeRegistry.Has(schema_[index_7.Kind]))
                    throw new TypeCompilerUnknownTypeError(schema);
                return yield* FromKind(schema_, references_, value);
        }
    }
    // ----------------------------------------------------------------
    // Compiler State
    // ----------------------------------------------------------------
    // prettier-ignore
    const state = {
        language: 'javascript', // target language
        functions: new Map(), // local functions
        variables: new Map(), // local variables
        instances: new Map() // exterior kind instances
    };
    // ----------------------------------------------------------------
    // Compiler Factory
    // ----------------------------------------------------------------
    function CreateExpression(schema, references, value, useHoisting = true) {
        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;
    }
    function CreateFunctionName($id) {
        return `check_${Identifier.Encode($id)}`;
    }
    function CreateVariable(expression) {
        const variableName = `local_${state.variables.size}`;
        state.variables.set(variableName, `const ${variableName} = ${expression}`);
        return variableName;
    }
    function CreateFunction(name, schema, references, value, useHoisting = true) {
        const [newline, pad] = ['\n', (length) => ''.padStart(length, ' ')];
        const parameter = CreateParameter('value', 'any');
        const returns = CreateReturns('boolean');
        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);
        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
    }
    function CreateParameter(name, type) {
        const annotation = state.language === 'typescript' ? `: ${type}` : '';
        return `${name}${annotation}`;
    }
    function CreateReturns(type) {
        return state.language === 'typescript' ? `: ${type}` : '';
    }
    // ----------------------------------------------------------------
    // Compile
    // ----------------------------------------------------------------
    function Build(schema, references, options) {
        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables
        const parameter = CreateParameter('value', 'any');
        const returns = CreateReturns('boolean');
        const functions = [...state.functions.values()];
        const variables = [...state.variables.values()];
        // prettier-ignore
        const checkFunction = (0, index_12.IsString)(schema.$id) // ensure top level schemas with $id's are hoisted
            ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}`
            : `return ${functionCode}`;
        return [...variables, ...functions, checkFunction].join('\n');
    }
    /** Generates the code used to assert this type and returns it as a string */
    function Code(...args) {
        const defaults = { language: 'javascript' };
        // prettier-ignore
        const [schema, references, options] = (args.length === 2 && (0, index_12.IsArray)(args[1]) ? [args[0], args[1], defaults] :
            args.length === 2 && !(0, index_12.IsArray)(args[1]) ? [args[0], [], args[1]] :
                args.length === 3 ? [args[0], args[1], args[2]] :
                    args.length === 1 ? [args[0], [], defaults] :
                        [null, [], defaults]);
        // compiler-reset
        state.language = options.language;
        state.variables.clear();
        state.functions.clear();
        state.instances.clear();
        if (!(0, type_1.IsSchema)(schema))
            throw new TypeCompilerTypeGuardError(schema);
        for (const schema of references)
            if (!(0, type_1.IsSchema)(schema))
                throw new TypeCompilerTypeGuardError(schema);
        return Build(schema, references, options);
    }
    TypeCompiler.Code = Code;
    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */
    function Compile(schema, references = []) {
        const generatedCode = Code(schema, references, { language: 'javascript' });
        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);
        const instances = new Map(state.instances);
        function typeRegistryFunction(kind, instance, value) {
            if (!index_8.TypeRegistry.Has(kind) || !instances.has(instance))
                return false;
            const checkFunc = index_8.TypeRegistry.Get(kind);
            const schema = instances.get(instance);
            return checkFunc(schema, value);
        }
        function formatRegistryFunction(format, value) {
            if (!index_8.FormatRegistry.Has(format))
                return false;
            const checkFunc = index_8.FormatRegistry.Get(format);
            return checkFunc(value);
        }
        function hashFunction(value) {
            return (0, index_6.Hash)(value);
        }
        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
        return new TypeCheck(schema, references, checkFunction, generatedCode);
    }
    TypeCompiler.Compile = Compile;
})(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\compiler\index.d.ts

Code:
export { ValueError, ValueErrorType, ValueErrorIterator } from '../errors/index';
export * from './compiler';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\compiler\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueErrorIterator = exports.ValueErrorType = void 0;
var index_1 = require("../errors/index");
Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function () { return index_1.ValueErrorType; } });
Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });
__exportStar(require("./compiler"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\errors.d.ts

Code:
import { TypeBoxError } from '../type/error/index';
import type { TSchema } from '../type/schema/index';
export declare enum ValueErrorType {
    ArrayContains = 0,
    ArrayMaxContains = 1,
    ArrayMaxItems = 2,
    ArrayMinContains = 3,
    ArrayMinItems = 4,
    ArrayUniqueItems = 5,
    Array = 6,
    AsyncIterator = 7,
    BigIntExclusiveMaximum = 8,
    BigIntExclusiveMinimum = 9,
    BigIntMaximum = 10,
    BigIntMinimum = 11,
    BigIntMultipleOf = 12,
    BigInt = 13,
    Boolean = 14,
    DateExclusiveMaximumTimestamp = 15,
    DateExclusiveMinimumTimestamp = 16,
    DateMaximumTimestamp = 17,
    DateMinimumTimestamp = 18,
    DateMultipleOfTimestamp = 19,
    Date = 20,
    Function = 21,
    IntegerExclusiveMaximum = 22,
    IntegerExclusiveMinimum = 23,
    IntegerMaximum = 24,
    IntegerMinimum = 25,
    IntegerMultipleOf = 26,
    Integer = 27,
    IntersectUnevaluatedProperties = 28,
    Intersect = 29,
    Iterator = 30,
    Kind = 31,
    Literal = 32,
    Never = 33,
    Not = 34,
    Null = 35,
    NumberExclusiveMaximum = 36,
    NumberExclusiveMinimum = 37,
    NumberMaximum = 38,
    NumberMinimum = 39,
    NumberMultipleOf = 40,
    Number = 41,
    ObjectAdditionalProperties = 42,
    ObjectMaxProperties = 43,
    ObjectMinProperties = 44,
    ObjectRequiredProperty = 45,
    Object = 46,
    Promise = 47,
    RegExp = 48,
    StringFormatUnknown = 49,
    StringFormat = 50,
    StringMaxLength = 51,
    StringMinLength = 52,
    StringPattern = 53,
    String = 54,
    Symbol = 55,
    TupleLength = 56,
    Tuple = 57,
    Uint8ArrayMaxByteLength = 58,
    Uint8ArrayMinByteLength = 59,
    Uint8Array = 60,
    Undefined = 61,
    Union = 62,
    Void = 63
}
export interface ValueError {
    type: ValueErrorType;
    schema: TSchema;
    path: string;
    value: unknown;
    message: string;
    errors: ValueErrorIterator[];
}
export declare class ValueErrorsUnknownTypeError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema);
}
export declare class ValueErrorIterator {
    private readonly iterator;
    constructor(iterator: IterableIterator<ValueError>);
    [Symbol.iterator](): IterableIterator<ValueError>;
    /** Returns the first value error or undefined if no errors */
    First(): ValueError | undefined;
}
/** Returns an iterator for each error in this value. */
export declare function Errors<T extends TSchema>(schema: T, references: TSchema[], value: unknown): ValueErrorIterator;
/** Returns an iterator for each error in this value. */
export declare function Errors<T extends TSchema>(schema: T, value: unknown): ValueErrorIterator;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\errors.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;
exports.Errors = Errors;
const index_1 = require("../system/index");
const index_2 = require("../type/keyof/index");
const index_3 = require("../type/registry/index");
const extends_undefined_1 = require("../type/extends/extends-undefined");
const function_1 = require("./function");
const index_4 = require("../type/error/index");
const index_5 = require("../value/deref/index");
const index_6 = require("../value/hash/index");
const index_7 = require("../value/check/index");
const index_8 = require("../type/symbols/index");
const index_9 = require("../type/never/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
// prettier-ignore
const index_10 = require("../value/guard/index");
// ------------------------------------------------------------------
// ValueErrorType
// ------------------------------------------------------------------
var ValueErrorType;
(function (ValueErrorType) {
    ValueErrorType[ValueErrorType["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType[ValueErrorType["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType[ValueErrorType["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType[ValueErrorType["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType[ValueErrorType["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType[ValueErrorType["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType[ValueErrorType["Array"] = 6] = "Array";
    ValueErrorType[ValueErrorType["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType[ValueErrorType["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType[ValueErrorType["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType[ValueErrorType["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType[ValueErrorType["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType[ValueErrorType["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType[ValueErrorType["BigInt"] = 13] = "BigInt";
    ValueErrorType[ValueErrorType["Boolean"] = 14] = "Boolean";
    ValueErrorType[ValueErrorType["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType[ValueErrorType["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType[ValueErrorType["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType[ValueErrorType["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType[ValueErrorType["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType[ValueErrorType["Date"] = 20] = "Date";
    ValueErrorType[ValueErrorType["Function"] = 21] = "Function";
    ValueErrorType[ValueErrorType["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType[ValueErrorType["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType[ValueErrorType["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType[ValueErrorType["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType[ValueErrorType["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType[ValueErrorType["Integer"] = 27] = "Integer";
    ValueErrorType[ValueErrorType["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType[ValueErrorType["Intersect"] = 29] = "Intersect";
    ValueErrorType[ValueErrorType["Iterator"] = 30] = "Iterator";
    ValueErrorType[ValueErrorType["Kind"] = 31] = "Kind";
    ValueErrorType[ValueErrorType["Literal"] = 32] = "Literal";
    ValueErrorType[ValueErrorType["Never"] = 33] = "Never";
    ValueErrorType[ValueErrorType["Not"] = 34] = "Not";
    ValueErrorType[ValueErrorType["Null"] = 35] = "Null";
    ValueErrorType[ValueErrorType["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType[ValueErrorType["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType[ValueErrorType["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType[ValueErrorType["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType[ValueErrorType["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType[ValueErrorType["Number"] = 41] = "Number";
    ValueErrorType[ValueErrorType["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType[ValueErrorType["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType[ValueErrorType["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType[ValueErrorType["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType[ValueErrorType["Object"] = 46] = "Object";
    ValueErrorType[ValueErrorType["Promise"] = 47] = "Promise";
    ValueErrorType[ValueErrorType["RegExp"] = 48] = "RegExp";
    ValueErrorType[ValueErrorType["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType[ValueErrorType["StringFormat"] = 50] = "StringFormat";
    ValueErrorType[ValueErrorType["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType[ValueErrorType["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType[ValueErrorType["StringPattern"] = 53] = "StringPattern";
    ValueErrorType[ValueErrorType["String"] = 54] = "String";
    ValueErrorType[ValueErrorType["Symbol"] = 55] = "Symbol";
    ValueErrorType[ValueErrorType["TupleLength"] = 56] = "TupleLength";
    ValueErrorType[ValueErrorType["Tuple"] = 57] = "Tuple";
    ValueErrorType[ValueErrorType["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType[ValueErrorType["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType[ValueErrorType["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType[ValueErrorType["Undefined"] = 61] = "Undefined";
    ValueErrorType[ValueErrorType["Union"] = 62] = "Union";
    ValueErrorType[ValueErrorType["Void"] = 63] = "Void";
})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));
// ------------------------------------------------------------------
// ValueErrors
// ------------------------------------------------------------------
class ValueErrorsUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
        super('Unknown type');
        this.schema = schema;
    }
}
exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
// ------------------------------------------------------------------
// EscapeKey
// ------------------------------------------------------------------
function EscapeKey(key) {
    return key.replace(/~/g, '~0').replace(/\//g, '~1'); // RFC6901 Path
}
// ------------------------------------------------------------------
// Guards
// ------------------------------------------------------------------
function IsDefined(value) {
    return value !== undefined;
}
// ------------------------------------------------------------------
// ValueErrorIterator
// ------------------------------------------------------------------
class ValueErrorIterator {
    constructor(iterator) {
        this.iterator = iterator;
    }
    [Symbol.iterator]() {
        return this.iterator;
    }
    /** Returns the first value error or undefined if no errors */
    First() {
        const next = this.iterator.next();
        return next.done ? undefined : next.value;
    }
}
exports.ValueErrorIterator = ValueErrorIterator;
// --------------------------------------------------------------------------
// Create
// --------------------------------------------------------------------------
function Create(errorType, schema, path, value, errors = []) {
    return {
        type: errorType,
        schema,
        path,
        value,
        message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value, errors }),
        errors,
    };
}
// --------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------
function* FromAny(schema, references, path, value) { }
function* FromArgument(schema, references, path, value) { }
function* FromArray(schema, references, path, value) {
    if (!(0, index_10.IsArray)(value)) {
        return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i = 0; i < value.length; i++) {
        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
    }
    // prettier-ignore
    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {
        const hashed = (0, index_6.Hash)(element);
        if (set.has(hashed)) {
            return false;
        }
        else {
            set.add(hashed);
        }
    } return true; })())) {
        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    // contains
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
        return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);
    if (containsCount === 0) {
        yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
}
function* FromAsyncIterator(schema, references, path, value) {
    if (!(0, index_10.IsAsyncIterator)(value))
        yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
    if (!(0, index_10.IsBigInt)(value))
        return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
}
function* FromBoolean(schema, references, path, value) {
    if (!(0, index_10.IsBoolean)(value))
        yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
    if (!(0, index_10.IsDate)(value))
        return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
}
function* FromFunction(schema, references, path, value) {
    if (!(0, index_10.IsFunction)(value))
        yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport(schema, references, path, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    yield* Visit(target, [...references, ...definitions], path, value);
}
function* FromInteger(schema, references, path, value) {
    if (!(0, index_10.IsInteger)(value))
        return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
}
function* FromIntersect(schema, references, path, value) {
    let hasError = false;
    for (const inner of schema.allOf) {
        for (const error of Visit(inner, references, path, value)) {
            hasError = true;
            yield error;
        }
    }
    if (hasError) {
        return yield Create(ValueErrorType.Intersect, schema, path, value);
    }
    if (schema.unevaluatedProperties === false) {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
            if (!keyCheck.test(valueKey)) {
                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
            }
        }
    }
    if (typeof schema.unevaluatedProperties === 'object') {
        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
            if (!keyCheck.test(valueKey)) {
                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
                if (!next.done)
                    yield next.value; // yield interior
            }
        }
    }
}
function* FromIterator(schema, references, path, value) {
    if (!(0, index_10.IsIterator)(value))
        yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral(schema, references, path, value) {
    if (!(value === schema.const))
        yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
        yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
    if (!(0, index_10.IsNull)(value))
        yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
}
function* FromObject(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
        if (unknownKeys.includes(requiredKey))
            continue;
        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
        for (const valueKey of unknownKeys) {
            if (!knownKeys.includes(valueKey)) {
                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
            }
        }
    }
    if (typeof schema.additionalProperties === 'object') {
        for (const valueKey of unknownKeys) {
            if (knownKeys.includes(valueKey))
                continue;
            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
    }
    for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
            if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
            }
        }
        else {
            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
            }
        }
    }
}
function* FromPromise(schema, references, path, value) {
    if (!(0, index_10.IsPromise)(value))
        yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value))
        return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === 'object') {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
            if (!regex.test(propertyKey))
                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
    }
    if (schema.additionalProperties === false) {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
            if (regex.test(propertyKey))
                continue;
            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
    }
}
function* FromRef(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    const regex = new RegExp(schema.source, schema.flags);
    if (!regex.test(value)) {
        return yield Create(ValueErrorType.RegExp, schema, path, value);
    }
}
function* FromString(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
        yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
        yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, index_10.IsString)(schema.pattern)) {
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value)) {
            yield Create(ValueErrorType.StringPattern, schema, path, value);
        }
    }
    if ((0, index_10.IsString)(schema.format)) {
        if (!index_3.FormatRegistry.Has(schema.format)) {
            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
        }
        else {
            const format = index_3.FormatRegistry.Get(schema.format);
            if (!format(value)) {
                yield Create(ValueErrorType.StringFormat, schema, path, value);
            }
        }
    }
}
function* FromSymbol(schema, references, path, value) {
    if (!(0, index_10.IsSymbol)(value))
        yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
        return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
}
function* FromThis(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
}
function* FromTuple(schema, references, path, value) {
    if (!(0, index_10.IsArray)(value))
        return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
        return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
        return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
        return;
    }
    for (let i = 0; i < schema.items.length; i++) {
        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
    }
}
function* FromUndefined(schema, references, path, value) {
    if (!(0, index_10.IsUndefined)(value))
        yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion(schema, references, path, value) {
    if ((0, index_7.Check)(schema, references, value))
        return;
    const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path, value)));
    yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array(schema, references, path, value) {
    if (!(0, index_10.IsUint8Array)(value))
        return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
}
function* FromUnknown(schema, references, path, value) { }
function* FromVoid(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value))
        yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
    const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);
    if (!check(schema, value))
        yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
        case 'Any':
            return yield* FromAny(schema_, references_, path, value);
        case 'Argument':
            return yield* FromArgument(schema_, references_, path, value);
        case 'Array':
            return yield* FromArray(schema_, references_, path, value);
        case 'AsyncIterator':
            return yield* FromAsyncIterator(schema_, references_, path, value);
        case 'BigInt':
            return yield* FromBigInt(schema_, references_, path, value);
        case 'Boolean':
            return yield* FromBoolean(schema_, references_, path, value);
        case 'Constructor':
            return yield* FromConstructor(schema_, references_, path, value);
        case 'Date':
            return yield* FromDate(schema_, references_, path, value);
        case 'Function':
            return yield* FromFunction(schema_, references_, path, value);
        case 'Import':
            return yield* FromImport(schema_, references_, path, value);
        case 'Integer':
            return yield* FromInteger(schema_, references_, path, value);
        case 'Intersect':
            return yield* FromIntersect(schema_, references_, path, value);
        case 'Iterator':
            return yield* FromIterator(schema_, references_, path, value);
        case 'Literal':
            return yield* FromLiteral(schema_, references_, path, value);
        case 'Never':
            return yield* FromNever(schema_, references_, path, value);
        case 'Not':
            return yield* FromNot(schema_, references_, path, value);
        case 'Null':
            return yield* FromNull(schema_, references_, path, value);
        case 'Number':
            return yield* FromNumber(schema_, references_, path, value);
        case 'Object':
            return yield* FromObject(schema_, references_, path, value);
        case 'Promise':
            return yield* FromPromise(schema_, references_, path, value);
        case 'Record':
            return yield* FromRecord(schema_, references_, path, value);
        case 'Ref':
            return yield* FromRef(schema_, references_, path, value);
        case 'RegExp':
            return yield* FromRegExp(schema_, references_, path, value);
        case 'String':
            return yield* FromString(schema_, references_, path, value);
        case 'Symbol':
            return yield* FromSymbol(schema_, references_, path, value);
        case 'TemplateLiteral':
            return yield* FromTemplateLiteral(schema_, references_, path, value);
        case 'This':
            return yield* FromThis(schema_, references_, path, value);
        case 'Tuple':
            return yield* FromTuple(schema_, references_, path, value);
        case 'Undefined':
            return yield* FromUndefined(schema_, references_, path, value);
        case 'Union':
            return yield* FromUnion(schema_, references_, path, value);
        case 'Uint8Array':
            return yield* FromUint8Array(schema_, references_, path, value);
        case 'Unknown':
            return yield* FromUnknown(schema_, references_, path, value);
        case 'Void':
            return yield* FromVoid(schema_, references_, path, value);
        default:
            if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))
                throw new ValueErrorsUnknownTypeError(schema);
            return yield* FromKind(schema_, references_, path, value);
    }
}
/** Returns an iterator for each error in this value. */
function Errors(...args) {
    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);
    return new ValueErrorIterator(iterator);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\function.d.ts

Code:
import { TSchema } from '../type/schema/index';
import { ValueErrorIterator, ValueErrorType } from './errors';
/** Creates an error message using en-US as the default locale */
export declare function DefaultErrorFunction(error: ErrorFunctionParameter): string;
export type ErrorFunctionParameter = {
    /** The type of validation error */
    errorType: ValueErrorType;
    /** The path of the error */
    path: string;
    /** The schema associated with the error */
    schema: TSchema;
    /** The value associated with the error */
    value: unknown;
    /** Interior errors for this error */
    errors: ValueErrorIterator[];
};
export type ErrorFunction = (parameter: ErrorFunctionParameter) => string;
/** Sets the error function used to generate error messages. */
export declare function SetErrorFunction(callback: ErrorFunction): void;
/** Gets the error function used to generate error messages */
export declare function GetErrorFunction(): ErrorFunction;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\function.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultErrorFunction = DefaultErrorFunction;
exports.SetErrorFunction = SetErrorFunction;
exports.GetErrorFunction = GetErrorFunction;
const index_1 = require("../type/symbols/index");
const errors_1 = require("./errors");
/** Creates an error message using en-US as the default locale */
function DefaultErrorFunction(error) {
    switch (error.errorType) {
        case errors_1.ValueErrorType.ArrayContains:
            return 'Expected array to contain at least one matching value';
        case errors_1.ValueErrorType.ArrayMaxContains:
            return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
        case errors_1.ValueErrorType.ArrayMinContains:
            return `Expected array to contain at least ${error.schema.minContains} matching values`;
        case errors_1.ValueErrorType.ArrayMaxItems:
            return `Expected array length to be less or equal to ${error.schema.maxItems}`;
        case errors_1.ValueErrorType.ArrayMinItems:
            return `Expected array length to be greater or equal to ${error.schema.minItems}`;
        case errors_1.ValueErrorType.ArrayUniqueItems:
            return 'Expected array elements to be unique';
        case errors_1.ValueErrorType.Array:
            return 'Expected array';
        case errors_1.ValueErrorType.AsyncIterator:
            return 'Expected AsyncIterator';
        case errors_1.ValueErrorType.BigIntExclusiveMaximum:
            return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.BigIntExclusiveMinimum:
            return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.BigIntMaximum:
            return `Expected bigint to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.BigIntMinimum:
            return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.BigIntMultipleOf:
            return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.BigInt:
            return 'Expected bigint';
        case errors_1.ValueErrorType.Boolean:
            return 'Expected boolean';
        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
            return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
            return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
        case errors_1.ValueErrorType.DateMinimumTimestamp:
            return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
        case errors_1.ValueErrorType.DateMaximumTimestamp:
            return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
        case errors_1.ValueErrorType.DateMultipleOfTimestamp:
            return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
        case errors_1.ValueErrorType.Date:
            return 'Expected Date';
        case errors_1.ValueErrorType.Function:
            return 'Expected function';
        case errors_1.ValueErrorType.IntegerExclusiveMaximum:
            return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.IntegerExclusiveMinimum:
            return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.IntegerMaximum:
            return `Expected integer to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.IntegerMinimum:
            return `Expected integer to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.IntegerMultipleOf:
            return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.Integer:
            return 'Expected integer';
        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
            return 'Unexpected property';
        case errors_1.ValueErrorType.Intersect:
            return 'Expected all values to match';
        case errors_1.ValueErrorType.Iterator:
            return 'Expected Iterator';
        case errors_1.ValueErrorType.Literal:
            return `Expected ${typeof error.schema.const === 'string' ? `'${error.schema.const}'` : error.schema.const}`;
        case errors_1.ValueErrorType.Never:
            return 'Never';
        case errors_1.ValueErrorType.Not:
            return 'Value should not match';
        case errors_1.ValueErrorType.Null:
            return 'Expected null';
        case errors_1.ValueErrorType.NumberExclusiveMaximum:
            return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
        case errors_1.ValueErrorType.NumberExclusiveMinimum:
            return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
        case errors_1.ValueErrorType.NumberMaximum:
            return `Expected number to be less or equal to ${error.schema.maximum}`;
        case errors_1.ValueErrorType.NumberMinimum:
            return `Expected number to be greater or equal to ${error.schema.minimum}`;
        case errors_1.ValueErrorType.NumberMultipleOf:
            return `Expected number to be a multiple of ${error.schema.multipleOf}`;
        case errors_1.ValueErrorType.Number:
            return 'Expected number';
        case errors_1.ValueErrorType.Object:
            return 'Expected object';
        case errors_1.ValueErrorType.ObjectAdditionalProperties:
            return 'Unexpected property';
        case errors_1.ValueErrorType.ObjectMaxProperties:
            return `Expected object to have no more than ${error.schema.maxProperties} properties`;
        case errors_1.ValueErrorType.ObjectMinProperties:
            return `Expected object to have at least ${error.schema.minProperties} properties`;
        case errors_1.ValueErrorType.ObjectRequiredProperty:
            return 'Expected required property';
        case errors_1.ValueErrorType.Promise:
            return 'Expected Promise';
        case errors_1.ValueErrorType.RegExp:
            return 'Expected string to match regular expression';
        case errors_1.ValueErrorType.StringFormatUnknown:
            return `Unknown format '${error.schema.format}'`;
        case errors_1.ValueErrorType.StringFormat:
            return `Expected string to match '${error.schema.format}' format`;
        case errors_1.ValueErrorType.StringMaxLength:
            return `Expected string length less or equal to ${error.schema.maxLength}`;
        case errors_1.ValueErrorType.StringMinLength:
            return `Expected string length greater or equal to ${error.schema.minLength}`;
        case errors_1.ValueErrorType.StringPattern:
            return `Expected string to match '${error.schema.pattern}'`;
        case errors_1.ValueErrorType.String:
            return 'Expected string';
        case errors_1.ValueErrorType.Symbol:
            return 'Expected symbol';
        case errors_1.ValueErrorType.TupleLength:
            return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
        case errors_1.ValueErrorType.Tuple:
            return 'Expected tuple';
        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
            return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
            return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
        case errors_1.ValueErrorType.Uint8Array:
            return 'Expected Uint8Array';
        case errors_1.ValueErrorType.Undefined:
            return 'Expected undefined';
        case errors_1.ValueErrorType.Union:
            return 'Expected union value';
        case errors_1.ValueErrorType.Void:
            return 'Expected void';
        case errors_1.ValueErrorType.Kind:
            return `Expected kind '${error.schema[index_1.Kind]}'`;
        default:
            return 'Unknown error type';
    }
}
/** Manages error message providers */
let errorFunction = DefaultErrorFunction;
/** Sets the error function used to generate error messages. */
function SetErrorFunction(callback) {
    errorFunction = callback;
}
/** Gets the error function used to generate error messages */
function GetErrorFunction() {
    return errorFunction;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\index.d.ts

Code:
export * from './errors';
export * from './function';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\errors\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./errors"), exports);
__exportStar(require("./function"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\index.d.ts

Code:
export * from './type/clone/index';
export * from './type/create/index';
export * from './type/error/index';
export * from './type/guard/index';
export * from './type/helpers/index';
export * from './type/patterns/index';
export * from './type/registry/index';
export * from './type/sets/index';
export * from './type/symbols/index';
export * from './type/any/index';
export * from './type/array/index';
export * from './type/argument/index';
export * from './type/async-iterator/index';
export * from './type/awaited/index';
export * from './type/bigint/index';
export * from './type/boolean/index';
export * from './type/composite/index';
export * from './type/const/index';
export * from './type/constructor/index';
export * from './type/constructor-parameters/index';
export * from './type/date/index';
export * from './type/enum/index';
export * from './type/exclude/index';
export * from './type/extends/index';
export * from './type/extract/index';
export * from './type/function/index';
export * from './type/indexed/index';
export * from './type/instance-type/index';
export * from './type/instantiate/index';
export * from './type/integer/index';
export * from './type/intersect/index';
export * from './type/iterator/index';
export * from './type/intrinsic/index';
export * from './type/keyof/index';
export * from './type/literal/index';
export * from './type/module/index';
export * from './type/mapped/index';
export * from './type/never/index';
export * from './type/not/index';
export * from './type/null/index';
export * from './type/number/index';
export * from './type/object/index';
export * from './type/omit/index';
export * from './type/optional/index';
export * from './type/parameters/index';
export * from './type/partial/index';
export * from './type/pick/index';
export * from './type/promise/index';
export * from './type/readonly/index';
export * from './type/readonly-optional/index';
export * from './type/record/index';
export * from './type/recursive/index';
export * from './type/ref/index';
export * from './type/regexp/index';
export * from './type/required/index';
export * from './type/rest/index';
export * from './type/return-type/index';
export * from './type/schema/index';
export * from './type/static/index';
export * from './type/string/index';
export * from './type/symbol/index';
export * from './type/template-literal/index';
export * from './type/transform/index';
export * from './type/tuple/index';
export * from './type/uint8array/index';
export * from './type/undefined/index';
export * from './type/union/index';
export * from './type/unknown/index';
export * from './type/unsafe/index';
export * from './type/void/index';
export * from './type/type/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// ------------------------------------------------------------------
// Infrastructure
// ------------------------------------------------------------------
__exportStar(require("./type/clone/index"), exports);
__exportStar(require("./type/create/index"), exports);
__exportStar(require("./type/error/index"), exports);
__exportStar(require("./type/guard/index"), exports);
__exportStar(require("./type/helpers/index"), exports);
__exportStar(require("./type/patterns/index"), exports);
__exportStar(require("./type/registry/index"), exports);
__exportStar(require("./type/sets/index"), exports);
__exportStar(require("./type/symbols/index"), exports);
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
__exportStar(require("./type/any/index"), exports);
__exportStar(require("./type/array/index"), exports);
__exportStar(require("./type/argument/index"), exports);
__exportStar(require("./type/async-iterator/index"), exports);
__exportStar(require("./type/awaited/index"), exports);
__exportStar(require("./type/bigint/index"), exports);
__exportStar(require("./type/boolean/index"), exports);
__exportStar(require("./type/composite/index"), exports);
__exportStar(require("./type/const/index"), exports);
__exportStar(require("./type/constructor/index"), exports);
__exportStar(require("./type/constructor-parameters/index"), exports);
__exportStar(require("./type/date/index"), exports);
__exportStar(require("./type/enum/index"), exports);
__exportStar(require("./type/exclude/index"), exports);
__exportStar(require("./type/extends/index"), exports);
__exportStar(require("./type/extract/index"), exports);
__exportStar(require("./type/function/index"), exports);
__exportStar(require("./type/indexed/index"), exports);
__exportStar(require("./type/instance-type/index"), exports);
__exportStar(require("./type/instantiate/index"), exports);
__exportStar(require("./type/integer/index"), exports);
__exportStar(require("./type/intersect/index"), exports);
__exportStar(require("./type/iterator/index"), exports);
__exportStar(require("./type/intrinsic/index"), exports);
__exportStar(require("./type/keyof/index"), exports);
__exportStar(require("./type/literal/index"), exports);
__exportStar(require("./type/module/index"), exports);
__exportStar(require("./type/mapped/index"), exports);
__exportStar(require("./type/never/index"), exports);
__exportStar(require("./type/not/index"), exports);
__exportStar(require("./type/null/index"), exports);
__exportStar(require("./type/number/index"), exports);
__exportStar(require("./type/object/index"), exports);
__exportStar(require("./type/omit/index"), exports);
__exportStar(require("./type/optional/index"), exports);
__exportStar(require("./type/parameters/index"), exports);
__exportStar(require("./type/partial/index"), exports);
__exportStar(require("./type/pick/index"), exports);
__exportStar(require("./type/promise/index"), exports);
__exportStar(require("./type/readonly/index"), exports);
__exportStar(require("./type/readonly-optional/index"), exports);
__exportStar(require("./type/record/index"), exports);
__exportStar(require("./type/recursive/index"), exports);
__exportStar(require("./type/ref/index"), exports);
__exportStar(require("./type/regexp/index"), exports);
__exportStar(require("./type/required/index"), exports);
__exportStar(require("./type/rest/index"), exports);
__exportStar(require("./type/return-type/index"), exports);
__exportStar(require("./type/schema/index"), exports);
__exportStar(require("./type/static/index"), exports);
__exportStar(require("./type/string/index"), exports);
__exportStar(require("./type/symbol/index"), exports);
__exportStar(require("./type/template-literal/index"), exports);
__exportStar(require("./type/transform/index"), exports);
__exportStar(require("./type/tuple/index"), exports);
__exportStar(require("./type/uint8array/index"), exports);
__exportStar(require("./type/undefined/index"), exports);
__exportStar(require("./type/union/index"), exports);
__exportStar(require("./type/unknown/index"), exports);
__exportStar(require("./type/unsafe/index"), exports);
__exportStar(require("./type/void/index"), exports);
// ------------------------------------------------------------------
// Type.*
// ------------------------------------------------------------------
__exportStar(require("./type/type/index"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\index.d.ts

Code:
export * as Runtime from './runtime/index';
export * as Static from './static/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Static = exports.Runtime = void 0;
exports.Runtime = require("./runtime/index");
exports.Static = require("./static/index");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\guard.d.ts

Code:
import { IArray, IConst, IContext, IIdent, INumber, IOptional, IRef, IString, ITuple, IUnion } from './types';
/** Returns true if the value is a Array Parser */
export declare function IsArray(value: unknown): value is IArray;
/** Returns true if the value is a Const Parser */
export declare function IsConst(value: unknown): value is IConst;
/** Returns true if the value is a Context Parser */
export declare function IsContext(value: unknown): value is IContext;
/** Returns true if the value is a Ident Parser */
export declare function IsIdent(value: unknown): value is IIdent;
/** Returns true if the value is a Number Parser */
export declare function IsNumber(value: unknown): value is INumber;
/** Returns true if the value is a Optional Parser */
export declare function IsOptional(value: unknown): value is IOptional;
/** Returns true if the value is a Ref Parser */
export declare function IsRef(value: unknown): value is IRef;
/** Returns true if the value is a String Parser */
export declare function IsString(value: unknown): value is IString;
/** Returns true if the value is a Tuple Parser */
export declare function IsTuple(value: unknown): value is ITuple;
/** Returns true if the value is a Union Parser */
export declare function IsUnion(value: unknown): value is IUnion;
/** Returns true if the value is a Parser */
export declare function IsParser(value: unknown): value is IContext<unknown> | IUnion<unknown> | IArray<unknown> | IConst<unknown> | IIdent<unknown> | INumber<unknown> | IOptional<unknown> | IRef<unknown> | IString<unknown> | ITuple<unknown>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\guard.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IsArray = IsArray;
exports.IsConst = IsConst;
exports.IsContext = IsContext;
exports.IsIdent = IsIdent;
exports.IsNumber = IsNumber;
exports.IsOptional = IsOptional;
exports.IsRef = IsRef;
exports.IsString = IsString;
exports.IsTuple = IsTuple;
exports.IsUnion = IsUnion;
exports.IsParser = IsParser;
// ------------------------------------------------------------------
// Value Guard
// ------------------------------------------------------------------
// prettier-ignore
function HasPropertyKey(value, key) {
    return key in value;
}
// prettier-ignore
function IsObjectValue(value) {
    return typeof value === 'object' && value !== null;
}
// prettier-ignore
function IsArrayValue(value) {
    return globalThis.Array.isArray(value);
}
// ------------------------------------------------------------------
// Parser Guard
// ------------------------------------------------------------------
/** Returns true if the value is a Array Parser */
function IsArray(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Array' && HasPropertyKey(value, 'parser') && IsObjectValue(value.parser);
}
/** Returns true if the value is a Const Parser */
function IsConst(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Const' && HasPropertyKey(value, 'value') && typeof value.value === 'string';
}
/** Returns true if the value is a Context Parser */
function IsContext(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Context' && HasPropertyKey(value, 'left') && IsParser(value.left) && HasPropertyKey(value, 'right') && IsParser(value.right);
}
/** Returns true if the value is a Ident Parser */
function IsIdent(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Ident';
}
/** Returns true if the value is a Number Parser */
function IsNumber(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Number';
}
/** Returns true if the value is a Optional Parser */
function IsOptional(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Optional' && HasPropertyKey(value, 'parser') && IsObjectValue(value.parser);
}
/** Returns true if the value is a Ref Parser */
function IsRef(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Ref' && HasPropertyKey(value, 'ref') && typeof value.ref === 'string';
}
/** Returns true if the value is a String Parser */
function IsString(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'String' && HasPropertyKey(value, 'options') && IsArrayValue(value.options);
}
/** Returns true if the value is a Tuple Parser */
function IsTuple(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Tuple' && HasPropertyKey(value, 'parsers') && IsArrayValue(value.parsers);
}
/** Returns true if the value is a Union Parser */
function IsUnion(value) {
    return IsObjectValue(value) && HasPropertyKey(value, 'type') && value.type === 'Union' && HasPropertyKey(value, 'parsers') && IsArrayValue(value.parsers);
}
/** Returns true if the value is a Parser */
function IsParser(value) {
    // prettier-ignore
    return (IsArray(value) ||
        IsConst(value) ||
        IsContext(value) ||
        IsIdent(value) ||
        IsNumber(value) ||
        IsOptional(value) ||
        IsRef(value) ||
        IsString(value) ||
        IsTuple(value) ||
        IsUnion(value));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\index.d.ts

Code:
export * as Guard from './guard';
export * as Token from './token';
export * from './types';
export * from './module';
export * from './parse';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = exports.Guard = void 0;
exports.Guard = require("./guard");
exports.Token = require("./token");
__exportStar(require("./types"), exports);
__exportStar(require("./module"), exports);
__exportStar(require("./parse"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\module.d.ts

Code:
import * as Types from './types';
export declare class Module<Properties extends Types.IModuleProperties = Types.IModuleProperties> {
    private readonly properties;
    constructor(properties: Properties);
    /** Parses using one of the parsers defined on this instance */
    Parse<Key extends keyof Properties>(key: Key, content: string, context: unknown): [] | [Types.StaticParser<Properties[Key]>, string];
    /** Parses using one of the parsers defined on this instance */
    Parse<Key extends keyof Properties>(key: Key, content: string): [] | [Types.StaticParser<Properties[Key]>, string];
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\module.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Module = void 0;
const parse_1 = require("./parse");
// ------------------------------------------------------------------
// Module
// ------------------------------------------------------------------
class Module {
    constructor(properties) {
        this.properties = properties;
    }
    /** Parses using one of the parsers defined on this instance */
    Parse(...args) {
        // prettier-ignore
        const [key, content, context] = (args.length === 3 ? [args[0], args[1], args[2]] :
            args.length === 2 ? [args[0], args[1], undefined] :
                (() => { throw Error('Invalid parse arguments'); })());
        return (0, parse_1.Parse)(this.properties, this.properties[key], content, context);
    }
}
exports.Module = Module;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\parse.d.ts

Code:
import * as Types from './types';
/** Parses content using the given Parser */
export declare function Parse<Parser extends Types.IParser>(moduleProperties: Types.IModuleProperties, parser: Parser, code: string, context: unknown): [] | [Types.StaticParser<Parser>, string];
/** Parses content using the given Parser */
export declare function Parse<Parser extends Types.IParser>(moduleProperties: Types.IModuleProperties, parser: Parser, code: string): [] | [Types.StaticParser<Parser>, string];
/** Parses content using the given Parser */
export declare function Parse<Parser extends Types.IParser>(parser: Parser, content: string, context: unknown): [] | [Types.StaticParser<Parser>, string];
/** Parses content using the given Parser */
export declare function Parse<Parser extends Types.IParser>(parser: Parser, content: string): [] | [Types.StaticParser<Parser>, string];


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\parse.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Parse = Parse;
const Guard = require("./guard");
const Token = require("./token");
// ------------------------------------------------------------------
// Context
// ------------------------------------------------------------------
function ParseContext(moduleProperties, left, right, code, context) {
    const result = ParseParser(moduleProperties, left, code, context);
    return result.length === 2 ? ParseParser(moduleProperties, right, result[1], result[0]) : [];
}
// ------------------------------------------------------------------
// Array
// ------------------------------------------------------------------
function ParseArray(moduleProperties, parser, code, context) {
    const buffer = [];
    let rest = code;
    while (rest.length > 0) {
        const result = ParseParser(moduleProperties, parser, rest, context);
        if (result.length === 0)
            return [buffer, rest];
        buffer.push(result[0]);
        rest = result[1];
    }
    return [buffer, rest];
}
// ------------------------------------------------------------------
// Const
// ------------------------------------------------------------------
function ParseConst(value, code, context) {
    return Token.Const(value, code);
}
// ------------------------------------------------------------------
// Ident
// ------------------------------------------------------------------
function ParseIdent(code, _context) {
    return Token.Ident(code);
}
// ------------------------------------------------------------------
// Number
// ------------------------------------------------------------------
// prettier-ignore
function ParseNumber(code, _context) {
    return Token.Number(code);
}
// ------------------------------------------------------------------
// Optional
// ------------------------------------------------------------------
function ParseOptional(moduleProperties, parser, code, context) {
    const result = ParseParser(moduleProperties, parser, code, context);
    return (result.length === 2 ? [[result[0]], result[1]] : [[], code]);
}
// ------------------------------------------------------------------
// Ref
// ------------------------------------------------------------------
function ParseRef(moduleProperties, ref, code, context) {
    const parser = moduleProperties[ref];
    if (!Guard.IsParser(parser))
        throw Error(`Cannot dereference Parser '${ref}'`);
    return ParseParser(moduleProperties, parser, code, context);
}
// ------------------------------------------------------------------
// String
// ------------------------------------------------------------------
// prettier-ignore
function ParseString(options, code, _context) {
    return Token.String(options, code);
}
// ------------------------------------------------------------------
// Tuple
// ------------------------------------------------------------------
function ParseTuple(moduleProperties, parsers, code, context) {
    const buffer = [];
    let rest = code;
    for (const parser of parsers) {
        const result = ParseParser(moduleProperties, parser, rest, context);
        if (result.length === 0)
            return [];
        buffer.push(result[0]);
        rest = result[1];
    }
    return [buffer, rest];
}
// ------------------------------------------------------------------
// Union
// ------------------------------------------------------------------
// prettier-ignore
function ParseUnion(moduleProperties, parsers, code, context) {
    for (const parser of parsers) {
        const result = ParseParser(moduleProperties, parser, code, context);
        if (result.length === 0)
            continue;
        return result;
    }
    return [];
}
// ------------------------------------------------------------------
// Parser
// ------------------------------------------------------------------
// prettier-ignore
function ParseParser(moduleProperties, parser, code, context) {
    const result = (Guard.IsContext(parser) ? ParseContext(moduleProperties, parser.left, parser.right, code, context) :
        Guard.IsArray(parser) ? ParseArray(moduleProperties, parser.parser, code, context) :
            Guard.IsConst(parser) ? ParseConst(parser.value, code, context) :
                Guard.IsIdent(parser) ? ParseIdent(code, context) :
                    Guard.IsNumber(parser) ? ParseNumber(code, context) :
                        Guard.IsOptional(parser) ? ParseOptional(moduleProperties, parser.parser, code, context) :
                            Guard.IsRef(parser) ? ParseRef(moduleProperties, parser.ref, code, context) :
                                Guard.IsString(parser) ? ParseString(parser.options, code, context) :
                                    Guard.IsTuple(parser) ? ParseTuple(moduleProperties, parser.parsers, code, context) :
                                        Guard.IsUnion(parser) ? ParseUnion(moduleProperties, parser.parsers, code, context) :
                                            []);
    return (result.length === 2
        ? [parser.mapping(result[0], context), result[1]]
        : result);
}
/** Parses content using the given parser */
// prettier-ignore
function Parse(...args) {
    const withModuleProperties = typeof args[1] === 'string' ? false : true;
    const [moduleProperties, parser, content, context] = withModuleProperties
        ? [args[0], args[1], args[2], args[3]]
        : [{}, args[0], args[1], args[2]];
    return ParseParser(moduleProperties, parser, content, context);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\token.d.ts

Code:
/** Takes the next constant string value skipping any whitespace */
export declare function Const(value: string, code: string): [] | [string, string];
/** Scans for the next Ident token */
export declare function Ident(code: string): [] | [string, string];
/** Scans for the next number token */
export declare function Number(code: string): [string, string] | [];
/** Scans the next Literal String value */
export declare function String(options: string[], code: string): [string, string] | [];


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\token.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Const = Const;
exports.Ident = Ident;
exports.Number = Number;
exports.String = String;
// ------------------------------------------------------------------
// Chars
// ------------------------------------------------------------------
// prettier-ignore
var Chars;
(function (Chars) {
    /** Returns true if the char code is a whitespace */
    function IsWhitespace(value) {
        return value === 32;
    }
    Chars.IsWhitespace = IsWhitespace;
    /** Returns true if the char code is a newline */
    function IsNewline(value) {
        return value === 10;
    }
    Chars.IsNewline = IsNewline;
    /** Returns true if the char code is a alpha  */
    function IsAlpha(value) {
        return ((value >= 65 && value <= 90) || // A-Z 
            (value >= 97 && value <= 122) // a-z
        );
    }
    Chars.IsAlpha = IsAlpha;
    /** Returns true if the char code is zero */
    function IsZero(value) {
        return value === 48;
    }
    Chars.IsZero = IsZero;
    /** Returns true if the char code is non-zero */
    function IsNonZero(value) {
        return value >= 49 && value <= 57;
    }
    Chars.IsNonZero = IsNonZero;
    /** Returns true if the char code is a digit */
    function IsDigit(value) {
        return (IsNonZero(value) ||
            IsZero(value));
    }
    Chars.IsDigit = IsDigit;
    /** Returns true if the char code is a dot */
    function IsDot(value) {
        return value === 46;
    }
    Chars.IsDot = IsDot;
    /** Returns true if this char code is a underscore */
    function IsUnderscore(value) {
        return value === 95;
    }
    Chars.IsUnderscore = IsUnderscore;
    /** Returns true if this char code is a dollar sign */
    function IsDollarSign(value) {
        return value === 36;
    }
    Chars.IsDollarSign = IsDollarSign;
})(Chars || (Chars = {}));
// ------------------------------------------------------------------
// Trim
// ------------------------------------------------------------------
// prettier-ignore
var Trim;
(function (Trim) {
    /** Trims Whitespace and retains Newline, Tabspaces, etc. */
    function TrimWhitespaceOnly(code) {
        for (let i = 0; i < code.length; i++) {
            if (Chars.IsWhitespace(code.charCodeAt(i)))
                continue;
            return code.slice(i);
        }
        return code;
    }
    Trim.TrimWhitespaceOnly = TrimWhitespaceOnly;
    /** Trims Whitespace including Newline, Tabspaces, etc. */
    function TrimAll(code) {
        return code.trimStart();
    }
    Trim.TrimAll = TrimAll;
})(Trim || (Trim = {}));
// ------------------------------------------------------------------
// Const
// ------------------------------------------------------------------
/** Checks the value matches the next string  */
// prettier-ignore
function NextTokenCheck(value, code) {
    if (value.length > code.length)
        return false;
    for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) !== code.charCodeAt(i))
            return false;
    }
    return true;
}
/** Gets the next constant string value or empty if no match */
// prettier-ignore
function NextConst(value, code) {
    return NextTokenCheck(value, code)
        ? [code.slice(0, value.length), code.slice(value.length)]
        : [];
}
/** Takes the next constant string value skipping any whitespace */
// prettier-ignore
function Const(value, code) {
    if (value.length === 0)
        return ['', code];
    const char_0 = value.charCodeAt(0);
    return (Chars.IsNewline(char_0) ? NextConst(value, Trim.TrimWhitespaceOnly(code)) :
        Chars.IsWhitespace(char_0) ? NextConst(value, code) :
            NextConst(value, Trim.TrimAll(code)));
}
// ------------------------------------------------------------------
// Ident
// ------------------------------------------------------------------
// prettier-ignore
function IdentIsFirst(char) {
    return (Chars.IsAlpha(char) ||
        Chars.IsDollarSign(char) ||
        Chars.IsUnderscore(char));
}
// prettier-ignore
function IdentIsRest(char) {
    return (Chars.IsAlpha(char) ||
        Chars.IsDigit(char) ||
        Chars.IsDollarSign(char) ||
        Chars.IsUnderscore(char));
}
// prettier-ignore
function NextIdent(code) {
    if (!IdentIsFirst(code.charCodeAt(0)))
        return [];
    for (let i = 1; i < code.length; i++) {
        const char = code.charCodeAt(i);
        if (IdentIsRest(char))
            continue;
        const slice = code.slice(0, i);
        const rest = code.slice(i);
        return [slice, rest];
    }
    return [code, ''];
}
/** Scans for the next Ident token */
// prettier-ignore
function Ident(code) {
    return NextIdent(Trim.TrimAll(code));
}
// ------------------------------------------------------------------
// Number
// ------------------------------------------------------------------
/** Checks that the next number is not a leading zero */
// prettier-ignore
function NumberLeadingZeroCheck(code, index) {
    const char_0 = code.charCodeAt(index + 0);
    const char_1 = code.charCodeAt(index + 1);
    return ((
    // 1-9
    Chars.IsNonZero(char_0)) || (
    // 0
    Chars.IsZero(char_0) &&
        !Chars.IsDigit(char_1)) || (
    // 0.
    Chars.IsZero(char_0) &&
        Chars.IsDot(char_1)) || (
    // .0
    Chars.IsDot(char_0) &&
        Chars.IsDigit(char_1)));
}
/** Gets the next number token */
// prettier-ignore
function NextNumber(code) {
    const negated = code.charAt(0) === '-';
    const index = negated ? 1 : 0;
    if (!NumberLeadingZeroCheck(code, index)) {
        return [];
    }
    const dash = negated ? '-' : '';
    let hasDot = false;
    for (let i = index; i < code.length; i++) {
        const char_i = code.charCodeAt(i);
        if (Chars.IsDigit(char_i)) {
            continue;
        }
        if (Chars.IsDot(char_i)) {
            if (hasDot) {
                const slice = code.slice(index, i);
                const rest = code.slice(i);
                return [`${dash}${slice}`, rest];
            }
            hasDot = true;
            continue;
        }
        const slice = code.slice(index, i);
        const rest = code.slice(i);
        return [`${dash}${slice}`, rest];
    }
    return [code, ''];
}
/** Scans for the next number token */
// prettier-ignore
function Number(code) {
    return NextNumber(Trim.TrimAll(code));
}
// ------------------------------------------------------------------
// String
// ------------------------------------------------------------------
// prettier-ignore
function NextString(options, code) {
    const first = code.charAt(0);
    if (!options.includes(first))
        return [];
    const quote = first;
    for (let i = 1; i < code.length; i++) {
        const char = code.charAt(i);
        if (char === quote) {
            const slice = code.slice(1, i);
            const rest = code.slice(i + 1);
            return [slice, rest];
        }
    }
    return [];
}
/** Scans the next Literal String value */
// prettier-ignore
function String(options, code) {
    return NextString(options, Trim.TrimAll(code));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\types.d.ts

Code:
export type IModuleProperties = Record<PropertyKey, IParser>;
/** Force output static type evaluation for Arrays */
export type StaticEnsure<T> = T extends infer R ? R : never;
/** Infers the Output Parameter for a Parser */
export type StaticParser<Parser extends IParser> = Parser extends IParser<infer Output extends unknown> ? Output : unknown;
export type IMapping<Input extends unknown = any, Output extends unknown = unknown> = (input: Input, context: any) => Output;
/** Maps input to output. This is the default Mapping */
export declare const Identity: (value: unknown) => unknown;
/** Maps the output as the given parameter T */
export declare const As: <T>(mapping: T) => ((value: unknown) => T);
export interface IParser<Output extends unknown = unknown> {
    type: string;
    mapping: IMapping<any, Output>;
}
export type ContextParameter<_Left extends IParser, Right extends IParser> = (StaticParser<Right>);
export interface IContext<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Context';
    left: IParser;
    right: IParser;
}
/** `[Context]` Creates a Context Parser */
export declare function Context<Left extends IParser, Right extends IParser, Mapping extends IMapping = IMapping<ContextParameter<Left, Right>>>(left: Left, right: Right, mapping: Mapping): IContext<ReturnType<Mapping>>;
/** `[Context]` Creates a Context Parser */
export declare function Context<Left extends IParser, Right extends IParser>(left: Left, right: Right): IContext<ContextParameter<Left, Right>>;
export type ArrayParameter<Parser extends IParser> = StaticEnsure<StaticParser<Parser>[]>;
export interface IArray<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Array';
    parser: IParser;
}
/** `[EBNF]` Creates an Array Parser */
export declare function Array<Parser extends IParser, Mapping extends IMapping = IMapping<ArrayParameter<Parser>>>(parser: Parser, mapping: Mapping): IArray<ReturnType<Mapping>>;
/** `[EBNF]` Creates an Array Parser */
export declare function Array<Parser extends IParser>(parser: Parser): IArray<ArrayParameter<Parser>>;
export interface IConst<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Const';
    value: string;
}
/** `[TERM]` Creates a Const Parser */
export declare function Const<Value extends string, Mapping extends IMapping<Value>>(value: Value, mapping: Mapping): IConst<ReturnType<Mapping>>;
/** `[TERM]` Creates a Const Parser */
export declare function Const<Value extends string>(value: Value): IConst<Value>;
export interface IRef<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Ref';
    ref: string;
}
/** `[BNF]` Creates a Ref Parser. This Parser can only be used in the context of a Module */
export declare function Ref<Type extends unknown, Mapping extends IMapping<Type>>(ref: string, mapping: Mapping): IRef<ReturnType<Mapping>>;
/** `[BNF]` Creates a Ref Parser. This Parser can only be used in the context of a Module */
export declare function Ref<Type extends unknown>(ref: string): IRef<Type>;
export interface IString<Output extends unknown = unknown> extends IParser<Output> {
    type: 'String';
    options: string[];
}
/** `[TERM]` Creates a String Parser. Options are an array of permissable quote characters */
export declare function String<Mapping extends IMapping<string>>(options: string[], mapping: Mapping): IString<ReturnType<Mapping>>;
/** `[TERM]` Creates a String Parser. Options are an array of permissable quote characters */
export declare function String(options: string[]): IString<string>;
export interface IIdent<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Ident';
}
/** `[TERM]` Creates an Ident Parser where Ident matches any valid JavaScript identifier */
export declare function Ident<Mapping extends IMapping<string>>(mapping: Mapping): IIdent<ReturnType<Mapping>>;
/** `[TERM]` Creates an Ident Parser where Ident matches any valid JavaScript identifier */
export declare function Ident(): IIdent<string>;
export interface INumber<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Number';
}
/** `[TERM]` Creates an Number Parser */
export declare function Number<Mapping extends IMapping<string>>(mapping: Mapping): INumber<ReturnType<Mapping>>;
/** `[TERM]` Creates an Number Parser */
export declare function Number(): INumber<string>;
export type OptionalParameter<Parser extends IParser, Result extends unknown = [StaticParser<Parser>] | []> = (Result);
export interface IOptional<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Optional';
    parser: IParser;
}
/** `[EBNF]` Creates an Optional Parser */
export declare function Optional<Parser extends IParser, Mapping extends IMapping = IMapping<OptionalParameter<Parser>>>(parser: Parser, mapping: Mapping): IOptional<ReturnType<Mapping>>;
/** `[EBNF]` Creates an Optional Parser */
export declare function Optional<Parser extends IParser>(parser: Parser): IOptional<OptionalParameter<Parser>>;
export type TupleParameter<Parsers extends IParser[], Result extends unknown[] = []> = StaticEnsure<Parsers extends [infer Left extends IParser, ...infer Right extends IParser[]] ? TupleParameter<Right, [...Result, StaticEnsure<StaticParser<Left>>]> : Result>;
export interface ITuple<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Tuple';
    parsers: IParser[];
}
/** `[BNF]` Creates a Tuple Parser */
export declare function Tuple<Parsers extends IParser[], Mapping extends IMapping = IMapping<TupleParameter<Parsers>>>(parsers: [...Parsers], mapping: Mapping): ITuple<ReturnType<Mapping>>;
/** `[BNF]` Creates a Tuple Parser */
export declare function Tuple<Parsers extends IParser[]>(parsers: [...Parsers]): ITuple<TupleParameter<Parsers>>;
export type UnionParameter<Parsers extends IParser[], Result extends unknown = never> = StaticEnsure<Parsers extends [infer Left extends IParser, ...infer Right extends IParser[]] ? UnionParameter<Right, Result | StaticParser<Left>> : Result>;
export interface IUnion<Output extends unknown = unknown> extends IParser<Output> {
    type: 'Union';
    parsers: IParser[];
}
/** `[BNF]` Creates a Union parser */
export declare function Union<Parsers extends IParser[], Mapping extends IMapping = IMapping<UnionParameter<Parsers>>>(parsers: [...Parsers], mapping: Mapping): IUnion<ReturnType<Mapping>>;
/** `[BNF]` Creates a Union parser */
export declare function Union<Parsers extends IParser[]>(parsers: [...Parsers]): IUnion<UnionParameter<Parsers>>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\runtime\types.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.As = exports.Identity = void 0;
exports.Context = Context;
exports.Array = Array;
exports.Const = Const;
exports.Ref = Ref;
exports.String = String;
exports.Ident = Ident;
exports.Number = Number;
exports.Optional = Optional;
exports.Tuple = Tuple;
exports.Union = Union;
/** Maps input to output. This is the default Mapping */
const Identity = (value) => value;
exports.Identity = Identity;
/** Maps the output as the given parameter T */
// prettier-ignore
const As = (mapping) => (_) => mapping;
exports.As = As;
/** `[Context]` Creates a Context Parser */
function Context(...args) {
    const [left, right, mapping] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], args[1], exports.Identity];
    return { type: 'Context', left, right, mapping };
}
/** `[EBNF]` Creates an Array Parser */
function Array(...args) {
    const [parser, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Array', parser, mapping };
}
/** `[TERM]` Creates a Const Parser */
function Const(...args) {
    const [value, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Const', value, mapping };
}
/** `[BNF]` Creates a Ref Parser. This Parser can only be used in the context of a Module */
function Ref(...args) {
    const [ref, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Ref', ref, mapping };
}
/** `[TERM]` Creates a String Parser. Options are an array of permissable quote characters */
function String(...params) {
    const [options, mapping] = params.length === 2 ? [params[0], params[1]] : [params[0], exports.Identity];
    return { type: 'String', options, mapping };
}
/** `[TERM]` Creates an Ident Parser where Ident matches any valid JavaScript identifier */
function Ident(...params) {
    const mapping = params.length === 1 ? params[0] : exports.Identity;
    return { type: 'Ident', mapping };
}
/** `[TERM]` Creates an Number Parser */
function Number(...params) {
    const mapping = params.length === 1 ? params[0] : exports.Identity;
    return { type: 'Number', mapping };
}
/** `[EBNF]` Creates an Optional Parser */
function Optional(...args) {
    const [parser, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Optional', parser, mapping };
}
/** `[BNF]` Creates a Tuple Parser */
function Tuple(...args) {
    const [parsers, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Tuple', parsers, mapping };
}
/** `[BNF]` Creates a Union parser */
function Union(...args) {
    const [parsers, mapping] = args.length === 2 ? [args[0], args[1]] : [args[0], exports.Identity];
    return { type: 'Union', parsers, mapping };
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\index.d.ts

Code:
export * as Token from './token';
export * from './parse';
export * from './types';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
exports.Token = require("./token");
__exportStar(require("./parse"), exports);
__exportStar(require("./types"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\parse.d.ts

Code:
import * as Tokens from './token';
import * as Types from './types';
type ContextParser<Left extends Types.IParser, Right extends Types.IParser, Code extends string, Context extends unknown> = (Parse<Left, Code, Context> extends [infer Context extends unknown, infer Rest extends string] ? Parse<Right, Rest, Context> : []);
type ArrayParser<Parser extends Types.IParser, Code extends string, Context extends unknown, Result extends unknown[] = []> = (Parse<Parser, Code, Context> extends [infer Value1 extends unknown, infer Rest extends string] ? ArrayParser<Parser, Rest, Context, [...Result, Value1]> : [Result, Code]);
type ConstParser<Value extends string, Code extends string, _Context extends unknown> = (Tokens.Const<Value, Code> extends [infer Match extends Value, infer Rest extends string] ? [Match, Rest] : []);
type IdentParser<Code extends string, _Context extends unknown> = (Tokens.Ident<Code> extends [infer Match extends string, infer Rest extends string] ? [Match, Rest] : []);
type NumberParser<Code extends string, _Context extends unknown> = (Tokens.Number<Code> extends [infer Match extends string, infer Rest extends string] ? [Match, Rest] : []);
type OptionalParser<Parser extends Types.IParser, Code extends string, Context extends unknown> = (Parse<Parser, Code, Context> extends [infer Value extends unknown, infer Rest extends string] ? [[Value], Rest] : [[], Code]);
type StringParser<Options extends string[], Code extends string, _Context extends unknown> = (Tokens.String<Options, Code> extends [infer Match extends string, infer Rest extends string] ? [Match, Rest] : []);
type TupleParser<Parsers extends Types.IParser[], Code extends string, Context extends unknown, Result extends unknown[] = []> = (Parsers extends [infer Left extends Types.IParser, ...infer Right extends Types.IParser[]] ? Parse<Left, Code, Context> extends [infer Value extends unknown, infer Rest extends string] ? TupleParser<Right, Rest, Context, [...Result, Value]> : [] : [Result, Code]);
type UnionParser<Parsers extends Types.IParser[], Code extends string, Context extends unknown> = (Parsers extends [infer Left extends Types.IParser, ...infer Right extends Types.IParser[]] ? Parse<Left, Code, Context> extends [infer Value extends unknown, infer Rest extends string] ? [Value, Rest] : UnionParser<Right, Code, Context> : []);
type ParseCode<Type extends Types.IParser, Code extends string, Context extends unknown = unknown> = (Type extends Types.Context<infer Left extends Types.IParser, infer Right extends Types.IParser> ? ContextParser<Left, Right, Code, Context> : Type extends Types.Array<infer Parser extends Types.IParser> ? ArrayParser<Parser, Code, Context> : Type extends Types.Const<infer Value extends string> ? ConstParser<Value, Code, Context> : Type extends Types.Ident ? IdentParser<Code, Context> : Type extends Types.Number ? NumberParser<Code, Context> : Type extends Types.Optional<infer Parser extends Types.IParser> ? OptionalParser<Parser, Code, Context> : Type extends Types.String<infer Options extends string[]> ? StringParser<Options, Code, Context> : Type extends Types.Tuple<infer Parsers extends Types.IParser[]> ? TupleParser<Parsers, Code, Context> : Type extends Types.Union<infer Parsers extends Types.IParser[]> ? UnionParser<Parsers, Code, Context> : [
]);
type ParseMapping<Parser extends Types.IParser, Result extends unknown, Context extends unknown = unknown> = ((Parser['mapping'] & {
    input: Result;
    context: Context;
})['output']);
/** Parses code with the given parser */
export type Parse<Type extends Types.IParser, Code extends string, Context extends unknown = unknown> = (ParseCode<Type, Code, Context> extends [infer L extends unknown, infer R extends string] ? [ParseMapping<Type, L, Context>, R] : []);
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\parse.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\token.d.ts

Code:
declare namespace Chars {
    type Empty = '';
    type Space = ' ';
    type Newline = '\n';
    type Dot = '.';
    type Hyphen = '-';
    type Digit = [
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9'
    ];
    type Alpha = [
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z'
    ];
}
declare namespace Trim {
    type W4 = `${W3}${W3}`;
    type W3 = `${W2}${W2}`;
    type W2 = `${W1}${W1}`;
    type W1 = `${W0}${W0}`;
    type W0 = ` `;
    /** Trims whitespace only */
    export type TrimWhitespace<Code extends string> = (Code extends `${W4}${infer Rest extends string}` ? TrimWhitespace<Rest> : Code extends `${W3}${infer Rest extends string}` ? TrimWhitespace<Rest> : Code extends `${W1}${infer Rest extends string}` ? TrimWhitespace<Rest> : Code extends `${W0}${infer Rest extends string}` ? TrimWhitespace<Rest> : Code);
    /** Trims Whitespace and Newline */
    export type TrimAll<Code extends string> = (Code extends `${W4}${infer Rest extends string}` ? TrimAll<Rest> : Code extends `${W3}${infer Rest extends string}` ? TrimAll<Rest> : Code extends `${W1}${infer Rest extends string}` ? TrimAll<Rest> : Code extends `${W0}${infer Rest extends string}` ? TrimAll<Rest> : Code extends `${Chars.Newline}${infer Rest extends string}` ? TrimAll<Rest> : Code);
    export {};
}
/** Scans for the next match union */
type NextUnion<Variants extends string[], Code extends string> = (Variants extends [infer Variant extends string, ...infer Rest1 extends string[]] ? NextConst<Variant, Code> extends [infer Match extends string, infer Rest2 extends string] ? [Match, Rest2] : NextUnion<Rest1, Code> : []);
type NextConst<Value extends string, Code extends string> = (Code extends `${Value}${infer Rest extends string}` ? [Value, Rest] : []);
/** Scans for the next constant value */
export type Const<Value extends string, Code extends string> = (Value extends '' ? ['', Code] : Value extends `${infer First extends string}${string}` ? (First extends Chars.Newline ? NextConst<Value, Trim.TrimWhitespace<Code>> : First extends Chars.Space ? NextConst<Value, Code> : NextConst<Value, Trim.TrimAll<Code>>) : never);
type NextNumberNegate<Code extends string> = (Code extends `${Chars.Hyphen}${infer Rest extends string}` ? [Chars.Hyphen, Rest] : [Chars.Empty, Code]);
type NextNumberZeroCheck<Code extends string> = (Code extends `0${infer Rest}` ? NextUnion<Chars.Digit, Rest> extends [string, string] ? false : true : true);
type NextNumberScan<Code extends string, HasDecimal extends boolean = false, Result extends string = Chars.Empty> = (NextUnion<[...Chars.Digit, Chars.Dot], Code> extends [infer Char extends string, infer Rest extends string] ? Char extends Chars.Dot ? HasDecimal extends false ? NextNumberScan<Rest, true, `${Result}${Char}`> : [Result, `.${Rest}`] : NextNumberScan<Rest, HasDecimal, `${Result}${Char}`> : [Result, Code]);
export type NextNumber<Code extends string> = (NextNumberNegate<Code> extends [infer Negate extends string, infer Rest extends string] ? NextNumberZeroCheck<Rest> extends true ? NextNumberScan<Rest> extends [infer Number extends string, infer Rest2 extends string] ? Number extends Chars.Empty ? [] : [`${Negate}${Number}`, Rest2] : [] : [] : []);
/** Scans for the next literal number */
export type Number<Code extends string> = NextNumber<Trim.TrimAll<Code>>;
type NextStringQuote<Options extends string[], Code extends string> = NextUnion<Options, Code>;
type NextStringBody<Code extends string, Quote extends string, Result extends string = Chars.Empty> = (Code extends `${infer Char extends string}${infer Rest extends string}` ? Char extends Quote ? [Result, Rest] : NextStringBody<Rest, Quote, `${Result}${Char}`> : []);
type NextString<Options extends string[], Code extends string> = (NextStringQuote<Options, Code> extends [infer Quote extends string, infer Rest extends string] ? NextStringBody<Rest, Quote> extends [infer String extends string, infer Rest extends string] ? [String, Rest] : [] : []);
/** Scans for the next literal string */
export type String<Options extends string[], Code extends string> = NextString<Options, Trim.TrimAll<Code>>;
type IdentLeft = [...Chars.Alpha, '_', '$'];
type IdentRight = [...Chars.Digit, ...IdentLeft];
type NextIdentScan<Code extends string, Result extends string = Chars.Empty> = (NextUnion<IdentRight, Code> extends [infer Char extends string, infer Rest extends string] ? NextIdentScan<Rest, `${Result}${Char}`> : [Result, Code]);
type NextIdent<Code extends string> = (NextUnion<IdentLeft, Code> extends [infer Left extends string, infer Rest1 extends string] ? NextIdentScan<Rest1> extends [infer Right extends string, infer Rest2 extends string] ? [`${Left}${Right}`, Rest2] : [] : []);
/** Scans for the next Ident */
export type Ident<Code extends string> = NextIdent<Trim.TrimAll<Code>>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\token.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\types.d.ts

Code:
/**
 * `[ACTION]` Inference mapping base type. Used to specify semantic actions for
 * Parser productions. This type is implemented as a higher-kinded type where
 * productions are received on the `input` property with mapping assigned
 * the `output` property. The parsing context is available on the `context`
 * property.
 */
export interface IMapping {
    context: unknown;
    input: unknown;
    output: unknown;
}
/** `[ACTION]` Default inference mapping. */
export interface Identity extends IMapping {
    output: this['input'];
}
/** `[ACTION]` Maps the given argument `T` as the mapping output */
export interface As<T> extends IMapping {
    output: T;
}
/** Base type Parser implemented by all other parsers */
export interface IParser<Mapping extends IMapping = Identity> {
    type: string;
    mapping: Mapping;
}
/** `[Context]` Creates a Context Parser */
export interface Context<Left extends IParser = IParser, Right extends IParser = IParser, Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Context';
    left: Left;
    right: Right;
}
/** `[EBNF]` Creates an Array Parser */
export interface Array<Parser extends IParser = IParser, Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Array';
    parser: Parser;
}
/** `[TERM]` Creates a Const Parser */
export interface Const<Value extends string = string, Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Const';
    value: Value;
}
/** `[TERM]` Creates an Ident Parser. */
export interface Ident<Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Ident';
}
/** `[TERM]` Creates a Number Parser. */
export interface Number<Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Number';
}
/** `[EBNF]` Creates a Optional Parser */
export interface Optional<Parser extends IParser = IParser, Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Optional';
    parser: Parser;
}
/** `[TERM]` Creates a String Parser. Options are an array of permissable quote characters */
export interface String<Options extends string[], Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'String';
    quote: Options;
}
/** `[BNF]` Creates a Tuple Parser */
export interface Tuple<Parsers extends IParser[] = [], Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Tuple';
    parsers: [...Parsers];
}
/** `[BNF]` Creates a Union Parser */
export interface Union<Parsers extends IParser[] = [], Mapping extends IMapping = Identity> extends IParser<Mapping> {
    type: 'Union';
    parsers: [...Parsers];
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\parser\static\types.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\index.d.ts

Code:
export * from './syntax';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./syntax"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\mapping.d.ts

Code:
import * as T from '../type/index';
type TDereference<Context extends T.TProperties, Key extends string> = (Key extends keyof Context ? Context[Key] : T.TRef<Key>);
type TDelimitedDecode<Input extends ([unknown, unknown] | unknown)[], Result extends unknown[] = []> = (Input extends [infer Left, ...infer Right] ? Left extends [infer Item, infer _] ? TDelimitedDecode<Right, [...Result, Item]> : TDelimitedDecode<Right, [...Result, Left]> : Result);
type TDelimited<Input extends [unknown, unknown]> = Input extends [infer Left extends unknown[], infer Right extends unknown[]] ? TDelimitedDecode<[...Left, ...Right]> : [];
export type TGenericReferenceParameterListMapping<Input extends [unknown, unknown], Context extends T.TProperties> = TDelimited<Input>;
export declare function GenericReferenceParameterListMapping(input: [unknown, unknown], context: unknown): unknown[];
export type TGenericReferenceMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties, Result = Context extends T.TProperties ? Input extends [infer Reference extends string, '<', infer Args extends T.TSchema[], '>'] ? T.TInstantiate<TDereference<Context, Reference>, Args> : never : never> = Result;
export declare function GenericReferenceMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TGenericArgumentsListMapping<Input extends [unknown, unknown], Context extends T.TProperties> = TDelimited<Input>;
export declare function GenericArgumentsListMapping(input: [unknown, unknown], context: unknown): unknown[];
type GenericArgumentsContext<Arguments extends string[], Context extends T.TProperties, Result extends T.TProperties = {}> = (Arguments extends [...infer Left extends string[], infer Right extends string] ? GenericArgumentsContext<Left, Context, Result & {
    [_ in Right]: T.TArgument<Left['length']>;
}> : T.Evaluate<Result & Context>);
export type TGenericArgumentsMapping<Input extends [unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['<', infer Arguments extends string[], '>'] ? Context extends infer Context extends T.TProperties ? GenericArgumentsContext<Arguments, Context> : never : never;
declare const GenericArgumentsContext: (_arguments: string[], context: T.TProperties) => T.TProperties;
export declare function GenericArgumentsMapping(input: [unknown, unknown, unknown], context: unknown): T.TProperties;
export type TKeywordStringMapping<Input extends 'string', Context extends T.TProperties> = T.TString;
export declare function KeywordStringMapping(input: 'string', context: unknown): T.TString;
export type TKeywordNumberMapping<Input extends 'number', Context extends T.TProperties> = T.TNumber;
export declare function KeywordNumberMapping(input: 'number', context: unknown): T.TNumber;
export type TKeywordBooleanMapping<Input extends 'boolean', Context extends T.TProperties> = T.TBoolean;
export declare function KeywordBooleanMapping(input: 'boolean', context: unknown): T.TBoolean;
export type TKeywordUndefinedMapping<Input extends 'undefined', Context extends T.TProperties> = T.TUndefined;
export declare function KeywordUndefinedMapping(input: 'undefined', context: unknown): T.TUndefined;
export type TKeywordNullMapping<Input extends 'null', Context extends T.TProperties> = T.TNull;
export declare function KeywordNullMapping(input: 'null', context: unknown): T.TNull;
export type TKeywordIntegerMapping<Input extends 'integer', Context extends T.TProperties> = T.TInteger;
export declare function KeywordIntegerMapping(input: 'integer', context: unknown): T.TInteger;
export type TKeywordBigIntMapping<Input extends 'bigint', Context extends T.TProperties> = T.TBigInt;
export declare function KeywordBigIntMapping(input: 'bigint', context: unknown): T.TBigInt;
export type TKeywordUnknownMapping<Input extends 'unknown', Context extends T.TProperties> = T.TUnknown;
export declare function KeywordUnknownMapping(input: 'unknown', context: unknown): T.TUnknown;
export type TKeywordAnyMapping<Input extends 'any', Context extends T.TProperties> = T.TAny;
export declare function KeywordAnyMapping(input: 'any', context: unknown): T.TAny;
export type TKeywordNeverMapping<Input extends 'never', Context extends T.TProperties> = T.TNever;
export declare function KeywordNeverMapping(input: 'never', context: unknown): T.TNever;
export type TKeywordSymbolMapping<Input extends 'symbol', Context extends T.TProperties> = T.TSymbol;
export declare function KeywordSymbolMapping(input: 'symbol', context: unknown): T.TSymbol;
export type TKeywordVoidMapping<Input extends 'void', Context extends T.TProperties> = T.TVoid;
export declare function KeywordVoidMapping(input: 'void', context: unknown): T.TVoid;
export type TKeywordMapping<Input extends unknown, Context extends T.TProperties> = Input;
export declare function KeywordMapping(input: unknown, context: unknown): unknown;
export type TLiteralStringMapping<Input extends string, Context extends T.TProperties> = Input extends T.TLiteralValue ? T.TLiteral<Input> : never;
export declare function LiteralStringMapping(input: string, context: unknown): T.TLiteral<string>;
export type TLiteralNumberMapping<Input extends string, Context extends T.TProperties> = Input extends `${infer Value extends number}` ? T.TLiteral<Value> : never;
export declare function LiteralNumberMapping(input: string, context: unknown): T.TLiteral<number>;
export type TLiteralBooleanMapping<Input extends 'true' | 'false', Context extends T.TProperties> = Input extends 'true' ? T.TLiteral<true> : T.TLiteral<false>;
export declare function LiteralBooleanMapping(input: 'true' | 'false', context: unknown): T.TLiteral<boolean>;
export type TLiteralMapping<Input extends unknown, Context extends T.TProperties> = Input;
export declare function LiteralMapping(input: unknown, context: unknown): unknown;
export type TKeyOfMapping<Input extends [unknown] | [], Context extends T.TProperties> = Input extends [unknown] ? true : false;
export declare function KeyOfMapping(input: [unknown] | [], context: unknown): boolean;
type TIndexArrayMappingReduce<Input extends unknown[], Result extends unknown[] = []> = (Input extends [infer Left extends unknown, ...infer Right extends unknown[]] ? Left extends ['[', infer Type extends T.TSchema, ']'] ? TIndexArrayMappingReduce<Right, [...Result, [Type]]> : TIndexArrayMappingReduce<Right, [...Result, []]> : Result);
export type TIndexArrayMapping<Input extends ([unknown, unknown, unknown] | [unknown, unknown])[], Context extends T.TProperties> = Input extends unknown[] ? TIndexArrayMappingReduce<Input> : [];
export declare function IndexArrayMapping(input: ([unknown, unknown, unknown] | [unknown, unknown])[], context: unknown): unknown[];
export type TExtendsMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown] | [], Context extends T.TProperties> = Input extends ['extends', infer Type extends T.TSchema, '?', infer True extends T.TSchema, ':', infer False extends T.TSchema] ? [Type, True, False] : [];
export declare function ExtendsMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown] | [], context: unknown): unknown[];
export type TBaseMapping<Input extends [unknown, unknown, unknown] | unknown, Context extends T.TProperties> = (Input extends ['(', infer Type extends T.TSchema, ')'] ? Type : Input extends infer Type extends T.TSchema ? Type : never);
export declare function BaseMapping(input: [unknown, unknown, unknown] | unknown, context: unknown): unknown;
type TFactorIndexArray<Type extends T.TSchema, IndexArray extends unknown[]> = (IndexArray extends [...infer Left extends unknown[], infer Right extends T.TSchema[]] ? (Right extends [infer Indexer extends T.TSchema] ? T.TIndex<TFactorIndexArray<Type, Left>, T.TIndexPropertyKeys<Indexer>> : Right extends [] ? T.TArray<TFactorIndexArray<Type, Left>> : T.TNever) : Type);
type TFactorExtends<Type extends T.TSchema, Extends extends unknown[]> = (Extends extends [infer Right extends T.TSchema, infer True extends T.TSchema, infer False extends T.TSchema] ? T.TExtends<Type, Right, True, False> : Type);
export type TFactorMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends [infer KeyOf extends boolean, infer Type extends T.TSchema, infer IndexArray extends unknown[], infer Extends extends unknown[]] ? KeyOf extends true ? TFactorExtends<T.TKeyOf<TFactorIndexArray<Type, IndexArray>>, Extends> : TFactorExtends<TFactorIndexArray<Type, IndexArray>, Extends> : never;
export declare function FactorMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
type TExprBinaryMapping<Left extends T.TSchema, Rest extends unknown[]> = (Rest extends [infer Operator extends unknown, infer Right extends T.TSchema, infer Next extends unknown[]] ? (TExprBinaryMapping<Right, Next> extends infer Schema extends T.TSchema ? (Operator extends '&' ? (Schema extends T.TIntersect<infer Types extends T.TSchema[]> ? T.TIntersect<[Left, ...Types]> : T.TIntersect<[Left, Schema]>) : Operator extends '|' ? (Schema extends T.TUnion<infer Types extends T.TSchema[]> ? T.TUnion<[Left, ...Types]> : T.TUnion<[Left, Schema]>) : never) : never) : Left);
export type TExprTermTailMapping<Input extends [unknown, unknown, unknown] | [], Context extends T.TProperties> = Input;
export declare function ExprTermTailMapping(input: [unknown, unknown, unknown] | [], context: unknown): [] | [unknown, unknown, unknown];
export type TExprTermMapping<Input extends [unknown, unknown], Context extends T.TProperties> = (Input extends [infer Left extends T.TSchema, infer Rest extends unknown[]] ? TExprBinaryMapping<Left, Rest> : []);
export declare function ExprTermMapping(input: [unknown, unknown], context: unknown): T.TSchema;
export type TExprTailMapping<Input extends [unknown, unknown, unknown] | [], Context extends T.TProperties> = Input;
export declare function ExprTailMapping(input: [unknown, unknown, unknown] | [], context: unknown): [] | [unknown, unknown, unknown];
export type TExprMapping<Input extends [unknown, unknown], Context extends T.TProperties> = Input extends [infer Left extends T.TSchema, infer Rest extends unknown[]] ? TExprBinaryMapping<Left, Rest> : [];
export declare function ExprMapping(input: [unknown, unknown], context: unknown): T.TSchema;
export type TTypeMapping<Input extends unknown, Context extends T.TProperties> = Input;
export declare function TypeMapping(input: unknown, context: unknown): unknown;
export type TPropertyKeyMapping<Input extends string, Context extends T.TProperties> = Input;
export declare function PropertyKeyMapping(input: string, context: unknown): string;
export type TReadonlyMapping<Input extends [unknown] | [], Context extends T.TProperties> = Input extends [unknown] ? true : false;
export declare function ReadonlyMapping(input: [unknown] | [], context: unknown): boolean;
export type TOptionalMapping<Input extends [unknown] | [], Context extends T.TProperties> = Input extends [unknown] ? true : false;
export declare function OptionalMapping(input: [unknown] | [], context: unknown): boolean;
export type TPropertyMapping<Input extends [unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends [infer IsReadonly extends boolean, infer Key extends string, infer IsOptional extends boolean, string, infer Type extends T.TSchema] ? {
    [_ in Key]: ([
        IsReadonly,
        IsOptional
    ] extends [true, true] ? T.TReadonlyOptional<Type> : [
        IsReadonly,
        IsOptional
    ] extends [true, false] ? T.TReadonly<Type> : [
        IsReadonly,
        IsOptional
    ] extends [false, true] ? T.TOptional<Type> : Type);
} : never;
export declare function PropertyMapping(input: [unknown, unknown, unknown, unknown, unknown], context: unknown): {
    [x: string]: T.TSchema;
};
export type TPropertyDelimiterMapping<Input extends [unknown, unknown] | [unknown], Context extends T.TProperties> = Input;
export declare function PropertyDelimiterMapping(input: [unknown, unknown] | [unknown], context: unknown): [unknown] | [unknown, unknown];
export type TPropertyListMapping<Input extends [unknown, unknown], Context extends T.TProperties> = TDelimited<Input>;
export declare function PropertyListMapping(input: [unknown, unknown], context: unknown): unknown[];
type TObjectMappingReduce<PropertiesList extends T.TProperties[], Result extends T.TProperties = {}> = (PropertiesList extends [infer Left extends T.TProperties, ...infer Right extends T.TProperties[]] ? TObjectMappingReduce<Right, Result & Left> : {
    [Key in keyof Result]: Result[Key];
});
export type TObjectMapping<Input extends [unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['{', infer PropertyList extends T.TProperties[], '}'] ? T.TObject<TObjectMappingReduce<PropertyList>> : never;
export declare function ObjectMapping(input: [unknown, unknown, unknown], context: unknown): T.TObject<T.TProperties>;
export type TElementListMapping<Input extends [unknown, unknown], Context extends T.TProperties> = TDelimited<Input>;
export declare function ElementListMapping(input: [unknown, unknown], context: unknown): unknown[];
export type TTupleMapping<Input extends [unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['[', infer Types extends T.TSchema[], ']'] ? T.TTuple<Types> : never;
export declare function TupleMapping(input: [unknown, unknown, unknown], context: unknown): T.TTuple<T.TSchema[]>;
export type TParameterMapping<Input extends [unknown, unknown, unknown], Context extends T.TProperties> = Input extends [string, ':', infer Type extends T.TSchema] ? Type : never;
export declare function ParameterMapping(input: [unknown, unknown, unknown], context: unknown): T.TSchema;
export type TParameterListMapping<Input extends [unknown, unknown], Context extends T.TProperties> = TDelimited<Input>;
export declare function ParameterListMapping(input: [unknown, unknown], context: unknown): unknown[];
export type TFunctionMapping<Input extends [unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['(', infer ParameterList extends T.TSchema[], ')', '=>', infer ReturnType extends T.TSchema] ? T.TFunction<ParameterList, ReturnType> : never;
export declare function FunctionMapping(input: [unknown, unknown, unknown, unknown, unknown], context: unknown): T.TFunction<T.TSchema[], T.TSchema>;
export type TConstructorMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['new', '(', infer ParameterList extends T.TSchema[], ')', '=>', infer InstanceType extends T.TSchema] ? T.TConstructor<ParameterList, InstanceType> : never;
export declare function ConstructorMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TConstructor<T.TSchema[], T.TSchema>;
export type TMappedMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['{', '[', infer _Key extends string, 'in', infer _Right extends T.TSchema, ']', ':', infer _Type extends T.TSchema, '}'] ? T.TLiteral<'Mapped types not supported'> : never;
export declare function MappedMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TLiteral<"Mapped types not supported">;
export type TAsyncIteratorMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['AsyncIterator', '<', infer Type extends T.TSchema, '>'] ? T.TAsyncIterator<Type> : never;
export declare function AsyncIteratorMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TAsyncIterator<T.TSchema>;
export type TIteratorMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Iterator', '<', infer Type extends T.TSchema, '>'] ? T.TIterator<Type> : never;
export declare function IteratorMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TIterator<T.TSchema>;
export type TArgumentMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Argument', '<', infer Type extends T.TSchema, '>'] ? Type extends T.TLiteral<infer Index extends number> ? T.TArgument<Index> : T.TNever : never;
export declare function ArgumentMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TNever | T.TArgument<number>;
export type TAwaitedMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Awaited', '<', infer Type extends T.TSchema, '>'] ? T.TAwaited<Type> : never;
export declare function AwaitedMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TArrayMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Array', '<', infer Type extends T.TSchema, '>'] ? T.TArray<Type> : never;
export declare function ArrayMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TArray<T.TSchema>;
export type TRecordMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Record', '<', infer Key extends T.TSchema, ',', infer Type extends T.TSchema, '>'] ? T.TRecordOrObject<Key, Type> : never;
export declare function RecordMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TPromiseMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Promise', '<', infer Type extends T.TSchema, '>'] ? T.TPromise<Type> : never;
export declare function PromiseMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TPromise<T.TSchema>;
export type TConstructorParametersMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['ConstructorParameters', '<', infer Type extends T.TSchema, '>'] ? T.TConstructorParameters<Type> : never;
export declare function ConstructorParametersMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TFunctionParametersMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Parameters', '<', infer Type extends T.TSchema, '>'] ? T.TParameters<Type> : never;
export declare function FunctionParametersMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TInstanceTypeMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['InstanceType', '<', infer Type extends T.TSchema, '>'] ? T.TInstanceType<Type> : never;
export declare function InstanceTypeMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TReturnTypeMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['ReturnType', '<', infer Type extends T.TSchema, '>'] ? T.TReturnType<Type> : never;
export declare function ReturnTypeMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TPartialMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Partial', '<', infer Type extends T.TSchema, '>'] ? T.TPartial<Type> : never;
export declare function PartialMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TObject<{}>;
export type TRequiredMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Required', '<', infer Type extends T.TSchema, '>'] ? T.TRequired<Type> : never;
export declare function RequiredMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TObject<{}>;
export type TPickMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Pick', '<', infer Type extends T.TSchema, ',', infer Key extends T.TSchema, '>'] ? T.TPick<Type, Key> : never;
export declare function PickMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TObject<{}>;
export type TOmitMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Omit', '<', infer Type extends T.TSchema, ',', infer Key extends T.TSchema, '>'] ? T.TOmit<Type, Key> : never;
export declare function OmitMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TObject<{}>;
export type TExcludeMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Exclude', '<', infer Type extends T.TSchema, ',', infer Key extends T.TSchema, '>'] ? T.TExclude<Type, Key> : never;
export declare function ExcludeMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TNever;
export type TExtractMapping<Input extends [unknown, unknown, unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Extract', '<', infer Type extends T.TSchema, ',', infer Key extends T.TSchema, '>'] ? T.TExtract<Type, Key> : never;
export declare function ExtractMapping(input: [unknown, unknown, unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TUppercaseMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Uppercase', '<', infer Type extends T.TSchema, '>'] ? T.TUppercase<Type> : never;
export declare function UppercaseMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TLowercaseMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Lowercase', '<', infer Type extends T.TSchema, '>'] ? T.TLowercase<Type> : never;
export declare function LowercaseMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TCapitalizeMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Capitalize', '<', infer Type extends T.TSchema, '>'] ? T.TCapitalize<Type> : never;
export declare function CapitalizeMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TUncapitalizeMapping<Input extends [unknown, unknown, unknown, unknown], Context extends T.TProperties> = Input extends ['Uncapitalize', '<', infer Type extends T.TSchema, '>'] ? T.TUncapitalize<Type> : never;
export declare function UncapitalizeMapping(input: [unknown, unknown, unknown, unknown], context: unknown): T.TSchema;
export type TDateMapping<Input extends 'Date', Context extends T.TProperties> = T.TDate;
export declare function DateMapping(input: 'Date', context: unknown): T.TDate;
export type TUint8ArrayMapping<Input extends 'Uint8Array', Context extends T.TProperties> = T.TUint8Array;
export declare function Uint8ArrayMapping(input: 'Uint8Array', context: unknown): T.TUint8Array;
export type TReferenceMapping<Input extends string, Context extends T.TProperties> = Context extends T.TProperties ? Input extends string ? TDereference<Context, Input> : never : never;
export declare function ReferenceMapping(input: string, context: unknown): T.TSchema;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\mapping.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericReferenceParameterListMapping = GenericReferenceParameterListMapping;
exports.GenericReferenceMapping = GenericReferenceMapping;
exports.GenericArgumentsListMapping = GenericArgumentsListMapping;
exports.GenericArgumentsMapping = GenericArgumentsMapping;
exports.KeywordStringMapping = KeywordStringMapping;
exports.KeywordNumberMapping = KeywordNumberMapping;
exports.KeywordBooleanMapping = KeywordBooleanMapping;
exports.KeywordUndefinedMapping = KeywordUndefinedMapping;
exports.KeywordNullMapping = KeywordNullMapping;
exports.KeywordIntegerMapping = KeywordIntegerMapping;
exports.KeywordBigIntMapping = KeywordBigIntMapping;
exports.KeywordUnknownMapping = KeywordUnknownMapping;
exports.KeywordAnyMapping = KeywordAnyMapping;
exports.KeywordNeverMapping = KeywordNeverMapping;
exports.KeywordSymbolMapping = KeywordSymbolMapping;
exports.KeywordVoidMapping = KeywordVoidMapping;
exports.KeywordMapping = KeywordMapping;
exports.LiteralStringMapping = LiteralStringMapping;
exports.LiteralNumberMapping = LiteralNumberMapping;
exports.LiteralBooleanMapping = LiteralBooleanMapping;
exports.LiteralMapping = LiteralMapping;
exports.KeyOfMapping = KeyOfMapping;
exports.IndexArrayMapping = IndexArrayMapping;
exports.ExtendsMapping = ExtendsMapping;
exports.BaseMapping = BaseMapping;
exports.FactorMapping = FactorMapping;
exports.ExprTermTailMapping = ExprTermTailMapping;
exports.ExprTermMapping = ExprTermMapping;
exports.ExprTailMapping = ExprTailMapping;
exports.ExprMapping = ExprMapping;
exports.TypeMapping = TypeMapping;
exports.PropertyKeyMapping = PropertyKeyMapping;
exports.ReadonlyMapping = ReadonlyMapping;
exports.OptionalMapping = OptionalMapping;
exports.PropertyMapping = PropertyMapping;
exports.PropertyDelimiterMapping = PropertyDelimiterMapping;
exports.PropertyListMapping = PropertyListMapping;
exports.ObjectMapping = ObjectMapping;
exports.ElementListMapping = ElementListMapping;
exports.TupleMapping = TupleMapping;
exports.ParameterMapping = ParameterMapping;
exports.ParameterListMapping = ParameterListMapping;
exports.FunctionMapping = FunctionMapping;
exports.ConstructorMapping = ConstructorMapping;
exports.MappedMapping = MappedMapping;
exports.AsyncIteratorMapping = AsyncIteratorMapping;
exports.IteratorMapping = IteratorMapping;
exports.ArgumentMapping = ArgumentMapping;
exports.AwaitedMapping = AwaitedMapping;
exports.ArrayMapping = ArrayMapping;
exports.RecordMapping = RecordMapping;
exports.PromiseMapping = PromiseMapping;
exports.ConstructorParametersMapping = ConstructorParametersMapping;
exports.FunctionParametersMapping = FunctionParametersMapping;
exports.InstanceTypeMapping = InstanceTypeMapping;
exports.ReturnTypeMapping = ReturnTypeMapping;
exports.PartialMapping = PartialMapping;
exports.RequiredMapping = RequiredMapping;
exports.PickMapping = PickMapping;
exports.OmitMapping = OmitMapping;
exports.ExcludeMapping = ExcludeMapping;
exports.ExtractMapping = ExtractMapping;
exports.UppercaseMapping = UppercaseMapping;
exports.LowercaseMapping = LowercaseMapping;
exports.CapitalizeMapping = CapitalizeMapping;
exports.UncapitalizeMapping = UncapitalizeMapping;
exports.DateMapping = DateMapping;
exports.Uint8ArrayMapping = Uint8ArrayMapping;
exports.ReferenceMapping = ReferenceMapping;
const T = require("../type/index");
// prettier-ignore
const Dereference = (context, key) => {
    return key in context ? context[key] : T.Ref(key);
};
// prettier-ignore
const DelimitedDecode = (input, result = []) => {
    return input.reduce((result, left) => {
        return T.ValueGuard.IsArray(left) && left.length === 2
            ? [...result, left[0]]
            : [...result, left];
    }, []);
};
// prettier-ignore
const Delimited = (input) => {
    const [left, right] = input;
    return DelimitedDecode([...left, ...right]);
};
// prettier-ignore
function GenericReferenceParameterListMapping(input, context) {
    return Delimited(input);
}
// prettier-ignore
function GenericReferenceMapping(input, context) {
    const type = Dereference(context, input[0]);
    const args = input[2];
    return T.Instantiate(type, args);
}
// prettier-ignore
function GenericArgumentsListMapping(input, context) {
    return Delimited(input);
}
// ...
// prettier-ignore
const GenericArgumentsContext = (_arguments, context) => {
    return _arguments.reduce((result, arg, index) => {
        return { ...result, [arg]: T.Argument(index) };
    }, context);
};
// prettier-ignore
function GenericArgumentsMapping(input, context) {
    return input.length === 3
        ? GenericArgumentsContext(input[1], context)
        : {};
}
// prettier-ignore
function KeywordStringMapping(input, context) {
    return T.String();
}
// prettier-ignore
function KeywordNumberMapping(input, context) {
    return T.Number();
}
// prettier-ignore
function KeywordBooleanMapping(input, context) {
    return T.Boolean();
}
// prettier-ignore
function KeywordUndefinedMapping(input, context) {
    return T.Undefined();
}
// prettier-ignore
function KeywordNullMapping(input, context) {
    return T.Null();
}
// prettier-ignore
function KeywordIntegerMapping(input, context) {
    return T.Integer();
}
// prettier-ignore
function KeywordBigIntMapping(input, context) {
    return T.BigInt();
}
// prettier-ignore
function KeywordUnknownMapping(input, context) {
    return T.Unknown();
}
// prettier-ignore
function KeywordAnyMapping(input, context) {
    return T.Any();
}
// prettier-ignore
function KeywordNeverMapping(input, context) {
    return T.Never();
}
// prettier-ignore
function KeywordSymbolMapping(input, context) {
    return T.Symbol();
}
// prettier-ignore
function KeywordVoidMapping(input, context) {
    return T.Void();
}
// prettier-ignore
function KeywordMapping(input, context) {
    return input;
}
// prettier-ignore
function LiteralStringMapping(input, context) {
    return T.Literal(input);
}
// prettier-ignore
function LiteralNumberMapping(input, context) {
    return T.Literal(parseFloat(input));
}
// prettier-ignore
function LiteralBooleanMapping(input, context) {
    return T.Literal(input === 'true');
}
// prettier-ignore
function LiteralMapping(input, context) {
    return input;
}
// prettier-ignore
function KeyOfMapping(input, context) {
    return input.length > 0;
}
// prettier-ignore
function IndexArrayMapping(input, context) {
    return input.reduce((result, current) => {
        return current.length === 3
            ? [...result, [current[1]]]
            : [...result, []];
    }, []);
}
// prettier-ignore
function ExtendsMapping(input, context) {
    return input.length === 6
        ? [input[1], input[3], input[5]]
        : [];
}
// prettier-ignore
function BaseMapping(input, context) {
    return T.ValueGuard.IsArray(input) && input.length === 3 ? input[1] : input;
}
// ...
// prettier-ignore
const FactorIndexArray = (Type, indexArray) => {
    return indexArray.reduceRight((result, right) => {
        const _right = right;
        return (_right.length === 1 ? T.Index(result, _right[0]) :
            _right.length === 0 ? T.Array(result, _right[0]) :
                T.Never());
    }, Type);
};
// prettier-ignore
const FactorExtends = (Type, Extends) => {
    return Extends.length === 3
        ? T.Extends(Type, Extends[0], Extends[1], Extends[2])
        : Type;
};
// prettier-ignore
function FactorMapping(input, context) {
    const [KeyOf, Type, IndexArray, Extends] = input;
    return KeyOf
        ? FactorExtends(T.KeyOf(FactorIndexArray(Type, IndexArray)), Extends)
        : FactorExtends(FactorIndexArray(Type, IndexArray), Extends);
}
// prettier-ignore
function ExprBinaryMapping(Left, Rest) {
    return (Rest.length === 3 ? (() => {
        const [Operator, Right, Next] = Rest;
        const Schema = ExprBinaryMapping(Right, Next);
        if (Operator === '&') {
            return T.TypeGuard.IsIntersect(Schema)
                ? T.Intersect([Left, ...Schema.allOf])
                : T.Intersect([Left, Schema]);
        }
        if (Operator === '|') {
            return T.TypeGuard.IsUnion(Schema)
                ? T.Union([Left, ...Schema.anyOf])
                : T.Union([Left, Schema]);
        }
        throw 1;
    })() : Left);
}
// prettier-ignore
function ExprTermTailMapping(input, context) {
    return input;
}
// prettier-ignore
function ExprTermMapping(input, context) {
    const [left, rest] = input;
    return ExprBinaryMapping(left, rest);
}
// prettier-ignore
function ExprTailMapping(input, context) {
    return input;
}
// prettier-ignore
function ExprMapping(input, context) {
    const [left, rest] = input;
    return ExprBinaryMapping(left, rest);
}
// prettier-ignore
function TypeMapping(input, context) {
    return input;
}
// prettier-ignore
function PropertyKeyMapping(input, context) {
    return input;
}
// prettier-ignore
function ReadonlyMapping(input, context) {
    return input.length > 0;
}
// prettier-ignore
function OptionalMapping(input, context) {
    return input.length > 0;
}
// prettier-ignore
function PropertyMapping(input, context) {
    const [isReadonly, key, isOptional, _colon, type] = input;
    return {
        [key]: (isReadonly && isOptional ? T.ReadonlyOptional(type) :
            isReadonly && !isOptional ? T.Readonly(type) :
                !isReadonly && isOptional ? T.Optional(type) :
                    type)
    };
}
// prettier-ignore
function PropertyDelimiterMapping(input, context) {
    return input;
}
// prettier-ignore
function PropertyListMapping(input, context) {
    return Delimited(input);
}
// prettier-ignore
function ObjectMapping(input, context) {
    const propertyList = input[1];
    return T.Object(propertyList.reduce((result, property) => {
        return { ...result, ...property };
    }, {}));
}
// prettier-ignore
function ElementListMapping(input, context) {
    return Delimited(input);
}
// prettier-ignore
function TupleMapping(input, context) {
    return T.Tuple(input[1]);
}
// prettier-ignore
function ParameterMapping(input, context) {
    const [_ident, _colon, type] = input;
    return type;
}
// prettier-ignore
function ParameterListMapping(input, context) {
    return Delimited(input);
}
// prettier-ignore
function FunctionMapping(input, context) {
    const [_lparan, parameterList, _rparan, _arrow, returnType] = input;
    return T.Function(parameterList, returnType);
}
// prettier-ignore
function ConstructorMapping(input, context) {
    const [_new, _lparan, parameterList, _rparan, _arrow, instanceType] = input;
    return T.Constructor(parameterList, instanceType);
}
// prettier-ignore
function MappedMapping(input, context) {
    const [_lbrace, _lbracket, _key, _in, _right, _rbracket, _colon, _type] = input;
    return T.Literal('Mapped types not supported');
}
// prettier-ignore
function AsyncIteratorMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.AsyncIterator(type);
}
// prettier-ignore
function IteratorMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Iterator(type);
}
// prettier-ignore
function ArgumentMapping(input, context) {
    return T.KindGuard.IsLiteralNumber(input[2])
        ? T.Argument(Math.trunc(input[2].const))
        : T.Never();
}
// prettier-ignore
function AwaitedMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Awaited(type);
}
// prettier-ignore
function ArrayMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Array(type);
}
// prettier-ignore
function RecordMapping(input, context) {
    const [_name, _langle, key, _comma, type, _rangle] = input;
    return T.Record(key, type);
}
// prettier-ignore
function PromiseMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Promise(type);
}
// prettier-ignore
function ConstructorParametersMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.ConstructorParameters(type);
}
// prettier-ignore
function FunctionParametersMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Parameters(type);
}
// prettier-ignore
function InstanceTypeMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.InstanceType(type);
}
// prettier-ignore
function ReturnTypeMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.ReturnType(type);
}
// prettier-ignore
function PartialMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Partial(type);
}
// prettier-ignore
function RequiredMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Required(type);
}
// prettier-ignore
function PickMapping(input, context) {
    const [_name, _langle, key, _comma, type, _rangle] = input;
    return T.Pick(key, type);
}
// prettier-ignore
function OmitMapping(input, context) {
    const [_name, _langle, key, _comma, type, _rangle] = input;
    return T.Omit(key, type);
}
// prettier-ignore
function ExcludeMapping(input, context) {
    const [_name, _langle, key, _comma, type, _rangle] = input;
    return T.Exclude(key, type);
}
// prettier-ignore
function ExtractMapping(input, context) {
    const [_name, _langle, key, _comma, type, _rangle] = input;
    return T.Extract(key, type);
}
// prettier-ignore
function UppercaseMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Uppercase(type);
}
// prettier-ignore
function LowercaseMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Lowercase(type);
}
// prettier-ignore
function CapitalizeMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Capitalize(type);
}
// prettier-ignore
function UncapitalizeMapping(input, context) {
    const [_name, _langle, type, _rangle] = input;
    return T.Uncapitalize(type);
}
// prettier-ignore
function DateMapping(input, context) {
    return T.Date();
}
// prettier-ignore
function Uint8ArrayMapping(input, context) {
    return T.Uint8Array();
}
// prettier-ignore
function ReferenceMapping(input, context) {
    const target = Dereference(context, input);
    return target;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\parser.d.ts

Code:
import { Static } from '../parser/index';
import * as T from '../type/index';
import * as S from './mapping';
export type TGenericReferenceParameterList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (TType<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TGenericReferenceParameterList_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TGenericReferenceParameterList<Input extends string, Context extends T.TProperties = {}> = (TGenericReferenceParameterList_0<Input, Context> extends [infer _0, infer Input extends string] ? ((TType<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : [] : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TGenericReferenceParameterListMapping<_0, Context>, Input] : [];
export type TGenericReference<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TGenericReferenceParameterList<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TGenericReferenceMapping<_0, Context>, Input] : [];
export type TGenericArgumentsList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TGenericArgumentsList_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TGenericArgumentsList<Input extends string, Context extends T.TProperties = {}> = (TGenericArgumentsList_0<Input, Context> extends [infer _0, infer Input extends string] ? ((Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : [] : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TGenericArgumentsListMapping<_0, Context>, Input] : [];
export type TGenericArguments<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'<', Input> extends [infer _0, infer Input extends string] ? TGenericArgumentsList<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericArgumentsMapping<_0, Context>, Input] : [];
export type TKeywordString<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'string', Input> extends [infer _0 extends 'string', infer Input extends string] ? [S.TKeywordStringMapping<_0, Context>, Input] : [];
export type TKeywordNumber<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'number', Input> extends [infer _0 extends 'number', infer Input extends string] ? [S.TKeywordNumberMapping<_0, Context>, Input] : [];
export type TKeywordBoolean<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'boolean', Input> extends [infer _0 extends 'boolean', infer Input extends string] ? [S.TKeywordBooleanMapping<_0, Context>, Input] : [];
export type TKeywordUndefined<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'undefined', Input> extends [infer _0 extends 'undefined', infer Input extends string] ? [S.TKeywordUndefinedMapping<_0, Context>, Input] : [];
export type TKeywordNull<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'null', Input> extends [infer _0 extends 'null', infer Input extends string] ? [S.TKeywordNullMapping<_0, Context>, Input] : [];
export type TKeywordInteger<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'integer', Input> extends [infer _0 extends 'integer', infer Input extends string] ? [S.TKeywordIntegerMapping<_0, Context>, Input] : [];
export type TKeywordBigInt<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'bigint', Input> extends [infer _0 extends 'bigint', infer Input extends string] ? [S.TKeywordBigIntMapping<_0, Context>, Input] : [];
export type TKeywordUnknown<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'unknown', Input> extends [infer _0 extends 'unknown', infer Input extends string] ? [S.TKeywordUnknownMapping<_0, Context>, Input] : [];
export type TKeywordAny<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'any', Input> extends [infer _0 extends 'any', infer Input extends string] ? [S.TKeywordAnyMapping<_0, Context>, Input] : [];
export type TKeywordNever<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'never', Input> extends [infer _0 extends 'never', infer Input extends string] ? [S.TKeywordNeverMapping<_0, Context>, Input] : [];
export type TKeywordSymbol<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'symbol', Input> extends [infer _0 extends 'symbol', infer Input extends string] ? [S.TKeywordSymbolMapping<_0, Context>, Input] : [];
export type TKeywordVoid<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'void', Input> extends [infer _0 extends 'void', infer Input extends string] ? [S.TKeywordVoidMapping<_0, Context>, Input] : [];
export type TKeyword<Input extends string, Context extends T.TProperties = {}> = (TKeywordString<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNumber<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordBoolean<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordUndefined<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNull<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordInteger<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordBigInt<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordUnknown<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordAny<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNever<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordSymbol<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordVoid<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TKeywordMapping<_0, Context>, Input] : [];
export type TLiteralString<Input extends string, Context extends T.TProperties = {}> = Static.Token.String<["'", '"', '`'], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralStringMapping<_0, Context>, Input] : [];
export type TLiteralNumber<Input extends string, Context extends T.TProperties = {}> = Static.Token.Number<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralNumberMapping<_0, Context>, Input] : [];
export type TLiteralBoolean<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'true', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Static.Token.Const<'false', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends 'true' | 'false', infer Input extends string] ? [S.TLiteralBooleanMapping<_0, Context>, Input] : [];
export type TLiteral<Input extends string, Context extends T.TProperties = {}> = (TLiteralBoolean<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteralNumber<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteralString<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TLiteralMapping<_0, Context>, Input] : [];
export type TKeyOf<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'keyof', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TKeyOfMapping<_0, Context>, Input] : [];
export type TIndexArray_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = ((Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string] ? TType<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<']', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<']', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
    infer _0,
    infer Input extends string
] ? [_0, Input] : []) extends [infer _0, infer Input extends string] ? TIndexArray_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TIndexArray<Input extends string, Context extends T.TProperties = {}> = TIndexArray_0<Input, Context> extends [infer _0 extends ([unknown, unknown, unknown] | [unknown, unknown])[], infer Input extends string] ? [S.TIndexArrayMapping<_0, Context>, Input] : [];
export type TExtends<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'extends', Input> extends [infer _0, infer Input extends string] ? TType<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<'?', Input> extends [infer _2, infer Input extends string] ? TType<Input, Context> extends [infer _3, infer Input extends string] ? Static.Token.Const<':', Input> extends [infer _4, infer Input extends string] ? TType<Input, Context> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExtendsMapping<_0, Context>, Input] : [];
export type TBase<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'(', Input> extends [infer _0, infer Input extends string] ? TType<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<')', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : TKeyword<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TObject<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TTuple<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteral<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TConstructor<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TFunction<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TMapped<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TAsyncIterator<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TIterator<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TConstructorParameters<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TFunctionParameters<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TInstanceType<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TReturnType<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TArgument<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TAwaited<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TArray<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TRecord<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TPromise<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TPartial<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TRequired<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TPick<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TOmit<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TExclude<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TExtract<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TUppercase<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TLowercase<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TCapitalize<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TUncapitalize<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TDate<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TUint8Array<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericReference<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : TReference<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | unknown, infer Input extends string] ? [S.TBaseMapping<_0, Context>, Input] : [];
export type TFactor<Input extends string, Context extends T.TProperties = {}> = (TKeyOf<Input, Context> extends [infer _0, infer Input extends string] ? TBase<Input, Context> extends [infer _1, infer Input extends string] ? TIndexArray<Input, Context> extends [infer _2, infer Input extends string] ? TExtends<Input, Context> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TFactorMapping<_0, Context>, Input] : [];
export type TExprTermTail<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'&', Input> extends [infer _0, infer Input extends string] ? TFactor<Input, Context> extends [infer _1, infer Input extends string] ? TExprTermTail<Input, Context> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExprTermTailMapping<_0, Context>, Input] : [];
export type TExprTerm<Input extends string, Context extends T.TProperties = {}> = (TFactor<Input, Context> extends [infer _0, infer Input extends string] ? (TExprTermTail<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TExprTermMapping<_0, Context>, Input] : [];
export type TExprTail<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'|', Input> extends [infer _0, infer Input extends string] ? TExprTerm<Input, Context> extends [infer _1, infer Input extends string] ? TExprTail<Input, Context> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExprTailMapping<_0, Context>, Input] : [];
export type TExpr<Input extends string, Context extends T.TProperties = {}> = (TExprTerm<Input, Context> extends [infer _0, infer Input extends string] ? (TExprTail<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TExprMapping<_0, Context>, Input] : [];
export type TType<Input extends string, Context extends T.TProperties = {}> = (TGenericArguments<Input, Context> extends [infer _0 extends T.TProperties, infer Input extends string] ? TExpr<Input, _0> : [] extends [infer _0, infer Input extends string] ? [_0, Input] : TExpr<Input, Context> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TTypeMapping<_0, Context>, Input] : [];
export type TPropertyKey<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Static.Token.String<["'", '"'], Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends string, infer Input extends string] ? [S.TPropertyKeyMapping<_0, Context>, Input] : [];
export type TReadonly<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'readonly', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TReadonlyMapping<_0, Context>, Input] : [];
export type TOptional<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<'?', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TOptionalMapping<_0, Context>, Input] : [];
export type TProperty<Input extends string, Context extends T.TProperties = {}> = (TReadonly<Input, Context> extends [infer _0, infer Input extends string] ? TPropertyKey<Input, Context> extends [infer _1, infer Input extends string] ? TOptional<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<':', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPropertyMapping<_0, Context>, Input] : [];
export type TPropertyDelimiter<Input extends string, Context extends T.TProperties = {}> = ((Static.Token.Const<',', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
    infer _0,
    infer Input extends string
] ? [_0, Input] : (Static.Token.Const<';', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
    infer _0,
    infer Input extends string
] ? [_0, Input] : (Static.Token.Const<',', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Static.Token.Const<';', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Static.Token.Const<'\n', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string] ? [S.TPropertyDelimiterMapping<_0, Context>, Input] : [];
export type TPropertyList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (TProperty<Input, Context> extends [infer _0, infer Input extends string] ? (TPropertyDelimiter<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TPropertyList_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TPropertyList<Input extends string, Context extends T.TProperties = {}> = (TPropertyList_0<Input, Context> extends [infer _0, infer Input extends string] ? ((TProperty<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : [] : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TPropertyListMapping<_0, Context>, Input] : [];
export type TObject<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'{', Input> extends [infer _0, infer Input extends string] ? TPropertyList<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<'}', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TObjectMapping<_0, Context>, Input] : [];
export type TElementList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (TType<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TElementList_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TElementList<Input extends string, Context extends T.TProperties = {}> = (TElementList_0<Input, Context> extends [infer _0, infer Input extends string] ? ((TType<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : [] : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TElementListMapping<_0, Context>, Input] : [];
export type TTuple<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string] ? TElementList<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<']', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TTupleMapping<_0, Context>, Input] : [];
export type TParameter<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<':', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TParameterMapping<_0, Context>, Input] : [];
export type TParameterList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (TParameter<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TParameterList_0<Input, Context, [...Result, _0]> : [Result, Input];
export type TParameterList<Input extends string, Context extends T.TProperties = {}> = (TParameterList_0<Input, Context> extends [infer _0, infer Input extends string] ? ((TParameter<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : [] : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TParameterListMapping<_0, Context>, Input] : [];
export type TFunction<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'(', Input> extends [infer _0, infer Input extends string] ? TParameterList<Input, Context> extends [infer _1, infer Input extends string] ? Static.Token.Const<')', Input> extends [infer _2, infer Input extends string] ? Static.Token.Const<'=>', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TFunctionMapping<_0, Context>, Input] : [];
export type TConstructor<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'new', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'(', Input> extends [infer _1, infer Input extends string] ? TParameterList<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<')', Input> extends [infer _3, infer Input extends string] ? Static.Token.Const<'=>', Input> extends [infer _4, infer Input extends string] ? TType<Input, Context> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TConstructorMapping<_0, Context>, Input] : [];
export type TMapped<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'{', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'[', Input> extends [infer _1, infer Input extends string] ? Static.Token.Ident<Input> extends [infer _2, infer Input extends string] ? Static.Token.Const<'in', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<']', Input> extends [infer _5, infer Input extends string] ? Static.Token.Const<':', Input> extends [infer _6, infer Input extends string] ? TType<Input, Context> extends [infer _7, infer Input extends string] ? Static.Token.Const<'}', Input> extends [infer _8, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5, _6, _7, _8], Input] : [] : [] : [] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TMappedMapping<_0, Context>, Input] : [];
export type TAsyncIterator<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'AsyncIterator', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TAsyncIteratorMapping<_0, Context>, Input] : [];
export type TIterator<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Iterator', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TIteratorMapping<_0, Context>, Input] : [];
export type TArgument<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Argument', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TArgumentMapping<_0, Context>, Input] : [];
export type TAwaited<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Awaited', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TAwaitedMapping<_0, Context>, Input] : [];
export type TArray<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Array', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TArrayMapping<_0, Context>, Input] : [];
export type TRecord<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Record', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TRecordMapping<_0, Context>, Input] : [];
export type TPromise<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Promise', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPromiseMapping<_0, Context>, Input] : [];
export type TConstructorParameters<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'ConstructorParameters', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TConstructorParametersMapping<_0, Context>, Input] : [];
export type TFunctionParameters<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Parameters', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TFunctionParametersMapping<_0, Context>, Input] : [];
export type TInstanceType<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'InstanceType', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TInstanceTypeMapping<_0, Context>, Input] : [];
export type TReturnType<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'ReturnType', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TReturnTypeMapping<_0, Context>, Input] : [];
export type TPartial<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Partial', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPartialMapping<_0, Context>, Input] : [];
export type TRequired<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Required', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TRequiredMapping<_0, Context>, Input] : [];
export type TPick<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Pick', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPickMapping<_0, Context>, Input] : [];
export type TOmit<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Omit', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TOmitMapping<_0, Context>, Input] : [];
export type TExclude<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Exclude', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TExcludeMapping<_0, Context>, Input] : [];
export type TExtract<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Extract', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string] ? TType<Input, Context> extends [infer _4, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : [] : [] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TExtractMapping<_0, Context>, Input] : [];
export type TUppercase<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Uppercase', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TUppercaseMapping<_0, Context>, Input] : [];
export type TLowercase<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Lowercase', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TLowercaseMapping<_0, Context>, Input] : [];
export type TCapitalize<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Capitalize', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TCapitalizeMapping<_0, Context>, Input] : [];
export type TUncapitalize<Input extends string, Context extends T.TProperties = {}> = (Static.Token.Const<'Uncapitalize', Input> extends [infer _0, infer Input extends string] ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string] ? TType<Input, Context> extends [infer _2, infer Input extends string] ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : [] : [] : [] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TUncapitalizeMapping<_0, Context>, Input] : [];
export type TDate<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'Date', Input> extends [infer _0 extends 'Date', infer Input extends string] ? [S.TDateMapping<_0, Context>, Input] : [];
export type TUint8Array<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'Uint8Array', Input> extends [infer _0 extends 'Uint8Array', infer Input extends string] ? [S.TUint8ArrayMapping<_0, Context>, Input] : [];
export type TReference<Input extends string, Context extends T.TProperties = {}> = Static.Token.Ident<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TReferenceMapping<_0, Context>, Input] : [];
export declare const GenericReferenceParameterList_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const GenericReferenceParameterList: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const GenericReference: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const GenericArgumentsList_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const GenericArgumentsList: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const GenericArguments: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordString: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordNumber: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordBoolean: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordUndefined: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordNull: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordInteger: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordBigInt: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordUnknown: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordAny: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordNever: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordSymbol: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeywordVoid: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Keyword: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const LiteralString: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const LiteralNumber: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const LiteralBoolean: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Literal: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const KeyOf: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const IndexArray_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const IndexArray: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Extends: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Base: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Factor: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ExprTermTail: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ExprTerm: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ExprTail: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Expr: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Type: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const PropertyKey: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Readonly: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Optional: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Property: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const PropertyDelimiter: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const PropertyList_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const PropertyList: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const _Object: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ElementList_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const ElementList: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Tuple: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Parameter: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ParameterList_0: (input: string, context: T.TProperties, result?: unknown[]) => [unknown[], string];
export declare const ParameterList: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Function: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Constructor: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Mapped: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const AsyncIterator: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Iterator: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Argument: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Awaited: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Array: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Record: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Promise: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ConstructorParameters: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const FunctionParameters: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const InstanceType: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const ReturnType: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Partial: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Required: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Pick: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Omit: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Exclude: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Extract: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Uppercase: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Lowercase: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Capitalize: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Uncapitalize: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Date: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Uint8Array: (input: string, context?: T.TProperties) => [unknown, string] | [];
export declare const Reference: (input: string, context?: T.TProperties) => [unknown, string] | [];


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\parser.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constructor = exports.Function = exports.ParameterList = exports.ParameterList_0 = exports.Parameter = exports.Tuple = exports.ElementList = exports.ElementList_0 = exports._Object = exports.PropertyList = exports.PropertyList_0 = exports.PropertyDelimiter = exports.Property = exports.Optional = exports.Readonly = exports.PropertyKey = exports.Type = exports.Expr = exports.ExprTail = exports.ExprTerm = exports.ExprTermTail = exports.Factor = exports.Base = exports.Extends = exports.IndexArray = exports.IndexArray_0 = exports.KeyOf = exports.Literal = exports.LiteralBoolean = exports.LiteralNumber = exports.LiteralString = exports.Keyword = exports.KeywordVoid = exports.KeywordSymbol = exports.KeywordNever = exports.KeywordAny = exports.KeywordUnknown = exports.KeywordBigInt = exports.KeywordInteger = exports.KeywordNull = exports.KeywordUndefined = exports.KeywordBoolean = exports.KeywordNumber = exports.KeywordString = exports.GenericArguments = exports.GenericArgumentsList = exports.GenericArgumentsList_0 = exports.GenericReference = exports.GenericReferenceParameterList = exports.GenericReferenceParameterList_0 = void 0;
exports.Reference = exports.Uint8Array = exports.Date = exports.Uncapitalize = exports.Capitalize = exports.Lowercase = exports.Uppercase = exports.Extract = exports.Exclude = exports.Omit = exports.Pick = exports.Required = exports.Partial = exports.ReturnType = exports.InstanceType = exports.FunctionParameters = exports.ConstructorParameters = exports.Promise = exports.Record = exports.Array = exports.Awaited = exports.Argument = exports.Iterator = exports.AsyncIterator = exports.Mapped = void 0;
const index_1 = require("../parser/index");
const S = require("./mapping");
const If = (result, left, right = () => []) => (result.length === 2 ? left(result) : right());
const GenericReferenceParameterList_0 = (input, context, result = []) => If(If((0, exports.Type)(input, context), ([_0, input]) => If(index_1.Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => (0, exports.GenericReferenceParameterList_0)(input, context, [...result, _0]), () => [result, input]);
exports.GenericReferenceParameterList_0 = GenericReferenceParameterList_0;
const GenericReferenceParameterList = (input, context = {}) => If(If((0, exports.GenericReferenceParameterList_0)(input, context), ([_0, input]) => If(If(If((0, exports.Type)(input, context), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericReferenceParameterListMapping(_0, context), input]);
exports.GenericReferenceParameterList = GenericReferenceParameterList;
const GenericReference = (input, context = {}) => If(If(index_1.Runtime.Token.Ident(input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.GenericReferenceParameterList)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.GenericReferenceMapping(_0, context), input]);
exports.GenericReference = GenericReference;
const GenericArgumentsList_0 = (input, context, result = []) => If(If(index_1.Runtime.Token.Ident(input), ([_0, input]) => If(index_1.Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => (0, exports.GenericArgumentsList_0)(input, context, [...result, _0]), () => [result, input]);
exports.GenericArgumentsList_0 = GenericArgumentsList_0;
const GenericArgumentsList = (input, context = {}) => If(If((0, exports.GenericArgumentsList_0)(input, context), ([_0, input]) => If(If(If(index_1.Runtime.Token.Ident(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericArgumentsListMapping(_0, context), input]);
exports.GenericArgumentsList = GenericArgumentsList;
const GenericArguments = (input, context = {}) => If(If(index_1.Runtime.Token.Const('<', input), ([_0, input]) => If((0, exports.GenericArgumentsList)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericArgumentsMapping(_0, context), input]);
exports.GenericArguments = GenericArguments;
const KeywordString = (input, context = {}) => If(index_1.Runtime.Token.Const('string', input), ([_0, input]) => [S.KeywordStringMapping(_0, context), input]);
exports.KeywordString = KeywordString;
const KeywordNumber = (input, context = {}) => If(index_1.Runtime.Token.Const('number', input), ([_0, input]) => [S.KeywordNumberMapping(_0, context), input]);
exports.KeywordNumber = KeywordNumber;
const KeywordBoolean = (input, context = {}) => If(index_1.Runtime.Token.Const('boolean', input), ([_0, input]) => [S.KeywordBooleanMapping(_0, context), input]);
exports.KeywordBoolean = KeywordBoolean;
const KeywordUndefined = (input, context = {}) => If(index_1.Runtime.Token.Const('undefined', input), ([_0, input]) => [S.KeywordUndefinedMapping(_0, context), input]);
exports.KeywordUndefined = KeywordUndefined;
const KeywordNull = (input, context = {}) => If(index_1.Runtime.Token.Const('null', input), ([_0, input]) => [S.KeywordNullMapping(_0, context), input]);
exports.KeywordNull = KeywordNull;
const KeywordInteger = (input, context = {}) => If(index_1.Runtime.Token.Const('integer', input), ([_0, input]) => [S.KeywordIntegerMapping(_0, context), input]);
exports.KeywordInteger = KeywordInteger;
const KeywordBigInt = (input, context = {}) => If(index_1.Runtime.Token.Const('bigint', input), ([_0, input]) => [S.KeywordBigIntMapping(_0, context), input]);
exports.KeywordBigInt = KeywordBigInt;
const KeywordUnknown = (input, context = {}) => If(index_1.Runtime.Token.Const('unknown', input), ([_0, input]) => [S.KeywordUnknownMapping(_0, context), input]);
exports.KeywordUnknown = KeywordUnknown;
const KeywordAny = (input, context = {}) => If(index_1.Runtime.Token.Const('any', input), ([_0, input]) => [S.KeywordAnyMapping(_0, context), input]);
exports.KeywordAny = KeywordAny;
const KeywordNever = (input, context = {}) => If(index_1.Runtime.Token.Const('never', input), ([_0, input]) => [S.KeywordNeverMapping(_0, context), input]);
exports.KeywordNever = KeywordNever;
const KeywordSymbol = (input, context = {}) => If(index_1.Runtime.Token.Const('symbol', input), ([_0, input]) => [S.KeywordSymbolMapping(_0, context), input]);
exports.KeywordSymbol = KeywordSymbol;
const KeywordVoid = (input, context = {}) => If(index_1.Runtime.Token.Const('void', input), ([_0, input]) => [S.KeywordVoidMapping(_0, context), input]);
exports.KeywordVoid = KeywordVoid;
const Keyword = (input, context = {}) => If(If((0, exports.KeywordString)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordNumber)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordBoolean)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordUndefined)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordNull)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordInteger)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordBigInt)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordUnknown)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordAny)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordNever)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordSymbol)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.KeywordVoid)(input, context), ([_0, input]) => [_0, input], () => [])))))))))))), ([_0, input]) => [S.KeywordMapping(_0, context), input]);
exports.Keyword = Keyword;
const LiteralString = (input, context = {}) => If(index_1.Runtime.Token.String(["'", '"', '`'], input), ([_0, input]) => [S.LiteralStringMapping(_0, context), input]);
exports.LiteralString = LiteralString;
const LiteralNumber = (input, context = {}) => If(index_1.Runtime.Token.Number(input), ([_0, input]) => [S.LiteralNumberMapping(_0, context), input]);
exports.LiteralNumber = LiteralNumber;
const LiteralBoolean = (input, context = {}) => If(If(index_1.Runtime.Token.Const('true', input), ([_0, input]) => [_0, input], () => If(index_1.Runtime.Token.Const('false', input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.LiteralBooleanMapping(_0, context), input]);
exports.LiteralBoolean = LiteralBoolean;
const Literal = (input, context = {}) => If(If((0, exports.LiteralBoolean)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.LiteralNumber)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.LiteralString)(input, context), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.LiteralMapping(_0, context), input]);
exports.Literal = Literal;
const KeyOf = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('keyof', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.KeyOfMapping(_0, context), input]);
exports.KeyOf = KeyOf;
const IndexArray_0 = (input, context, result = []) => If(If(If(index_1.Runtime.Token.Const('[', input), ([_0, input]) => If((0, exports.Type)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(index_1.Runtime.Token.Const('[', input), ([_0, input]) => If(index_1.Runtime.Token.Const(']', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => (0, exports.IndexArray_0)(input, context, [...result, _0]), () => [result, input]);
exports.IndexArray_0 = IndexArray_0;
const IndexArray = (input, context = {}) => If((0, exports.IndexArray_0)(input, context), ([_0, input]) => [S.IndexArrayMapping(_0, context), input]);
exports.IndexArray = IndexArray;
const Extends = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('extends', input), ([_0, input]) => If((0, exports.Type)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const('?', input), ([_2, input]) => If((0, exports.Type)(input, context), ([_3, input]) => If(index_1.Runtime.Token.Const(':', input), ([_4, input]) => If((0, exports.Type)(input, context), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExtendsMapping(_0, context), input]);
exports.Extends = Extends;
const Base = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('(', input), ([_0, input]) => If((0, exports.Type)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If((0, exports.Keyword)(input, context), ([_0, input]) => [_0, input], () => If((0, exports._Object)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Tuple)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Literal)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Constructor)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Function)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Mapped)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.AsyncIterator)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Iterator)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.ConstructorParameters)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.FunctionParameters)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.InstanceType)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.ReturnType)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Argument)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Awaited)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Array)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Record)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Promise)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Partial)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Required)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Pick)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Omit)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Exclude)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Extract)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Uppercase)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Lowercase)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Capitalize)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Uncapitalize)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Date)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Uint8Array)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.GenericReference)(input, context), ([_0, input]) => [_0, input], () => If((0, exports.Reference)(input, context), ([_0, input]) => [_0, input], () => []))))))))))))))))))))))))))))))))), ([_0, input]) => [S.BaseMapping(_0, context), input]);
exports.Base = Base;
const Factor = (input, context = {}) => If(If((0, exports.KeyOf)(input, context), ([_0, input]) => If((0, exports.Base)(input, context), ([_1, input]) => If((0, exports.IndexArray)(input, context), ([_2, input]) => If((0, exports.Extends)(input, context), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.FactorMapping(_0, context), input]);
exports.Factor = Factor;
const ExprTermTail = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('&', input), ([_0, input]) => If((0, exports.Factor)(input, context), ([_1, input]) => If((0, exports.ExprTermTail)(input, context), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTermTailMapping(_0, context), input]);
exports.ExprTermTail = ExprTermTail;
const ExprTerm = (input, context = {}) => If(If((0, exports.Factor)(input, context), ([_0, input]) => If((0, exports.ExprTermTail)(input, context), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprTermMapping(_0, context), input]);
exports.ExprTerm = ExprTerm;
const ExprTail = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('|', input), ([_0, input]) => If((0, exports.ExprTerm)(input, context), ([_1, input]) => If((0, exports.ExprTail)(input, context), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTailMapping(_0, context), input]);
exports.ExprTail = ExprTail;
const Expr = (input, context = {}) => If(If((0, exports.ExprTerm)(input, context), ([_0, input]) => If((0, exports.ExprTail)(input, context), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprMapping(_0, context), input]);
exports.Expr = Expr;
const Type = (input, context = {}) => If(If(If((0, exports.GenericArguments)(input, context), ([_0, input]) => (0, exports.Expr)(input, _0), () => []), ([_0, input]) => [_0, input], () => If((0, exports.Expr)(input, context), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.TypeMapping(_0, context), input]);
exports.Type = Type;
const PropertyKey = (input, context = {}) => If(If(index_1.Runtime.Token.Ident(input), ([_0, input]) => [_0, input], () => If(index_1.Runtime.Token.String(["'", '"'], input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.PropertyKeyMapping(_0, context), input]);
exports.PropertyKey = PropertyKey;
const Readonly = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('readonly', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ReadonlyMapping(_0, context), input]);
exports.Readonly = Readonly;
const Optional = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const('?', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.OptionalMapping(_0, context), input]);
exports.Optional = Optional;
const Property = (input, context = {}) => If(If((0, exports.Readonly)(input, context), ([_0, input]) => If((0, exports.PropertyKey)(input, context), ([_1, input]) => If((0, exports.Optional)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(':', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.PropertyMapping(_0, context), input]);
exports.Property = Property;
const PropertyDelimiter = (input, context = {}) => If(If(If(index_1.Runtime.Token.Const(',', input), ([_0, input]) => If(index_1.Runtime.Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(index_1.Runtime.Token.Const(';', input), ([_0, input]) => If(index_1.Runtime.Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(index_1.Runtime.Token.Const(',', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(index_1.Runtime.Token.Const(';', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(index_1.Runtime.Token.Const('\n', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))))), ([_0, input]) => [S.PropertyDelimiterMapping(_0, context), input]);
exports.PropertyDelimiter = PropertyDelimiter;
const PropertyList_0 = (input, context, result = []) => If(If((0, exports.Property)(input, context), ([_0, input]) => If((0, exports.PropertyDelimiter)(input, context), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => (0, exports.PropertyList_0)(input, context, [...result, _0]), () => [result, input]);
exports.PropertyList_0 = PropertyList_0;
const PropertyList = (input, context = {}) => If(If((0, exports.PropertyList_0)(input, context), ([_0, input]) => If(If(If((0, exports.Property)(input, context), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.PropertyListMapping(_0, context), input]);
exports.PropertyList = PropertyList;
const _Object = (input, context = {}) => If(If(index_1.Runtime.Token.Const('{', input), ([_0, input]) => If((0, exports.PropertyList)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ObjectMapping(_0, context), input]);
exports._Object = _Object;
const ElementList_0 = (input, context, result = []) => If(If((0, exports.Type)(input, context), ([_0, input]) => If(index_1.Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => (0, exports.ElementList_0)(input, context, [...result, _0]), () => [result, input]);
exports.ElementList_0 = ElementList_0;
const ElementList = (input, context = {}) => If(If((0, exports.ElementList_0)(input, context), ([_0, input]) => If(If(If((0, exports.Type)(input, context), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementListMapping(_0, context), input]);
exports.ElementList = ElementList;
const Tuple = (input, context = {}) => If(If(index_1.Runtime.Token.Const('[', input), ([_0, input]) => If((0, exports.ElementList)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TupleMapping(_0, context), input]);
exports.Tuple = Tuple;
const Parameter = (input, context = {}) => If(If(index_1.Runtime.Token.Ident(input), ([_0, input]) => If(index_1.Runtime.Token.Const(':', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ParameterMapping(_0, context), input]);
exports.Parameter = Parameter;
const ParameterList_0 = (input, context, result = []) => If(If((0, exports.Parameter)(input, context), ([_0, input]) => If(index_1.Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => (0, exports.ParameterList_0)(input, context, [...result, _0]), () => [result, input]);
exports.ParameterList_0 = ParameterList_0;
const ParameterList = (input, context = {}) => If(If((0, exports.ParameterList_0)(input, context), ([_0, input]) => If(If(If((0, exports.Parameter)(input, context), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ParameterListMapping(_0, context), input]);
exports.ParameterList = ParameterList;
const Function = (input, context = {}) => If(If(index_1.Runtime.Token.Const('(', input), ([_0, input]) => If((0, exports.ParameterList)(input, context), ([_1, input]) => If(index_1.Runtime.Token.Const(')', input), ([_2, input]) => If(index_1.Runtime.Token.Const('=>', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.FunctionMapping(_0, context), input]);
exports.Function = Function;
const Constructor = (input, context = {}) => If(If(index_1.Runtime.Token.Const('new', input), ([_0, input]) => If(index_1.Runtime.Token.Const('(', input), ([_1, input]) => If((0, exports.ParameterList)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(')', input), ([_3, input]) => If(index_1.Runtime.Token.Const('=>', input), ([_4, input]) => If((0, exports.Type)(input, context), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.ConstructorMapping(_0, context), input]);
exports.Constructor = Constructor;
const Mapped = (input, context = {}) => If(If(index_1.Runtime.Token.Const('{', input), ([_0, input]) => If(index_1.Runtime.Token.Const('[', input), ([_1, input]) => If(index_1.Runtime.Token.Ident(input), ([_2, input]) => If(index_1.Runtime.Token.Const('in', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const(']', input), ([_5, input]) => If(index_1.Runtime.Token.Const(':', input), ([_6, input]) => If((0, exports.Type)(input, context), ([_7, input]) => If(index_1.Runtime.Token.Const('}', input), ([_8, input]) => [[_0, _1, _2, _3, _4, _5, _6, _7, _8], input]))))))))), ([_0, input]) => [S.MappedMapping(_0, context), input]);
exports.Mapped = Mapped;
const AsyncIterator = (input, context = {}) => If(If(index_1.Runtime.Token.Const('AsyncIterator', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.AsyncIteratorMapping(_0, context), input]);
exports.AsyncIterator = AsyncIterator;
const Iterator = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Iterator', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.IteratorMapping(_0, context), input]);
exports.Iterator = Iterator;
const Argument = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Argument', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ArgumentMapping(_0, context), input]);
exports.Argument = Argument;
const Awaited = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Awaited', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.AwaitedMapping(_0, context), input]);
exports.Awaited = Awaited;
const Array = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Array', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ArrayMapping(_0, context), input]);
exports.Array = Array;
const Record = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Record', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(',', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.RecordMapping(_0, context), input]);
exports.Record = Record;
const Promise = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Promise', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.PromiseMapping(_0, context), input]);
exports.Promise = Promise;
const ConstructorParameters = (input, context = {}) => If(If(index_1.Runtime.Token.Const('ConstructorParameters', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ConstructorParametersMapping(_0, context), input]);
exports.ConstructorParameters = ConstructorParameters;
const FunctionParameters = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Parameters', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.FunctionParametersMapping(_0, context), input]);
exports.FunctionParameters = FunctionParameters;
const InstanceType = (input, context = {}) => If(If(index_1.Runtime.Token.Const('InstanceType', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.InstanceTypeMapping(_0, context), input]);
exports.InstanceType = InstanceType;
const ReturnType = (input, context = {}) => If(If(index_1.Runtime.Token.Const('ReturnType', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ReturnTypeMapping(_0, context), input]);
exports.ReturnType = ReturnType;
const Partial = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Partial', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.PartialMapping(_0, context), input]);
exports.Partial = Partial;
const Required = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Required', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.RequiredMapping(_0, context), input]);
exports.Required = Required;
const Pick = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Pick', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(',', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.PickMapping(_0, context), input]);
exports.Pick = Pick;
const Omit = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Omit', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(',', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.OmitMapping(_0, context), input]);
exports.Omit = Omit;
const Exclude = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Exclude', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(',', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.ExcludeMapping(_0, context), input]);
exports.Exclude = Exclude;
const Extract = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Extract', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const(',', input), ([_3, input]) => If((0, exports.Type)(input, context), ([_4, input]) => If(index_1.Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.ExtractMapping(_0, context), input]);
exports.Extract = Extract;
const Uppercase = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Uppercase', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.UppercaseMapping(_0, context), input]);
exports.Uppercase = Uppercase;
const Lowercase = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Lowercase', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.LowercaseMapping(_0, context), input]);
exports.Lowercase = Lowercase;
const Capitalize = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Capitalize', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.CapitalizeMapping(_0, context), input]);
exports.Capitalize = Capitalize;
const Uncapitalize = (input, context = {}) => If(If(index_1.Runtime.Token.Const('Uncapitalize', input), ([_0, input]) => If(index_1.Runtime.Token.Const('<', input), ([_1, input]) => If((0, exports.Type)(input, context), ([_2, input]) => If(index_1.Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.UncapitalizeMapping(_0, context), input]);
exports.Uncapitalize = Uncapitalize;
const Date = (input, context = {}) => If(index_1.Runtime.Token.Const('Date', input), ([_0, input]) => [S.DateMapping(_0, context), input]);
exports.Date = Date;
const Uint8Array = (input, context = {}) => If(index_1.Runtime.Token.Const('Uint8Array', input), ([_0, input]) => [S.Uint8ArrayMapping(_0, context), input]);
exports.Uint8Array = Uint8Array;
const Reference = (input, context = {}) => If(index_1.Runtime.Token.Ident(input), ([_0, input]) => [S.ReferenceMapping(_0, context), input]);
exports.Reference = Reference;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\syntax.d.ts

Code:
import * as t from '../type/index';
import { TType } from './parser';
/** `[Experimental]` Parses type expressions into TypeBox types but does not infer */
export declare function NoInfer<Context extends Record<PropertyKey, t.TSchema>, Input extends string>(context: Context, input: Input, options?: t.SchemaOptions): t.TSchema;
/** `[Experimental]` Parses type expressions into TypeBox types but does not infer */
export declare function NoInfer<Input extends string>(input: Input, options?: t.SchemaOptions): t.TSchema;
/** `[Experimental]` Parses type expressions into TypeBox types */
export type TSyntax<Context extends Record<PropertyKey, t.TSchema>, Code extends string> = (TType<Code, Context> extends [infer Type extends t.TSchema, string] ? Type : t.TNever);
/** `[Experimental]` Parses type expressions into TypeBox types */
export declare function Syntax<Context extends Record<PropertyKey, t.TSchema>, Input extends string>(context: Context, input: Input, options?: t.SchemaOptions): TSyntax<Context, Input>;
/** `[Experimental]` Parses type expressions into TypeBox types */
export declare function Syntax<Input extends string>(annotation: Input, options?: t.SchemaOptions): TSyntax<{}, Input>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\syntax\syntax.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NoInfer = NoInfer;
exports.Syntax = Syntax;
const t = require("../type/index");
const parser_1 = require("./parser");
/** `[Experimental]` Parses type expressions into TypeBox types but does not infer */
// prettier-ignore
function NoInfer(...args) {
    const withContext = typeof args[0] === 'string' ? false : true;
    const [context, code, options] = withContext ? [args[0], args[1], args[2] || {}] : [{}, args[0], args[1] || {}];
    const result = (0, parser_1.Type)(code, context)[0];
    return t.KindGuard.IsSchema(result)
        ? t.CloneType(result, options)
        : t.Never(options);
}
/** `[Experimental]` Parses type expressions into TypeBox types */
function Syntax(...args) {
    return NoInfer.apply(null, args);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\index.d.ts

Code:
export * from './policy';
export * from './system';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./policy"), exports);
__exportStar(require("./system"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\policy.d.ts

Code:
export declare namespace TypeSystemPolicy {
    /**
     * Configures the instantiation behavior of TypeBox types. The `default` option assigns raw JavaScript
     * references for embedded types, which may cause side effects if type properties are explicitly updated
     * outside the TypeBox type builder. The `clone` option creates copies of any shared types upon creation,
     * preventing unintended side effects. The `freeze` option applies `Object.freeze()` to the type, making
     * it fully readonly and immutable. Implementations should use `default` whenever possible, as it is the
     * fastest way to instantiate types. The default setting is `default`.
     */
    let InstanceMode: 'default' | 'clone' | 'freeze';
    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */
    let ExactOptionalPropertyTypes: boolean;
    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */
    let AllowArrayObject: boolean;
    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */
    let AllowNaN: boolean;
    /** Sets whether `null` should validate for void types. The default is `false` */
    let AllowNullVoid: boolean;
    /** Checks this value using the ExactOptionalPropertyTypes policy */
    function IsExactOptionalProperty(value: Record<keyof any, unknown>, key: string): boolean;
    /** Checks this value using the AllowArrayObjects policy */
    function IsObjectLike(value: unknown): value is Record<keyof any, unknown>;
    /** Checks this value as a record using the AllowArrayObjects policy */
    function IsRecordLike(value: unknown): value is Record<keyof any, unknown>;
    /** Checks this value using the AllowNaN policy */
    function IsNumberLike(value: unknown): value is number;
    /** Checks this value using the AllowVoidNull policy */
    function IsVoidLike(value: unknown): value is void;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\policy.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeSystemPolicy = void 0;
const index_1 = require("../value/guard/index");
var TypeSystemPolicy;
(function (TypeSystemPolicy) {
    // ------------------------------------------------------------------
    // TypeSystemPolicy: Instancing
    // ------------------------------------------------------------------
    /**
     * Configures the instantiation behavior of TypeBox types. The `default` option assigns raw JavaScript
     * references for embedded types, which may cause side effects if type properties are explicitly updated
     * outside the TypeBox type builder. The `clone` option creates copies of any shared types upon creation,
     * preventing unintended side effects. The `freeze` option applies `Object.freeze()` to the type, making
     * it fully readonly and immutable. Implementations should use `default` whenever possible, as it is the
     * fastest way to instantiate types. The default setting is `default`.
     */
    TypeSystemPolicy.InstanceMode = 'default';
    // ------------------------------------------------------------------
    // TypeSystemPolicy: Checking
    // ------------------------------------------------------------------
    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */
    TypeSystemPolicy.ExactOptionalPropertyTypes = false;
    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */
    TypeSystemPolicy.AllowArrayObject = false;
    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */
    TypeSystemPolicy.AllowNaN = false;
    /** Sets whether `null` should validate for void types. The default is `false` */
    TypeSystemPolicy.AllowNullVoid = false;
    /** Checks this value using the ExactOptionalPropertyTypes policy */
    function IsExactOptionalProperty(value, key) {
        return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;
    /** Checks this value using the AllowArrayObjects policy */
    function IsObjectLike(value) {
        const isObject = (0, index_1.IsObject)(value);
        return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !(0, index_1.IsArray)(value);
    }
    TypeSystemPolicy.IsObjectLike = IsObjectLike;
    /** Checks this value as a record using the AllowArrayObjects policy */
    function IsRecordLike(value) {
        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy.IsRecordLike = IsRecordLike;
    /** Checks this value using the AllowNaN policy */
    function IsNumberLike(value) {
        return TypeSystemPolicy.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
    }
    TypeSystemPolicy.IsNumberLike = IsNumberLike;
    /** Checks this value using the AllowVoidNull policy */
    function IsVoidLike(value) {
        const isUndefined = (0, index_1.IsUndefined)(value);
        return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\system.d.ts

Code:
import { type TUnsafe } from '../type/unsafe/index';
import { TypeBoxError } from '../type/error/index';
export declare class TypeSystemDuplicateTypeKind extends TypeBoxError {
    constructor(kind: string);
}
export declare class TypeSystemDuplicateFormat extends TypeBoxError {
    constructor(kind: string);
}
export type TypeFactoryFunction<Type, Options = Record<PropertyKey, unknown>> = (options?: Partial<Options>) => TUnsafe<Type>;
/** Creates user defined types and formats and provides overrides for value checking behaviours */
export declare namespace TypeSystem {
    /** Creates a new type */
    function Type<Type, Options = Record<PropertyKey, unknown>>(kind: string, check: (options: Options, value: unknown) => boolean): TypeFactoryFunction<Type, Options>;
    /** Creates a new string format */
    function Format<F extends string>(format: F, check: (value: string) => boolean): F;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\system\system.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
const index_1 = require("../type/registry/index");
const index_2 = require("../type/unsafe/index");
const index_3 = require("../type/symbols/index");
const index_4 = require("../type/error/index");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {
    constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
    }
}
exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
class TypeSystemDuplicateFormat extends index_4.TypeBoxError {
    constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
    }
}
exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
/** Creates user defined types and formats and provides overrides for value checking behaviours */
var TypeSystem;
(function (TypeSystem) {
    /** Creates a new type */
    function Type(kind, check) {
        if (index_1.TypeRegistry.Has(kind))
            throw new TypeSystemDuplicateTypeKind(kind);
        index_1.TypeRegistry.Set(kind, check);
        return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem.Type = Type;
    /** Creates a new string format */
    function Format(format, check) {
        if (index_1.FormatRegistry.Has(format))
            throw new TypeSystemDuplicateFormat(format);
        index_1.FormatRegistry.Set(format, check);
        return format;
    }
    TypeSystem.Format = Format;
})(TypeSystem || (exports.TypeSystem = TypeSystem = {}));


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\any\any.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TAny extends TSchema {
    [Kind]: 'Any';
    static: any;
}
/** `[Json]` Creates an Any type */
export declare function Any(options?: SchemaOptions): TAny;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\any\any.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Any = Any;
const index_1 = require("../create/index");
const index_2 = require("../symbols/index");
/** `[Json]` Creates an Any type */
function Any(options) {
    return (0, index_1.CreateType)({ [index_2.Kind]: 'Any' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\any\index.d.ts

Code:
export * from './any';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\any\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./any"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\argument\argument.d.ts

Code:
import type { TSchema } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TArgument<Index extends number = number> extends TSchema {
    [Kind]: 'Argument';
    static: unknown;
    index: Index;
}
/** `[JavaScript]` Creates an Argument Type. */
export declare function Argument<Index extends number>(index: Index): TArgument<Index>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\argument\argument.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Argument = Argument;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates an Argument Type. */
function Argument(index) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Argument', index });
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\argument\index.d.ts

Code:
export * from './argument';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\argument\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./argument"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\array\array.d.ts

Code:
import { Ensure } from '../helpers/index';
import type { SchemaOptions, TSchema } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
export interface ArrayOptions extends SchemaOptions {
    /** The minimum number of items in this array */
    minItems?: number;
    /** The maximum number of items in this array */
    maxItems?: number;
    /** Should this schema contain unique items */
    uniqueItems?: boolean;
    /** A schema for which some elements should match */
    contains?: TSchema;
    /** A minimum number of contains schema matches */
    minContains?: number;
    /** A maximum number of contains schema matches */
    maxContains?: number;
}
type ArrayStatic<T extends TSchema, P extends unknown[]> = Ensure<Static<T, P>[]>;
export interface TArray<T extends TSchema = TSchema> extends TSchema, ArrayOptions {
    [Kind]: 'Array';
    static: ArrayStatic<T, this['params']>;
    type: 'array';
    items: T;
}
/** `[Json]` Creates an Array type */
export declare function Array<Type extends TSchema>(items: Type, options?: ArrayOptions): TArray<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\array\array.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Array = Array;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates an Array type */
function Array(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Array', type: 'array', items }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\array\index.d.ts

Code:
export * from './array';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\array\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./array"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\async-iterator\async-iterator.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
export interface TAsyncIterator<T extends TSchema = TSchema> extends TSchema {
    [Kind]: 'AsyncIterator';
    static: AsyncIterableIterator<Static<T, this['params']>>;
    type: 'AsyncIterator';
    items: T;
}
/** `[JavaScript]` Creates a AsyncIterator type */
export declare function AsyncIterator<T extends TSchema>(items: T, options?: SchemaOptions): TAsyncIterator<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\async-iterator\async-iterator.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncIterator = AsyncIterator;
const index_1 = require("../symbols/index");
const type_1 = require("../create/type");
/** `[JavaScript]` Creates a AsyncIterator type */
function AsyncIterator(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'AsyncIterator', type: 'AsyncIterator', items }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\async-iterator\index.d.ts

Code:
export * from './async-iterator';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\async-iterator\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./async-iterator"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\awaited\awaited.d.ts

Code:
import { Ensure } from '../helpers/index';
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TComputed } from '../computed/index';
import { type TIntersect } from '../intersect/index';
import { type TUnion } from '../union/index';
import { type TPromise } from '../promise/index';
import { type TRef } from '../ref/index';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<(TComputed<'Awaited', [TComputed<Target, Parameters>]>)>;
type TFromRef<Ref extends string> = Ensure<TComputed<'Awaited', [TRef<Ref>]>>;
type TFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromRest<Right, [...Result, TAwaited<Left>]> : Result);
export type TAwaited<Type extends TSchema> = (Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromRest<Types>> : Type extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromRest<Types>> : Type extends TPromise<infer Type extends TSchema> ? TAwaited<Type> : Type);
/** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
export declare function Awaited<T extends TSchema>(type: T, options?: SchemaOptions): TAwaited<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\awaited\awaited.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Awaited = Awaited;
const type_1 = require("../create/type");
const index_1 = require("../computed/index");
const index_2 = require("../intersect/index");
const index_3 = require("../union/index");
const index_4 = require("../ref/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromComputed(target, parameters) {
    return (0, index_1.Computed)('Awaited', [(0, index_1.Computed)(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return (0, index_1.Computed)('Awaited', [(0, index_4.Ref)($ref)]);
}
// prettier-ignore
function FromIntersect(types) {
    return (0, index_2.Intersect)(FromRest(types));
}
// prettier-ignore
function FromUnion(types) {
    return (0, index_3.Union)(FromRest(types));
}
// prettier-ignore
function FromPromise(type) {
    return Awaited(type);
}
// prettier-ignore
function FromRest(types) {
    return types.map(type => Awaited(type));
}
/** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
function Awaited(type, options) {
    return (0, type_1.CreateType)((0, kind_1.IsComputed)(type) ? FromComputed(type.target, type.parameters) : (0, kind_1.IsIntersect)(type) ? FromIntersect(type.allOf) : (0, kind_1.IsUnion)(type) ? FromUnion(type.anyOf) : (0, kind_1.IsPromise)(type) ? FromPromise(type.item) : (0, kind_1.IsRef)(type) ? FromRef(type.$ref) : type, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\awaited\index.d.ts

Code:
export * from './awaited';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\awaited\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./awaited"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\bigint\bigint.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface BigIntOptions extends SchemaOptions {
    exclusiveMaximum?: bigint;
    exclusiveMinimum?: bigint;
    maximum?: bigint;
    minimum?: bigint;
    multipleOf?: bigint;
}
export interface TBigInt extends TSchema, BigIntOptions {
    [Kind]: 'BigInt';
    static: bigint;
    type: 'bigint';
}
/** `[JavaScript]` Creates a BigInt type */
export declare function BigInt(options?: BigIntOptions): TBigInt;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\bigint\bigint.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BigInt = BigInt;
const index_1 = require("../symbols/index");
const index_2 = require("../create/index");
/** `[JavaScript]` Creates a BigInt type */
function BigInt(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: 'BigInt', type: 'bigint' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\bigint\index.d.ts

Code:
export * from './bigint';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\bigint\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./bigint"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\boolean\boolean.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TBoolean extends TSchema {
    [Kind]: 'Boolean';
    static: boolean;
    type: 'boolean';
}
/** `[Json]` Creates a Boolean type */
export declare function Boolean(options?: SchemaOptions): TBoolean;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\boolean\boolean.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Boolean = Boolean;
const index_1 = require("../symbols/index");
const index_2 = require("../create/index");
/** `[Json]` Creates a Boolean type */
function Boolean(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: 'Boolean', type: 'boolean' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\boolean\index.d.ts

Code:
export * from './boolean';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\boolean\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./boolean"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\index.d.ts

Code:
export * from './type';
export * from './value';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./type"), exports);
__exportStar(require("./value"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\type.d.ts

Code:
import { TSchema, SchemaOptions } from '../schema/index';
/** Clones a Rest */
export declare function CloneRest<T extends TSchema[]>(schemas: T): T;
/** Clones a Type */
export declare function CloneType<T extends TSchema>(schema: T, options?: SchemaOptions): T;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CloneRest = CloneRest;
exports.CloneType = CloneType;
const value_1 = require("./value");
/** Clones a Rest */
function CloneRest(schemas) {
    return schemas.map((schema) => CloneType(schema));
}
/** Clones a Type */
function CloneType(schema, options) {
    return options === undefined ? (0, value_1.Clone)(schema) : (0, value_1.Clone)({ ...options, ...schema });
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\value.d.ts

Code:
/** Clones a value */
export declare function Clone<T>(value: T): T;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\clone\value.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Clone = Clone;
const ValueGuard = require("../guard/value");
function ArrayType(value) {
    return value.map((value) => Visit(value));
}
function DateType(value) {
    return new Date(value.getTime());
}
function Uint8ArrayType(value) {
    return new Uint8Array(value);
}
function RegExpType(value) {
    return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Visit(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Visit(value[key]);
    }
    return result;
}
// prettier-ignore
function Visit(value) {
    return (ValueGuard.IsArray(value) ? ArrayType(value) :
        ValueGuard.IsDate(value) ? DateType(value) :
            ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) :
                ValueGuard.IsRegExp(value) ? RegExpType(value) :
                    ValueGuard.IsObject(value) ? ObjectType(value) :
                        value);
}
/** Clones a value */
function Clone(value) {
    return Visit(value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\composite\composite.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Evaluate } from '../helpers/index';
import { type TIntersectEvaluated } from '../intersect/index';
import { type TIndexFromPropertyKeys } from '../indexed/index';
import { type TKeyOfPropertyKeys } from '../keyof/index';
import { type TNever } from '../never/index';
import { type TObject, type TProperties, type ObjectOptions } from '../object/index';
import { TSetDistinct } from '../sets/index';
type TCompositeKeys<T extends TSchema[], Acc extends PropertyKey[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TCompositeKeys<R, [...Acc, ...TKeyOfPropertyKeys<L>]> : TSetDistinct<Acc>);
type TFilterNever<T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? L extends TNever ? TFilterNever<R, [...Acc]> : TFilterNever<R, [...Acc, L]> : Acc);
type TCompositeProperty<T extends TSchema[], K extends PropertyKey, Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TCompositeProperty<R, K, [...Acc, ...TIndexFromPropertyKeys<L, [K]>]> : TFilterNever<Acc>);
type TCompositeProperties<T extends TSchema[], K extends PropertyKey[], Acc = {}> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TCompositeProperties<T, R, Acc & {
    [_ in L]: TIntersectEvaluated<TCompositeProperty<T, L>>;
}> : Acc);
type TCompositeEvaluate<T extends TSchema[], K extends PropertyKey[] = TCompositeKeys<T>, P extends TProperties = Evaluate<TCompositeProperties<T, K>>, R extends TObject = TObject<P>> = R;
export type TComposite<T extends TSchema[]> = TCompositeEvaluate<T>;
export declare function Composite<T extends TSchema[]>(T: [...T], options?: ObjectOptions): TComposite<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\composite\composite.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Composite = Composite;
const index_1 = require("../intersect/index");
const index_2 = require("../indexed/index");
const index_3 = require("../keyof/index");
const index_4 = require("../object/index");
const index_5 = require("../sets/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
        Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
}
// prettier-ignore
function FilterNever(T) {
    return T.filter(L => !(0, kind_1.IsNever)(L));
}
// prettier-ignore
function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
        Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever(Acc);
}
// prettier-ignore
function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
        Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
    }
    return Acc;
}
// prettier-ignore
function Composite(T, options) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\composite\index.d.ts

Code:
export * from './composite';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\composite\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./composite"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\computed\computed.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/symbols';
export interface TComputed<Target extends string = string, Parameters extends TSchema[] = []> extends TSchema {
    [Kind]: 'Computed';
    target: Target;
    parameters: Parameters;
}
/** `[Internal]` Creates a deferred computed type. This type is used exclusively in modules to defer resolution of computable types that contain interior references  */
export declare function Computed<Target extends string, Parameters extends TSchema[]>(target: Target, parameters: [...Parameters], options?: SchemaOptions): TComputed<Target, Parameters>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\computed\computed.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Computed = Computed;
const index_1 = require("../create/index");
const symbols_1 = require("../symbols/symbols");
/** `[Internal]` Creates a deferred computed type. This type is used exclusively in modules to defer resolution of computable types that contain interior references  */
function Computed(target, parameters, options) {
    return (0, index_1.CreateType)({ [symbols_1.Kind]: 'Computed', target, parameters }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\computed\index.d.ts

Code:
export * from './computed';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\computed\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./computed"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\const\const.d.ts

Code:
import type { AssertRest, Evaluate } from '../helpers/index';
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TAny } from '../any/index';
import { type TBigInt } from '../bigint/index';
import { type TDate } from '../date/index';
import { type TFunction } from '../function/index';
import { type TLiteral } from '../literal/index';
import { type TNever } from '../never/index';
import { type TNull } from '../null/index';
import { type TObject } from '../object/index';
import { type TSymbol } from '../symbol/index';
import { type TTuple } from '../tuple/index';
import { type TReadonly } from '../readonly/index';
import { type TUndefined } from '../undefined/index';
import { type TUint8Array } from '../uint8array/index';
import { type TUnknown } from '../unknown/index';
type TFromArray<T extends readonly unknown[]> = T extends readonly [infer L extends unknown, ...infer R extends unknown[]] ? [FromValue<L, false>, ...TFromArray<R>] : T;
type TFromProperties<T extends Record<PropertyKey, unknown>> = {
    -readonly [K in keyof T]: FromValue<T[K], false> extends infer R extends TSchema ? TReadonly<R> : TReadonly<TNever>;
};
type TConditionalReadonly<T extends TSchema, Root extends boolean> = Root extends true ? T : TReadonly<T>;
type FromValue<T, Root extends boolean> = T extends AsyncIterableIterator<unknown> ? TConditionalReadonly<TAny, Root> : T extends IterableIterator<unknown> ? TConditionalReadonly<TAny, Root> : T extends readonly unknown[] ? TReadonly<TTuple<AssertRest<TFromArray<T>>>> : T extends Uint8Array ? TUint8Array : T extends Date ? TDate : T extends Record<PropertyKey, unknown> ? TConditionalReadonly<TObject<Evaluate<TFromProperties<T>>>, Root> : T extends Function ? TConditionalReadonly<TFunction<[], TUnknown>, Root> : T extends undefined ? TUndefined : T extends null ? TNull : T extends symbol ? TSymbol : T extends number ? TLiteral<T> : T extends boolean ? TLiteral<T> : T extends string ? TLiteral<T> : T extends bigint ? TBigInt : TObject<{}>;
declare function FromValue<T, Root extends boolean>(value: T, root: Root): FromValue<T, Root>;
export type TConst<T> = FromValue<T, true>;
/** `[JavaScript]` Creates a readonly const type from the given value. */
export declare function Const</* const (not supported in 4.0) */ T>(T: T, options?: SchemaOptions): TConst<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\const\const.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Const = Const;
const index_1 = require("../any/index");
const index_2 = require("../bigint/index");
const index_3 = require("../date/index");
const index_4 = require("../function/index");
const index_5 = require("../literal/index");
const index_6 = require("../null/index");
const index_7 = require("../object/index");
const index_8 = require("../symbol/index");
const index_9 = require("../tuple/index");
const index_10 = require("../readonly/index");
const index_11 = require("../undefined/index");
const index_12 = require("../uint8array/index");
const index_13 = require("../unknown/index");
const index_14 = require("../create/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const value_1 = require("../guard/value");
// prettier-ignore
function FromArray(T) {
    return T.map(L => FromValue(L, false));
}
// prettier-ignore
function FromProperties(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
        Acc[K] = (0, index_10.Readonly)(FromValue(value[K], false));
    return Acc;
}
function ConditionalReadonly(T, root) {
    return (root === true ? T : (0, index_10.Readonly)(T));
}
// prettier-ignore
function FromValue(value, root) {
    return ((0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) :
        (0, value_1.IsIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) :
            (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value))) :
                (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() :
                    (0, value_1.IsDate)(value) ? (0, index_3.Date)() :
                        (0, value_1.IsObject)(value) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value)), root) :
                            (0, value_1.IsFunction)(value) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root) :
                                (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() :
                                    (0, value_1.IsNull)(value) ? (0, index_6.Null)() :
                                        (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() :
                                            (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() :
                                                (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) :
                                                    (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) :
                                                        (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) :
                                                            (0, index_7.Object)({}));
}
/** `[JavaScript]` Creates a readonly const type from the given value. */
function Const(T, options) {
    return (0, index_14.CreateType)(FromValue(T, true), options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\const\index.d.ts

Code:
export * from './const';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\const\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./const"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor\constructor.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import type { Ensure } from '../helpers/index';
import type { TReadonlyOptional } from '../readonly-optional/index';
import type { TReadonly } from '../readonly/index';
import type { TOptional } from '../optional/index';
import { Kind } from '../symbols/index';
type StaticReturnType<U extends TSchema, P extends unknown[]> = Static<U, P>;
type StaticParameter<T extends TSchema, P extends unknown[]> = T extends TReadonlyOptional<T> ? [Readonly<Static<T, P>>?] : T extends TReadonly<T> ? [Readonly<Static<T, P>>] : T extends TOptional<T> ? [Static<T, P>?] : [
    Static<T, P>
];
type StaticParameters<T extends TSchema[], P extends unknown[], Acc extends unknown[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? StaticParameters<R, P, [...Acc, ...StaticParameter<L, P>]> : Acc);
type StaticConstructor<T extends TSchema[], U extends TSchema, P extends unknown[]> = Ensure<new (...param: StaticParameters<T, P>) => StaticReturnType<U, P>>;
export interface TConstructor<T extends TSchema[] = TSchema[], U extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Constructor';
    static: StaticConstructor<T, U, this['params']>;
    type: 'Constructor';
    parameters: T;
    returns: U;
}
/** `[JavaScript]` Creates a Constructor type */
export declare function Constructor<T extends TSchema[], U extends TSchema>(parameters: [...T], returns: U, options?: SchemaOptions): TConstructor<T, U>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor\constructor.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constructor = Constructor;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Constructor type */
function Constructor(parameters, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Constructor', type: 'Constructor', parameters, returns }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor\index.d.ts

Code:
export * from './constructor';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./constructor"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor-parameters\constructor-parameters.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TConstructor } from '../constructor/index';
import { type TTuple } from '../tuple/index';
import { type TNever } from '../never/index';
export type TConstructorParameters<Type extends TSchema> = (Type extends TConstructor<infer Parameters extends TSchema[], infer _InstanceType extends TSchema> ? TTuple<Parameters> : TNever);
/** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
export declare function ConstructorParameters<Type extends TSchema>(schema: Type, options?: SchemaOptions): TConstructorParameters<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor-parameters\constructor-parameters.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorParameters = ConstructorParameters;
const index_1 = require("../tuple/index");
const index_2 = require("../never/index");
const KindGuard = require("../guard/kind");
/** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
function ConstructorParameters(schema, options) {
    return (KindGuard.IsConstructor(schema) ? (0, index_1.Tuple)(schema.parameters, options) : (0, index_2.Never)(options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor-parameters\index.d.ts

Code:
export * from './constructor-parameters';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\constructor-parameters\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./constructor-parameters"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\immutable.d.ts

Code:
/** Specialized deep immutable value. Applies freeze recursively to the given value */
export declare function Immutable(value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\immutable.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Immutable = Immutable;
const ValueGuard = require("../guard/value");
function ImmutableArray(value) {
    return globalThis.Object.freeze(value).map((value) => Immutable(value));
}
function ImmutableDate(value) {
    return value;
}
function ImmutableUint8Array(value) {
    return value;
}
function ImmutableRegExp(value) {
    return value;
}
function ImmutableObject(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Immutable(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Immutable(value[key]);
    }
    return globalThis.Object.freeze(result);
}
/** Specialized deep immutable value. Applies freeze recursively to the given value */
// prettier-ignore
function Immutable(value) {
    return (ValueGuard.IsArray(value) ? ImmutableArray(value) :
        ValueGuard.IsDate(value) ? ImmutableDate(value) :
            ValueGuard.IsUint8Array(value) ? ImmutableUint8Array(value) :
                ValueGuard.IsRegExp(value) ? ImmutableRegExp(value) :
                    ValueGuard.IsObject(value) ? ImmutableObject(value) :
                        value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\index.d.ts

Code:
export * from './type';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./type"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\type.d.ts

Code:
import { SchemaOptions } from '../schema/schema';
/** Creates TypeBox schematics using the configured InstanceMode */
export declare function CreateType(schema: Record<any, unknown>, options?: SchemaOptions): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\create\type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateType = CreateType;
const policy_1 = require("../../system/policy");
const immutable_1 = require("./immutable");
const value_1 = require("../clone/value");
/** Creates TypeBox schematics using the configured InstanceMode */
function CreateType(schema, options) {
    const result = options !== undefined ? { ...options, ...schema } : schema;
    switch (policy_1.TypeSystemPolicy.InstanceMode) {
        case 'freeze':
            return (0, immutable_1.Immutable)(result);
        case 'clone':
            return (0, value_1.Clone)(result);
        default:
            return result;
    }
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\date\date.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface DateOptions extends SchemaOptions {
    /** The exclusive maximum timestamp value */
    exclusiveMaximumTimestamp?: number;
    /** The exclusive minimum timestamp value */
    exclusiveMinimumTimestamp?: number;
    /** The maximum timestamp value */
    maximumTimestamp?: number;
    /** The minimum timestamp value */
    minimumTimestamp?: number;
    /** The multiple of timestamp value */
    multipleOfTimestamp?: number;
}
export interface TDate extends TSchema, DateOptions {
    [Kind]: 'Date';
    static: Date;
    type: 'date';
}
/** `[JavaScript]` Creates a Date type */
export declare function Date(options?: DateOptions): TDate;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\date\date.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Date = Date;
const index_1 = require("../symbols/index");
const type_1 = require("../create/type");
/** `[JavaScript]` Creates a Date type */
function Date(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Date', type: 'Date' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\date\index.d.ts

Code:
export * from './date';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\date\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./date"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\discard\discard.d.ts

Code:
/** Discards property keys from the given value. This function returns a shallow Clone. */
export declare function Discard(value: Record<PropertyKey, any>, keys: PropertyKey[]): Record<PropertyKey, any>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\discard\discard.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Discard = Discard;
function DiscardKey(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
}
/** Discards property keys from the given value. This function returns a shallow Clone. */
function Discard(value, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\discard\index.d.ts

Code:
export * from './discard';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\discard\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./discard"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\enum\enum.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TLiteral } from '../literal/index';
import { Kind, Hint } from '../symbols/index';
export type TEnumRecord = Record<TEnumKey, TEnumValue>;
export type TEnumValue = string | number;
export type TEnumKey = string;
export interface TEnum<T extends Record<string, string | number> = Record<string, string | number>> extends TSchema {
    [Kind]: 'Union';
    [Hint]: 'Enum';
    static: T[keyof T];
    anyOf: TLiteral<T[keyof T]>[];
}
/** `[Json]` Creates a Enum type */
export declare function Enum<V extends TEnumValue, T extends Record<TEnumKey, V>>(item: T, options?: SchemaOptions): TEnum<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\enum\enum.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Enum = Enum;
const index_1 = require("../literal/index");
const index_2 = require("../symbols/index");
const index_3 = require("../union/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const value_1 = require("../guard/value");
/** `[Json]` Creates a Enum type */
function Enum(item, options) {
    if ((0, value_1.IsUndefined)(item))
        throw new Error('Enum undefined or empty');
    const values1 = globalThis.Object.getOwnPropertyNames(item)
        .filter((key) => isNaN(key))
        .map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => (0, index_1.Literal)(value));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: 'Enum' });
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\enum\index.d.ts

Code:
export * from './enum';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\enum\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./enum"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\error\error.d.ts

Code:
/** The base Error type thrown for all TypeBox exceptions  */
export declare class TypeBoxError extends Error {
    constructor(message: string);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\error\error.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeBoxError = void 0;
/** The base Error type thrown for all TypeBox exceptions  */
class TypeBoxError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.TypeBoxError = TypeBoxError;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\error\index.d.ts

Code:
export * from './error';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\error\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./error"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude-from-mapped-result.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TExclude } from './exclude';
type TFromProperties<K extends TProperties, T extends TSchema> = ({
    [K2 in keyof K]: TExclude<K[K2], T>;
});
type TFromMappedResult<R extends TMappedResult, T extends TSchema> = (TFromProperties<R['properties'], T>);
export type TExcludeFromMappedResult<R extends TMappedResult, T extends TSchema, P extends TProperties = TFromMappedResult<R, T>> = (TMappedResult<P>);
export declare function ExcludeFromMappedResult<R extends TMappedResult, T extends TSchema, P extends TProperties = TFromMappedResult<R, T>>(R: R, T: T): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExcludeFromMappedResult = ExcludeFromMappedResult;
const index_1 = require("../mapped/index");
const exclude_1 = require("./exclude");
// prettier-ignore
function FromProperties(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
}
// prettier-ignore
function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude-from-template-literal.d.ts

Code:
import type { TSchema } from '../schema/index';
import { TExclude } from './exclude';
import { type TTemplateLiteral, type TTemplateLiteralToUnion } from '../template-literal/index';
export type TExcludeFromTemplateLiteral<L extends TTemplateLiteral, R extends TSchema> = (TExclude<TTemplateLiteralToUnion<L>, R>);
export declare function ExcludeFromTemplateLiteral<L extends TTemplateLiteral, R extends TSchema>(L: L, R: R): TExcludeFromTemplateLiteral<L, R>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude-from-template-literal.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
const exclude_1 = require("./exclude");
const index_1 = require("../template-literal/index");
function ExcludeFromTemplateLiteral(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { UnionToTuple, AssertRest, AssertType } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import { type TTemplateLiteral } from '../template-literal/index';
import { type TUnion } from '../union/index';
import { type TNever } from '../never/index';
import { type Static } from '../static/index';
import { type TUnionEvaluated } from '../union/index';
import { type TExcludeFromMappedResult } from './exclude-from-mapped-result';
import { type TExcludeFromTemplateLiteral } from './exclude-from-template-literal';
type TExcludeRest<L extends TSchema[], R extends TSchema> = AssertRest<UnionToTuple<{
    [K in keyof L]: Static<AssertType<L[K]>> extends Static<R> ? never : L[K];
}[number]>> extends infer R extends TSchema[] ? TUnionEvaluated<R> : never;
export type TExclude<L extends TSchema, R extends TSchema> = (L extends TUnion<infer S> ? TExcludeRest<S, R> : L extends R ? TNever : L);
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
export declare function Exclude<L extends TMappedResult, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExcludeFromMappedResult<L, R>;
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
export declare function Exclude<L extends TTemplateLiteral, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExcludeFromTemplateLiteral<L, R>;
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
export declare function Exclude<L extends TSchema, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExclude<L, R>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\exclude.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Exclude = Exclude;
const type_1 = require("../create/type");
const index_1 = require("../union/index");
const index_2 = require("../never/index");
const index_3 = require("../extends/index");
const exclude_from_mapped_result_1 = require("./exclude-from-mapped-result");
const exclude_from_template_literal_1 = require("./exclude-from-template-literal");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
}
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
function Exclude(L, R, options = {}) {
    // overloads
    if ((0, kind_1.IsTemplateLiteral)(L))
        return (0, type_1.CreateType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
        return (0, type_1.CreateType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    // prettier-ignore
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) :
        (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\index.d.ts

Code:
export * from './exclude-from-mapped-result';
export * from './exclude-from-template-literal';
export * from './exclude';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\exclude\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./exclude-from-mapped-result"), exports);
__exportStar(require("./exclude-from-template-literal"), exports);
__exportStar(require("./exclude"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-check.d.ts

Code:
import { type TSchema } from '../schema/index';
import { TypeBoxError } from '../error/index';
export declare class ExtendsResolverError extends TypeBoxError {
}
export declare enum ExtendsResult {
    Union = 0,
    True = 1,
    False = 2
}
export declare function ExtendsCheck(left: TSchema, right: TSchema): ExtendsResult;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-check.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendsResult = exports.ExtendsResolverError = void 0;
exports.ExtendsCheck = ExtendsCheck;
const index_1 = require("../any/index");
const index_2 = require("../function/index");
const index_3 = require("../number/index");
const index_4 = require("../string/index");
const index_5 = require("../unknown/index");
const index_6 = require("../template-literal/index");
const index_7 = require("../patterns/index");
const index_8 = require("../symbols/index");
const index_9 = require("../error/index");
const index_10 = require("../guard/index");
class ExtendsResolverError extends index_9.TypeBoxError {
}
exports.ExtendsResolverError = ExtendsResolverError;
var ExtendsResult;
(function (ExtendsResult) {
    ExtendsResult[ExtendsResult["Union"] = 0] = "Union";
    ExtendsResult[ExtendsResult["True"] = 1] = "True";
    ExtendsResult[ExtendsResult["False"] = 2] = "False";
})(ExtendsResult || (exports.ExtendsResult = ExtendsResult = {}));
// ------------------------------------------------------------------
// IntoBooleanResult
// ------------------------------------------------------------------
// prettier-ignore
function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
}
// ------------------------------------------------------------------
// Throw
// ------------------------------------------------------------------
// prettier-ignore
function Throw(message) {
    throw new ExtendsResolverError(message);
}
// ------------------------------------------------------------------
// StructuralRight
// ------------------------------------------------------------------
// prettier-ignore
function IsStructuralRight(right) {
    return (index_10.TypeGuard.IsNever(right) ||
        index_10.TypeGuard.IsIntersect(right) ||
        index_10.TypeGuard.IsUnion(right) ||
        index_10.TypeGuard.IsUnknown(right) ||
        index_10.TypeGuard.IsAny(right));
}
// prettier-ignore
function StructuralRight(left, right) {
    return (index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) :
        index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :
            index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :
                index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :
                    index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) :
                        Throw('StructuralRight'));
}
// ------------------------------------------------------------------
// Any
// ------------------------------------------------------------------
// prettier-ignore
function FromAnyRight(left, right) {
    return ExtendsResult.True;
}
// prettier-ignore
function FromAny(left, right) {
    return (index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :
        (index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema))) ? ExtendsResult.True :
            index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union :
                index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True :
                    index_10.TypeGuard.IsAny(right) ? ExtendsResult.True :
                        ExtendsResult.Union);
}
// ------------------------------------------------------------------
// Array
// ------------------------------------------------------------------
// prettier-ignore
function FromArrayRight(left, right) {
    return (index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False :
        index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union :
            index_10.TypeGuard.IsNever(left) ? ExtendsResult.True :
                ExtendsResult.False);
}
// prettier-ignore
function FromArray(left, right) {
    return (index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// AsyncIterator
// ------------------------------------------------------------------
// prettier-ignore
function FromAsyncIterator(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False :
            IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// BigInt
// ------------------------------------------------------------------
// prettier-ignore
function FromBigInt(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Boolean
// ------------------------------------------------------------------
// prettier-ignore
function FromBooleanRight(left, right) {
    return (index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True :
        index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromBoolean(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Constructor
// ------------------------------------------------------------------
// prettier-ignore
function FromConstructor(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False :
                left.parameters.length > right.parameters.length ? ExtendsResult.False :
                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                        IntoBooleanResult(Visit(left.returns, right.returns)));
}
// ------------------------------------------------------------------
// Date
// ------------------------------------------------------------------
// prettier-ignore
function FromDate(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsDate(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Function
// ------------------------------------------------------------------
// prettier-ignore
function FromFunction(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False :
                left.parameters.length > right.parameters.length ? ExtendsResult.False :
                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                        IntoBooleanResult(Visit(left.returns, right.returns)));
}
// ------------------------------------------------------------------
// Integer
// ------------------------------------------------------------------
// prettier-ignore
function FromIntegerRight(left, right) {
    return (index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True :
        index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromInteger(left, right) {
    return (index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
                index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Intersect
// ------------------------------------------------------------------
// prettier-ignore
function FromIntersectRight(left, right) {
    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// prettier-ignore
function FromIntersect(left, right) {
    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// ------------------------------------------------------------------
// Iterator
// ------------------------------------------------------------------
// prettier-ignore
function FromIterator(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False :
            IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// Literal
// ------------------------------------------------------------------
// prettier-ignore
function FromLiteral(left, right) {
    return (index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
                index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                    index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) :
                        index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :
                            index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :
                                index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :
                                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Never
// ------------------------------------------------------------------
// prettier-ignore
function FromNeverRight(left, right) {
    return ExtendsResult.False;
}
// prettier-ignore
function FromNever(left, right) {
    return ExtendsResult.True;
}
// ------------------------------------------------------------------
// Not
// ------------------------------------------------------------------
// prettier-ignore
function UnwrapTNot(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
        if (!index_10.TypeGuard.IsNot(current))
            break;
        current = current.not;
        depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
}
// prettier-ignore
function FromNot(left, right) {
    // TypeScript has no concept of negated types, and attempts to correctly check the negated
    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer
    // the type. Instead we unwrap to either unknown or T and continue evaluating.
    // prettier-ignore
    return (index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) :
        index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) :
            Throw('Invalid fallthrough for Not'));
}
// ------------------------------------------------------------------
// Null
// ------------------------------------------------------------------
// prettier-ignore
function FromNull(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsNull(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Number
// ------------------------------------------------------------------
// prettier-ignore
function FromNumberRight(left, right) {
    return (index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True :
        index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromNumber(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Object
// ------------------------------------------------------------------
// prettier-ignore
function IsObjectPropertyCount(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
}
// prettier-ignore
function IsObjectStringLike(schema) {
    return IsObjectArrayLike(schema);
}
// prettier-ignore
function IsObjectSymbolLike(schema) {
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) &&
        index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1])) || (index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) &&
        index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]))));
}
// prettier-ignore
function IsObjectNumberLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectBooleanLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectBigIntLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectDateLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectUint8ArrayLike(schema) {
    return IsObjectArrayLike(schema);
}
// prettier-ignore
function IsObjectFunctionLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);
}
// prettier-ignore
function IsObjectConstructorLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectArrayLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);
}
// prettier-ignore
function IsObjectPromiseLike(schema) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);
}
// ------------------------------------------------------------------
// Property
// ------------------------------------------------------------------
// prettier-ignore
function Property(left, right) {
    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :
        index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False :
            ExtendsResult.True);
}
// prettier-ignore
function FromObjectRight(left, right) {
    return (index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False :
        index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : (index_10.TypeGuard.IsNever(left) ||
            (index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right)) ||
            (index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||
            (index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
            (index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||
            (index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right)) ||
            (index_10.TypeGuard.IsString(left) && IsObjectStringLike(right)) ||
            (index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||
            (index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right)) ||
            (index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right)) ||
            (index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right)) ||
            (index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||
            (index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right)) ||
            (index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right)) ||
            (index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :
            (index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left))) ? (() => {
                // When expressing a Record with literal key values, the Record is converted into a Object with
                // the Hint assigned as `Record`. This is used to invert the extends logic.
                return right[index_8.Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;
            })() :
                (index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left))) ? (() => {
                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
                })() :
                    ExtendsResult.False);
}
// prettier-ignore
function FromObject(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
            !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False :
                (() => {
                    for (const key of Object.getOwnPropertyNames(right.properties)) {
                        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
                            return ExtendsResult.False;
                        }
                        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
                            return ExtendsResult.True;
                        }
                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
                            return ExtendsResult.False;
                        }
                    }
                    return ExtendsResult.True;
                })());
}
// ------------------------------------------------------------------
// Promise
// ------------------------------------------------------------------
// prettier-ignore
function FromPromise(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :
            !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit(left.item, right.item)));
}
// ------------------------------------------------------------------
// Record
// ------------------------------------------------------------------
// prettier-ignore
function RecordKey(schema) {
    return (index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() :
        index_7.PatternStringExact in schema.patternProperties ? (0, index_4.String)() :
            Throw('Unknown record key pattern'));
}
// prettier-ignore
function RecordValue(schema) {
    return (index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] :
        index_7.PatternStringExact in schema.patternProperties ? schema.patternProperties[index_7.PatternStringExact] :
            Throw('Unable to get record value schema'));
}
// prettier-ignore
function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return ((index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :
        index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) :
            index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) :
                index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) :
                    index_10.TypeGuard.IsObject(left) ? (() => {
                        for (const key of Object.getOwnPropertyNames(left.properties)) {
                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {
                                return ExtendsResult.False;
                            }
                        }
                        return ExtendsResult.True;
                    })() :
                        ExtendsResult.False);
}
// prettier-ignore
function FromRecord(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False :
                Visit(RecordValue(left), RecordValue(right)));
}
// ------------------------------------------------------------------
// RegExp
// ------------------------------------------------------------------
// prettier-ignore
function FromRegExp(left, right) {
    // Note: RegExp types evaluate as strings, not RegExp objects.
    // Here we remap either into string and continue evaluating.
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit(L, R);
}
// ------------------------------------------------------------------
// String
// ------------------------------------------------------------------
// prettier-ignore
function FromStringRight(left, right) {
    return (index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True :
        index_10.TypeGuard.IsString(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromString(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsString(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Symbol
// ------------------------------------------------------------------
// prettier-ignore
function FromSymbol(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// TemplateLiteral
// ------------------------------------------------------------------
// prettier-ignore
function FromTemplateLiteral(left, right) {
    // TemplateLiteral types are resolved to either unions for finite expressions or string
    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for
    // either type and continue evaluating.
    return (index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) :
        index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) :
            Throw('Invalid fallthrough for TemplateLiteral'));
}
// ------------------------------------------------------------------
// Tuple
// ------------------------------------------------------------------
// prettier-ignore
function IsArrayOfTuple(left, right) {
    return (index_10.TypeGuard.IsArray(right) &&
        left.items !== undefined &&
        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));
}
// prettier-ignore
function FromTupleRight(left, right) {
    return (index_10.TypeGuard.IsNever(left) ? ExtendsResult.True :
        index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False :
            index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union :
                ExtendsResult.False);
}
// prettier-ignore
function FromTuple(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
            index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :
                !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False :
                    (index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items)) || (!index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items)) ? ExtendsResult.False :
                        (index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items)) ? ExtendsResult.True :
                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :
                                ExtendsResult.False);
}
// ------------------------------------------------------------------
// Uint8Array
// ------------------------------------------------------------------
// prettier-ignore
function FromUint8Array(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Undefined
// ------------------------------------------------------------------
// prettier-ignore
function FromUndefined(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
            index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :
                index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left, right) :
                    index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True :
                        ExtendsResult.False);
}
// ------------------------------------------------------------------
// Union
// ------------------------------------------------------------------
// prettier-ignore
function FromUnionRight(left, right) {
    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// prettier-ignore
function FromUnion(left, right) {
    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// ------------------------------------------------------------------
// Unknown
// ------------------------------------------------------------------
// prettier-ignore
function FromUnknownRight(left, right) {
    return ExtendsResult.True;
}
// prettier-ignore
function FromUnknown(left, right) {
    return (index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) :
        index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :
            index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :
                index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) :
                    index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) :
                        index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :
                            index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :
                                index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :
                                    index_10.TypeGuard.IsArray(right) ? FromArrayRight(left, right) :
                                        index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left, right) :
                                            index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
                                                index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True :
                                                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Void
// ------------------------------------------------------------------
// prettier-ignore
function FromVoidRight(left, right) {
    return (index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True :
        index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromVoid(left, right) {
    return (index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :
        index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :
            index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :
                index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) :
                    index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) :
                        index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True :
                            ExtendsResult.False);
}
// prettier-ignore
function Visit(left, right) {
    return (
    // resolvable
    (index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right)) ? FromTemplateLiteral(left, right) :
        (index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right)) ? FromRegExp(left, right) :
            (index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right)) ? FromNot(left, right) :
                // standard
                index_10.TypeGuard.IsAny(left) ? FromAny(left, right) :
                    index_10.TypeGuard.IsArray(left) ? FromArray(left, right) :
                        index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) :
                            index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) :
                                index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) :
                                    index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) :
                                        index_10.TypeGuard.IsDate(left) ? FromDate(left, right) :
                                            index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) :
                                                index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) :
                                                    index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) :
                                                        index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) :
                                                            index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) :
                                                                index_10.TypeGuard.IsNever(left) ? FromNever(left, right) :
                                                                    index_10.TypeGuard.IsNull(left) ? FromNull(left, right) :
                                                                        index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) :
                                                                            index_10.TypeGuard.IsObject(left) ? FromObject(left, right) :
                                                                                index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) :
                                                                                    index_10.TypeGuard.IsString(left) ? FromString(left, right) :
                                                                                        index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) :
                                                                                            index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) :
                                                                                                index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) :
                                                                                                    index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) :
                                                                                                        index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) :
                                                                                                            index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) :
                                                                                                                index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) :
                                                                                                                    index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) :
                                                                                                                        Throw(`Unknown left type operand '${left[index_8.Kind]}'`));
}
function ExtendsCheck(left, right) {
    return Visit(left, right);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-from-mapped-key.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import type { Assert } from '../helpers/index';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TExtends } from './extends';
type TFromPropertyKey<K extends PropertyKey, U extends TSchema, L extends TSchema, R extends TSchema> = {
    [_ in K]: TExtends<TLiteral<Assert<K, TLiteralValue>>, U, L, R>;
};
type TFromPropertyKeys<K extends PropertyKey[], U extends TSchema, L extends TSchema, R extends TSchema, Acc extends TProperties = {}> = (K extends [infer LK extends PropertyKey, ...infer RK extends PropertyKey[]] ? TFromPropertyKeys<RK, U, L, R, Acc & TFromPropertyKey<LK, U, L, R>> : Acc);
type TFromMappedKey<K extends TMappedKey, U extends TSchema, L extends TSchema, R extends TSchema> = (TFromPropertyKeys<K['keys'], U, L, R>);
export type TExtendsFromMappedKey<T extends TMappedKey, U extends TSchema, L extends TSchema, R extends TSchema, P extends TProperties = TFromMappedKey<T, U, L, R>> = (TMappedResult<P>);
export declare function ExtendsFromMappedKey<T extends TMappedKey, U extends TSchema, L extends TSchema, R extends TSchema, P extends TProperties = TFromMappedKey<T, U, L, R>>(T: T, U: U, L: L, R: R, options?: SchemaOptions): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-from-mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendsFromMappedKey = ExtendsFromMappedKey;
const index_1 = require("../mapped/index");
const index_2 = require("../literal/index");
const extends_1 = require("./extends");
const value_1 = require("../clone/value");
// prettier-ignore
function FromPropertyKey(K, U, L, R, options) {
    return {
        [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, (0, value_1.Clone)(options))
    };
}
// prettier-ignore
function FromPropertyKeys(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey(K, U, L, R, options) {
    return FromPropertyKeys(K.keys, U, L, R, options);
}
// prettier-ignore
function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-from-mapped-result.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TExtends } from './extends';
type TFromProperties<P extends TProperties, Right extends TSchema, False extends TSchema, True extends TSchema> = ({
    [K2 in keyof P]: TExtends<P[K2], Right, False, True>;
});
type TFromMappedResult<Left extends TMappedResult, Right extends TSchema, True extends TSchema, False extends TSchema> = (TFromProperties<Left['properties'], Right, True, False>);
export type TExtendsFromMappedResult<Left extends TMappedResult, Right extends TSchema, True extends TSchema, False extends TSchema, P extends TProperties = TFromMappedResult<Left, Right, True, False>> = (TMappedResult<P>);
export declare function ExtendsFromMappedResult<Left extends TMappedResult, Right extends TSchema, True extends TSchema, False extends TSchema, P extends TProperties = TFromMappedResult<Left, Right, True, False>>(Left: Left, Right: Right, True: True, False: False, options?: SchemaOptions): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendsFromMappedResult = ExtendsFromMappedResult;
const index_1 = require("../mapped/index");
const extends_1 = require("./extends");
const value_1 = require("../clone/value");
// prettier-ignore
function FromProperties(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, (0, value_1.Clone)(options));
    return Acc;
}
// prettier-ignore
function FromMappedResult(Left, Right, True, False, options) {
    return FromProperties(Left.properties, Right, True, False, options);
}
// prettier-ignore
function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-undefined.d.ts

Code:
import type { TSchema } from '../schema/index';
/** Fast undefined check used for properties of type undefined */
export declare function ExtendsUndefinedCheck(schema: TSchema): boolean;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends-undefined.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
const index_1 = require("../symbols/index");
/** Fast undefined check used for properties of type undefined */
function Intersect(schema) {
    return schema.allOf.every((schema) => ExtendsUndefinedCheck(schema));
}
function Union(schema) {
    return schema.anyOf.some((schema) => ExtendsUndefinedCheck(schema));
}
function Not(schema) {
    return !ExtendsUndefinedCheck(schema.not);
}
/** Fast undefined check used for properties of type undefined */
// prettier-ignore
function ExtendsUndefinedCheck(schema) {
    return (schema[index_1.Kind] === 'Intersect' ? Intersect(schema) :
        schema[index_1.Kind] === 'Union' ? Union(schema) :
            schema[index_1.Kind] === 'Not' ? Not(schema) :
                schema[index_1.Kind] === 'Undefined' ? true :
                    false);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { type TUnion } from '../union/index';
import { TMappedKey, TMappedResult } from '../mapped/index';
import { UnionToTuple } from '../helpers/index';
import { type TExtendsFromMappedKey } from './extends-from-mapped-key';
import { type TExtendsFromMappedResult } from './extends-from-mapped-result';
type TExtendsResolve<L extends TSchema, R extends TSchema, T extends TSchema, U extends TSchema> = ((Static<L> extends Static<R> ? T : U) extends infer O extends TSchema ? UnionToTuple<O> extends [infer X extends TSchema, infer Y extends TSchema] ? TUnion<[X, Y]> : O : never);
export type TExtends<L extends TSchema, R extends TSchema, T extends TSchema, F extends TSchema> = TExtendsResolve<L, R, T, F>;
/** `[Json]` Creates a Conditional type */
export declare function Extends<L extends TMappedResult, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtendsFromMappedResult<L, R, T, F>;
/** `[Json]` Creates a Conditional type */
export declare function Extends<L extends TMappedKey, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtendsFromMappedKey<L, R, T, F>;
/** `[Json]` Creates a Conditional type */
export declare function Extends<L extends TSchema, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtends<L, R, T, F>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\extends.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Extends = Extends;
const type_1 = require("../create/type");
const index_1 = require("../union/index");
const extends_check_1 = require("./extends-check");
const extends_from_mapped_key_1 = require("./extends-from-mapped-key");
const extends_from_mapped_result_1 = require("./extends-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function ExtendsResolve(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return (R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) :
        R === extends_check_1.ExtendsResult.True ? trueType :
            falseType);
}
/** `[Json]` Creates a Conditional type */
function Extends(L, R, T, F, options) {
    // prettier-ignore
    return ((0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) :
        (0, kind_1.IsMappedKey)(L) ? (0, type_1.CreateType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) :
            (0, type_1.CreateType)(ExtendsResolve(L, R, T, F), options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\index.d.ts

Code:
export * from './extends-check';
export * from './extends-from-mapped-key';
export * from './extends-from-mapped-result';
export * from './extends-undefined';
export * from './extends';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extends\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./extends-check"), exports);
__exportStar(require("./extends-from-mapped-key"), exports);
__exportStar(require("./extends-from-mapped-result"), exports);
__exportStar(require("./extends-undefined"), exports);
__exportStar(require("./extends"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract-from-mapped-result.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TExtract } from './extract';
type TFromProperties<P extends TProperties, T extends TSchema> = ({
    [K2 in keyof P]: TExtract<P[K2], T>;
});
type TFromMappedResult<R extends TMappedResult, T extends TSchema> = (TFromProperties<R['properties'], T>);
export type TExtractFromMappedResult<R extends TMappedResult, T extends TSchema, P extends TProperties = TFromMappedResult<R, T>> = (TMappedResult<P>);
export declare function ExtractFromMappedResult<R extends TMappedResult, T extends TSchema, P extends TProperties = TFromMappedResult<R, T>>(R: R, T: T): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtractFromMappedResult = ExtractFromMappedResult;
const index_1 = require("../mapped/index");
const extract_1 = require("./extract");
// prettier-ignore
function FromProperties(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
}
// prettier-ignore
function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract-from-template-literal.d.ts

Code:
import type { TSchema } from '../schema/index';
import { type TExtract } from './extract';
import { type TTemplateLiteral, type TTemplateLiteralToUnion } from '../template-literal/index';
export type TExtractFromTemplateLiteral<L extends TTemplateLiteral, R extends TSchema> = (TExtract<TTemplateLiteralToUnion<L>, R>);
export declare function ExtractFromTemplateLiteral<L extends TTemplateLiteral, R extends TSchema>(L: L, R: R): TExtractFromTemplateLiteral<L, R>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract-from-template-literal.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
const extract_1 = require("./extract");
const index_1 = require("../template-literal/index");
function ExtractFromTemplateLiteral(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { AssertRest, AssertType, UnionToTuple } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import { type TUnion } from '../union/index';
import { type Static } from '../static/index';
import { type TNever } from '../never/index';
import { type TUnionEvaluated } from '../union/index';
import { type TTemplateLiteral } from '../template-literal/index';
import { type TExtractFromMappedResult } from './extract-from-mapped-result';
import { type TExtractFromTemplateLiteral } from './extract-from-template-literal';
type TExtractRest<L extends TSchema[], R extends TSchema> = AssertRest<UnionToTuple<{
    [K in keyof L]: Static<AssertType<L[K]>> extends Static<R> ? L[K] : never;
}[number]>> extends infer R extends TSchema[] ? TUnionEvaluated<R> : never;
export type TExtract<L extends TSchema, U extends TSchema> = (L extends TUnion<infer S> ? TExtractRest<S, U> : L extends U ? L : TNever);
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TMappedResult, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtractFromMappedResult<L, R>;
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TTemplateLiteral, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtractFromTemplateLiteral<L, R>;
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TSchema, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtract<L, R>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\extract.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Extract = Extract;
const type_1 = require("../create/type");
const index_1 = require("../union/index");
const index_2 = require("../never/index");
const index_3 = require("../extends/index");
const extract_from_mapped_result_1 = require("./extract-from-mapped-result");
const extract_from_template_literal_1 = require("./extract-from-template-literal");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
function ExtractRest(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
}
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
function Extract(L, R, options) {
    // overloads
    if ((0, kind_1.IsTemplateLiteral)(L))
        return (0, type_1.CreateType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
        return (0, type_1.CreateType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    // prettier-ignore
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) :
        (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\index.d.ts

Code:
export * from './extract-from-mapped-result';
export * from './extract-from-template-literal';
export * from './extract';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\extract\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./extract-from-mapped-result"), exports);
__exportStar(require("./extract-from-template-literal"), exports);
__exportStar(require("./extract"), exports);


---

