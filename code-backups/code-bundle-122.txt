File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\create\create.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueCreateError = void 0;
exports.Create = Create;
const index_1 = require("../guard/index");
const index_2 = require("../check/index");
const index_3 = require("../clone/index");
const index_4 = require("../deref/index");
const index_5 = require("../../type/template-literal/index");
const index_6 = require("../../type/registry/index");
const index_7 = require("../../type/symbols/index");
const index_8 = require("../../type/error/index");
const guard_1 = require("../guard/guard");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueCreateError extends index_8.TypeBoxError {
    constructor(schema, message) {
        super(message);
        this.schema = schema;
    }
}
exports.ValueCreateError = ValueCreateError;
// ------------------------------------------------------------------
// Default
// ------------------------------------------------------------------
function FromDefault(value) {
    return (0, guard_1.IsFunction)(value) ? value() : (0, index_3.Clone)(value);
}
// ------------------------------------------------------------------
// Create
// ------------------------------------------------------------------
function FromAny(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return {};
    }
}
function FromArgument(schema, references) {
    return {};
}
function FromArray(schema, references) {
    if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, 'default')) {
        throw new ValueCreateError(schema, 'Array with the uniqueItems constraint requires a default value');
    }
    else if ('contains' in schema && !(0, index_1.HasPropertyKey)(schema, 'default')) {
        throw new ValueCreateError(schema, 'Array with the contains constraint requires a default value');
    }
    else if ('default' in schema) {
        return FromDefault(schema.default);
    }
    else if (schema.minItems !== undefined) {
        return Array.from({ length: schema.minItems }).map((item) => {
            return Visit(schema.items, references);
        });
    }
    else {
        return [];
    }
}
function FromAsyncIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return (async function* () { })();
    }
}
function FromBigInt(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return BigInt(0);
    }
}
function FromBoolean(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return false;
    }
}
function FromConstructor(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        const value = Visit(schema.returns, references);
        if (typeof value === 'object' && !Array.isArray(value)) {
            return class {
                constructor() {
                    for (const [key, val] of Object.entries(value)) {
                        const self = this;
                        self[key] = val;
                    }
                }
            };
        }
        else {
            return class {
            };
        }
    }
}
function FromDate(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if (schema.minimumTimestamp !== undefined) {
        return new Date(schema.minimumTimestamp);
    }
    else {
        return new Date();
    }
}
function FromFunction(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return () => Visit(schema.returns, references);
    }
}
function FromImport(schema, references) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions]);
}
function FromInteger(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if (schema.minimum !== undefined) {
        return schema.minimum;
    }
    else {
        return 0;
    }
}
function FromIntersect(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        // --------------------------------------------------------------
        // Note: The best we can do here is attempt to instance each
        // sub type and apply through object assign. For non-object
        // sub types, we just escape the assignment and just return
        // the value. In the latter case, this is typically going to
        // be a consequence of an illogical intersection.
        // --------------------------------------------------------------
        const value = schema.allOf.reduce((acc, schema) => {
            const next = Visit(schema, references);
            return typeof next === 'object' ? { ...acc, ...next } : next;
        }, {});
        if (!(0, index_2.Check)(schema, references, value))
            throw new ValueCreateError(schema, 'Intersect produced invalid value. Consider using a default value.');
        return value;
    }
}
function FromIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return (function* () { })();
    }
}
function FromLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return schema.const;
    }
}
function FromNever(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        throw new ValueCreateError(schema, 'Never types cannot be created. Consider using a default value.');
    }
}
function FromNot(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        throw new ValueCreateError(schema, 'Not types must have a default value');
    }
}
function FromNull(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return null;
    }
}
function FromNumber(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if (schema.minimum !== undefined) {
        return schema.minimum;
    }
    else {
        return 0;
    }
}
function FromObject(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        const required = new Set(schema.required);
        const Acc = {};
        for (const [key, subschema] of Object.entries(schema.properties)) {
            if (!required.has(key))
                continue;
            Acc[key] = Visit(subschema, references);
        }
        return Acc;
    }
}
function FromPromise(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return Promise.resolve(Visit(schema.item, references));
    }
}
function FromRecord(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return {};
    }
}
function FromRef(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return Visit((0, index_4.Deref)(schema, references), references);
    }
}
function FromRegExp(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        throw new ValueCreateError(schema, 'RegExp types cannot be created. Consider using a default value.');
    }
}
function FromString(schema, references) {
    if (schema.pattern !== undefined) {
        if (!(0, index_1.HasPropertyKey)(schema, 'default')) {
            throw new ValueCreateError(schema, 'String types with patterns must specify a default value');
        }
        else {
            return FromDefault(schema.default);
        }
    }
    else if (schema.format !== undefined) {
        if (!(0, index_1.HasPropertyKey)(schema, 'default')) {
            throw new ValueCreateError(schema, 'String types with formats must specify a default value');
        }
        else {
            return FromDefault(schema.default);
        }
    }
    else {
        if ((0, index_1.HasPropertyKey)(schema, 'default')) {
            return FromDefault(schema.default);
        }
        else if (schema.minLength !== undefined) {
            // prettier-ignore
            return Array.from({ length: schema.minLength }).map(() => ' ').join('');
        }
        else {
            return '';
        }
    }
}
function FromSymbol(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if ('value' in schema) {
        return Symbol.for(schema.value);
    }
    else {
        return Symbol();
    }
}
function FromTemplateLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema))
        throw new ValueCreateError(schema, 'Can only create template literals that produce a finite variants. Consider using a default value.');
    const generated = (0, index_5.TemplateLiteralGenerate)(schema);
    return generated[0];
}
function FromThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
        throw new ValueCreateError(schema, 'Cannot create recursive type as it appears possibly infinite. Consider using a default.');
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return Visit((0, index_4.Deref)(schema, references), references);
    }
}
function FromTuple(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    if (schema.items === undefined) {
        return [];
    }
    else {
        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
}
function FromUndefined(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return undefined;
    }
}
function FromUnion(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if (schema.anyOf.length === 0) {
        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');
    }
    else {
        return Visit(schema.anyOf[0], references);
    }
}
function FromUint8Array(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else if (schema.minByteLength !== undefined) {
        return new Uint8Array(schema.minByteLength);
    }
    else {
        return new Uint8Array(0);
    }
}
function FromUnknown(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return {};
    }
}
function FromVoid(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        return void 0;
    }
}
function FromKind(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, 'default')) {
        return FromDefault(schema.default);
    }
    else {
        throw new Error('User defined types must specify a default value');
    }
}
function Visit(schema, references) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema_[index_7.Kind]) {
        case 'Any':
            return FromAny(schema_, references_);
        case 'Argument':
            return FromArgument(schema_, references_);
        case 'Array':
            return FromArray(schema_, references_);
        case 'AsyncIterator':
            return FromAsyncIterator(schema_, references_);
        case 'BigInt':
            return FromBigInt(schema_, references_);
        case 'Boolean':
            return FromBoolean(schema_, references_);
        case 'Constructor':
            return FromConstructor(schema_, references_);
        case 'Date':
            return FromDate(schema_, references_);
        case 'Function':
            return FromFunction(schema_, references_);
        case 'Import':
            return FromImport(schema_, references_);
        case 'Integer':
            return FromInteger(schema_, references_);
        case 'Intersect':
            return FromIntersect(schema_, references_);
        case 'Iterator':
            return FromIterator(schema_, references_);
        case 'Literal':
            return FromLiteral(schema_, references_);
        case 'Never':
            return FromNever(schema_, references_);
        case 'Not':
            return FromNot(schema_, references_);
        case 'Null':
            return FromNull(schema_, references_);
        case 'Number':
            return FromNumber(schema_, references_);
        case 'Object':
            return FromObject(schema_, references_);
        case 'Promise':
            return FromPromise(schema_, references_);
        case 'Record':
            return FromRecord(schema_, references_);
        case 'Ref':
            return FromRef(schema_, references_);
        case 'RegExp':
            return FromRegExp(schema_, references_);
        case 'String':
            return FromString(schema_, references_);
        case 'Symbol':
            return FromSymbol(schema_, references_);
        case 'TemplateLiteral':
            return FromTemplateLiteral(schema_, references_);
        case 'This':
            return FromThis(schema_, references_);
        case 'Tuple':
            return FromTuple(schema_, references_);
        case 'Undefined':
            return FromUndefined(schema_, references_);
        case 'Union':
            return FromUnion(schema_, references_);
        case 'Uint8Array':
            return FromUint8Array(schema_, references_);
        case 'Unknown':
            return FromUnknown(schema_, references_);
        case 'Void':
            return FromVoid(schema_, references_);
        default:
            if (!index_6.TypeRegistry.Has(schema_[index_7.Kind]))
                throw new ValueCreateError(schema_, 'Unknown type');
            return FromKind(schema_, references_);
    }
}
// ------------------------------------------------------------------
// State
// ------------------------------------------------------------------
const recursiveMaxDepth = 512;
let recursiveDepth = 0;
/** Creates a value from the given schema */
function Create(...args) {
    recursiveDepth = 0;
    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\create\index.d.ts

Code:
export * from './create';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\create\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./create"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\decode\decode.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
import type { StaticDecode } from '../../type/static/index';
/** Decodes a value or throws if error */
export declare function Decode<T extends TSchema, Static = StaticDecode<T>, Result extends Static = Static>(schema: T, references: TSchema[], value: unknown): Result;
/** Decodes a value or throws if error */
export declare function Decode<T extends TSchema, Static = StaticDecode<T>, Result extends Static = Static>(schema: T, value: unknown): Result;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\decode\decode.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Decode = Decode;
const index_1 = require("../transform/index");
const index_2 = require("../check/index");
const index_3 = require("../../errors/index");
/** Decodes a value or throws if error */
function Decode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!(0, index_2.Check)(schema, references, value))
        throw new index_1.TransformDecodeCheckError(schema, value, (0, index_3.Errors)(schema, references, value).First());
    return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\decode\index.d.ts

Code:
export * from './decode';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\decode\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./decode"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\default\default.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */
export declare function Default(schema: TSchema, references: TSchema[], value: unknown): unknown;
/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */
export declare function Default(schema: TSchema, value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\default\default.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Default = Default;
const index_1 = require("../check/index");
const index_2 = require("../clone/index");
const index_3 = require("../deref/index");
const index_4 = require("../../type/symbols/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_5 = require("../guard/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// ValueOrDefault
// ------------------------------------------------------------------
function ValueOrDefault(schema, value) {
    const defaultValue = (0, index_5.HasPropertyKey)(schema, 'default') ? schema.default : undefined;
    const clone = (0, index_5.IsFunction)(defaultValue) ? defaultValue() : (0, index_2.Clone)(defaultValue);
    return (0, index_5.IsUndefined)(value) ? clone : (0, index_5.IsObject)(value) && (0, index_5.IsObject)(clone) ? Object.assign(clone, value) : value;
}
// ------------------------------------------------------------------
// HasDefaultProperty
// ------------------------------------------------------------------
function HasDefaultProperty(schema) {
    return (0, kind_1.IsKind)(schema) && 'default' in schema;
}
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
function FromArray(schema, references, value) {
    // if the value is an array, we attempt to initialize it's elements
    if ((0, index_5.IsArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            value[i] = Visit(schema.items, references, value[i]);
        }
        return value;
    }
    // ... otherwise use default initialization
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted))
        return defaulted;
    for (let i = 0; i < defaulted.length; i++) {
        defaulted[i] = Visit(schema.items, references, defaulted[i]);
    }
    return defaulted;
}
function FromDate(schema, references, value) {
    // special case intercept for dates
    return (0, index_5.IsDate)(value) ? value : ValueOrDefault(schema, value);
}
function FromImport(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions], value);
}
function FromIntersect(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    return schema.allOf.reduce((acc, schema) => {
        const next = Visit(schema, references, defaulted);
        return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
    }, {});
}
function FromObject(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    // return defaulted
    if (!(0, index_5.IsObject)(defaulted))
        return defaulted;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
    // properties
    for (const key of knownPropertyKeys) {
        // note: we need to traverse into the object and test if the return value
        // yielded a non undefined result. Here we interpret an undefined result as
        // a non assignable property and continue.
        const propertyValue = Visit(schema.properties[key], references, defaulted[key]);
        if ((0, index_5.IsUndefined)(propertyValue))
            continue;
        defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);
    }
    // return if not additional properties
    if (!HasDefaultProperty(schema.additionalProperties))
        return defaulted;
    // additional properties
    for (const key of Object.getOwnPropertyNames(defaulted)) {
        if (knownPropertyKeys.includes(key))
            continue;
        defaulted[key] = Visit(schema.additionalProperties, references, defaulted[key]);
    }
    return defaulted;
}
function FromRecord(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
        return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    // properties
    for (const key of Object.getOwnPropertyNames(defaulted)) {
        if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
            continue;
        defaulted[key] = Visit(propertySchema, references, defaulted[key]);
    }
    // return if not additional properties
    if (!HasDefaultProperty(additionalPropertiesSchema))
        return defaulted;
    // additional properties
    for (const key of Object.getOwnPropertyNames(defaulted)) {
        if (knownPropertyKey.test(key))
            continue;
        defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
}
function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
}
function FromTuple(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
        return defaulted;
    const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
    for (let i = 0; i < max; i++) {
        if (i < items.length)
            defaulted[i] = Visit(items[i], references, defaulted[i]);
    }
    return defaulted;
}
function FromUnion(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    for (const inner of schema.anyOf) {
        const result = Visit(inner, references, (0, index_2.Clone)(defaulted));
        if ((0, index_1.Check)(inner, references, result)) {
            return result;
        }
    }
    return defaulted;
}
function Visit(schema, references, value) {
    const references_ = (0, index_3.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'Date':
            return FromDate(schema_, references_, value);
        case 'Import':
            return FromImport(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        default:
            return ValueOrDefault(schema_, value);
    }
}
/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */
function Default(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\default\index.d.ts

Code:
export * from './default';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\default\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./default"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\delta\delta.d.ts

Code:
import type { Static } from '../../type/static/index';
import { TypeBoxError } from '../../type/error/index';
import { type TLiteral } from '../../type/literal/index';
import { type TObject } from '../../type/object/index';
import { type TString } from '../../type/string/index';
import { type TUnknown } from '../../type/unknown/index';
import { type TUnion } from '../../type/union/index';
export type Insert = Static<typeof Insert>;
export declare const Insert: TObject<{
    type: TLiteral<'insert'>;
    path: TString;
    value: TUnknown;
}>;
export type Update = Static<typeof Update>;
export declare const Update: TObject<{
    type: TLiteral<'update'>;
    path: TString;
    value: TUnknown;
}>;
export type Delete = Static<typeof Delete>;
export declare const Delete: TObject<{
    type: TLiteral<'delete'>;
    path: TString;
}>;
export type Edit = Static<typeof Edit>;
export declare const Edit: TUnion<[typeof Insert, typeof Update, typeof Delete]>;
export declare class ValueDiffError extends TypeBoxError {
    readonly value: unknown;
    constructor(value: unknown, message: string);
}
export declare function Diff(current: unknown, next: unknown): Edit[];
export declare function Patch<T = any>(current: unknown, edits: Edit[]): T;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\delta\delta.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueDiffError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
exports.Diff = Diff;
exports.Patch = Patch;
const index_1 = require("../guard/index");
const index_2 = require("../pointer/index");
const index_3 = require("../clone/index");
const equal_1 = require("../equal/equal");
const index_4 = require("../../type/error/index");
const index_5 = require("../../type/literal/index");
const index_6 = require("../../type/object/index");
const index_7 = require("../../type/string/index");
const index_8 = require("../../type/unknown/index");
const index_9 = require("../../type/union/index");
exports.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)('insert'),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)(),
});
exports.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)('update'),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)(),
});
exports.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)('delete'),
    path: (0, index_7.String)(),
});
exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueDiffError extends index_4.TypeBoxError {
    constructor(value, message) {
        super(message);
        this.value = value;
    }
}
exports.ValueDiffError = ValueDiffError;
// ------------------------------------------------------------------
// Command Factory
// ------------------------------------------------------------------
function CreateUpdate(path, value) {
    return { type: 'update', path, value };
}
function CreateInsert(path, value) {
    return { type: 'insert', path, value };
}
function CreateDelete(path) {
    return { type: 'delete', path };
}
// ------------------------------------------------------------------
// AssertDiffable
// ------------------------------------------------------------------
function AssertDiffable(value) {
    if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
        throw new ValueDiffError(value, 'Cannot diff objects with symbols');
}
// ------------------------------------------------------------------
// Diffing Generators
// ------------------------------------------------------------------
function* ObjectType(path, current, next) {
    AssertDiffable(current);
    AssertDiffable(next);
    if (!(0, index_1.IsStandardObject)(next))
        return yield CreateUpdate(path, next);
    const currentKeys = globalThis.Object.getOwnPropertyNames(current);
    const nextKeys = globalThis.Object.getOwnPropertyNames(next);
    // ----------------------------------------------------------------
    // inserts
    // ----------------------------------------------------------------
    for (const key of nextKeys) {
        if ((0, index_1.HasPropertyKey)(current, key))
            continue;
        yield CreateInsert(`${path}/${key}`, next[key]);
    }
    // ----------------------------------------------------------------
    // updates
    // ----------------------------------------------------------------
    for (const key of currentKeys) {
        if (!(0, index_1.HasPropertyKey)(next, key))
            continue;
        if ((0, equal_1.Equal)(current, next))
            continue;
        yield* Visit(`${path}/${key}`, current[key], next[key]);
    }
    // ----------------------------------------------------------------
    // deletes
    // ----------------------------------------------------------------
    for (const key of currentKeys) {
        if ((0, index_1.HasPropertyKey)(next, key))
            continue;
        yield CreateDelete(`${path}/${key}`);
    }
}
function* ArrayType(path, current, next) {
    if (!(0, index_1.IsArray)(next))
        return yield CreateUpdate(path, next);
    for (let i = 0; i < Math.min(current.length, next.length); i++) {
        yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
    for (let i = 0; i < next.length; i++) {
        if (i < current.length)
            continue;
        yield CreateInsert(`${path}/${i}`, next[i]);
    }
    for (let i = current.length - 1; i >= 0; i--) {
        if (i < next.length)
            continue;
        yield CreateDelete(`${path}/${i}`);
    }
}
function* TypedArrayType(path, current, next) {
    if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
        return yield CreateUpdate(path, next);
    for (let i = 0; i < Math.min(current.length, next.length); i++) {
        yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
}
function* ValueType(path, current, next) {
    if (current === next)
        return;
    yield CreateUpdate(path, next);
}
function* Visit(path, current, next) {
    if ((0, index_1.IsStandardObject)(current))
        return yield* ObjectType(path, current, next);
    if ((0, index_1.IsArray)(current))
        return yield* ArrayType(path, current, next);
    if ((0, index_1.IsTypedArray)(current))
        return yield* TypedArrayType(path, current, next);
    if ((0, index_1.IsValueType)(current))
        return yield* ValueType(path, current, next);
    throw new ValueDiffError(current, 'Unable to diff value');
}
// ------------------------------------------------------------------
// Diff
// ------------------------------------------------------------------
function Diff(current, next) {
    return [...Visit('', current, next)];
}
// ------------------------------------------------------------------
// Patch
// ------------------------------------------------------------------
function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === '' && edits[0].type === 'update';
}
function IsIdentity(edits) {
    return edits.length === 0;
}
function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
        return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
        return (0, index_3.Clone)(current);
    }
    const clone = (0, index_3.Clone)(current);
    for (const edit of edits) {
        switch (edit.type) {
            case 'insert': {
                index_2.ValuePointer.Set(clone, edit.path, edit.value);
                break;
            }
            case 'update': {
                index_2.ValuePointer.Set(clone, edit.path, edit.value);
                break;
            }
            case 'delete': {
                index_2.ValuePointer.Delete(clone, edit.path);
                break;
            }
        }
    }
    return clone;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\delta\index.d.ts

Code:
export * from './delta';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\delta\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./delta"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\deref\deref.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
import type { TRef } from '../../type/ref/index';
import type { TThis } from '../../type/recursive/index';
import { TypeBoxError } from '../../type/error/index';
export declare class TypeDereferenceError extends TypeBoxError {
    readonly schema: TRef | TThis;
    constructor(schema: TRef | TThis);
}
/** `[Internal]` Pushes a schema onto references if the schema has an $id and does not exist on references */
export declare function Pushref(schema: TSchema, references: TSchema[]): TSchema[];
/** `[Internal]` Dereferences a schema from the references array or throws if not found */
export declare function Deref(schema: TSchema, references: TSchema[]): TSchema;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\deref\deref.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeDereferenceError = void 0;
exports.Pushref = Pushref;
exports.Deref = Deref;
const index_1 = require("../../type/error/index");
const index_2 = require("../../type/symbols/index");
const guard_1 = require("../guard/guard");
class TypeDereferenceError extends index_1.TypeBoxError {
    constructor(schema) {
        super(`Unable to dereference schema with $id '${schema.$ref}'`);
        this.schema = schema;
    }
}
exports.TypeDereferenceError = TypeDereferenceError;
function Resolve(schema, references) {
    const target = references.find((target) => target.$id === schema.$ref);
    if (target === undefined)
        throw new TypeDereferenceError(schema);
    return Deref(target, references);
}
/** `[Internal]` Pushes a schema onto references if the schema has an $id and does not exist on references */
function Pushref(schema, references) {
    if (!(0, guard_1.IsString)(schema.$id) || references.some((target) => target.$id === schema.$id))
        return references;
    references.push(schema);
    return references;
}
/** `[Internal]` Dereferences a schema from the references array or throws if not found */
function Deref(schema, references) {
    // prettier-ignore
    return (schema[index_2.Kind] === 'This' || schema[index_2.Kind] === 'Ref')
        ? Resolve(schema, references)
        : schema;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\deref\index.d.ts

Code:
export * from './deref';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\deref\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./deref"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\encode\encode.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
import type { StaticEncode } from '../../type/static/index';
/** Encodes a value or throws if error */
export declare function Encode<T extends TSchema, Static = StaticEncode<T>, Result extends Static = Static>(schema: T, references: TSchema[], value: unknown): Result;
/** Encodes a value or throws if error */
export declare function Encode<T extends TSchema, Static = StaticEncode<T>, Result extends Static = Static>(schema: T, value: unknown): Result;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\encode\encode.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Encode = Encode;
const index_1 = require("../transform/index");
const index_2 = require("../check/index");
const index_3 = require("../../errors/index");
/** Encodes a value or throws if error */
function Encode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
    if (!(0, index_2.Check)(schema, references, encoded))
        throw new index_1.TransformEncodeCheckError(schema, encoded, (0, index_3.Errors)(schema, references, encoded).First());
    return encoded;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\encode\index.d.ts

Code:
export * from './encode';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\encode\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./encode"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\equal\equal.d.ts

Code:
/** Returns true if the left value deep-equals the right */
export declare function Equal<T>(left: T, right: unknown): right is T;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\equal\equal.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Equal = Equal;
const index_1 = require("../guard/index");
// ------------------------------------------------------------------
// Equality Checks
// ------------------------------------------------------------------
function ObjectType(left, right) {
    if (!(0, index_1.IsObject)(right))
        return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
        return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
}
function ArrayType(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
        return false;
    return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
        return false;
    return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
    return left === right;
}
// ------------------------------------------------------------------
// Equal
// ------------------------------------------------------------------
/** Returns true if the left value deep-equals the right */
function Equal(left, right) {
    if ((0, index_1.IsDate)(left))
        return DateType(left, right);
    if ((0, index_1.IsTypedArray)(left))
        return TypedArrayType(left, right);
    if ((0, index_1.IsArray)(left))
        return ArrayType(left, right);
    if ((0, index_1.IsObject)(left))
        return ObjectType(left, right);
    if ((0, index_1.IsValueType)(left))
        return ValueType(left, right);
    throw new Error('ValueEquals: Unable to compare value');
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\equal\index.d.ts

Code:
export * from './equal';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\equal\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./equal"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\guard\guard.d.ts

Code:
export type ObjectType = Record<PropertyKey, unknown>;
export type ArrayType = unknown[];
export type ValueType = null | undefined | symbol | bigint | number | boolean | string;
export type TypedArrayType = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;
/** Returns true if this value is an async iterator */
export declare function IsAsyncIterator(value: unknown): value is AsyncIterableIterator<any>;
/** Returns true if this value is an iterator */
export declare function IsIterator(value: unknown): value is IterableIterator<any>;
/** Returns true if this value is not an instance of a class */
export declare function IsStandardObject(value: unknown): value is ObjectType;
/** Returns true if this value is an instance of a class */
export declare function IsInstanceObject(value: unknown): value is ObjectType;
/** Returns true if this value is a Promise */
export declare function IsPromise(value: unknown): value is Promise<unknown>;
/** Returns true if this value is a Date */
export declare function IsDate(value: unknown): value is Date;
/** Returns true if this value is an instance of Map<K, T> */
export declare function IsMap(value: unknown): value is Map<unknown, unknown>;
/** Returns true if this value is an instance of Set<T> */
export declare function IsSet(value: unknown): value is Set<unknown>;
/** Returns true if this value is RegExp */
export declare function IsRegExp(value: unknown): value is RegExp;
/** Returns true if this value is a typed array */
export declare function IsTypedArray(value: unknown): value is TypedArrayType;
/** Returns true if the value is a Int8Array */
export declare function IsInt8Array(value: unknown): value is Int8Array;
/** Returns true if the value is a Uint8Array */
export declare function IsUint8Array(value: unknown): value is Uint8Array;
/** Returns true if the value is a Uint8ClampedArray */
export declare function IsUint8ClampedArray(value: unknown): value is Uint8ClampedArray;
/** Returns true if the value is a Int16Array */
export declare function IsInt16Array(value: unknown): value is Int16Array;
/** Returns true if the value is a Uint16Array */
export declare function IsUint16Array(value: unknown): value is Uint16Array;
/** Returns true if the value is a Int32Array */
export declare function IsInt32Array(value: unknown): value is Int32Array;
/** Returns true if the value is a Uint32Array */
export declare function IsUint32Array(value: unknown): value is Uint32Array;
/** Returns true if the value is a Float32Array */
export declare function IsFloat32Array(value: unknown): value is Float32Array;
/** Returns true if the value is a Float64Array */
export declare function IsFloat64Array(value: unknown): value is Float64Array;
/** Returns true if the value is a BigInt64Array */
export declare function IsBigInt64Array(value: unknown): value is BigInt64Array;
/** Returns true if the value is a BigUint64Array */
export declare function IsBigUint64Array(value: unknown): value is BigUint64Array;
/** Returns true if this value has this property key */
export declare function HasPropertyKey<K extends PropertyKey>(value: Record<any, unknown>, key: K): value is Record<PropertyKey, unknown> & {
    [_ in K]: unknown;
};
/** Returns true of this value is an object type */
export declare function IsObject(value: unknown): value is ObjectType;
/** Returns true if this value is an array, but not a typed array */
export declare function IsArray(value: unknown): value is ArrayType;
/** Returns true if this value is an undefined */
export declare function IsUndefined(value: unknown): value is undefined;
/** Returns true if this value is an null */
export declare function IsNull(value: unknown): value is null;
/** Returns true if this value is an boolean */
export declare function IsBoolean(value: unknown): value is boolean;
/** Returns true if this value is an number */
export declare function IsNumber(value: unknown): value is number;
/** Returns true if this value is an integer */
export declare function IsInteger(value: unknown): value is number;
/** Returns true if this value is bigint */
export declare function IsBigInt(value: unknown): value is bigint;
/** Returns true if this value is string */
export declare function IsString(value: unknown): value is string;
/** Returns true if this value is a function */
export declare function IsFunction(value: unknown): value is Function;
/** Returns true if this value is a symbol */
export declare function IsSymbol(value: unknown): value is symbol;
/** Returns true if this value is a value type such as number, string, boolean */
export declare function IsValueType(value: unknown): value is ValueType;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\guard\guard.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IsAsyncIterator = IsAsyncIterator;
exports.IsIterator = IsIterator;
exports.IsStandardObject = IsStandardObject;
exports.IsInstanceObject = IsInstanceObject;
exports.IsPromise = IsPromise;
exports.IsDate = IsDate;
exports.IsMap = IsMap;
exports.IsSet = IsSet;
exports.IsRegExp = IsRegExp;
exports.IsTypedArray = IsTypedArray;
exports.IsInt8Array = IsInt8Array;
exports.IsUint8Array = IsUint8Array;
exports.IsUint8ClampedArray = IsUint8ClampedArray;
exports.IsInt16Array = IsInt16Array;
exports.IsUint16Array = IsUint16Array;
exports.IsInt32Array = IsInt32Array;
exports.IsUint32Array = IsUint32Array;
exports.IsFloat32Array = IsFloat32Array;
exports.IsFloat64Array = IsFloat64Array;
exports.IsBigInt64Array = IsBigInt64Array;
exports.IsBigUint64Array = IsBigUint64Array;
exports.HasPropertyKey = HasPropertyKey;
exports.IsObject = IsObject;
exports.IsArray = IsArray;
exports.IsUndefined = IsUndefined;
exports.IsNull = IsNull;
exports.IsBoolean = IsBoolean;
exports.IsNumber = IsNumber;
exports.IsInteger = IsInteger;
exports.IsBigInt = IsBigInt;
exports.IsString = IsString;
exports.IsFunction = IsFunction;
exports.IsSymbol = IsSymbol;
exports.IsValueType = IsValueType;
// --------------------------------------------------------------------------
// Iterators
// --------------------------------------------------------------------------
/** Returns true if this value is an async iterator */
function IsAsyncIterator(value) {
    return IsObject(value) && globalThis.Symbol.asyncIterator in value;
}
/** Returns true if this value is an iterator */
function IsIterator(value) {
    return IsObject(value) && globalThis.Symbol.iterator in value;
}
// --------------------------------------------------------------------------
// Object Instances
// --------------------------------------------------------------------------
/** Returns true if this value is not an instance of a class */
function IsStandardObject(value) {
    return IsObject(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
/** Returns true if this value is an instance of a class */
function IsInstanceObject(value) {
    return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== 'Object';
}
// --------------------------------------------------------------------------
// JavaScript
// --------------------------------------------------------------------------
/** Returns true if this value is a Promise */
function IsPromise(value) {
    return value instanceof globalThis.Promise;
}
/** Returns true if this value is a Date */
function IsDate(value) {
    return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
/** Returns true if this value is an instance of Map<K, T> */
function IsMap(value) {
    return value instanceof globalThis.Map;
}
/** Returns true if this value is an instance of Set<T> */
function IsSet(value) {
    return value instanceof globalThis.Set;
}
/** Returns true if this value is RegExp */
function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
}
/** Returns true if this value is a typed array */
function IsTypedArray(value) {
    return globalThis.ArrayBuffer.isView(value);
}
/** Returns true if the value is a Int8Array */
function IsInt8Array(value) {
    return value instanceof globalThis.Int8Array;
}
/** Returns true if the value is a Uint8Array */
function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
}
/** Returns true if the value is a Uint8ClampedArray */
function IsUint8ClampedArray(value) {
    return value instanceof globalThis.Uint8ClampedArray;
}
/** Returns true if the value is a Int16Array */
function IsInt16Array(value) {
    return value instanceof globalThis.Int16Array;
}
/** Returns true if the value is a Uint16Array */
function IsUint16Array(value) {
    return value instanceof globalThis.Uint16Array;
}
/** Returns true if the value is a Int32Array */
function IsInt32Array(value) {
    return value instanceof globalThis.Int32Array;
}
/** Returns true if the value is a Uint32Array */
function IsUint32Array(value) {
    return value instanceof globalThis.Uint32Array;
}
/** Returns true if the value is a Float32Array */
function IsFloat32Array(value) {
    return value instanceof globalThis.Float32Array;
}
/** Returns true if the value is a Float64Array */
function IsFloat64Array(value) {
    return value instanceof globalThis.Float64Array;
}
/** Returns true if the value is a BigInt64Array */
function IsBigInt64Array(value) {
    return value instanceof globalThis.BigInt64Array;
}
/** Returns true if the value is a BigUint64Array */
function IsBigUint64Array(value) {
    return value instanceof globalThis.BigUint64Array;
}
// --------------------------------------------------------------------------
// PropertyKey
// --------------------------------------------------------------------------
/** Returns true if this value has this property key */
function HasPropertyKey(value, key) {
    return key in value;
}
// --------------------------------------------------------------------------
// Standard
// --------------------------------------------------------------------------
/** Returns true of this value is an object type */
function IsObject(value) {
    return value !== null && typeof value === 'object';
}
/** Returns true if this value is an array, but not a typed array */
function IsArray(value) {
    return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
/** Returns true if this value is an undefined */
function IsUndefined(value) {
    return value === undefined;
}
/** Returns true if this value is an null */
function IsNull(value) {
    return value === null;
}
/** Returns true if this value is an boolean */
function IsBoolean(value) {
    return typeof value === 'boolean';
}
/** Returns true if this value is an number */
function IsNumber(value) {
    return typeof value === 'number';
}
/** Returns true if this value is an integer */
function IsInteger(value) {
    return globalThis.Number.isInteger(value);
}
/** Returns true if this value is bigint */
function IsBigInt(value) {
    return typeof value === 'bigint';
}
/** Returns true if this value is string */
function IsString(value) {
    return typeof value === 'string';
}
/** Returns true if this value is a function */
function IsFunction(value) {
    return typeof value === 'function';
}
/** Returns true if this value is a symbol */
function IsSymbol(value) {
    return typeof value === 'symbol';
}
/** Returns true if this value is a value type such as number, string, boolean */
function IsValueType(value) {
    // prettier-ignore
    return (IsBigInt(value) ||
        IsBoolean(value) ||
        IsNull(value) ||
        IsNumber(value) ||
        IsString(value) ||
        IsSymbol(value) ||
        IsUndefined(value));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\guard\index.d.ts

Code:
export * from './guard';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\guard\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./guard"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\hash\hash.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
export declare class ValueHashError extends TypeBoxError {
    readonly value: unknown;
    constructor(value: unknown);
}
/** Creates a FNV1A-64 non cryptographic hash of the given value */
export declare function Hash(value: unknown): bigint;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\hash\hash.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueHashError = void 0;
exports.Hash = Hash;
const index_1 = require("../guard/index");
const index_2 = require("../../type/error/index");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueHashError extends index_2.TypeBoxError {
    constructor(value) {
        super(`Unable to hash value`);
        this.value = value;
    }
}
exports.ValueHashError = ValueHashError;
// ------------------------------------------------------------------
// ByteMarker
// ------------------------------------------------------------------
var ByteMarker;
(function (ByteMarker) {
    ByteMarker[ByteMarker["Undefined"] = 0] = "Undefined";
    ByteMarker[ByteMarker["Null"] = 1] = "Null";
    ByteMarker[ByteMarker["Boolean"] = 2] = "Boolean";
    ByteMarker[ByteMarker["Number"] = 3] = "Number";
    ByteMarker[ByteMarker["String"] = 4] = "String";
    ByteMarker[ByteMarker["Object"] = 5] = "Object";
    ByteMarker[ByteMarker["Array"] = 6] = "Array";
    ByteMarker[ByteMarker["Date"] = 7] = "Date";
    ByteMarker[ByteMarker["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker[ByteMarker["Symbol"] = 9] = "Symbol";
    ByteMarker[ByteMarker["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
// ------------------------------------------------------------------
// State
// ------------------------------------------------------------------
let Accumulator = BigInt('14695981039346656037');
const [Prime, Size] = [BigInt('1099511628211'), BigInt('18446744073709551616' /* 2 ^ 64 */)];
const Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
const F64 = new Float64Array(1);
const F64In = new DataView(F64.buffer);
const F64Out = new Uint8Array(F64.buffer);
// ------------------------------------------------------------------
// NumberToBytes
// ------------------------------------------------------------------
function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0; i < byteCount; i++) {
        yield (value >> (8 * (byteCount - 1 - i))) & 0xff;
    }
}
// ------------------------------------------------------------------
// Hashing Functions
// ------------------------------------------------------------------
function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
        Visit(item);
    }
}
function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
        FNV1A64(byte);
    }
}
function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
}
function NullType(value) {
    FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
        FNV1A64(byte);
    }
}
function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
        Visit(key);
        Visit(value[key]);
    }
}
function StringType(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0; i < value.length; i++) {
        for (const byte of NumberToBytes(value.charCodeAt(i))) {
            FNV1A64(byte);
        }
    }
}
function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
}
function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0; i < value.length; i++) {
        FNV1A64(value[i]);
    }
}
function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
}
function Visit(value) {
    if ((0, index_1.IsArray)(value))
        return ArrayType(value);
    if ((0, index_1.IsBoolean)(value))
        return BooleanType(value);
    if ((0, index_1.IsBigInt)(value))
        return BigIntType(value);
    if ((0, index_1.IsDate)(value))
        return DateType(value);
    if ((0, index_1.IsNull)(value))
        return NullType(value);
    if ((0, index_1.IsNumber)(value))
        return NumberType(value);
    if ((0, index_1.IsObject)(value))
        return ObjectType(value);
    if ((0, index_1.IsString)(value))
        return StringType(value);
    if ((0, index_1.IsSymbol)(value))
        return SymbolType(value);
    if ((0, index_1.IsUint8Array)(value))
        return Uint8ArrayType(value);
    if ((0, index_1.IsUndefined)(value))
        return UndefinedType(value);
    throw new ValueHashError(value);
}
function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = (Accumulator * Prime) % Size;
}
// ------------------------------------------------------------------
// Hash
// ------------------------------------------------------------------
/** Creates a FNV1A-64 non cryptographic hash of the given value */
function Hash(value) {
    Accumulator = BigInt('14695981039346656037');
    Visit(value);
    return Accumulator;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\hash\index.d.ts

Code:
export * from './hash';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\hash\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./hash"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\index.d.ts

Code:
export { ValueError, ValueErrorType, ValueErrorIterator } from '../errors/index';
export * from './guard/index';
export * from './assert/index';
export * from './cast/index';
export * from './check/index';
export * from './clean/index';
export * from './clone/index';
export * from './convert/index';
export * from './create/index';
export * from './decode/index';
export * from './default/index';
export * from './delta/index';
export * from './encode/index';
export * from './equal/index';
export * from './hash/index';
export * from './mutate/index';
export * from './parse/index';
export * from './pointer/index';
export * from './transform/index';
export { Value } from './value/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
// ------------------------------------------------------------------
// Errors (re-export)
// ------------------------------------------------------------------
var index_1 = require("../errors/index");
Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function () { return index_1.ValueErrorType; } });
Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });
// ------------------------------------------------------------------
// Guards
// ------------------------------------------------------------------
__exportStar(require("./guard/index"), exports);
// ------------------------------------------------------------------
// Operators
// ------------------------------------------------------------------
__exportStar(require("./assert/index"), exports);
__exportStar(require("./cast/index"), exports);
__exportStar(require("./check/index"), exports);
__exportStar(require("./clean/index"), exports);
__exportStar(require("./clone/index"), exports);
__exportStar(require("./convert/index"), exports);
__exportStar(require("./create/index"), exports);
__exportStar(require("./decode/index"), exports);
__exportStar(require("./default/index"), exports);
__exportStar(require("./delta/index"), exports);
__exportStar(require("./encode/index"), exports);
__exportStar(require("./equal/index"), exports);
__exportStar(require("./hash/index"), exports);
__exportStar(require("./mutate/index"), exports);
__exportStar(require("./parse/index"), exports);
__exportStar(require("./pointer/index"), exports);
__exportStar(require("./transform/index"), exports);
// ------------------------------------------------------------------
// Namespace
// ------------------------------------------------------------------
var index_2 = require("./value/index");
Object.defineProperty(exports, "Value", { enumerable: true, get: function () { return index_2.Value; } });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\mutate\index.d.ts

Code:
export * from './mutate';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\mutate\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./mutate"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\mutate\mutate.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
export declare class ValueMutateError extends TypeBoxError {
    constructor(message: string);
}
export type Mutable = {
    [key: string]: unknown;
} | unknown[];
/** `[Mutable]` Performs a deep mutable value assignment while retaining internal references */
export declare function Mutate(current: Mutable, next: Mutable): void;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\mutate\mutate.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueMutateError = void 0;
exports.Mutate = Mutate;
const index_1 = require("../guard/index");
const index_2 = require("../pointer/index");
const index_3 = require("../clone/index");
const index_4 = require("../../type/error/index");
// ------------------------------------------------------------------
// IsStandardObject
// ------------------------------------------------------------------
function IsStandardObject(value) {
    return (0, index_1.IsObject)(value) && !(0, index_1.IsArray)(value);
}
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueMutateError extends index_4.TypeBoxError {
    constructor(message) {
        super(message);
    }
}
exports.ValueMutateError = ValueMutateError;
function ObjectType(root, path, current, next) {
    if (!IsStandardObject(current)) {
        index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
    else {
        const currentKeys = Object.getOwnPropertyNames(current);
        const nextKeys = Object.getOwnPropertyNames(next);
        for (const currentKey of currentKeys) {
            if (!nextKeys.includes(currentKey)) {
                delete current[currentKey];
            }
        }
        for (const nextKey of nextKeys) {
            if (!currentKeys.includes(nextKey)) {
                current[nextKey] = null;
            }
        }
        for (const nextKey of nextKeys) {
            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
        }
    }
}
function ArrayType(root, path, current, next) {
    if (!(0, index_1.IsArray)(current)) {
        index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
    else {
        for (let index = 0; index < next.length; index++) {
            Visit(root, `${path}/${index}`, current[index], next[index]);
        }
        current.splice(next.length);
    }
}
function TypedArrayType(root, path, current, next) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
        for (let i = 0; i < current.length; i++) {
            current[i] = next[i];
        }
    }
    else {
        index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
}
function ValueType(root, path, current, next) {
    if (current === next)
        return;
    index_2.ValuePointer.Set(root, path, next);
}
function Visit(root, path, current, next) {
    if ((0, index_1.IsArray)(next))
        return ArrayType(root, path, current, next);
    if ((0, index_1.IsTypedArray)(next))
        return TypedArrayType(root, path, current, next);
    if (IsStandardObject(next))
        return ObjectType(root, path, current, next);
    if ((0, index_1.IsValueType)(next))
        return ValueType(root, path, current, next);
}
// ------------------------------------------------------------------
// IsNonMutableValue
// ------------------------------------------------------------------
function IsNonMutableValue(value) {
    return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
}
function IsMismatchedValue(current, next) {
    // prettier-ignore
    return ((IsStandardObject(current) && (0, index_1.IsArray)(next)) ||
        ((0, index_1.IsArray)(current) && IsStandardObject(next)));
}
// ------------------------------------------------------------------
// Mutate
// ------------------------------------------------------------------
/** `[Mutable]` Performs a deep mutable value assignment while retaining internal references */
function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
        throw new ValueMutateError('Only object and array types can be mutated at the root level');
    if (IsMismatchedValue(current, next))
        throw new ValueMutateError('Cannot assign due type mismatch of assignable values');
    Visit(current, '', current, next);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\parse\index.d.ts

Code:
export * from './parse';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\parse\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./parse"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\parse\parse.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import { TSchema } from '../../type/schema/index';
import { StaticDecode } from '../../type/static/index';
export declare class ParseError extends TypeBoxError {
    constructor(message: string);
}
export type TParseOperation = 'Assert' | 'Cast' | 'Clean' | 'Clone' | 'Convert' | 'Decode' | 'Default' | 'Encode' | ({} & string);
export type TParseFunction = (type: TSchema, references: TSchema[], value: unknown) => unknown;
export declare namespace ParseRegistry {
    function Delete(key: string): void;
    function Set(key: string, callback: TParseFunction): void;
    function Get(key: string): TParseFunction | undefined;
}
export declare const ParseDefault: readonly ["Clone", "Clean", "Default", "Convert", "Assert", "Decode"];
/** Parses a value using the default parse pipeline. Will throws an `AssertError` if invalid. */
export declare function Parse<Type extends TSchema, Output = StaticDecode<Type>, Result extends Output = Output>(schema: Type, references: TSchema[], value: unknown): Result;
/** Parses a value using the default parse pipeline. Will throws an `AssertError` if invalid. */
export declare function Parse<Type extends TSchema, Output = StaticDecode<Type>, Result extends Output = Output>(schema: Type, value: unknown): Result;
/** Parses a value using the specified operations. */
export declare function Parse<Type extends TSchema>(operations: TParseOperation[], schema: Type, references: TSchema[], value: unknown): unknown;
/** Parses a value using the specified operations. */
export declare function Parse<Type extends TSchema>(operations: TParseOperation[], schema: Type, value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\parse\parse.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseDefault = exports.ParseRegistry = exports.ParseError = void 0;
exports.Parse = Parse;
const index_1 = require("../../type/error/index");
const index_2 = require("../transform/index");
const index_3 = require("../assert/index");
const index_4 = require("../cast/index");
const index_5 = require("../clean/index");
const index_6 = require("../clone/index");
const index_7 = require("../convert/index");
const index_8 = require("../default/index");
// ------------------------------------------------------------------
// Guards
// ------------------------------------------------------------------
const index_9 = require("../guard/index");
// ------------------------------------------------------------------
// Error
// ------------------------------------------------------------------
class ParseError extends index_1.TypeBoxError {
    constructor(message) {
        super(message);
    }
}
exports.ParseError = ParseError;
// prettier-ignore
var ParseRegistry;
(function (ParseRegistry) {
    const registry = new Map([
        ['Assert', (type, references, value) => { (0, index_3.Assert)(type, references, value); return value; }],
        ['Cast', (type, references, value) => (0, index_4.Cast)(type, references, value)],
        ['Clean', (type, references, value) => (0, index_5.Clean)(type, references, value)],
        ['Clone', (_type, _references, value) => (0, index_6.Clone)(value)],
        ['Convert', (type, references, value) => (0, index_7.Convert)(type, references, value)],
        ['Decode', (type, references, value) => ((0, index_2.HasTransform)(type, references) ? (0, index_2.TransformDecode)(type, references, value) : value)],
        ['Default', (type, references, value) => (0, index_8.Default)(type, references, value)],
        ['Encode', (type, references, value) => ((0, index_2.HasTransform)(type, references) ? (0, index_2.TransformEncode)(type, references, value) : value)],
    ]);
    // Deletes an entry from the registry
    function Delete(key) {
        registry.delete(key);
    }
    ParseRegistry.Delete = Delete;
    // Sets an entry in the registry
    function Set(key, callback) {
        registry.set(key, callback);
    }
    ParseRegistry.Set = Set;
    // Gets an entry in the registry
    function Get(key) {
        return registry.get(key);
    }
    ParseRegistry.Get = Get;
})(ParseRegistry || (exports.ParseRegistry = ParseRegistry = {}));
// ------------------------------------------------------------------
// Default Parse Pipeline
// ------------------------------------------------------------------
// prettier-ignore
exports.ParseDefault = [
    'Clone',
    'Clean',
    'Default',
    'Convert',
    'Assert',
    'Decode'
];
// ------------------------------------------------------------------
// ParseValue
// ------------------------------------------------------------------
function ParseValue(operations, type, references, value) {
    return operations.reduce((value, operationKey) => {
        const operation = ParseRegistry.Get(operationKey);
        if ((0, index_9.IsUndefined)(operation))
            throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
        return operation(type, references, value);
    }, value);
}
/** Parses a value */
function Parse(...args) {
    // prettier-ignore
    const [operations, schema, references, value] = (args.length === 4 ? [args[0], args[1], args[2], args[3]] :
        args.length === 3 ? (0, index_9.IsArray)(args[0]) ? [args[0], args[1], [], args[2]] : [exports.ParseDefault, args[0], args[1], args[2]] :
            args.length === 2 ? [exports.ParseDefault, args[0], [], args[1]] :
                (() => { throw new ParseError('Invalid Arguments'); })());
    return ParseValue(operations, schema, references, value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\pointer\index.d.ts

Code:
export * as ValuePointer from './pointer';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\pointer\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValuePointer = void 0;
exports.ValuePointer = require("./pointer");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\pointer\pointer.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
export declare class ValuePointerRootSetError extends TypeBoxError {
    readonly value: unknown;
    readonly path: string;
    readonly update: unknown;
    constructor(value: unknown, path: string, update: unknown);
}
export declare class ValuePointerRootDeleteError extends TypeBoxError {
    readonly value: unknown;
    readonly path: string;
    constructor(value: unknown, path: string);
}
/** Formats the given pointer into navigable key components */
export declare function Format(pointer: string): IterableIterator<string>;
/** Sets the value at the given pointer. If the value at the pointer does not exist it is created */
export declare function Set(value: any, pointer: string, update: unknown): void;
/** Deletes a value at the given pointer */
export declare function Delete(value: any, pointer: string): void;
/** Returns true if a value exists at the given pointer */
export declare function Has(value: any, pointer: string): boolean;
/** Gets the value at the given pointer */
export declare function Get(value: any, pointer: string): any;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\pointer\pointer.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;
exports.Format = Format;
exports.Set = Set;
exports.Delete = Delete;
exports.Has = Has;
exports.Get = Get;
const index_1 = require("../../type/error/index");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValuePointerRootSetError extends index_1.TypeBoxError {
    constructor(value, path, update) {
        super('Cannot set root value');
        this.value = value;
        this.path = path;
        this.update = update;
    }
}
exports.ValuePointerRootSetError = ValuePointerRootSetError;
class ValuePointerRootDeleteError extends index_1.TypeBoxError {
    constructor(value, path) {
        super('Cannot delete root value');
        this.value = value;
        this.path = path;
    }
}
exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
// ------------------------------------------------------------------
// ValuePointer
// ------------------------------------------------------------------
/** Provides functionality to update values through RFC6901 string pointers */
// prettier-ignore
function Escape(component) {
    return component.indexOf('~') === -1 ? component : component.replace(/~1/g, '/').replace(/~0/g, '~');
}
/** Formats the given pointer into navigable key components */
// prettier-ignore
function* Format(pointer) {
    if (pointer === '')
        return;
    let [start, end] = [0, 0];
    for (let i = 0; i < pointer.length; i++) {
        const char = pointer.charAt(i);
        if (char === '/') {
            if (i === 0) {
                start = i + 1;
            }
            else {
                end = i;
                yield Escape(pointer.slice(start, end));
                start = i + 1;
            }
        }
        else {
            end = i;
        }
    }
    yield Escape(pointer.slice(start));
}
/** Sets the value at the given pointer. If the value at the pointer does not exist it is created */
// prettier-ignore
function Set(value, pointer, update) {
    if (pointer === '')
        throw new ValuePointerRootSetError(value, pointer, update);
    let [owner, next, key] = [null, value, ''];
    for (const component of Format(pointer)) {
        if (next[component] === undefined)
            next[component] = {};
        owner = next;
        next = next[component];
        key = component;
    }
    owner[key] = update;
}
/** Deletes a value at the given pointer */
// prettier-ignore
function Delete(value, pointer) {
    if (pointer === '')
        throw new ValuePointerRootDeleteError(value, pointer);
    let [owner, next, key] = [null, value, ''];
    for (const component of Format(pointer)) {
        if (next[component] === undefined || next[component] === null)
            return;
        owner = next;
        next = next[component];
        key = component;
    }
    if (Array.isArray(owner)) {
        const index = parseInt(key);
        owner.splice(index, 1);
    }
    else {
        delete owner[key];
    }
}
/** Returns true if a value exists at the given pointer */
// prettier-ignore
function Has(value, pointer) {
    if (pointer === '')
        return true;
    let [owner, next, key] = [null, value, ''];
    for (const component of Format(pointer)) {
        if (next[component] === undefined)
            return false;
        owner = next;
        next = next[component];
        key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
}
/** Gets the value at the given pointer */
// prettier-ignore
function Get(value, pointer) {
    if (pointer === '')
        return value;
    let current = value;
    for (const component of Format(pointer)) {
        if (current[component] === undefined)
            return undefined;
        current = current[component];
    }
    return current;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\decode.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import { ValueError } from '../../errors/index';
import type { TSchema } from '../../type/schema/index';
export declare class TransformDecodeCheckError extends TypeBoxError {
    readonly schema: TSchema;
    readonly value: unknown;
    readonly error: ValueError;
    constructor(schema: TSchema, value: unknown, error: ValueError);
}
export declare class TransformDecodeError extends TypeBoxError {
    readonly schema: TSchema;
    readonly path: string;
    readonly value: unknown;
    readonly error: Error;
    constructor(schema: TSchema, path: string, value: unknown, error: Error);
}
/**
 * `[Internal]` Decodes the value and returns the result. This function requires that
 * the caller `Check` the value before use. Passing unchecked values may result in
 * undefined behavior. Refer to the `Value.Decode()` for implementation details.
 */
export declare function TransformDecode(schema: TSchema, references: TSchema[], value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\decode.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformDecodeError = exports.TransformDecodeCheckError = void 0;
exports.TransformDecode = TransformDecode;
const policy_1 = require("../../system/policy");
const index_1 = require("../../type/symbols/index");
const index_2 = require("../../type/error/index");
const index_3 = require("../../type/keyof/index");
const index_4 = require("../deref/index");
const index_5 = require("../check/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_6 = require("../guard/index");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
// thrown externally
// prettier-ignore
class TransformDecodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
        super(`Unable to decode value as it does not match the expected schema`);
        this.schema = schema;
        this.value = value;
        this.error = error;
    }
}
exports.TransformDecodeCheckError = TransformDecodeCheckError;
// prettier-ignore
class TransformDecodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error) {
        super(error instanceof Error ? error.message : 'Unknown error');
        this.schema = schema;
        this.path = path;
        this.value = value;
        this.error = error;
    }
}
exports.TransformDecodeError = TransformDecodeError;
// ------------------------------------------------------------------
// Decode
// ------------------------------------------------------------------
// prettier-ignore
function Default(schema, path, value) {
    try {
        return (0, kind_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
    }
    catch (error) {
        throw new TransformDecodeError(schema, path, value, error);
    }
}
// prettier-ignore
function FromArray(schema, references, path, value) {
    return ((0, index_6.IsArray)(value))
        ? Default(schema, path, value.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value)))
        : Default(schema, path, value);
}
// prettier-ignore
function FromIntersect(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsValueType)(value))
        return Default(schema, path, value);
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map(entry => entry[0]);
    const knownProperties = { ...value };
    for (const [knownKey, knownSchema] of knownEntries)
        if (knownKey in knownProperties) {
            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
        }
    if (!(0, kind_1.IsTransform)(schema.unevaluatedProperties)) {
        return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.includes(key)) {
            unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
        }
    return Default(schema, path, unknownProperties);
}
// prettier-ignore
function FromImport(schema, references, path, value) {
    const additional = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    const result = Visit(target, [...references, ...additional], path, value);
    return Default(schema, path, result);
}
function FromNot(schema, references, path, value) {
    return Default(schema, path, Visit(schema.not, references, path, value));
}
// prettier-ignore
function FromObject(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value))
        return Default(schema, path, value);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...value };
    for (const key of knownKeys) {
        if (!(0, index_6.HasPropertyKey)(knownProperties, key))
            continue;
        // if the property value is undefined, but the target is not, nor does it satisfy exact optional 
        // property policy, then we need to continue. This is a special case for optional property handling 
        // where a transforms wrapped in a optional modifiers should not run.
        if ((0, index_6.IsUndefined)(knownProperties[key]) && (!(0, kind_1.IsUndefined)(schema.properties[key]) ||
            policy_1.TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
            continue;
        // decode property
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
        return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.includes(key)) {
            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
        }
    return Default(schema, path, unknownProperties);
}
// prettier-ignore
function FromRecord(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value))
        return Default(schema, path, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...value };
    for (const key of Object.getOwnPropertyNames(value))
        if (knownKeys.test(key)) {
            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
        }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
        return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.test(key)) {
            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
        }
    return Default(schema, path, unknownProperties);
}
// prettier-ignore
function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
}
// prettier-ignore
function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
}
// prettier-ignore
function FromTuple(schema, references, path, value) {
    return ((0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items))
        ? Default(schema, path, schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value[index])))
        : Default(schema, path, value);
}
// prettier-ignore
function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
        if (!(0, index_5.Check)(subschema, references, value))
            continue;
        // note: ensure interior is decoded first
        const decoded = Visit(subschema, references, path, value);
        return Default(schema, path, decoded);
    }
    return Default(schema, path, value);
}
// prettier-ignore
function Visit(schema, references, path, value) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, path, value);
        case 'Import':
            return FromImport(schema_, references_, path, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, path, value);
        case 'Not':
            return FromNot(schema_, references_, path, value);
        case 'Object':
            return FromObject(schema_, references_, path, value);
        case 'Record':
            return FromRecord(schema_, references_, path, value);
        case 'Ref':
            return FromRef(schema_, references_, path, value);
        case 'Symbol':
            return Default(schema_, path, value);
        case 'This':
            return FromThis(schema_, references_, path, value);
        case 'Tuple':
            return FromTuple(schema_, references_, path, value);
        case 'Union':
            return FromUnion(schema_, references_, path, value);
        default:
            return Default(schema_, path, value);
    }
}
/**
 * `[Internal]` Decodes the value and returns the result. This function requires that
 * the caller `Check` the value before use. Passing unchecked values may result in
 * undefined behavior. Refer to the `Value.Decode()` for implementation details.
 */
function TransformDecode(schema, references, value) {
    return Visit(schema, references, '', value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\encode.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import { ValueError } from '../../errors/index';
import type { TSchema } from '../../type/schema/index';
export declare class TransformEncodeCheckError extends TypeBoxError {
    readonly schema: TSchema;
    readonly value: unknown;
    readonly error: ValueError;
    constructor(schema: TSchema, value: unknown, error: ValueError);
}
export declare class TransformEncodeError extends TypeBoxError {
    readonly schema: TSchema;
    readonly path: string;
    readonly value: unknown;
    readonly error: Error;
    constructor(schema: TSchema, path: string, value: unknown, error: Error);
}
/**
 * `[Internal]` Encodes the value and returns the result. This function expects the
 * caller to pass a statically checked value. This function does not check the encoded
 * result, meaning the result should be passed to `Check` before use. Refer to the
 * `Value.Encode()` function for implementation details.
 */
export declare function TransformEncode(schema: TSchema, references: TSchema[], value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\encode.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformEncodeError = exports.TransformEncodeCheckError = void 0;
exports.TransformEncode = TransformEncode;
const policy_1 = require("../../system/policy");
const index_1 = require("../../type/symbols/index");
const index_2 = require("../../type/error/index");
const index_3 = require("../../type/keyof/index");
const index_4 = require("../deref/index");
const index_5 = require("../check/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_6 = require("../guard/index");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
// prettier-ignore
class TransformEncodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
        super(`The encoded value does not match the expected schema`);
        this.schema = schema;
        this.value = value;
        this.error = error;
    }
}
exports.TransformEncodeCheckError = TransformEncodeCheckError;
// prettier-ignore
class TransformEncodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error) {
        super(`${error instanceof Error ? error.message : 'Unknown error'}`);
        this.schema = schema;
        this.path = path;
        this.value = value;
        this.error = error;
    }
}
exports.TransformEncodeError = TransformEncodeError;
// ------------------------------------------------------------------
// Encode
// ------------------------------------------------------------------
// prettier-ignore
function Default(schema, path, value) {
    try {
        return (0, kind_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    }
    catch (error) {
        throw new TransformEncodeError(schema, path, value, error);
    }
}
// prettier-ignore
function FromArray(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    return (0, index_6.IsArray)(defaulted)
        ? defaulted.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value))
        : defaulted;
}
// prettier-ignore
function FromImport(schema, references, path, value) {
    const additional = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    const result = Default(schema, path, value);
    return Visit(target, [...references, ...additional], path, result);
}
// prettier-ignore
function FromIntersect(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsValueType)(value))
        return defaulted;
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map(entry => entry[0]);
    const knownProperties = { ...defaulted };
    for (const [knownKey, knownSchema] of knownEntries)
        if (knownKey in knownProperties) {
            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
        }
    if (!(0, kind_1.IsTransform)(schema.unevaluatedProperties)) {
        return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.includes(key)) {
            properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);
        }
    return properties;
}
// prettier-ignore
function FromNot(schema, references, path, value) {
    return Default(schema.not, path, Default(schema, path, value));
}
// prettier-ignore
function FromObject(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsObject)(defaulted))
        return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...defaulted };
    for (const key of knownKeys) {
        if (!(0, index_6.HasPropertyKey)(knownProperties, key))
            continue;
        // if the property value is undefined, but the target is not, nor does it satisfy exact optional 
        // property policy, then we need to continue. This is a special case for optional property handling 
        // where a transforms wrapped in a optional modifiers should not run.
        if ((0, index_6.IsUndefined)(knownProperties[key]) && (!(0, kind_1.IsUndefined)(schema.properties[key]) ||
            policy_1.TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
            continue;
        // encode property
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
        return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.includes(key)) {
            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
        }
    return properties;
}
// prettier-ignore
function FromRecord(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsObject)(value))
        return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...defaulted };
    for (const key of Object.getOwnPropertyNames(value))
        if (knownKeys.test(key)) {
            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
        }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
        return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
        if (!knownKeys.test(key)) {
            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
        }
    return properties;
}
// prettier-ignore
function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
}
// prettier-ignore
function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
}
// prettier-ignore
function FromTuple(schema, references, path, value) {
    const value1 = Default(schema, path, value);
    return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value1[index])) : [];
}
// prettier-ignore
function FromUnion(schema, references, path, value) {
    // test value against union variants
    for (const subschema of schema.anyOf) {
        if (!(0, index_5.Check)(subschema, references, value))
            continue;
        const value1 = Visit(subschema, references, path, value);
        return Default(schema, path, value1);
    }
    // test transformed value against union variants
    for (const subschema of schema.anyOf) {
        const value1 = Visit(subschema, references, path, value);
        if (!(0, index_5.Check)(schema, references, value1))
            continue;
        return Default(schema, path, value1);
    }
    return Default(schema, path, value);
}
// prettier-ignore
function Visit(schema, references, path, value) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, path, value);
        case 'Import':
            return FromImport(schema_, references_, path, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, path, value);
        case 'Not':
            return FromNot(schema_, references_, path, value);
        case 'Object':
            return FromObject(schema_, references_, path, value);
        case 'Record':
            return FromRecord(schema_, references_, path, value);
        case 'Ref':
            return FromRef(schema_, references_, path, value);
        case 'This':
            return FromThis(schema_, references_, path, value);
        case 'Tuple':
            return FromTuple(schema_, references_, path, value);
        case 'Union':
            return FromUnion(schema_, references_, path, value);
        default:
            return Default(schema_, path, value);
    }
}
/**
 * `[Internal]` Encodes the value and returns the result. This function expects the
 * caller to pass a statically checked value. This function does not check the encoded
 * result, meaning the result should be passed to `Check` before use. Refer to the
 * `Value.Encode()` function for implementation details.
 */
function TransformEncode(schema, references, value) {
    return Visit(schema, references, '', value);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\has.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
/** Returns true if this schema contains a transform codec */
export declare function HasTransform(schema: TSchema, references: TSchema[]): boolean;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\has.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HasTransform = HasTransform;
const index_1 = require("../deref/index");
const index_2 = require("../../type/symbols/index");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_3 = require("../guard/index");
// prettier-ignore
function FromArray(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.items, references);
}
// prettier-ignore
function FromAsyncIterator(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.items, references);
}
// prettier-ignore
function FromConstructor(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));
}
// prettier-ignore
function FromFunction(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));
}
// prettier-ignore
function FromIntersect(schema, references) {
    return (0, kind_1.IsTransform)(schema) || (0, kind_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));
}
// prettier-ignore
function FromImport(schema, references) {
    const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
    const target = schema.$defs[schema.$ref];
    return (0, kind_1.IsTransform)(schema) || Visit(target, [...additional, ...references]);
}
// prettier-ignore
function FromIterator(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.items, references);
}
// prettier-ignore
function FromNot(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.not, references);
}
// prettier-ignore
function FromObject(schema, references) {
    return ((0, kind_1.IsTransform)(schema) ||
        Object.values(schema.properties).some((schema) => Visit(schema, references)) ||
        ((0, kind_1.IsSchema)(schema.additionalProperties) && Visit(schema.additionalProperties, references)));
}
// prettier-ignore
function FromPromise(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit(schema.item, references);
}
// prettier-ignore
function FromRecord(schema, references) {
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern];
    return (0, kind_1.IsTransform)(schema) || Visit(property, references) || ((0, kind_1.IsSchema)(schema.additionalProperties) && (0, kind_1.IsTransform)(schema.additionalProperties));
}
// prettier-ignore
function FromRef(schema, references) {
    if ((0, kind_1.IsTransform)(schema))
        return true;
    return Visit((0, index_1.Deref)(schema, references), references);
}
// prettier-ignore
function FromThis(schema, references) {
    if ((0, kind_1.IsTransform)(schema))
        return true;
    return Visit((0, index_1.Deref)(schema, references), references);
}
// prettier-ignore
function FromTuple(schema, references) {
    return (0, kind_1.IsTransform)(schema) || (!(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema) => Visit(schema, references)));
}
// prettier-ignore
function FromUnion(schema, references) {
    return (0, kind_1.IsTransform)(schema) || schema.anyOf.some((schema) => Visit(schema, references));
}
// prettier-ignore
function Visit(schema, references) {
    const references_ = (0, index_1.Pushref)(schema, references);
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
        return false;
    if (schema.$id)
        visited.add(schema.$id);
    switch (schema[index_2.Kind]) {
        case 'Array':
            return FromArray(schema_, references_);
        case 'AsyncIterator':
            return FromAsyncIterator(schema_, references_);
        case 'Constructor':
            return FromConstructor(schema_, references_);
        case 'Function':
            return FromFunction(schema_, references_);
        case 'Import':
            return FromImport(schema_, references_);
        case 'Intersect':
            return FromIntersect(schema_, references_);
        case 'Iterator':
            return FromIterator(schema_, references_);
        case 'Not':
            return FromNot(schema_, references_);
        case 'Object':
            return FromObject(schema_, references_);
        case 'Promise':
            return FromPromise(schema_, references_);
        case 'Record':
            return FromRecord(schema_, references_);
        case 'Ref':
            return FromRef(schema_, references_);
        case 'This':
            return FromThis(schema_, references_);
        case 'Tuple':
            return FromTuple(schema_, references_);
        case 'Union':
            return FromUnion(schema_, references_);
        default:
            return (0, kind_1.IsTransform)(schema);
    }
}
const visited = new Set();
/** Returns true if this schema contains a transform codec */
function HasTransform(schema, references) {
    visited.clear();
    return Visit(schema, references);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\index.d.ts

Code:
export * from './decode';
export * from './encode';
export * from './has';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\transform\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./decode"), exports);
__exportStar(require("./encode"), exports);
__exportStar(require("./has"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\value\index.d.ts

Code:
export * as Value from './value';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\value\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Value = void 0;
exports.Value = require("./value");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\value\value.d.ts

Code:
export { Errors, ValueErrorIterator } from '../../errors/index';
export { Assert } from '../assert/index';
export { Cast } from '../cast/index';
export { Check } from '../check/index';
export { Clean } from '../clean/index';
export { Clone } from '../clone/index';
export { Convert } from '../convert/index';
export { Create } from '../create/index';
export { Decode } from '../decode/index';
export { Default } from '../default/index';
export { Diff, Patch, Edit } from '../delta/index';
export { Encode } from '../encode/index';
export { Equal } from '../equal/index';
export { Hash } from '../hash/index';
export { Mutate, type Mutable } from '../mutate/index';
export { Parse } from '../parse/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\value\value.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Parse = exports.Mutate = exports.Hash = exports.Equal = exports.Encode = exports.Edit = exports.Patch = exports.Diff = exports.Default = exports.Decode = exports.Create = exports.Convert = exports.Clone = exports.Clean = exports.Check = exports.Cast = exports.Assert = exports.ValueErrorIterator = exports.Errors = void 0;
var index_1 = require("../../errors/index");
Object.defineProperty(exports, "Errors", { enumerable: true, get: function () { return index_1.Errors; } });
Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });
var index_2 = require("../assert/index");
Object.defineProperty(exports, "Assert", { enumerable: true, get: function () { return index_2.Assert; } });
var index_3 = require("../cast/index");
Object.defineProperty(exports, "Cast", { enumerable: true, get: function () { return index_3.Cast; } });
var index_4 = require("../check/index");
Object.defineProperty(exports, "Check", { enumerable: true, get: function () { return index_4.Check; } });
var index_5 = require("../clean/index");
Object.defineProperty(exports, "Clean", { enumerable: true, get: function () { return index_5.Clean; } });
var index_6 = require("../clone/index");
Object.defineProperty(exports, "Clone", { enumerable: true, get: function () { return index_6.Clone; } });
var index_7 = require("../convert/index");
Object.defineProperty(exports, "Convert", { enumerable: true, get: function () { return index_7.Convert; } });
var index_8 = require("../create/index");
Object.defineProperty(exports, "Create", { enumerable: true, get: function () { return index_8.Create; } });
var index_9 = require("../decode/index");
Object.defineProperty(exports, "Decode", { enumerable: true, get: function () { return index_9.Decode; } });
var index_10 = require("../default/index");
Object.defineProperty(exports, "Default", { enumerable: true, get: function () { return index_10.Default; } });
var index_11 = require("../delta/index");
Object.defineProperty(exports, "Diff", { enumerable: true, get: function () { return index_11.Diff; } });
Object.defineProperty(exports, "Patch", { enumerable: true, get: function () { return index_11.Patch; } });
Object.defineProperty(exports, "Edit", { enumerable: true, get: function () { return index_11.Edit; } });
var index_12 = require("../encode/index");
Object.defineProperty(exports, "Encode", { enumerable: true, get: function () { return index_12.Encode; } });
var index_13 = require("../equal/index");
Object.defineProperty(exports, "Equal", { enumerable: true, get: function () { return index_13.Equal; } });
var index_14 = require("../hash/index");
Object.defineProperty(exports, "Hash", { enumerable: true, get: function () { return index_14.Hash; } });
var index_15 = require("../mutate/index");
Object.defineProperty(exports, "Mutate", { enumerable: true, get: function () { return index_15.Mutate; } });
var index_16 = require("../parse/index");
Object.defineProperty(exports, "Parse", { enumerable: true, get: function () { return index_16.Parse; } });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\compiler\package.json

Code:
{
  "main": "../build/cjs/compiler/index.js",
  "types": "../build/cjs/compiler/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\errors\package.json

Code:
{
  "main": "../build/cjs/errors/index.js",
  "types": "../build/cjs/errors/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\package.json

Code:
{
  "name": "@sinclair/typebox",
  "version": "0.34.37",
  "description": "Json Schema Type Builder with Static Type Resolution for TypeScript",
  "keywords": [
    "typescript",
    "json-schema",
    "validate",
    "typecheck"
  ],
  "author": "sinclairzx81",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/sinclairzx81/typebox"
  },
  "scripts": {
    "test": "echo test"
  },
  "types": "./build/cjs/index.d.ts",
  "main": "./build/cjs/index.js",
  "module": "./build/esm/index.mjs",
  "esm.sh": {
    "bundle": false
  },
  "sideEffects": [
    "./build/esm/type/registry/format.mjs",
    "./build/esm/type/registry/type.mjs",
    "./build/esm/type/system/policy.mjs",
    "./build/cjs/type/registry/format.js",
    "./build/cjs/type/registry/type.js",
    "./build/cjs/type/system/policy.js"
  ],
  "exports": {
    ".": {
      "require": {
        "types": "./build/cjs/index.d.ts",
        "default": "./build/cjs/index.js"
      },
      "import": {
        "types": "./build/esm/index.d.mts",
        "default": "./build/esm/index.mjs"
      }
    },
    "./compiler": {
      "require": {
        "types": "./build/cjs/compiler/index.d.ts",
        "default": "./build/cjs/compiler/index.js"
      },
      "import": {
        "types": "./build/esm/compiler/index.d.mts",
        "default": "./build/esm/compiler/index.mjs"
      }
    },
    "./errors": {
      "require": {
        "types": "./build/cjs/errors/index.d.ts",
        "default": "./build/cjs/errors/index.js"
      },
      "import": {
        "types": "./build/esm/errors/index.d.mts",
        "default": "./build/esm/errors/index.mjs"
      }
    },
    "./parser": {
      "require": {
        "types": "./build/cjs/parser/index.d.ts",
        "default": "./build/cjs/parser/index.js"
      },
      "import": {
        "types": "./build/esm/parser/index.d.mts",
        "default": "./build/esm/parser/index.mjs"
      }
    },
    "./syntax": {
      "require": {
        "types": "./build/cjs/syntax/index.d.ts",
        "default": "./build/cjs/syntax/index.js"
      },
      "import": {
        "types": "./build/esm/syntax/index.d.mts",
        "default": "./build/esm/syntax/index.mjs"
      }
    },
    "./system": {
      "require": {
        "types": "./build/cjs/system/index.d.ts",
        "default": "./build/cjs/system/index.js"
      },
      "import": {
        "types": "./build/esm/system/index.d.mts",
        "default": "./build/esm/system/index.mjs"
      }
    },
    "./type": {
      "require": {
        "types": "./build/cjs/type/index.d.ts",
        "default": "./build/cjs/type/index.js"
      },
      "import": {
        "types": "./build/esm/type/index.d.mts",
        "default": "./build/esm/type/index.mjs"
      }
    },
    "./value": {
      "require": {
        "types": "./build/cjs/value/index.d.ts",
        "default": "./build/cjs/value/index.js"
      },
      "import": {
        "types": "./build/esm/value/index.d.mts",
        "default": "./build/esm/value/index.mjs"
      }
    }
  }
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\parser\package.json

Code:
{
  "main": "../build/cjs/parser/index.js",
  "types": "../build/cjs/parser/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\readme.md

Code:
<div align='center'>

<h1>TypeBox</h1>

<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>

<img src="https://raw.githubusercontent.com/sinclairzx81/typebox/refs/heads/master/typebox.png" />

<br />
<br />

[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)
[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)
[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)
[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

</div>

<a name="Install"></a>

## Install

```bash
$ npm install @sinclair/typebox --save
```

## Example

```typescript
import { Type, type Static } from '@sinclair/typebox'

const T = Type.Object({                              // const T = {
  x: Type.Number(),                                  //   type: 'object',
  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],
  z: Type.Number()                                   //   properties: {
})                                                   //     x: { type: 'number' },
                                                     //     y: { type: 'number' },
                                                     //     z: { type: 'number' }
                                                     //   }
                                                     // }

type T = Static<typeof T>                            // type T = {
                                                     //   x: number,
                                                     //   y: number,
                                                     //   z: number
                                                     // }
```


<a name="Overview"></a>

## Overview

TypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.

This library is designed to allow Json Schema to compose similar to how types compose within TypeScript's type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.

License MIT

## Contents
- [Install](#install)
- [Overview](#overview)
- [Usage](#usage)
- [Types](#types)
  - [Json](#types-json)
  - [JavaScript](#types-javascript)
  - [Options](#types-options)
  - [Properties](#types-properties)
  - [Generics](#types-generics)
  - [Recursive](#types-recursive)
  - [Modules](#types-modules)
  - [Template Literal](#types-template-literal)
  - [Indexed](#types-indexed)
  - [Mapped](#types-mapped)
  - [Conditional](#types-conditional)
  - [Transform](#types-transform)
  - [Guard](#types-guard)
  - [Unsafe](#types-unsafe)
- [Values](#values)
  - [Assert](#values-assert)
  - [Create](#values-create)
  - [Clone](#values-clone)
  - [Check](#values-check)
  - [Convert](#values-convert)
  - [Default](#values-default)
  - [Clean](#values-clean)
  - [Cast](#values-cast)
  - [Decode](#values-decode)
  - [Encode](#values-decode)
  - [Parse](#values-parse)
  - [Equal](#values-equal)
  - [Hash](#values-hash)
  - [Diff](#values-diff)
  - [Patch](#values-patch)
  - [Errors](#values-errors)
  - [Mutate](#values-mutate)
  - [Pointer](#values-pointer)
- [Syntax](#syntax)
  - [Create](#syntax-create)
  - [Parameters](#syntax-parameters)
  - [Generics](#syntax-generics)
  - [Options](#syntax-options)
  - [NoInfer](#syntax-no-infer)
- [TypeRegistry](#typeregistry)
  - [Type](#typeregistry-type)
  - [Format](#typeregistry-format)
- [TypeCheck](#typecheck)
  - [Ajv](#typecheck-ajv)
  - [TypeCompiler](#typecheck-typecompiler)
- [TypeMap](#typemap)
  - [Usage](#typemap-usage)
- [TypeSystem](#typesystem)
  - [Policies](#typesystem-policies)
- [Error Function](#error-function)
- [Workbench](#workbench)
- [Codegen](#codegen)
- [Ecosystem](#ecosystem)
- [Benchmark](#benchmark)
  - [Compile](#benchmark-compile)
  - [Validate](#benchmark-validate)
  - [Compression](#benchmark-compression)
- [Contribute](#contribute)

<a name="usage"></a>

## Usage

The following shows general usage.

```typescript
import { Type, type Static } from '@sinclair/typebox'

//--------------------------------------------------------------------------------------------
//
// Let's say you have the following type ...
//
//--------------------------------------------------------------------------------------------

type T = {
  id: string,
  name: string,
  timestamp: number
}

//--------------------------------------------------------------------------------------------
//
// ... you can express this type in the following way.
//
//--------------------------------------------------------------------------------------------

const T = Type.Object({                              // const T = {
  id: Type.String(),                                 //   type: 'object',
  name: Type.String(),                               //   properties: {
  timestamp: Type.Integer()                          //     id: {
})                                                   //       type: 'string'
                                                     //     },
                                                     //     name: {
                                                     //       type: 'string'
                                                     //     },
                                                     //     timestamp: {
                                                     //       type: 'integer'
                                                     //     }
                                                     //   },
                                                     //   required: [
                                                     //     'id',
                                                     //     'name',
                                                     //     'timestamp'
                                                     //   ]
                                                     // }

//--------------------------------------------------------------------------------------------
//
// ... then infer back to the original static type this way.
//
//--------------------------------------------------------------------------------------------

type T = Static<typeof T>                            // type T = {
                                                     //   id: string,
                                                     //   name: string,
                                                     //   timestamp: number
                                                     // }

//--------------------------------------------------------------------------------------------
//
// ... or use the type to parse JavaScript values.
//
//--------------------------------------------------------------------------------------------

import { Value } from '@sinclair/typebox/value'

const R = Value.Parse(T, value)                      // const R: {
                                                     //   id: string,
                                                     //   name: string,
                                                     //   timestamp: number
                                                     // }
```

<a name='types'></a>

## Types

TypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.

<a name='types-json'></a>

### Json Types

The following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.

```typescript

 TypeBox                         TypeScript                   Json Schema                    
                                                                                             

 const T = Type.Any()            type T = any                 const T = { }                  
                                                                                             

 const T = Type.Unknown()        type T = unknown             const T = { }                  
                                                                                             

 const T = Type.String()         type T = string              const T = {                    
                                                                type: 'string'               
                                                              }                              
                                                                                             

 const T = Type.Number()         type T = number              const T = {                    
                                                                type: 'number'               
                                                              }                              
                                                                                             

 const T = Type.Integer()        type T = number              const T = {                    
                                                                type: 'integer'              
                                                              }                              
                                                                                             

 const T = Type.Boolean()        type T = boolean             const T = {                    
                                                                type: 'boolean'              
                                                              }                              
                                                                                             

 const T = Type.Null()           type T = null                const T = {                    
                                                                type: 'null'                 
                                                              }                              
                                                                                             

 const T = Type.Literal(42)      type T = 42                  const T = {                    
                                                                const: 42,                   
                                                                type: 'number'               
                                                              }                              
                                                                                             

 const T = Type.Array(           type T = number[]            const T = {                    
   Type.Number()                                                type: 'array',               
 )                                                              items: {                     
                                                                  type: 'number'             
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Object({         type T = {                   const T = {                    
   x: Type.Number(),               x: number,                   type: 'object',              
   y: Type.Number()                y: number                    required: ['x', 'y'],        
 })                              }                              properties: {                
                                                                  x: {                       
                                                                    type: 'number'           
                                                                  },                         
                                                                  y: {                       
                                                                    type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Tuple([          type T = [number, number]    const T = {                    
   Type.Number(),                                               type: 'array',               
   Type.Number()                                                items: [{                    
 ])                                                               type: 'number'             
                                                                }, {                         
                                                                  type: 'number'             
                                                                }],                          
                                                                additionalItems: false,      
                                                                minItems: 2,                 
                                                                maxItems: 2                  
                                                              }                              
                                                                                             
                                                                                             

 enum Foo {                      enum Foo {                   const T = {                    
   A,                              A,                           anyOf: [{                    
   B                               B                              type: 'number',            
 }                               }                                const: 0                   
                                                                }, {                         
 const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            
                                                                  const: 1                   
                                                                }]                           
                                                              }                              
                                                                                             

 const T = Type.Const({          type T = {                   const T = {                    
   x: 1,                           readonly x: 1,               type: 'object',              
   y: 2,                           readonly y: 2                required: ['x', 'y'],        
 } as const)                     }                              properties: {                
                                                                  x: {                       
                                                                    type: 'number',          
                                                                    const: 1                 
                                                                  },                         
                                                                  y: {                       
                                                                    type: 'number',          
                                                                    const: 2                 
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.KeyOf(           type T = keyof {             const T = {                    
   Type.Object({                   x: number,                   anyOf: [{                    
     x: Type.Number(),             y: number                      type: 'string',            
     y: Type.Number()            }                                const: 'x'                 
   })                                                           }, {                         
 )                                                                type: 'string',            
                                                                  const: 'y'                 
                                                                }]                           
                                                              }                              
                                                                                             

 const T = Type.Union([          type T = string | number     const T = {                    
   Type.String(),                                               anyOf: [{                    
   Type.Number()                                                  type: 'string'             
 ])                                                             }, {                         
                                                                  type: 'number'             
                                                                }]                           
                                                              }                              
                                                                                             

 const T = Type.Intersect([      type T = {                   const T = {                    
   Type.Object({                   x: number                    allOf: [{                    
     x: Type.Number()            } & {                            type: 'object',            
   }),                             y: number                      required: ['x'],           
   Type.Object({                 }                                properties: {              
     y: Type.Number()                                               x: {                     
   })                                                                 type: 'number'         
 ])                                                                 }                        
                                                                  }                          
                                                                }, {                         
                                                                  type: 'object',            |
                                                                  required: ['y'],           
                                                                  properties: {              
                                                                    y: {                     
                                                                      type: 'number'         
                                                                    }                        
                                                                  }                          
                                                                }]                           
                                                              }                              
                                                                                             

 const T = Type.Composite([      type T = {                   const T = {                    
   Type.Object({                   x: number,                   type: 'object',              
     x: Type.Number()              y: number                    required: ['x', 'y'],        
   }),                           }                              properties: {                
   Type.Object({                                                  x: {                       
     y: Type.Number()                                               type: 'number'           
   })                                                             },                         
 ])                                                               y: {                       
                                                                    type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Never()          type T = never               const T = {                    
                                                                not: {}                      
                                                              }                              
                                                                                             

 const T = Type.Not(            | type T = unknown             const T = {                    
   Type.String()                                                not: {                       
 )                                                                type: 'string'             
                                                                }                            
                                                              }                              

 const T = Type.Extends(         type T =                     const T = {                    
   Type.String(),                 string extends number         const: false,                
   Type.Number(),                   ? true                      type: 'boolean'              
   Type.Literal(true),              : false                   }                              
   Type.Literal(false)                                                                       
 )                                                                                           
                                                                                             

 const T = Type.Extract(         type T = Extract<            const T = {                    
   Type.Union([                    string | number,             type: 'string'               
     Type.String(),                string                     }                              
     Type.Number(),              >                                                           
   ]),                                                                                       
   Type.String()                                                                             
 )                                                                                           
                                                                                             

 const T = Type.Exclude(         type T = Exclude<            const T = {                    
   Type.Union([                    string | number,             type: 'number'               
     Type.String(),                string                     }                              
     Type.Number(),              >                                                           
   ]),                                                                                       
   Type.String()                                                                             
 )                                                                                           
                                                                                             

 const T = Type.Mapped(          type T = {                   const T = {                    
   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              
     Type.Literal('x'),          }                              required: ['x', 'y'],        
     Type.Literal('y')                                          properties: {                
   ]),                                                            x: {                       
   () => Type.Number()                                              type: 'number'           
 )                                                                },                         
                                                                  y: {                       
                                                                    type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const U = Type.Union([          type U = 'open' | 'close'    const T = {                    
   Type.Literal('open'),                                        type: 'string',              
   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  
 ])                                                           }                              
                                                                                             
 const T = Type                                                                              
   .TemplateLiteral([                                                                        
      Type.Literal('on'),                                                                    
      U                                                                                      
   ])                                                                                        
                                                                                             

 const T = Type.Record(          type T = Record<             const T = {                    
   Type.String(),                  string,                      type: 'object',              
   Type.Number()                   number                       patternProperties: {         
 )                               >                                '^.*$': {                  
                                                                    type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Partial(         type T = Partial<{           const T = {                    
   Type.Object({                   x: number,                   type: 'object',              
     x: Type.Number(),             y: number                    properties: {                
     y: Type.Number()           | }>                               x: {                       
   })                                                               type: 'number'           
 )                                                                },                         
                                                                  y: {                       
                                                                    type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Required(        type T = Required<{          const T = {                    
   Type.Object({                   x?: number,                  type: 'object',              
     x: Type.Optional(             y?: number                   required: ['x', 'y'],        
       Type.Number()            | }>                             properties: {                
     ),                                                           x: {                       
     y: Type.Optional(                                              type: 'number'           
       Type.Number()                                              },                         
     )                                                            y: {                       
   })                                                               type: 'number'           
 )                                                                }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Pick(            type T = Pick<{              const T = {                    
   Type.Object({                   x: number,                   type: 'object',              
     x: Type.Number(),             y: number                    required: ['x'],             
     y: Type.Number()            }, 'x'>                        properties: {                
   }), ['x']                    |                                  x: {                       
 )                                                                  type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Omit(            type T = Omit<{              const T = {                    
   Type.Object({                   x: number,                   type: 'object',              
     x: Type.Number(),             y: number                    required: ['y'],             
     y: Type.Number()            }, 'x'>                        properties: {                
   }), ['x']                    |                                  y: {                       
 )                                                                  type: 'number'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Index(           type T = {                   const T = {                    
   Type.Object({                   x: number,                   type: 'number'               
     x: Type.Number(),             y: string                  }                              
     y: Type.String()            }['x']                                                      
   }), ['x']                                                                                 
 )                                                                                           
                                                                                             

 const A = Type.Tuple([          type A = [0, 1]              const T = {                    
   Type.Literal(0),              type B = [2, 3]                type: 'array',               
   Type.Literal(1)               type T = [                     items: [                     
 ])                                ...A,                          { const: 0 },              
 const B = Type.Tuple([            ...B                           { const: 1 },              
|   Type.Literal(2),              ]                                { const: 2 },              
|   Type.Literal(3)                                                { const: 3 }               
 ])                                                             ],                           
 const T = Type.Tuple([                                         additionalItems: false,      
|   ...Type.Rest(A),                                             minItems: 4,                 
|   ...Type.Rest(B)                                              maxItems: 4                  
 ])                                                           }                              
                                                                                             

 const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    
   Type.Literal('Hello')           'Hello'                      type: 'string',              
 )                               >                              const: 'hello'               
                                                              }                              
                                                                                             

 const T = Type.Capitalize(      type T = Capitalize<         const T = {                    
   Type.Literal('hello')           'hello'                      type: 'string',              
 )                               >                              const: 'Hello'               
                                                              }                              
                                                                                             

 const T = Type.Uppercase(       type T = Uppercase<          const T = {                    
   Type.Literal('hello')           'hello'                      type: 'string',              
 )                               >                              const: 'HELLO'               
                                                              }                              
                                                                                             

 const T = Type.Lowercase(       type T = Lowercase<          const T = {                    
   Type.Literal('HELLO')           'HELLO'                      type: 'string',              
 )                               >                              const: 'hello'               
                                                              }                              
                                                                                             

 const R = Type.Ref('T')         type R = unknown             const R = { $ref: 'T' }        
                                                                                             

```

<a name='types-javascript'></a>

### JavaScript Types

TypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` JSDoc comment for convenience. The following table lists the supported types.

```typescript

 TypeBox                         TypeScript                   Extended Schema                
                                                                                             

 const T = Type.Constructor([    type T = new (               const T = {                    
   Type.String(),                 arg0: string,                 type: 'Constructor',         
   Type.Number()                  arg0: number                  parameters: [{               
 ], Type.Boolean())              ) => boolean                     type: 'string'             
                                                                }, {                         
                                                                  type: 'number'             
                                                                }],                          
                                                                returns: {                   
                                                                  type: 'boolean'            
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Function([       type T = (                   const T = {                    
|   Type.String(),                 arg0: string,                 type: 'Function',            
   Type.Number()                  arg1: number                  parameters: [{               
 ], Type.Boolean())              ) => boolean                     type: 'string'             
                                                                }, {                         
                                                                  type: 'number'             
                                                                }],                          
                                                                returns: {                   
                                                                  type: 'boolean'            
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Promise(         type T = Promise<string>     const T = {                    
   Type.String()                                                type: 'Promise',             
 )                                                              item: {                      
                                                                  type: 'string'             
                                                                }                            
                                                              }                              
                                                                                             

 const T =                       type T =                     const T = {                    
   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       
     Type.String()                  string                      items: {                     
   )                               >                              type: 'string'             
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Iterator(        type T =                     const T = {                    
   Type.String()                   IterableIterator<string>     type: 'Iterator',            
 )                                                              items: {                     
                                                                  type: 'string'             
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.RegExp(/abc/i)   type T = string              const T = {                    
                                                                type: 'RegExp'               
                                                                source: 'abc'                
                                                                flags: 'i'                   
                                                              }                              
                                                                                             

 const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    
                                                                type: 'Uint8Array'           
                                                              }                              
                                                                                             

 const T = Type.Date()           type T = Date                const T = {                    
                                                                type: 'Date'                 
                                                              }                              
                                                                                             

 const T = Type.Undefined()      type T = undefined           const T = {                    
                                                                type: 'undefined'            
                                                              }                              
                                                                                             

 const T = Type.Symbol()         type T = symbol              const T = {                    
                                                                type: 'symbol'               
                                                              }                              
                                                                                             

 const T = Type.BigInt()         type T = bigint              const T = {                    
                                                                type: 'bigint'               
                                                              }                              
                                                                                             

 const T = Type.Void()           type T = void                const T = {                    
                                                                type: 'void'                 
                                                              }                              
                                                                                             

```

<a name='types-options'></a>

### Options

You can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.

```typescript
// String must be an email
const T = Type.String({                              // const T = {
  format: 'email'                                    //   type: 'string',
})                                                   //   format: 'email'
                                                     // }

// Number must be a multiple of 2
const T = Type.Number({                              // const T = {
  multipleOf: 2                                      //  type: 'number',
})                                                   //  multipleOf: 2
                                                     // }

// Array must have at least 5 integer values
const T = Type.Array(Type.Integer(), {               // const T = {
  minItems: 5                                        //   type: 'array',
})                                                   //   minItems: 5,
                                                     //   items: {
                                                     //     type: 'integer'
                                                     //   }
                                                     // }
```

<a name='types-properties'></a>

### Properties

Object properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.

```typescript

 TypeBox                         TypeScript                   Json Schema                    
                                                                                             

 const T = Type.Object({         type T = {                   const T = {                    
   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              
     Type.String()               }                              properties: {                
   )                                                              name: {                    
 })  	                                                             type: 'string'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

 const T = Type.Object({         type T = {                   const T = {                    
   name: Type.Readonly(            readonly name: string        type: 'object',              
     Type.String()               }                              properties: {                
   )                                                              name: {                    
 })  	                                                             type: 'string'           
                                                                  }                          
                                                                },                           
                                                                required: ['name']           
                                                              }                              
                                                                                             

 const T = Type.Object({         type T = {                   const T = {                    
   name: Type.Optional(            name?: string                type: 'object',              
     Type.String()               }                              properties: {                
   )                                                              name: {                    
 })  	                                                             type: 'string'           
                                                                  }                          
                                                                }                            
                                                              }                              
                                                                                             

```

<a name='types-generics'></a>

### Generic Types

Generic types can be created with generic functions.

```typescript
const Nullable = <T extends TSchema>(T: T) => {     // type Nullable<T> = T | null
  return Type.Union([T, Type.Null()])
}

const T = Nullable(Type.String())                  // type T = Nullable<string>
```

<a name='types-recursive'></a>

### Recursive Types

Use the Recursive function to create recursive types.

```typescript
const Node = Type.Recursive(This => Type.Object({    // const Node = {
  id: Type.String(),                                 //   $id: 'Node',
  nodes: Type.Array(This)                            //   type: 'object',
}), { $id: 'Node' })                                 //   properties: {
                                                     //     id: {
                                                     //       type: 'string'
                                                     //     },
                                                     //     nodes: {
                                                     //       type: 'array',
                                                     //       items: {
                                                     //         $ref: 'Node'
                                                     //       }
                                                     //     }
                                                     //   },
                                                     //   required: [
                                                     //     'id',
                                                     //     'nodes'
                                                     //   ]
                                                     // }

type Node = Static<typeof Node>                      // type Node = {
                                                     //   id: string
                                                     //   nodes: Node[]
                                                     // }

function test(node: Node) {
  const id = node.nodes[0].nodes[0].id               // id is string
}
```

<a name='types-modules'></a>

### Module Types

Module types are containers for a set of referential types. Modules act as namespaces, enabling types to reference one another via string identifiers. Modules support both singular and mutually recursive references, as well as deferred dereferencing for computed types such as Partial. Types imported from a module are expressed using the Json Schema `$defs` keyword. 

```typescript
const Module = Type.Module({
  PartialUser: Type.Partial(Type.Ref('User')),  // TComputed<'Partial', [TRef<'User'>]>

  User: Type.Object({                           // TObject<{
    id: Type.String(),                          //   user: TString,
    name: Type.String(),                        //   name: TString,
    email: Type.String()                        //   email: TString
  }),                                           // }>
})
const User = Module.Import('User')               // const User: TImport<{...}, 'User'>

type User = Static<typeof User>                  // type User = { 
                                                 //   id: string,
                                                 //   name: string,
                                                 //   email: string
                                                 // }

const PartialUser = Module.Import('PartialUser') // const PartialUser: TImport<{...}, 'PartialUser'>

type PartialUser = Static<typeof PartialUser>    // type PartialUser = { 
                                                 //   id?: string,
                                                 //   name?: string,
                                                 //   email?: string
                                                 // }
```

<a name='types-template-literal'></a>

### Template Literal Types

TypeBox supports template literal types with the TemplateLiteral function. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.

```typescript
// TypeScript

type K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'

type R = Record<K, string>                           // type R = {
                                                     //   propA: string
                                                     //   propB: string
                                                     //   propC: string
                                                     // }

// TypeBox

const K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[
                                                     //   TLiteral<'prop'>,
                                                     //   TUnion<[
                                                     //      TLiteral<'A'>,
                                                     //      TLiteral<'B'>,
                                                     //      TLiteral<'C'>,
                                                     //   ]>
                                                     // ]>

const R = Type.Record(K, Type.String())              // const R: TObject<{
                                                     //   propA: TString,
                                                     //   propB: TString,
                                                     //   propC: TString,
                                                     // }>
```

<a name='types-indexed'></a>

### Indexed Access Types

TypeBox supports indexed access types with the Index function. This function enables uniform access to interior property and element types without having to extract them from the underlying schema representation. Index types are supported for Object, Array, Tuple, Union and Intersect types.

```typescript
const T = Type.Object({                              // type T = {
  x: Type.Number(),                                  //   x: number,
  y: Type.String(),                                  //   y: string,
  z: Type.Boolean()                                  //   z: boolean
})                                                   // }

const A = Type.Index(T, ['x'])                       // type A = T['x']
                                                     //
                                                     // ... evaluated as
                                                     //
                                                     // const A: TNumber

const B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']
                                                     //
                                                     // ... evaluated as
                                                     //
                                                     // const B: TUnion<[
                                                     //   TNumber,
                                                     //   TString,
                                                     // ]>

const C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]
                                                     //
                                                     // ... evaluated as
                                                     // 
                                                     // const C: TUnion<[
                                                     //   TNumber,
                                                     //   TString,
                                                     //   TBoolean
                                                     // ]>
```

<a name='types-mapped'></a>

### Mapped Types

TypeBox supports mapped types with the Mapped function. This function accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements a mapped type that remaps each property to be `T | null`.

```typescript
const T = Type.Object({                              // type T = {
  x: Type.Number(),                                  //   x: number,
  y: Type.String(),                                  //   y: string,
  z: Type.Boolean()                                  //   z: boolean
})                                                   // }

const M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]: T[K] | null }
  return Type.Union([Type.Index(T, K), Type.Null()]) //
})                                                   // ... evaluated as
                                                     // 
                                                     // const M: TObject<{
                                                     //   x: TUnion<[TNumber, TNull]>,
                                                     //   y: TUnion<[TString, TNull]>,
                                                     //   z: TUnion<[TBoolean, TNull]>
                                                     // }>
```

<a name='types-conditional'></a>

### Conditional Types

TypeBox supports runtime conditional types with the Extends function. This function performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.

```typescript
// Extends
const A = Type.Extends(                              // type A = string extends number ? 1 : 2
  Type.String(),                                     //   
  Type.Number(),                                     // ... evaluated as
  Type.Literal(1),                                   //
  Type.Literal(2)                                    // const A: TLiteral<2>
)

// Extract
const B = Type.Extract(                              // type B = Extract<1 | 2 | 3, 1>
  Type.Union([                                       //
    Type.Literal(1),                                 // ... evaluated as
    Type.Literal(2),                                 //
    Type.Literal(3)                                  // const B: TLiteral<1>
  ]), 
  Type.Literal(1)
)

// Exclude
const C = Type.Exclude(                              // type C = Exclude<1 | 2 | 3, 1>
  Type.Union([                                       // 
    Type.Literal(1),                                 // ... evaluated as
    Type.Literal(2),                                 //
    Type.Literal(3)                                  // const C: TUnion<[
  ]),                                                //   TLiteral<2>,
  Type.Literal(1)                                    //   TLiteral<3>,
)                                                    // ]>
```

<a name='types-transform'></a>

### Transform Types

TypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.

```typescript
import { Value } from '@sinclair/typebox/value'

const T = Type.Transform(Type.Number())
  .Decode(value => new Date(value))                  // decode: number to Date
  .Encode(value => value.getTime())                  // encode: Date to number

const D = Value.Decode(T, 0)                         // const D = Date(1970-01-01T00:00:00.000Z)
const E = Value.Encode(T, D)                         // const E = 0
```
Use the StaticEncode or StaticDecode types to infer a Transform type.
```typescript
import { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'

const T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         
  .Decode(value => new Set(value))
  .Encode(value => [...value])

type D = StaticDecode<typeof T>                      // type D = Set<number>      
type E = StaticEncode<typeof T>                      // type E = Array<number>
type T = Static<typeof T>                            // type T = Array<number>
```

<a name='types-unsafe'></a>

### Unsafe Types

TypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.

```typescript
const T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }

type T = Static<typeof T>                            // type T = string - ?
```
The Unsafe type is often used to create schematics for extended specifications like OpenAPI.
```typescript

const Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ 
  ...schema, nullable: true 
})

const T = Nullable(Type.String())                    // const T = {
                                                     //   type: 'string',
                                                     //   nullable: true
                                                     // }

type T = Static<typeof T>                            // type T = string | null

const StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ 
  type: 'string', enum: values 
})
const S = StringEnum(['A', 'B', 'C'])                // const S = {
                                                     //   enum: ['A', 'B', 'C']
                                                     // }

type S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'
```
<a name='types-guard'></a>

### TypeGuard

TypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.

```typescript
import { TypeGuard, Kind } from '@sinclair/typebox'

const T = { [Kind]: 'String', type: 'string' }

if(TypeGuard.IsString(T)) {

  // T is TString
}
```

<a name='values'></a>

## Values

TypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.

```typescript
import { Value } from '@sinclair/typebox/value'
```

<a name='values-assert'></a>

### Assert

Use the Assert function to assert a value is valid.

```typescript
let value: unknown = 1

Value.Assert(Type.Number(), value)                   // throws AssertError if invalid
```

<a name='values-create'></a>

### Create

Use the Create function to create a value from a type. TypeBox will use default values if specified.

```typescript
const T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })

const A = Value.Create(T)                            // const A = { x: 0, y: 42 }
```

<a name='values-clone'></a>

### Clone

Use the Clone function to deeply clone a value.

```typescript
const A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }
```

<a name='values-check'></a>

### Check

Use the Check function to type check a value.

```typescript
const T = Type.Object({ x: Type.Number() })

const R = Value.Check(T, { x: 1 })                   // const R = true
```

<a name='values-convert'></a>

### Convert

Use the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.

```typescript
const T = Type.Object({ x: Type.Number() })

const R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }

const R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }
```

<a name='values-clean'></a>

### Clean

Use Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.

```typescript
const T = Type.Object({ 
  x: Type.Number(), 
  y: Type.Number() 
})

const X = Value.Clean(T, null)                        // const 'X = null

const Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }

const Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }
```

<a name='values-default'></a>

### Default

Use Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.

```typescript
const T = Type.Object({ 
  x: Type.Number({ default: 0 }), 
  y: Type.Number({ default: 0 })
})

const X = Value.Default(T, null)                        // const 'X = null - non-enumerable

const Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }

const Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }
```

<a name='values-cast'></a>

### Cast

Use the Cast function to upcast a value into a target type. This function will retain as much information as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.

```typescript
const T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })

const X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }

const Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }

const Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }
```

<a name='values-decode'></a>

### Decode

Use the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.

```typescript
const A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'

const B = Value.Decode(Type.String(), 42)             // throw
```
<a name='values-decode'></a>

### Encode

Use the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.

```typescript
const A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'

const B = Value.Encode(Type.String(), 42)             // throw
```

<a name='values-parse'></a>

### Parse

Use the Parse function to parse a value. This function calls the `Clone` `Clean`, `Default`, `Convert`, `Assert` and `Decode` Value functions in this exact order to process a value.

```typescript
const R = Value.Parse(Type.String(), 'hello')      // const R: string = "hello"

const E = Value.Parse(Type.String(), undefined)    // throws AssertError 
```

You can override the order in which functions are run, or omit functions entirely using the following.

```typescript
// Runs no functions.

const R = Value.Parse([], Type.String(), 12345)

// Runs the Assert() function.

const E = Value.Parse(['Assert'], Type.String(), 12345)

// Runs the Convert() function followed by the Assert() function.

const S = Value.Parse(['Convert', 'Assert'], Type.String(), 12345)
```

<a name='values-equal'></a>

### Equal

Use the Equal function to deeply check for value equality.

```typescript
const R = Value.Equal(                               // const R = true
  { x: 1, y: 2, z: 3 },
  { x: 1, y: 2, z: 3 }
)
```

<a name='values-hash'></a>

### Hash

Use the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non-cryptographic hash of a value.

```typescript
const A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n

const B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n
```

<a name='values-diff'></a>

### Diff

Use the Diff function to generate a sequence of edits that will transform one value into another.

```typescript
const E = Value.Diff(                                // const E = [
  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },
  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },
)                                                    //   { type: 'insert', path: '/w', value: 6 },
                                                     //   { type: 'delete', path: '/x' }
                                                     // ]
```

<a name='values-patch'></a>

### Patch

Use the Patch function to apply a sequence of edits.

```typescript
const A = { x: 1, y: 2 }

const B = { x: 3 }

const E = Value.Diff(A, B)                           // const E = [
                                                     //   { type: 'update', path: '/x', value: 3 },
                                                     //   { type: 'delete', path: '/y' }
                                                     // ]

const C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }
```

<a name='values-errors'></a>

### Errors

Use the Errors function to enumerate validation errors.

```typescript
const T = Type.Object({ x: Type.Number(), y: Type.Number() })

const R = [...Value.Errors(T, { x: '42' })]          // const R = [{
                                                     //   schema: { type: 'number' },
                                                     //   path: '/x',
                                                     //   value: '42',
                                                     //   message: 'Expected number'
                                                     // }, {
                                                     //   schema: { type: 'number' },
                                                     //   path: '/y',
                                                     //   value: undefined,
                                                     //   message: 'Expected number'
                                                     // }]
```

<a name='values-mutate'></a>

### Mutate

Use the Mutate function to perform a deep mutable value assignment while retaining internal references.

```typescript
const Y = { z: 1 }                                   // const Y = { z: 1 }
const X = { y: Y }                                   // const X = { y: { z: 1 } }
const A = { x: X }                                   // const A = { x: { y: { z: 1 } } }

Value.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }

const R0 = A.x.y.z === 2                             // const R0 = true
const R1 = A.x.y === Y                               // const R1 = true
const R2 = A.x === X                                 // const R2 = true
```

<a name='values-pointer'></a>

### Pointer

Use ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.

```typescript
import { ValuePointer } from '@sinclair/typebox/value'

const A = { x: 0, y: 0, z: 0 }

ValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }
ValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }
ValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }
```



<a name='syntax'></a>

## Syntax Types

TypeBox provides experimental support for parsing TypeScript annotation syntax into TypeBox types.

This feature is provided via optional import.

```typescript
import { Syntax } from '@sinclair/typebox/syntax'
```

<a name='syntax-create'></a>

### Create

Use the Syntax function to create TypeBox types from TypeScript syntax ([Example](https://www.typescriptlang.org/play/?moduleResolution=99&module=199&ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgChQkWIhTYYwBgWKly1OoxZtO3foMkSGEdDXgAVOAF4Uo3AAoABkhwAuOOgCuIPjygAaOFR3Lx8-AkcASjgY2Jj2djhjUwt3cwB5PgArHgYYAB4ECTiS0rLyisrYhNi3OHMAOW9fAOKq9o7OuBqY4PqmsKg2rpHR+MT8AD4JCS5eeut5LEUGfLmeCCJ6ybHKmvWFmyLdk86euDrQlv9h07uy876rv1v7t-GCIA))

```typescript
const T = Syntax(`{ x: number, y: number }`)        // const T: TObject<{
                                                    //   x: TNumber,
                                                    //   y: TNumber
                                                    // }>

type T = Static<typeof T>                            // type T = {
                                                     //   x: number,
                                                     //   y: number
                                                     // }
```

<a name="syntax-parameters"></a>

### Parameters

Syntax types can be parameterized to receive exterior types ([Example](https://www.typescriptlang.org/play/?moduleResolution=99&module=199&ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgCgJDCOhrwAKnAC8KUbgAUAAyQ4AXHHQBXEHx5QANHFQHjp8wS0BKOK7ev27ODLmKDCgHk+ACseBhgAHgQJd1i4+ITEpLdPN304BQA5EzNLGOSCwqK4VNcbDOz7KHzi2rqPL3wAPikfeRQVNUxNJCV8Ky0ABSxYYCwmCIUm52LUtvhkfyDQ8Kia+o2C0rh0wLAYYFlxycrcpot1zav47fK9g6OJrJzzFuv3m8amoA))

```typescript
const T = Syntax(`{ x: number, y: number }`)        // const T: TObject<{
                                                    //   x: TNumber,
                                                    //   y: TNumber
                                                    // }>

const S = Syntax({ T }, `Partial<T>`)               // const S: TObject<{
                                                    //   x: TOptional<TNumber>,
                                                    //   y: TOptional<TNumber>
                                                    // }>
```



<a name="syntax-generics"></a>

### Generics

Syntax types support generic parameters in the following way ([Example](https://www.typescriptlang.org/play/?moduleResolution=99&module=199&ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgChQkWIhTYYwBgWKly1OoxZtO3foMkSGEdDXgA1HgxjQ4AXhSjcACgAGAHgAaAGjgBNXwAtAD45CTg4HAAuOB84cLhUGID4iIAvGMD4-FcASgkjEzM4ACEsOhpLa2gae0dMFyQqmygCX1cEBOi4Zuh3AEZfAAZh4O8EpJ6rFvcRuEG4IbGEjKnqqFnh337lnPyJLl5S8uBK6Zq65AUld0OeCCJjit6oGlCIiPZ2ODun05fag5Oh8QaCweCIZCoV8Pt0kN0FpM5qshm0ElCMZisSCYRFJvCYnNJgsUWjseSKeDcXBVgTFr4kb5Vv0COjKezsTD8EA))

```typescript
const Vector = Syntax(`<X, Y, Z> { 
  x: X, 
  y: Y, 
  z: Z 
}`)

const BasisVectors = Syntax({ Vector }, `{
  x: Vector<1, 0, 0>,
  y: Vector<0, 1, 0>,
  z: Vector<0, 0, 1>,
}`)

type BasisVectors = Static<typeof BasisVectors>     // type BasisVectors = {
                                                    //   x: { x: 1, y: 0, z: 0 },
                                                    //   y: { x: 0, y: 1, z: 0 },
                                                    //   z: { x: 0, y: 0, z: 1 }
                                                    // }
```

<a name='syntax-options'></a>

### Options

Options can be passed via the last parameter.

```typescript
const T = Syntax(`number`, { minimum: 42 })       // const T = {
                                                  //   type: 'number',
                                                  //   minimum: 42
                                                  // }
```

<a name='syntax-no-infer'></a>

### NoInfer

Syntax parsing is an expensive type level operation and can impact on language service performance. Use the NoInfer function parse syntax at runtime only.

```typescript
import { NoInfer } from '@sinclair/typebox/syntax'

const T = NoInfer(`number | string`)                // const T: TSchema = {
                                                    //   anyOf: [
                                                    //     { type: 'number' },
                                                    //     { type: 'string' }
                                                    //   ]
                                                    // }
```

<a name='typeregistry'></a>

## TypeRegistry

The TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.

<a name='typeregistry-type'></a>

### TypeRegistry

Use the TypeRegistry to register a type. The Kind must match the registered type name.

```typescript
import { TSchema, Kind, TypeRegistry } from '@sinclair/typebox'

TypeRegistry.Set('Foo', (schema, value) => value === 'foo')

const Foo = { [Kind]: 'Foo' } as TSchema 

const A = Value.Check(Foo, 'foo')                    // const A = true

const B = Value.Check(Foo, 'bar')                    // const B = false
```

<a name='typeregistry-format'></a>

### FormatRegistry

Use the FormatRegistry to register a string format.

```typescript
import { FormatRegistry } from '@sinclair/typebox'

FormatRegistry.Set('foo', (value) => value === 'foo')

const T = Type.String({ format: 'foo' })

const A = Value.Check(T, 'foo')                      // const A = true

const B = Value.Check(T, 'bar')                      // const B = false
```

<a name='typecheck'></a>

## TypeCheck

TypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built-in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.

The following sections detail using Ajv and the TypeBox compiler infrastructure.

<a name='typecheck-ajv'></a>

## Ajv

The following shows the recommended setup for Ajv.

```bash
$ npm install ajv ajv-formats --save
```

```typescript
import { Type }   from '@sinclair/typebox'
import addFormats from 'ajv-formats'
import Ajv        from 'ajv'

const ajv = addFormats(new Ajv({}), [
  'date-time',
  'time',
  'date',
  'email',
  'hostname',
  'ipv4',
  'ipv6',
  'uri',
  'uri-reference',
  'uuid',
  'uri-template',
  'json-pointer',
  'relative-json-pointer',
  'regex'
])

const validate = ajv.compile(Type.Object({
  x: Type.Number(),
  y: Type.Number(),
  z: Type.Number()
}))

const R = validate({ x: 1, y: 2, z: 3 })             // const R = true
```

<a name='typecheck-typecompiler'></a>

### TypeCompiler

The TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.

The TypeCompiler is provided as an optional import.

```typescript
import { TypeCompiler } from '@sinclair/typebox/compiler'
```

Use the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.

```typescript
const C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{
  x: Type.Number(),                                  //     x: TNumber;
  y: Type.Number(),                                  //     y: TNumber;
  z: Type.Number()                                   //     z: TNumber;
}))                                                  // }>>

const R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true
```

Use the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.

```typescript
const C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{
  x: Type.Number(),                                  //     x: TNumber;
  y: Type.Number(),                                  //     y: TNumber;
  z: Type.Number()                                   //     z: TNumber;
}))                                                  // }>>

const value = { }

const first = C.Errors(value).First()                // const first = {
                                                     //   schema: { type: 'number' },
                                                     //   path: '/x',
                                                     //   value: undefined,
                                                     //   message: 'Expected number'
                                                     // }

const all = [...C.Errors(value)]                     // const all = [{
                                                     //   schema: { type: 'number' },
                                                     //   path: '/x',
                                                     //   value: undefined,
                                                     //   message: 'Expected number'
                                                     // }, {
                                                     //   schema: { type: 'number' },
                                                     //   path: '/y',
                                                     //   value: undefined,
                                                     //   message: 'Expected number'
                                                     // }, {
                                                     //   schema: { type: 'number' },
                                                     //   path: '/z',
                                                     //   value: undefined,
                                                     //   message: 'Expected number'
                                                     // }]
```

Use the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.

```typescript
const C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {
                                                     //   return (
                                                     //     (typeof value === 'string')
                                                     //   )
                                                     // }`
```

<a name='typemap'></a>

## TypeMap

TypeBox offers an external package for bidirectional mapping between TypeBox, Valibot, and Zod type libraries. It also includes syntax parsing support for Valibot and Zod and supports the Standard Schema specification. For more details on TypeMap, refer to the project repository.

[TypeMap Repository](https://github.com/sinclairzx81/typemap)

<a name='typemap-usage'></a>

### Usage

TypeMap needs to be installed separately

```bash
$ npm install @sinclair/typemap
```

Once installed it offers advanced structural remapping between various runtime type libraries ([Example](https://www.typescriptlang.org/play/?moduleResolution=99&module=199&ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgFQJ5gKYCEIA8A0cAyqgHYwCGBcAWhACZwC+cAZlBCHAOQACAzsFIBjADYVgUAPQx0GEBTDcAUMuERS-eMjgBeFHJy4AFAAMkuAFxxSAVxAAjDFEKprdx88IAvd-adQzKYAlHBwUlJw6pra1sgA8g4AVhjCMAA8CMphObl5+QWFRcW5ETlWKABy-s4A3NkljU3NBWVhblU1UPUtvX3FbXC+nZ7dDf0TE2VMAHyq0VrEesRklCbIoS1lC-BE1twWfqOuRwE+p87MKmoaiwBKy3T0xkTBAHRgFFD8GMZ2oqJNnltrd4HdrFlJltImEKh4Aj0oU1Bh14XVxkiBjChhcxpjGtMwkA))

```typescript
import { TypeBox, Syntax, Zod } from '@sinclair/typemap'

const T = TypeBox(`{ x: number, y: number, z: number }`)  // const T: TObject<{
                                                          //   x: TNumber;
                                                          //   y: TNumber;
                                                          //   z: TNumber;
                                                          // }>

const S = Syntax(T)                // const S: '{ x: number, y: number, z: number }'

const R = Zod(S).parse(null)       // const R: {
                                   //   x: number;
                                   //   y: number;
                                   //   z: number;
                                   // }                    
```

<a name='typesystem'></a>

## TypeSystem

The TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.

<a name='typesystem-policies'></a>

### Policies

TypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. 

The following overrides are available.

```typescript
import { TypeSystemPolicy } from '@sinclair/typebox/system'

// Disallow undefined values for optional properties (default is false)
//
// const A: { x?: number } = { x: undefined } - disallowed when enabled

TypeSystemPolicy.ExactOptionalPropertyTypes = true

// Allow arrays to validate as object types (default is false)
//
// const A: {} = [] - allowed in TS

TypeSystemPolicy.AllowArrayObject = true

// Allow numeric values to be NaN or + or - Infinity (default is false)
//
// const A: number = NaN - allowed in TS

TypeSystemPolicy.AllowNaN = true

// Allow void types to check with undefined and null (default is false)
//
// Used to signal void return on Json-Rpc 2.0 protocol

TypeSystemPolicy.AllowNullVoid = true
```

<a name='error-function'></a>

## Error Function

Error messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.

The following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.


```typescript
import { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'

SetErrorFunction((error) => { // i18n override
  switch(error.errorType) {
    /* en-US */ case ValueErrorType.String: return 'Expected string'
    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  
    /* ko-KR */ case ValueErrorType.Boolean: return ' '      
    /* en-US */ default: return DefaultErrorFunction(error)          
  }
})
const T = Type.Object({                              // const T: TObject<{
  x: Type.String(),                                  //  TString,
  y: Type.Number(),                                  //  TNumber,
  z: Type.Boolean()                                  //  TBoolean
})                                                   // }>

const E = [...Value.Errors(T, {                      // const E = [{
  x: null,                                           //   type: 48,
  y: null,                                           //   schema: { ... },
  z: null                                            //   path: '/x',
})]                                                  //   value: null,
                                                     //   message: 'Expected string'
                                                     // }, {
                                                     //   type: 34,
                                                     //   schema: { ... },
                                                     //   path: '/y',
                                                     //   value: null,
                                                     //   message: 'Nombre attendu'
                                                     // }, {
                                                     //   type: 14,
                                                     //   schema: { ... },
                                                     //   path: '/z',
                                                     //   value: null,
                                                     //   message: ' '
                                                     // }]
```

<a name='workbench'></a>

## TypeBox Workbench

TypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.

[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)

<a name='codegen'></a>

## TypeBox Codegen

TypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.

[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)

<a name='ecosystem'></a>

## Ecosystem

The following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.

| Package   |  Description |
| ------------- | ------------- |
| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |
| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |
| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |
| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |
| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |
| [@lonli-lokli/fetcher-typebox](https://github.com/Lonli-Lokli/fetcher-ts/tree/master/packages/fetcher-typebox) | A strongly-typed fetch wrapper for TypeScript applications with optional runtime validation using TypeBox |
| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |
| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |
| [json2typebox](https://github.com/hacxy/json2typebox) | Creating TypeBox code from Json Data |
| [nominal-typebox](https://github.com/Coder-Spirit/nominal/tree/main/%40coderspirit/nominal-typebox) | Allows devs to integrate nominal types into TypeBox schemas |
| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |
| [prismabox](https://github.com/m1212e/prismabox) | Converts a prisma.schema to TypeBox schema matching the database models |
| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |
| [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms)  | A comprehensive SvelteKit form library for server and client validation |
| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |
| [typebox-cli](https://github.com/gsuess/typebox-cli) | Generate Schema with TypeBox from the CLI |
| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |
| [typebox-schema-faker](https://github.com/iam-medvedev/typebox-schema-faker) | Generate fake data from TypeBox schemas for testing, prototyping and development |


<a name='benchmark'></a>

## Benchmark

This project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.

For additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).

<a name='benchmark-compile'></a>

### Compile

This benchmark measures compilation performance for varying types.

```typescript

 (index)                     Iterations  Ajv           TypeCompiler  Performance  

 Literal_String              1000        '    211 ms'  '      8 ms'  '   26.38 x' 
 Literal_Number              1000        '    185 ms'  '      5 ms'  '   37.00 x' 
 Literal_Boolean             1000        '    195 ms'  '      4 ms'  '   48.75 x' 
 Primitive_Number            1000        '    149 ms'  '      7 ms'  '   21.29 x' 
 Primitive_String            1000        '    135 ms'  '      5 ms'  '   27.00 x' 
 Primitive_String_Pattern    1000        '    193 ms'  '     10 ms'  '   19.30 x' 
 Primitive_Boolean           1000        '    152 ms'  '      4 ms'  '   38.00 x' 
 Primitive_Null              1000        '    147 ms'  '      4 ms'  '   36.75 x' 
 Object_Unconstrained        1000        '   1065 ms'  '     26 ms'  '   40.96 x' 
 Object_Constrained          1000        '   1183 ms'  '     26 ms'  '   45.50 x' 
 Object_Vector3              1000        '    407 ms'  '      9 ms'  '   45.22 x' 
 Object_Box3D                1000        '   1777 ms'  '     24 ms'  '   74.04 x' 
 Tuple_Primitive             1000        '    485 ms'  '     11 ms'  '   44.09 x' 
 Tuple_Object                1000        '   1344 ms'  '     17 ms'  '   79.06 x' 
 Composite_Intersect         1000        '    606 ms'  '     14 ms'  '   43.29 x' 
 Composite_Union             1000        '    522 ms'  '     17 ms'  '   30.71 x' 
 Math_Vector4                1000        '    851 ms'  '      9 ms'  '   94.56 x' 
 Math_Matrix4                1000        '    406 ms'  '     10 ms'  '   40.60 x' 
 Array_Primitive_Number      1000        '    367 ms'  '      6 ms'  '   61.17 x' 
 Array_Primitive_String      1000        '    339 ms'  '      7 ms'  '   48.43 x' 
 Array_Primitive_Boolean     1000        '    325 ms'  '      5 ms'  '   65.00 x' 
 Array_Object_Unconstrained  1000        '   1863 ms'  '     21 ms'  '   88.71 x' 
 Array_Object_Constrained    1000        '   1535 ms'  '     18 ms'  '   85.28 x' 
 Array_Tuple_Primitive       1000        '    829 ms'  '     14 ms'  '   59.21 x' 
 Array_Tuple_Object          1000        '   1674 ms'  '     14 ms'  '  119.57 x' 
 Array_Composite_Intersect   1000        '    789 ms'  '     13 ms'  '   60.69 x' 
 Array_Composite_Union       1000        '    822 ms'  '     15 ms'  '   54.80 x' 
 Array_Math_Vector4          1000        '   1129 ms'  '     14 ms'  '   80.64 x' 
 Array_Math_Matrix4          1000        '    673 ms'  '      9 ms'  '   74.78 x' 

```

<a name='benchmark-validate'></a>

### Validate

This benchmark measures validation performance for varying types.

```typescript

 (index)                     Iterations  ValueCheck    Ajv           TypeCompiler  Performance  

 Literal_String              1000000     '     17 ms'  '      5 ms'  '      5 ms'  '    1.00 x' 
 Literal_Number              1000000     '     14 ms'  '     18 ms'  '      9 ms'  '    2.00 x' 
 Literal_Boolean             1000000     '     14 ms'  '     20 ms'  '      9 ms'  '    2.22 x' 
 Primitive_Number            1000000     '     17 ms'  '     19 ms'  '      9 ms'  '    2.11 x' 
 Primitive_String            1000000     '     17 ms'  '     18 ms'  '     10 ms'  '    1.80 x' 
 Primitive_String_Pattern    1000000     '    172 ms'  '     46 ms'  '     41 ms'  '    1.12 x' 
 Primitive_Boolean           1000000     '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' 
 Primitive_Null              1000000     '     16 ms'  '     19 ms'  '      9 ms'  '    2.11 x' 
 Object_Unconstrained        1000000     '    437 ms'  '     28 ms'  '     14 ms'  '    2.00 x' 
 Object_Constrained          1000000     '    653 ms'  '     46 ms'  '     37 ms'  '    1.24 x' 
 Object_Vector3              1000000     '    201 ms'  '     22 ms'  '     12 ms'  '    1.83 x' 
 Object_Box3D                1000000     '    961 ms'  '     37 ms'  '     19 ms'  '    1.95 x' 
 Object_Recursive            1000000     '   3715 ms'  '    363 ms'  '    174 ms'  '    2.09 x' 
 Tuple_Primitive             1000000     '    107 ms'  '     23 ms'  '     11 ms'  '    2.09 x' 
 Tuple_Object                1000000     '    375 ms'  '     28 ms'  '     15 ms'  '    1.87 x' 
 Composite_Intersect         1000000     '    377 ms'  '     22 ms'  '     12 ms'  '    1.83 x' 
 Composite_Union             1000000     '    337 ms'  '     30 ms'  '     17 ms'  '    1.76 x' 
 Math_Vector4                1000000     '    137 ms'  '     23 ms'  '     11 ms'  '    2.09 x' 
 Math_Matrix4                1000000     '    576 ms'  '     37 ms'  '     28 ms'  '    1.32 x' 
 Array_Primitive_Number      1000000     '    145 ms'  '     23 ms'  '     12 ms'  '    1.92 x' 
 Array_Primitive_String      1000000     '    152 ms'  '     22 ms'  '     13 ms'  '    1.69 x' 
 Array_Primitive_Boolean     1000000     '    131 ms'  '     20 ms'  '     13 ms'  '    1.54 x' 
 Array_Object_Unconstrained  1000000     '   2821 ms'  '     62 ms'  '     45 ms'  '    1.38 x' 
 Array_Object_Constrained    1000000     '   2958 ms'  '    119 ms'  '    134 ms'  '    0.89 x' 
 Array_Object_Recursive      1000000     '  14695 ms'  '   1621 ms'  '    635 ms'  '    2.55 x' 
 Array_Tuple_Primitive       1000000     '    478 ms'  '     35 ms'  '     28 ms'  '    1.25 x' 
 Array_Tuple_Object          1000000     '   1623 ms'  '     63 ms'  '     48 ms'  '    1.31 x' 
 Array_Composite_Intersect   1000000     '   1582 ms'  '     43 ms'  '     30 ms'  '    1.43 x' 
 Array_Composite_Union       1000000     '   1331 ms'  '     76 ms'  '     40 ms'  '    1.90 x' 
 Array_Math_Vector4          1000000     '    564 ms'  '     38 ms'  '     24 ms'  '    1.58 x' 
 Array_Math_Matrix4          1000000     '   2382 ms'  '    111 ms'  '     83 ms'  '    1.34 x' 

```

<a name='benchmark-compression'></a>

### Compression

The following table lists esbuild compiled and minified sizes for each TypeBox module.

```typescript

 (index)               Compiled    Minified    Compression 

 typebox/compiler      '122.4 kb'  ' 53.4 kb'  '2.29 x'    
 typebox/errors        ' 67.6 kb'  ' 29.6 kb'  '2.28 x'    
 typebox/syntax        '132.9 kb'  ' 54.2 kb'  '2.45 x'    
 typebox/system        '  7.4 kb'  '  3.2 kb'  '2.33 x'    
 typebox/value         '150.1 kb'  ' 62.2 kb'  '2.41 x'    
 typebox               '106.8 kb'  ' 43.2 kb'  '2.47 x'    

```

<a name='contribute'></a>

## Contribute

TypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project prefers open community discussion before accepting new features.


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\syntax\package.json

Code:
{
  "main": "../build/cjs/syntax/index.js",
  "types": "../build/cjs/syntax/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\system\package.json

Code:
{
  "main": "../build/cjs/system/index.js",
  "types": "../build/cjs/system/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\type\package.json

Code:
{
  "main": "../build/cjs/type/index.js",
  "types": "../build/cjs/type/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\value\package.json

Code:
{
  "main": "../build/cjs/value/index.js",
  "types": "../build/cjs/value/index.d.ts"
}

---

File name: node_modules\babel-jest\node_modules\babel-plugin-istanbul\CHANGELOG.md

Code:
# Changelog

All notable changes to this project will be documented in this file. See [standard-version](https://github.com/conventional-changelog/standard-version) for commit guidelines.

## [7.0.0](https://www.github.com/istanbuljs/babel-plugin-istanbul/compare/v6.1.1...v7.0.0) (2024-07-05)


###  BREAKING CHANGES

* Drop support for Node versions 8 and 10

### Bug Fixes

* container is falsy error with block scoping transform ([#291](https://www.github.com/istanbuljs/babel-plugin-istanbul/issues/291)) ([8e76919](https://www.github.com/istanbuljs/babel-plugin-istanbul/commit/8e7691901986d9aed751ff28724695e0beafb2a8))
* update `istanbul-lib-instrument` to v6 ([#292](https://www.github.com/istanbuljs/babel-plugin-istanbul/issues/292)) ([643e080](https://www.github.com/istanbuljs/babel-plugin-istanbul/commit/643e0801b23f5f1f96786e70b2a08379fe909b1a))

### [6.1.1](https://www.github.com/istanbuljs/babel-plugin-istanbul/compare/v6.1.0...v6.1.1) (2021-10-16)


### Bug Fixes

* **build:** first automated publication ([9a1b893](https://www.github.com/istanbuljs/babel-plugin-istanbul/commit/9a1b89342565d1127a011e31262520b057120531))

## [6.1.0](https://www.github.com/istanbuljs/babel-plugin-istanbul/compare/v6.0.0...v6.1.0) (2021-10-16)


### Features

* **instrumenter:** instrumenter with fixes for branchMap instrumentation ([#265](https://www.github.com/istanbuljs/babel-plugin-istanbul/issues/265)) ([1e9ec62](https://www.github.com/istanbuljs/babel-plugin-istanbul/commit/1e9ec62b50c9d2224e7bb0ccb071fd10b80e018f))

## [6.0.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.2.0...v6.0.0) (2019-12-20)


###  BREAKING CHANGES

* Drop node.js 6 (#226)

### Features

* Add support for instrumenter options ([#227](https://github.com/istanbuljs/babel-plugin-istanbul/issues/227)) ([fe08f5b](https://github.com/istanbuljs/babel-plugin-istanbul/commit/fe08f5b8282136c7ed9375fa32148586bd6a7e28)), closes [#208](https://github.com/istanbuljs/babel-plugin-istanbul/issues/208) [#212](https://github.com/istanbuljs/babel-plugin-istanbul/issues/212)
* Drop node.js 6 ([#226](https://github.com/istanbuljs/babel-plugin-istanbul/issues/226)) ([93db21a](https://github.com/istanbuljs/babel-plugin-istanbul/commit/93db21aa2bbdbb06fb784f52c24a7847fad6be92)), closes [#209](https://github.com/istanbuljs/babel-plugin-istanbul/issues/209)

## [5.2.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.1.4...v5.2.0) (2019-07-18)


### Bug Fixes

* Print explicit error if use with babel 6 is attempted ([#207](https://github.com/istanbuljs/babel-plugin-istanbul/issues/207)) ([a12cf16](https://github.com/istanbuljs/babel-plugin-istanbul/commit/a12cf16))


### Features

* Support turning off node_modules default exclude via flag ([#172](https://github.com/istanbuljs/babel-plugin-istanbul/issues/172)) ([a314f06](https://github.com/istanbuljs/babel-plugin-istanbul/commit/a314f06))



## [5.1.4](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.1.3...v5.1.4) (2019-04-25)



## [5.1.3](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.1.2...v5.1.3) (2019-04-23)


### Bug Fixes

* Revert [#192](https://github.com/istanbuljs/babel-plugin-istanbul/issues/192) ([201a933](https://github.com/istanbuljs/babel-plugin-istanbul/commit/201a933)) due to regression detailed at [#201](https://github.com/istanbuljs/babel-plugin-istanbul/issues/201)



## [5.1.2](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.1.1...v5.1.2) (2019-04-10)


### Bug Fixes

* Ensure correct scope references after traversal ([#192](https://github.com/istanbuljs/babel-plugin-istanbul/issues/192)) ([201a933](https://github.com/istanbuljs/babel-plugin-istanbul/commit/201a933))



<a name="5.1.1"></a>
## [5.1.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.1.0...v5.1.1) (2019-01-11)


### Bug Fixes

* respect changes of cwd in options ([#171](https://github.com/istanbuljs/babel-plugin-istanbul/issues/171)) ([adec723](https://github.com/istanbuljs/babel-plugin-istanbul/commit/adec723))



<a name="5.1.0"></a>
# [5.1.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.0.1...v5.1.0) (2018-09-07)


### Features

* Bump dependencies. ([b509649](https://github.com/istanbuljs/babel-plugin-istanbul/commit/b509649))



<a name="5.0.1"></a>
## [5.0.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v5.0.0...v5.0.1) (2018-07-24)



<a name="5.0.0"></a>
# [5.0.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.6...v5.0.0) (2018-06-27)


### Features

* upgrade to babel 7 and newest istanbul libraries ([#158](https://github.com/istanbuljs/babel-plugin-istanbul/issues/158)) ([a9e1564](https://github.com/istanbuljs/babel-plugin-istanbul/commit/a9e1564))


### BREAKING CHANGES

* Drop node 4 support, upgrade to babel 7, stop shipping @babel/plugin-syntax-object-rest-spread



<a name="4.1.6"></a>
## <small>4.1.6 (2018-03-09)</small>

* chore: explicit update of istanbul dependencies (#149) ([77b6eb7](https://github.com/istanbuljs/babel-plugin-istanbul/commit/77b6eb7)), closes [#149](https://github.com/istanbuljs/babel-plugin-istanbul/issues/149)
* chore(package): update coveralls to version 3.0.0 (#133) ([7045a03](https://github.com/istanbuljs/babel-plugin-istanbul/commit/7045a03)), closes [#133](https://github.com/istanbuljs/babel-plugin-istanbul/issues/133)
* chore(package): update mocha to version 4.0.0 (#134) ([38176ba](https://github.com/istanbuljs/babel-plugin-istanbul/commit/38176ba)), closes [#134](https://github.com/istanbuljs/babel-plugin-istanbul/issues/134)
* fix: babel-preset-es2015 => babel-preset-env (#138) ([18fe954](https://github.com/istanbuljs/babel-plugin-istanbul/commit/18fe954)), closes [#138](https://github.com/istanbuljs/babel-plugin-istanbul/issues/138)
* fix: include object-spread-syntax plugin (#141) ([428a952](https://github.com/istanbuljs/babel-plugin-istanbul/commit/428a952)), closes [#141](https://github.com/istanbuljs/babel-plugin-istanbul/issues/141)



<a name="4.1.5"></a>
## [4.1.5](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.2...v4.1.5) (2017-08-23)



<a name="4.1.4"></a>
## [4.1.4](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.3...v4.1.4) (2017-05-27)



<a name="4.1.3"></a>
## [4.1.3](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.1...v4.1.3) (2017-04-29)



<a name="4.1.2"></a>
## [4.1.2](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.1...v4.1.2) (2017-03-27)



<a name="4.1.1"></a>
## [4.1.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.1.0...v4.1.1) (2017-03-22)


### Bug Fixes

* explicit upgrade to patched version of istanbul-lib-instrument ([db8ecbe](https://github.com/istanbuljs/babel-plugin-istanbul/commit/db8ecbe))



<a name="4.1.0"></a>
# [4.1.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v4.0.0...v4.1.0) (2017-03-21)


### Features

* add includeUntested option to expose coverage of all instrumented files ([#80](https://github.com/istanbuljs/babel-plugin-istanbul/issues/80)) ([b078bbd](https://github.com/istanbuljs/babel-plugin-istanbul/commit/b078bbd))



<a name="4.0.0"></a>
# [4.0.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v3.1.2...v4.0.0) (2017-02-07)


### Bug Fixes

* load configuration from process.env.NYC_CONFIG if present ([#93](https://github.com/istanbuljs/babel-plugin-istanbul/issues/93)) ([e902924](https://github.com/istanbuljs/babel-plugin-istanbul/commit/e902924))


### Features

* drop Node 0.10 and 0.12 support, upgrade dependencies to reflect this ([#88](https://github.com/istanbuljs/babel-plugin-istanbul/issues/88)) ([594c03a](https://github.com/istanbuljs/babel-plugin-istanbul/commit/594c03a))
* we can now use the language feature Object.assign ([#92](https://github.com/istanbuljs/babel-plugin-istanbul/issues/92)) ([f77db2a](https://github.com/istanbuljs/babel-plugin-istanbul/commit/f77db2a))


### BREAKING CHANGES

* I've updated dependencies and dropped Node 0.10 and Node 0.12 support.



<a name="3.1.2"></a>
## [3.1.2](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v3.1.1...v3.1.2) (2017-01-04)


### Bug Fixes

* address regression related to export const foo = () => {} ([#79](https://github.com/istanbuljs/babel-plugin-istanbul/issues/79)) ([f870a8f](https://github.com/istanbuljs/babel-plugin-istanbul/commit/f870a8f))



<a name="3.1.1"></a>
## [3.1.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v3.1.0...v3.1.1) (2017-01-02)



<a name="3.1.0"></a>
# [3.1.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v3.0.0...v3.1.0) (2016-12-27)


### Bug Fixes

* upgrade a bunch of core dependencies ([#77](https://github.com/istanbuljs/babel-plugin-istanbul/issues/77)) ([e764330](https://github.com/istanbuljs/babel-plugin-istanbul/commit/e764330))


### Features

* accept source map input for the visitor ([#75](https://github.com/istanbuljs/babel-plugin-istanbul/issues/75)) ([437e90b](https://github.com/istanbuljs/babel-plugin-istanbul/commit/437e90b))



<a name="3.0.0"></a>
# [3.0.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v2.0.3...v3.0.0) (2016-11-14)


### Chores

* **package:** update test-exclude to version 3.0.0 ([#68](https://github.com/istanbuljs/babel-plugin-istanbul/issues/68)) ([0396385](https://github.com/istanbuljs/babel-plugin-istanbul/commit/0396385))


### BREAKING CHANGES

* package: test-exclude now adds `**/node_modules/**` as exclude rule by default.



<a name="2.0.3"></a>
## [2.0.3](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v2.0.2...v2.0.3) (2016-10-17)


### Bug Fixes

* force istanbul-lib-instrument with variable hoisting fix ([#64](https://github.com/istanbuljs/babel-plugin-istanbul/issues/64)) ([209a0cf](https://github.com/istanbuljs/babel-plugin-istanbul/commit/209a0cf))
* switch deprecated lodash.assign for object-assign ([#58](https://github.com/istanbuljs/babel-plugin-istanbul/issues/58)) ([6e051fc](https://github.com/istanbuljs/babel-plugin-istanbul/commit/6e051fc))



<a name="2.0.2"></a>
## [2.0.2](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v2.0.1...v2.0.2) (2016-09-08)


### Bug Fixes

* take realpath of cwd, whether or not set in env ([#37](https://github.com/istanbuljs/babel-plugin-istanbul/issues/37)) ([6274d83](https://github.com/istanbuljs/babel-plugin-istanbul/commit/6274d83))



<a name="2.0.1"></a>
## [2.0.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v2.0.0...v2.0.1) (2016-09-02)


### Bug Fixes

* update istanbul-lib-instrument ([573e0d4](https://github.com/istanbuljs/babel-plugin-istanbul/commit/573e0d4))



<a name="2.0.0"></a>
# [2.0.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v1.1.0...v2.0.0) (2016-08-14)


### Chores

* upgrade to version of test-exclude with new exclude rules ([#35](https://github.com/istanbuljs/babel-plugin-istanbul/issues/35)) ([220ce2b](https://github.com/istanbuljs/babel-plugin-istanbul/commit/220ce2b))


### BREAKING CHANGES

* see https://github.com/istanbuljs/test-exclude/blob/master/CHANGELOG.md#breaking-changes



<a name="1.1.0"></a>
# [1.1.0](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v1.0.3...v1.1.0) (2016-07-21)


### Bug Fixes

* upgrade to istanbul-lib-instrument with faster babel-generator ([#18](https://github.com/istanbuljs/babel-plugin-istanbul/issues/18)) ([d33263c](https://github.com/istanbuljs/babel-plugin-istanbul/commit/d33263c))


### Features

* allow exclude/include options to be passed as Babel plugin config ([#16](https://github.com/istanbuljs/babel-plugin-istanbul/issues/16)) ([cf68421](https://github.com/istanbuljs/babel-plugin-istanbul/commit/cf68421))



<a name="1.0.3"></a>
## [1.0.3](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v1.0.2...v1.0.3) (2016-07-09)


### Bug Fixes

* keep using NYC_CWD if available ([#10](https://github.com/istanbuljs/babel-plugin-istanbul/issues/10)) ([db0352b](https://github.com/istanbuljs/babel-plugin-istanbul/commit/db0352b))



<a name="1.0.2"></a>
## [1.0.2](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v1.0.1...v1.0.2) (2016-07-03)


### Bug Fixes

* take realpath of process.cwd(), fixes [#7](https://github.com/istanbuljs/babel-plugin-istanbul/issues/7) ([#8](https://github.com/istanbuljs/babel-plugin-istanbul/issues/8)) ([e8d3785](https://github.com/istanbuljs/babel-plugin-istanbul/commit/e8d3785)), closes [#7](https://github.com/istanbuljs/babel-plugin-istanbul/issues/7) [#8](https://github.com/istanbuljs/babel-plugin-istanbul/issues/8)



<a name="1.0.1"></a>
## [1.0.1](https://github.com/istanbuljs/babel-plugin-istanbul/compare/v1.0.0...v1.0.1) (2016-06-30)


### Bug Fixes

* upgrade to version of istanbul-lib-instrument that fixes some out of bounds issues ([#6](https://github.com/istanbuljs/babel-plugin-istanbul/issues/6)) ([a949065](https://github.com/istanbuljs/babel-plugin-istanbul/commit/a949065)), closes [#6](https://github.com/istanbuljs/babel-plugin-istanbul/issues/6)


<a name="1.0.0"></a>
# 1.0.0 (2016-06-26)


### Features

* port functionality from __coverage__, get ready for first release ([#2](https://github.com/istanbuljs/babel-plugin-istanbul/issues/2)) ([2a8ee44](https://github.com/istanbuljs/babel-plugin-istanbul/commit/2a8ee44))


---

File name: node_modules\babel-jest\node_modules\babel-plugin-istanbul\lib\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _fs = require("fs");
var _child_process = require("child_process");
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _istanbulLibInstrument = require("istanbul-lib-instrument");
var _testExclude = _interopRequireDefault(require("test-exclude"));
var _schema = _interopRequireDefault(require("@istanbuljs/schema"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function getRealpath(n) {
  try {
    return (0, _fs.realpathSync)(n) || /* istanbul ignore next */n;
  } catch (e) {
    /* istanbul ignore next */
    return n;
  }
}
const memoize = new Map();
/* istanbul ignore next */
const memosep = _path.default.sep === '/' ? ':' : ';';
function loadNycConfig(cwd, opts) {
  let memokey = cwd;
  const args = [_path.default.resolve(__dirname, 'load-nyc-config-sync.js'), cwd];
  if ('nycrcPath' in opts) {
    args.push(opts.nycrcPath);
    memokey += memosep + opts.nycrcPath;
  }

  /* execFileSync is expensive, avoid it if possible! */
  if (memoize.has(memokey)) {
    return memoize.get(memokey);
  }
  const result = JSON.parse((0, _child_process.execFileSync)(process.execPath, args));
  const error = result['load-nyc-config-sync-error'];
  if (error) {
    throw new Error(error);
  }
  const config = {
    ..._schema.default.defaults.babelPluginIstanbul,
    cwd,
    ...result
  };
  memoize.set(memokey, config);
  return config;
}
function findConfig(opts) {
  const cwd = getRealpath(opts.cwd || process.env.NYC_CWD || /* istanbul ignore next */process.cwd());
  const keys = Object.keys(opts);
  const ignored = Object.keys(opts).filter(s => s === 'nycrcPath' || s === 'cwd');
  if (keys.length > ignored.length) {
    // explicitly configuring options in babel
    // takes precedence.
    return {
      ..._schema.default.defaults.babelPluginIstanbul,
      cwd,
      ...opts
    };
  }
  if (ignored.length === 0 && process.env.NYC_CONFIG) {
    // defaults were already applied by nyc
    return JSON.parse(process.env.NYC_CONFIG);
  }
  return loadNycConfig(cwd, opts);
}
function makeShouldSkip() {
  let exclude;
  return function shouldSkip(file, nycConfig) {
    if (!exclude || exclude.cwd !== nycConfig.cwd) {
      exclude = new _testExclude.default({
        cwd: nycConfig.cwd,
        include: nycConfig.include,
        exclude: nycConfig.exclude,
        extension: nycConfig.extension,
        // Make sure this is true unless explicitly set to `false`. `undefined` is still `true`.
        excludeNodeModules: nycConfig.excludeNodeModules !== false
      });
    }
    return !exclude.shouldInstrument(file);
  };
}
var _default = exports.default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const shouldSkip = makeShouldSkip();
  const t = api.types;
  return {
    visitor: {
      Program: {
        enter(path) {
          this.__dv__ = null;
          this.nycConfig = findConfig(this.opts);
          const realPath = getRealpath(this.file.opts.filename);
          if (shouldSkip(realPath, this.nycConfig)) {
            return;
          }
          let {
            inputSourceMap
          } = this.opts;
          if (this.opts.useInlineSourceMaps !== false) {
            if (!inputSourceMap && this.file.inputMap) {
              inputSourceMap = this.file.inputMap.sourcemap;
            }
          }
          const visitorOptions = {};
          Object.entries(_schema.default.defaults.instrumentVisitor).forEach(([name, defaultValue]) => {
            if (name in this.nycConfig) {
              visitorOptions[name] = this.nycConfig[name];
            } else {
              visitorOptions[name] = _schema.default.defaults.instrumentVisitor[name];
            }
          });
          this.__dv__ = (0, _istanbulLibInstrument.programVisitor)(t, realPath, {
            ...visitorOptions,
            inputSourceMap
          });
          this.__dv__.enter(path);
          path.scope.crawl();
        },
        exit(path) {
          if (!this.__dv__) {
            return;
          }
          const result = this.__dv__.exit(path);
          if (this.opts.onCover) {
            this.opts.onCover(getRealpath(this.file.opts.filename), result.fileCoverage);
          }
        }
      }
    }
  };
});

---

File name: node_modules\babel-jest\node_modules\babel-plugin-istanbul\lib\load-nyc-config-sync.js

Code:
#!/usr/bin/env node
'use strict';

const {
  loadNycConfig
} = require('@istanbuljs/load-nyc-config');
async function main() {
  const [cwd, nycrcPath] = process.argv.slice(2);
  console.log(JSON.stringify(await loadNycConfig({
    cwd,
    nycrcPath
  })));
}
main().catch(error => {
  console.log(JSON.stringify({
    'load-nyc-config-sync-error': error.message
  }));
});

---

File name: node_modules\babel-jest\node_modules\babel-plugin-istanbul\package.json

Code:
{
  "name": "babel-plugin-istanbul",
  "version": "7.0.0",
  "author": "Thai Pangsakulyanont @dtinth",
  "license": "BSD-3-Clause",
  "description": "A babel plugin that adds istanbul instrumentation to ES6 code",
  "main": "lib/index.js",
  "files": [
    "lib"
  ],
  "dependencies": {
    "@babel/helper-plugin-utils": "^7.0.0",
    "@istanbuljs/load-nyc-config": "^1.0.0",
    "@istanbuljs/schema": "^0.1.3",
    "istanbul-lib-instrument": "^6.0.2",
    "test-exclude": "^6.0.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.24.1",
    "@babel/core": "^7.24.1",
    "@babel/plugin-transform-block-scoping": "^7.24.1",
    "@babel/plugin-transform-modules-commonjs": "^7.24.1",
    "@babel/register": "^7.23.7",
    "chai": "^4.2.0",
    "coveralls": "^3.1.1",
    "cross-env": "^7.0.3",
    "mocha": "^6.2.2",
    "nyc": "^15.0.0",
    "pmock": "^0.2.3",
    "standard": "^14.3.1"
  },
  "scripts": {
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "release": "babel src --out-dir lib",
    "pretest": "standard && npm run release",
    "test": "cross-env NODE_ENV=test nyc --reporter=lcov --reporter=text mocha --timeout 5000 test/*.js",
    "prepublish": "npm test && npm run release"
  },
  "standard": {
    "ignore": [
      "fixtures/*.js"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/istanbuljs/babel-plugin-istanbul.git"
  },
  "keywords": [
    "istanbul",
    "babel",
    "plugin",
    "instrumentation"
  ],
  "nyc": {
    "include": [
      "src/*.js",
      "fixtures/should-cover.js"
    ],
    "require": [
      "@babel/register"
    ],
    "sourceMap": false,
    "instrument": false
  },
  "bugs": {
    "url": "https://github.com/istanbuljs/babel-plugin-istanbul/issues"
  },
  "homepage": "https://github.com/istanbuljs/babel-plugin-istanbul#readme",
  "engines": {
    "node": ">=12"
  }
}


---

File name: node_modules\babel-jest\node_modules\babel-plugin-istanbul\README.md

Code:
# babel-plugin-istanbul

[![Coverage Status](https://coveralls.io/repos/github/istanbuljs/babel-plugin-istanbul/badge.svg?branch=master)](https://coveralls.io/github/istanbuljs/babel-plugin-istanbul?branch=master)
[![Conventional Commits](https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg)](https://conventionalcommits.org)
[![community slack](http://devtoolscommunity.herokuapp.com/badge.svg)](http://devtoolscommunity.herokuapp.com)

_Having problems? want to contribute? join our [community slack](http://devtoolscommunity.herokuapp.com)_.

A Babel plugin that instruments your code with Istanbul coverage.
It can instantly be used with [karma-coverage](https://github.com/karma-runner/karma-coverage) and mocha on Node.js (through [nyc](https://github.com/bcoe/nyc)).

__Note:__ This plugin does not generate any report or save any data to any file;
it only adds instrumenting code to your JavaScript source code.
To integrate with testing tools, please see the [Integrations](#integrations) section.

## Usage

Install it:

```
npm install --save-dev babel-plugin-istanbul
```

Add it to `.babelrc` in test mode:

```js
{
  "env": {
    "test": {
      "plugins": [ "istanbul" ]
    }
  }
}
```

Optionally, use [cross-env](https://www.npmjs.com/package/cross-env) to set
`NODE_ENV=test`:

```json
{
  "scripts": {
    "test": "cross-env NODE_ENV=test nyc --reporter=lcov --reporter=text mocha test/*.js"
  }
}
```

## Integrations

### karma

It _just works_ with Karma. First, make sure that the code is already transpiled by Babel (either using `karma-babel-preprocessor`, `karma-webpack`, or `karma-browserify`). Then, simply set up [karma-coverage](https://github.com/karma-runner/karma-coverage) according to the docs, but __dont add the `coverage` preprocessor.__ This plugin has already instrumented your code, and Karma should pick it up automatically.

It has been tested with [bemusic/bemuse](https://codecov.io/github/bemusic/bemuse) project, which contains ~2400 statements.

### mocha on node.js (through nyc)

Configure Mocha to transpile JavaScript code using Babel, then you can run your tests with [`nyc`](https://github.com/bcoe/nyc), which will collect all the coverage report.

babel-plugin-istanbul respects the `include`/`exclude` configuration options from nyc,
but you also need to __configure NYC not to instrument your code__ by adding these settings in your `package.json`:

```js
  "nyc": {
    "sourceMap": false,
    "instrument": false
  },
```

## Ignoring files

You don't want to cover your test files as this will skew your coverage results. You can configure this by providing plugin options matching nyc's [`exclude`/`include` rules](https://github.com/bcoe/nyc#excluding-files):

```json
{
  "env": {
    "test": {
      "plugins": [
        ["istanbul", {
          "exclude": [
            "**/*.spec.js"
          ]
        }]
      ]
    }
  }
}
```

If you don't provide options in your Babel config, the plugin will look for `exclude`/`include` config under an `"nyc"` key in `package.json`.

You can also use [istanbul's ignore hints](https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes) to specify specific lines of code to skip instrumenting.

## Source Maps

By default, this plugin will pick up inline source maps and attach them to the instrumented code such that code coverage can be remapped back to the original source, even for multi-step build processes. This can be memory intensive. Set `useInlineSourceMaps` to prevent this behavior.

```json
{
  "env": {
    "test": {
      "plugins": [
        ["istanbul", {
          "useInlineSourceMaps": false
        }]
      ]
    }
  }
}
```

If you're instrumenting code programatically, you can pass a source map explicitly.
```js
import babelPluginIstanbul from 'babel-plugin-istanbul';

function instrument(sourceCode, sourceMap, filename) {
  return babel.transform(sourceCode, {
    filename,
    plugins: [
      [babelPluginIstanbul, {
        inputSourceMap: sourceMap
      }]
    ]
  })
}
```

## Credit where credit is due

The approach used in `babel-plugin-istanbul` was inspired by [Thai Pangsakulyanont](https://github.com/dtinth)'s original library [`babel-plugin-__coverage__`](https://github.com/dtinth/babel-plugin-__coverage__).

## `babel-plugin-istanbul` for enterprise

Available as part of the Tidelift Subscription.

The maintainers of `babel-plugin-istanbul` and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-babel-plugin-istanbul?utm_source=npm-babel-plugin-istanbul&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)


---

File name: node_modules\babel-jest\node_modules\ci-info\CHANGELOG.md

Code:
# Changelog

## v4.2.0

- support Cloudflare Pages [75c9de8](https://github.com/watson/ci-info/commit/75c9de8)

### v4.1.0

- support Appcircle PR [1d42c26](https://github.com/watson/ci-info/commit/1d42c26)
- support AWS CodeBuild PR [e6fcdd2](https://github.com/watson/ci-info/commit/e6fcdd2)
- add `ci.id` to return vendor constant [81fd993](https://github.com/watson/ci-info/commit/81fd993)

## v4.0.0

- support Earthly CI [fb8bd85](https://github.com/watson/ci-info/commit/fb8bd85)
- support Prow CI [8e6a591](https://github.com/watson/ci-info/commit/8e6a591)
- support Vela CI [bb13901](https://github.com/watson/ci-info/commit/bb13901)
- support Agola CI [ec4e149](https://github.com/watson/ci-info/commit/ec4e149)
- support Gitea Actions [f6f173f](https://github.com/watson/ci-info/commit/f6f173f)
- run tests on nodejs v20 [bff314d](https://github.com/watson/ci-info/commit/bff314d)

#### Breaking Changes

- remove Shippable CI [2c5571a](https://github.com/watson/ci-info/commit/2c5571a)
- remove Solano CI [d6315fc](https://github.com/watson/ci-info/commit/d6315fc)

## v3.9.0

- better support for Azure Pipelines ([#116](https://github.com/watson/ci-info/pull/116)), [5ea8d85](https://github.com/watson/ci-info/commit/5ea8d85)
- detect PullRequest in Azure Pipelines [5ea8d85](https://github.com/watson/ci-info/commit/5ea8d85)

## v3.8.0

- support Harness CI [76a2867](https://github.com/watson/ci-info/commit/76a2867)

## v3.7.1

- ignore ci detection when CI is set to `'false'` [24cc450](https://github.com/watson/ci-info/commit/24cc450)

## v3.7.0

- support Sourcehut CI [85b96ea](https://github.com/watson/ci-info/commit/85b96ea)
- support ReleaseHub CI [409d886](https://github.com/watson/ci-info/commit/409d886)

## v3.6.2

- fix VERCEL environment detection ([#98](https://github.com/watson/ci-info/pull/98))

## v3.6.1

- fix error in typings [357b454](https://github.com/watson/ci-info/commit/357b454)

## v3.6.0

This release attempts to bring parity with [@npmcli/ci-detect](https://github.com/npm/ci-detect). See [#95](https://github.com/watson/ci-info/pull/95) for more details.

- support gerrit ([#95](https://github.com/watson/ci-info/pull/95))
- support google cloud build ([#95](https://github.com/watson/ci-info/pull/95))
- support heroku ([#95](https://github.com/watson/ci-info/pull/95))
- support anonymous CI's that exposes BUILD_ID and CI_NAME env vars ([#95](https://github.com/watson/ci-info/pull/95))
- support more vercel environments ([#95](https://github.com/watson/ci-info/pull/95))

## v3.5.0

- support Woodpecker CI ([#90](https://github.com/watson/ci-info/pull/90))

## v3.4.0

- partial support Appflow CI (only CI detection) ([#84](https://github.com/watson/ci-info/pull/84))
- support Codemagic CI ([#85](https://github.com/watson/ci-info/pull/85))
- support Xcode Server CI ([#86](https://github.com/watson/ci-info/pull/86))
- support Xcode Cloud CI ([#86](https://github.com/watson/ci-info/pull/86))

## v3.3.2

- fix: export correct typings for `EAS`

## v3.3.1

- fix: export `EAS_BUILD` constant in typings
- Add support for nodejs v18

## v3.3.0

- support Expo Application Services ([#70](https://github.com/watson/ci-info/pull/70))

## v3.2.0

- support LayerCI ([#68](https://github.com/watson/ci-info/pull/68))
- support Appcircle ([#69](https://github.com/watson/ci-info/pull/69))
- support Codefresh CI ([#65](https://github.com/watson/ci-info/pull/65))
- add support for nodejs v16

## v3.1.1

Bug Fixes:

- remove duplicate declaration in typings

## v3.1.0

Features:

- add typings

## v3.0.0

Features:

- Add support nodejs versions: 14, 15
- support Nevercode ([#30](https://github.com/watson/ci-info/pull/30))
- support Render CI ([#36](https://github.com/watson/ci-info/pull/36))
- support Now CI ([#37](https://github.com/watson/ci-info/pull/37))
- support GitLab PR ([#59](https://github.com/watson/ci-info/pull/59))
- support Screwdriver CD ([#60](https://github.com/watson/ci-info/pull/60))
- support Visual Studio App Center ([#61](https://github.com/watson/ci-info/pull/61))

Bug Fixes:

- update Netlify env constant ([#47](https://github.com/watson/ci-info/pull/47))

Breaking changes:

- Drop support for Node.js end-of-life versions: 6, 13
- replace `Zeit Now` with `Vercel` ([#55](https://github.com/watson/ci-info/pull/55))

## v2.0.0

Breaking changes:

- Drop support for Node.js end-of-life versions: 0.10, 0.12, 4, 5, 7, and 9
- Team Foundation Server will now be detected as Azure Pipelines. The constant `ci.TFS` no longer exists - use
  `ci.AZURE_PIPELINES` instead
- Remove deprecated `ci.TDDIUM` constant - use `ci.SOLANDO` instead

New features:

- feat: support Azure Pipelines ([#23](https://github.com/watson/ci-info/pull/23))
- feat: support Netlify CI ([#26](https://github.com/watson/ci-info/pull/26))
- feat: support Bitbucket pipelines PR detection ([#27](https://github.com/watson/ci-info/pull/27))

## v1.6.0

- feat: add Sail CI support
- feat: add Buddy support
- feat: add Bitrise support
- feat: detect Jenkins PRs
- feat: detect Drone PRs

## v1.5.1

- fix: use full path to vendors.json

## v1.5.0

- feat: add dsari detection ([#15](https://github.com/watson/ci-info/pull/15))
- feat: add ci.isPR ([#16](https://github.com/watson/ci-info/pull/16))

## v1.4.0

- feat: add Cirrus CI detection ([#13](https://github.com/watson/ci-info/pull/13))
- feat: add Shippable CI detection ([#14](https://github.com/watson/ci-info/pull/14))

## v1.3.1

- chore: reduce npm package size by not including `.github` folder content
  ([#11](https://github.com/watson/ci-info/pull/11))

## v1.3.0

- feat: add support for Strider CD
- chore: deprecate vendor constant `TDDIUM` in favor of `SOLANO`
- docs: add missing vendor constant to docs

## v1.2.0

- feat: detect solano-ci ([#9](https://github.com/watson/ci-info/pull/9))

## v1.1.3

- fix: fix spelling of Hunson in `ci.name`

## v1.1.2

- fix: no more false positive matches for Jenkins

## v1.1.1

- docs: sort lists of CI servers in README.md
- docs: add missing AWS CodeBuild to the docs

## v1.1.0

- feat: add AWS CodeBuild to CI detection ([#2](https://github.com/watson/ci-info/pull/2))

## v1.0.1

- chore: reduce npm package size by using an `.npmignore` file ([#3](https://github.com/watson/ci-info/pull/3))

## v1.0.0

- Initial release


---

File name: node_modules\babel-jest\node_modules\ci-info\index.d.ts

Code:
// This file is generated at pre-commit by running `node create-typings.js`.

/**
 * Returns a boolean. Will be `true` if the code is running on a CI server,
 * otherwise `false`.
 *
 * Some CI servers not listed here might still trigger the `ci.isCI`
 * boolean to be set to `true` if they use certain vendor neutral environment
 * variables. In those cases `ci.name` will be `null` and no vendor specific
 * boolean will be set to `true`.
 */
export const isCI: boolean;
/**
 * Returns a boolean if PR detection is supported for the current CI server.
 * Will be `true` if a PR is being tested, otherwise `false`. If PR detection is
 * not supported for the current CI server, the value will be `null`.
 */
export const isPR: boolean | null;
/**
 * Returns a string containing name of the CI server the code is running on. If
 * CI server is not detected, it returns `null`.
 *
 * Don't depend on the value of this string not to change for a specific vendor.
 * If you find your self writing `ci.name === 'Travis CI'`, you most likely want
 * to use `ci.TRAVIS` instead.
 */
export const name: string | null;
/**
 * Returns a string containing the identifier of the CI server the code is running on. If
 * CI server is not detected, it returns `null`.
 */
export const id: string | null;

/* Vendor constants */
export const AGOLA: boolean;
export const APPCIRCLE: boolean;
export const APPVEYOR: boolean;
export const CODEBUILD: boolean;
export const AZURE_PIPELINES: boolean;
export const BAMBOO: boolean;
export const BITBUCKET: boolean;
export const BITRISE: boolean;
export const BUDDY: boolean;
export const BUILDKITE: boolean;
export const CIRCLE: boolean;
export const CIRRUS: boolean;
export const CLOUDFLARE_PAGES: boolean;
export const CODEFRESH: boolean;
export const CODEMAGIC: boolean;
export const CODESHIP: boolean;
export const DRONE: boolean;
export const DSARI: boolean;
export const EARTHLY: boolean;
export const EAS: boolean;
export const GERRIT: boolean;
export const GITEA_ACTIONS: boolean;
export const GITHUB_ACTIONS: boolean;
export const GITLAB: boolean;
export const GOCD: boolean;
export const GOOGLE_CLOUD_BUILD: boolean;
export const HARNESS: boolean;
export const HEROKU: boolean;
export const HUDSON: boolean;
export const JENKINS: boolean;
export const LAYERCI: boolean;
export const MAGNUM: boolean;
export const NETLIFY: boolean;
export const NEVERCODE: boolean;
export const PROW: boolean;
export const RELEASEHUB: boolean;
export const RENDER: boolean;
export const SAIL: boolean;
export const SCREWDRIVER: boolean;
export const SEMAPHORE: boolean;
export const SOURCEHUT: boolean;
export const STRIDER: boolean;
export const TASKCLUSTER: boolean;
export const TEAMCITY: boolean;
export const TRAVIS: boolean;
export const VELA: boolean;
export const VERCEL: boolean;
export const APPCENTER: boolean;
export const WOODPECKER: boolean;
export const XCODE_CLOUD: boolean;
export const XCODE_SERVER: boolean;


---

File name: node_modules\babel-jest\node_modules\ci-info\index.js

Code:
'use strict'

const vendors = require('./vendors.json')

const env = process.env

// Used for testing only
Object.defineProperty(exports, '_vendors', {
  value: vendors.map(function (v) {
    return v.constant
  })
})

exports.name = null
exports.isPR = null
exports.id = null

vendors.forEach(function (vendor) {
  const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env]
  const isCI = envs.every(function (obj) {
    return checkEnv(obj)
  })

  exports[vendor.constant] = isCI

  if (!isCI) {
    return
  }

  exports.name = vendor.name
  exports.isPR = checkPR(vendor)
  exports.id = vendor.constant
})

exports.isCI = !!(
  env.CI !== 'false' && // Bypass all checks if CI env is explicitly set to 'false'
  (env.BUILD_ID || // Jenkins, Cloudbees
    env.BUILD_NUMBER || // Jenkins, TeamCity
    env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari, Cloudflare Pages
    env.CI_APP_ID || // Appflow
    env.CI_BUILD_ID || // Appflow
    env.CI_BUILD_NUMBER || // Appflow
    env.CI_NAME || // Codeship and others
    env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
    env.RUN_ID || // TaskCluster, dsari
    exports.name ||
    false)
)

function checkEnv (obj) {
  // "env": "CIRRUS"
  if (typeof obj === 'string') return !!env[obj]

  // "env": { "env": "NODE", "includes": "/app/.heroku/node/bin/node" }
  if ('env' in obj) {
    // Currently there are no other types, uncomment when there are
    // if ('includes' in obj) {
    return env[obj.env] && env[obj.env].includes(obj.includes)
    // }
  }

  if ('any' in obj) {
    return obj.any.some(function (k) {
      return !!env[k]
    })
  }

  return Object.keys(obj).every(function (k) {
    return env[k] === obj[k]
  })
}

function checkPR (vendor) {
  switch (typeof vendor.pr) {
    case 'string':
      // "pr": "CIRRUS_PR"
      return !!env[vendor.pr]
    case 'object':
      if ('env' in vendor.pr) {
        if ('any' in vendor.pr) {
          // "pr": { "env": "CODEBUILD_WEBHOOK_EVENT", "any": ["PULL_REQUEST_CREATED", "PULL_REQUEST_UPDATED"] }
          return vendor.pr.any.some(function (key) {
            return env[vendor.pr.env] === key
          })
        } else {
          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
          return vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne
        }
      } else if ('any' in vendor.pr) {
        // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
        return vendor.pr.any.some(function (key) {
          return !!env[key]
        })
      } else {
        // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
        return checkEnv(vendor.pr)
      }
    default:
      // PR detection not supported for this vendor
      return null
  }
}


---

File name: node_modules\babel-jest\node_modules\ci-info\package.json

Code:
{
  "name": "ci-info",
  "version": "4.2.0",
  "description": "Get details about the current Continuous Integration environment",
  "main": "index.js",
  "typings": "index.d.ts",
  "type": "commonjs",
  "author": "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
  "license": "MIT",
  "repository": "github:watson/ci-info",
  "bugs": "https://github.com/watson/ci-info/issues",
  "homepage": "https://github.com/watson/ci-info",
  "contributors": [
    {
      "name": "Sibiraj",
      "url": "https://github.com/sibiraj-s"
    }
  ],
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/sibiraj-s"
    }
  ],
  "keywords": [
    "ci",
    "continuous",
    "integration",
    "test",
    "detect"
  ],
  "files": [
    "vendors.json",
    "index.js",
    "index.d.ts",
    "CHANGELOG.md"
  ],
  "scripts": {
    "lint:fix": "standard --fix",
    "test": "standard && node test.js",
    "prepare": "husky install || true"
  },
  "devDependencies": {
    "clear-module": "^4.1.2",
    "husky": "^9.1.7",
    "publint": "^0.3.8",
    "standard": "^17.1.2",
    "tape": "^5.9.0"
  },
  "engines": {
    "node": ">=8"
  }
}


---

File name: node_modules\babel-jest\node_modules\ci-info\README.md

Code:
# ci-info

Get details about the current Continuous Integration environment.

Please [open an
issue](https://github.com/watson/ci-info/issues/new?template=ci-server-not-detected.md)
if your CI server isn't properly detected :)

[![npm](https://img.shields.io/npm/v/ci-info.svg)](https://www.npmjs.com/package/ci-info)
[![Tests](https://github.com/watson/ci-info/workflows/Tests/badge.svg)](https://github.com/watson/ci-info/actions)
[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://github.com/feross/standard)

## Installation

```bash
npm install ci-info --save
```

## Usage

```js
var ci = require('ci-info')

if (ci.isCI) {
  console.log('The name of the CI server is:', ci.name)
} else {
  console.log('This program is not running on a CI server')
}
```

## Supported CI tools

Officially supported CI servers:

| Name                                                                            | Constant                | isPR |
| ------------------------------------------------------------------------------- | ----------------------- | ---- |
| [Agola CI](https://agola.io/)                                                   | `ci.AGOLA`              |    |
| [Appcircle](https://appcircle.io/)                                              | `ci.APPCIRCLE`          |    |
| [AppVeyor](http://www.appveyor.com)                                             | `ci.APPVEYOR`           |    |
| [AWS CodeBuild](https://aws.amazon.com/codebuild/)                              | `ci.CODEBUILD`          |    |
| [Azure Pipelines](https://azure.microsoft.com/en-us/services/devops/pipelines/) | `ci.AZURE_PIPELINES`    |    |
| [Bamboo](https://www.atlassian.com/software/bamboo) by Atlassian                | `ci.BAMBOO`             |    |
| [Bitbucket Pipelines](https://bitbucket.org/product/features/pipelines)         | `ci.BITBUCKET`          |    |
| [Bitrise](https://www.bitrise.io/)                                              | `ci.BITRISE`            |    |
| [Buddy](https://buddy.works/)                                                   | `ci.BUDDY`              |    |
| [Buildkite](https://buildkite.com)                                              | `ci.BUILDKITE`          |    |
| [CircleCI](http://circleci.com)                                                 | `ci.CIRCLE`             |    |
| [Cirrus CI](https://cirrus-ci.org)                                              | `ci.CIRRUS`             |    |
| [Cloudflare Pages](https://pages.cloudflare.com/)                               | `ci.CLOUDFLARE_PAGES`   |    |
| [Codefresh](https://codefresh.io/)                                              | `ci.CODEFRESH`          |    |
| [Codeship](https://codeship.com)                                                | `ci.CODESHIP`           |    |
| [Drone](https://drone.io)                                                       | `ci.DRONE`              |    |
| [dsari](https://github.com/rfinnie/dsari)                                       | `ci.DSARI`              |    |
| [Earthly CI](https://earthly.dev/)                                              | `ci.EARTHLY`            |    |
| [Expo Application Services](https://expo.dev/eas)                               | `ci.EAS`                |    |
| [Gerrit CI](https://www.gerritcodereview.com)                                   | `ci.GERRIT`             |    |
| [GitHub Actions](https://github.com/features/actions/)                          | `ci.GITHUB_ACTIONS`     |    |
| [GitLab CI](https://about.gitlab.com/gitlab-ci/)                                | `ci.GITLAB`             |    |
| [Gitea Actions](https://about.gitea.com/)                                       | `ci.GITEA_ACTIONS`      |   |
| [GoCD](https://www.go.cd/)                                                      | `ci.GOCD`               |    |
| [Google Cloud Build](https://cloud.google.com/build)                            | `ci.GOOGLE_CLOUD_BUILD` |    |
| [Harness CI](https://www.harness.io/products/continuous-integration)            | `ci.HARNESS`            |    |
| [Heroku](https://www.heroku.com)                                                | `ci.HEROKU`             |    |
| [Hudson](http://hudson-ci.org)                                                  | `ci.HUDSON`             |    |
| [Jenkins CI](https://jenkins-ci.org)                                            | `ci.JENKINS`            |    |
| [LayerCI](https://layerci.com/)                                                 | `ci.LAYERCI`            |    |
| [Magnum CI](https://magnum-ci.com)                                              | `ci.MAGNUM`             |    |
| [Netlify CI](https://www.netlify.com/)                                          | `ci.NETLIFY`            |    |
| [Nevercode](http://nevercode.io/)                                               | `ci.NEVERCODE`          |    |
| [Prow](https://docs.prow.k8s.io/)                                               | `ci.PROW`               |    |
| [ReleaseHub](https://releasehub.com/)                                           | `ci.RELEASEHUB`         |    |
| [Render](https://render.com/)                                                   | `ci.RENDER`             |    |
| [Sail CI](https://sail.ci/)                                                     | `ci.SAIL`               |    |
| [Screwdriver](https://screwdriver.cd/)                                          | `ci.SCREWDRIVER`        |    |
| [Semaphore](https://semaphoreci.com)                                            | `ci.SEMAPHORE`          |    |
| [Sourcehut](https://sourcehut.org/)                                             | `ci.SOURCEHUT`          |    |
| [Strider CD](https://strider-cd.github.io/)                                     | `ci.STRIDER`            |    |
| [TaskCluster](http://docs.taskcluster.net)                                      | `ci.TASKCLUSTER`        |    |
| [TeamCity](https://www.jetbrains.com/teamcity/) by JetBrains                    | `ci.TEAMCITY`           |    |
| [Travis CI](http://travis-ci.org)                                               | `ci.TRAVIS`             |    |
| [Vela](https://go-vela.github.io/docs/)                                         | `ci.VELA`               |    |
| [Vercel](https://vercel.com/)                                                   | `ci.VERCEL`             |    |
| [Visual Studio App Center](https://appcenter.ms/)                               | `ci.APPCENTER`          |    |
| [Woodpecker](https://woodpecker-ci.org/)                                        | `ci.WOODPECKER`         |    |

## API

### `ci.name`

Returns a string containing name of the CI server the code is running on.
If CI server is not detected, it returns `null`.

Don't depend on the value of this string not to change for a specific
vendor. If you find your self writing `ci.name === 'Travis CI'`, you
most likely want to use `ci.TRAVIS` instead.

### `ci.isCI`

Returns a boolean. Will be `true` if the code is running on a CI server,
otherwise `false`.

Some CI servers not listed here might still trigger the `ci.isCI`
boolean to be set to `true` if they use certain vendor neutral
environment variables. In those cases `ci.name` will be `null` and no
vendor specific boolean will be set to `true`.

### `ci.isPR`

Returns a boolean if PR detection is supported for the current CI server. Will
be `true` if a PR is being tested, otherwise `false`. If PR detection is
not supported for the current CI server, the value will be `null`.

### `ci.<VENDOR-CONSTANT>`

A vendor specific boolean constant is exposed for each support CI
vendor. A constant will be `true` if the code is determined to run on
the given CI server, otherwise `false`.

Examples of vendor constants are `ci.TRAVIS` or `ci.APPVEYOR`. For a
complete list, see the support table above.

## Ports

ci-info has been ported to the following languages

| Language | Repository |
|----------|------------|
| Go       | https://github.com/hofstadter-io/cinful |
| Rust     | https://github.com/sagiegurari/ci_info |
| Kotlin   | https://github.com/cloudflightio/ci-info |

## License

[MIT](LICENSE)


---

File name: node_modules\babel-jest\node_modules\ci-info\vendors.json

Code:
[
  {
    "name": "Agola CI",
    "constant": "AGOLA",
    "env": "AGOLA_GIT_REF",
    "pr": "AGOLA_PULL_REQUEST_ID"
  },
  {
    "name": "Appcircle",
    "constant": "APPCIRCLE",
    "env": "AC_APPCIRCLE",
    "pr": {
      "env": "AC_GIT_PR",
      "ne": "false"
    }
  },
  {
    "name": "AppVeyor",
    "constant": "APPVEYOR",
    "env": "APPVEYOR",
    "pr": "APPVEYOR_PULL_REQUEST_NUMBER"
  },
  {
    "name": "AWS CodeBuild",
    "constant": "CODEBUILD",
    "env": "CODEBUILD_BUILD_ARN",
    "pr": {
      "env": "CODEBUILD_WEBHOOK_EVENT",
      "any": [
        "PULL_REQUEST_CREATED",
        "PULL_REQUEST_UPDATED",
        "PULL_REQUEST_REOPENED"
      ]
    }
  },
  {
    "name": "Azure Pipelines",
    "constant": "AZURE_PIPELINES",
    "env": "TF_BUILD",
    "pr": {
      "BUILD_REASON": "PullRequest"
    }
  },
  {
    "name": "Bamboo",
    "constant": "BAMBOO",
    "env": "bamboo_planKey"
  },
  {
    "name": "Bitbucket Pipelines",
    "constant": "BITBUCKET",
    "env": "BITBUCKET_COMMIT",
    "pr": "BITBUCKET_PR_ID"
  },
  {
    "name": "Bitrise",
    "constant": "BITRISE",
    "env": "BITRISE_IO",
    "pr": "BITRISE_PULL_REQUEST"
  },
  {
    "name": "Buddy",
    "constant": "BUDDY",
    "env": "BUDDY_WORKSPACE_ID",
    "pr": "BUDDY_EXECUTION_PULL_REQUEST_ID"
  },
  {
    "name": "Buildkite",
    "constant": "BUILDKITE",
    "env": "BUILDKITE",
    "pr": {
      "env": "BUILDKITE_PULL_REQUEST",
      "ne": "false"
    }
  },
  {
    "name": "CircleCI",
    "constant": "CIRCLE",
    "env": "CIRCLECI",
    "pr": "CIRCLE_PULL_REQUEST"
  },
  {
    "name": "Cirrus CI",
    "constant": "CIRRUS",
    "env": "CIRRUS_CI",
    "pr": "CIRRUS_PR"
  },
  {
    "name": "Cloudflare Pages",
    "constant": "CLOUDFLARE_PAGES",
    "env": "CF_PAGES"
  },
  {
    "name": "Codefresh",
    "constant": "CODEFRESH",
    "env": "CF_BUILD_ID",
    "pr": {
      "any": [
        "CF_PULL_REQUEST_NUMBER",
        "CF_PULL_REQUEST_ID"
      ]
    }
  },
  {
    "name": "Codemagic",
    "constant": "CODEMAGIC",
    "env": "CM_BUILD_ID",
    "pr": "CM_PULL_REQUEST"
  },
  {
    "name": "Codeship",
    "constant": "CODESHIP",
    "env": {
      "CI_NAME": "codeship"
    }
  },
  {
    "name": "Drone",
    "constant": "DRONE",
    "env": "DRONE",
    "pr": {
      "DRONE_BUILD_EVENT": "pull_request"
    }
  },
  {
    "name": "dsari",
    "constant": "DSARI",
    "env": "DSARI"
  },
  {
    "name": "Earthly",
    "constant": "EARTHLY",
    "env": "EARTHLY_CI"
  },
  {
    "name": "Expo Application Services",
    "constant": "EAS",
    "env": "EAS_BUILD"
  },
  {
    "name": "Gerrit",
    "constant": "GERRIT",
    "env": "GERRIT_PROJECT"
  },
  {
    "name": "Gitea Actions",
    "constant": "GITEA_ACTIONS",
    "env": "GITEA_ACTIONS"
  },
  {
    "name": "GitHub Actions",
    "constant": "GITHUB_ACTIONS",
    "env": "GITHUB_ACTIONS",
    "pr": {
      "GITHUB_EVENT_NAME": "pull_request"
    }
  },
  {
    "name": "GitLab CI",
    "constant": "GITLAB",
    "env": "GITLAB_CI",
    "pr": "CI_MERGE_REQUEST_ID"
  },
  {
    "name": "GoCD",
    "constant": "GOCD",
    "env": "GO_PIPELINE_LABEL"
  },
  {
    "name": "Google Cloud Build",
    "constant": "GOOGLE_CLOUD_BUILD",
    "env": "BUILDER_OUTPUT"
  },
  {
    "name": "Harness CI",
    "constant": "HARNESS",
    "env": "HARNESS_BUILD_ID"
  },
  {
    "name": "Heroku",
    "constant": "HEROKU",
    "env": {
      "env": "NODE",
      "includes": "/app/.heroku/node/bin/node"
    }
  },
  {
    "name": "Hudson",
    "constant": "HUDSON",
    "env": "HUDSON_URL"
  },
  {
    "name": "Jenkins",
    "constant": "JENKINS",
    "env": [
      "JENKINS_URL",
      "BUILD_ID"
    ],
    "pr": {
      "any": [
        "ghprbPullId",
        "CHANGE_ID"
      ]
    }
  },
  {
    "name": "LayerCI",
    "constant": "LAYERCI",
    "env": "LAYERCI",
    "pr": "LAYERCI_PULL_REQUEST"
  },
  {
    "name": "Magnum CI",
    "constant": "MAGNUM",
    "env": "MAGNUM"
  },
  {
    "name": "Netlify CI",
    "constant": "NETLIFY",
    "env": "NETLIFY",
    "pr": {
      "env": "PULL_REQUEST",
      "ne": "false"
    }
  },
  {
    "name": "Nevercode",
    "constant": "NEVERCODE",
    "env": "NEVERCODE",
    "pr": {
      "env": "NEVERCODE_PULL_REQUEST",
      "ne": "false"
    }
  },
  {
    "name": "Prow",
    "constant": "PROW",
    "env": "PROW_JOB_ID"
  },
  {
    "name": "ReleaseHub",
    "constant": "RELEASEHUB",
    "env": "RELEASE_BUILD_ID"
  },
  {
    "name": "Render",
    "constant": "RENDER",
    "env": "RENDER",
    "pr": {
      "IS_PULL_REQUEST": "true"
    }
  },
  {
    "name": "Sail CI",
    "constant": "SAIL",
    "env": "SAILCI",
    "pr": "SAIL_PULL_REQUEST_NUMBER"
  },
  {
    "name": "Screwdriver",
    "constant": "SCREWDRIVER",
    "env": "SCREWDRIVER",
    "pr": {
      "env": "SD_PULL_REQUEST",
      "ne": "false"
    }
  },
  {
    "name": "Semaphore",
    "constant": "SEMAPHORE",
    "env": "SEMAPHORE",
    "pr": "PULL_REQUEST_NUMBER"
  },
  {
    "name": "Sourcehut",
    "constant": "SOURCEHUT",
    "env": {
      "CI_NAME": "sourcehut"
    }
  },
  {
    "name": "Strider CD",
    "constant": "STRIDER",
    "env": "STRIDER"
  },
  {
    "name": "TaskCluster",
    "constant": "TASKCLUSTER",
    "env": [
      "TASK_ID",
      "RUN_ID"
    ]
  },
  {
    "name": "TeamCity",
    "constant": "TEAMCITY",
    "env": "TEAMCITY_VERSION"
  },
  {
    "name": "Travis CI",
    "constant": "TRAVIS",
    "env": "TRAVIS",
    "pr": {
      "env": "TRAVIS_PULL_REQUEST",
      "ne": "false"
    }
  },
  {
    "name": "Vela",
    "constant": "VELA",
    "env": "VELA",
    "pr": {
      "VELA_PULL_REQUEST": "1"
    }
  },
  {
    "name": "Vercel",
    "constant": "VERCEL",
    "env": {
      "any": [
        "NOW_BUILDER",
        "VERCEL"
      ]
    },
    "pr": "VERCEL_GIT_PULL_REQUEST_ID"
  },
  {
    "name": "Visual Studio App Center",
    "constant": "APPCENTER",
    "env": "APPCENTER_BUILD_ID"
  },
  {
    "name": "Woodpecker",
    "constant": "WOODPECKER",
    "env": {
      "CI": "woodpecker"
    },
    "pr": {
      "CI_BUILD_EVENT": "pull_request"
    }
  },
  {
    "name": "Xcode Cloud",
    "constant": "XCODE_CLOUD",
    "env": "CI_XCODE_PROJECT",
    "pr": "CI_PULL_REQUEST_NUMBER"
  },
  {
    "name": "Xcode Server",
    "constant": "XCODE_SERVER",
    "env": "XCS"
  }
]


---

File name: node_modules\babel-jest\node_modules\jest-haste-map\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {Stats} from 'fs';
import {Config} from '@jest/types';

declare type ChangeEvent = {
  eventsQueue: EventsQueue;
  hasteFS: HasteFS;
  moduleMap: ModuleMap_2;
};

export declare class DuplicateError extends Error {
  mockPath1: string;
  mockPath2: string;
  constructor(mockPath1: string, mockPath2: string);
}

declare class DuplicateHasteCandidatesError extends Error {
  hasteName: string;
  platform: string | null;
  supportsNativePlatform: boolean;
  duplicatesSet: DuplicatesSet;
  constructor(
    name: string,
    platform: string,
    supportsNativePlatform: boolean,
    duplicatesSet: DuplicatesSet,
  );
}

declare type DuplicatesIndex = Map<string, Map<string, DuplicatesSet>>;

declare type DuplicatesSet = Map<string, /* type */ number>;

declare type EventsQueue = Array<{
  filePath: string;
  stat: Stats | undefined;
  type: string;
}>;

declare type FileData = Map<string, FileMetaData>;

declare type FileMetaData = [
  id: string,
  mtime: number,
  size: number,
  visited: 0 | 1,
  dependencies: string,
  sha1: string | null | undefined,
];

declare class HasteFS implements IHasteFS {
  private readonly _rootDir;
  private readonly _files;
  constructor({rootDir, files}: {rootDir: string; files: FileData});
  getModuleName(file: string): string | null;
  getSize(file: string): number | null;
  getDependencies(file: string): Array<string> | null;
  getSha1(file: string): string | null;
  exists(file: string): boolean;
  getAllFiles(): Array<string>;
  getFileIterator(): Iterable<string>;
  getAbsoluteFileIterator(): Iterable<string>;
  matchFiles(pattern: RegExp | string): Array<string>;
  matchFilesWithGlob(globs: Array<string>, root: string | null): Set<string>;
  private _getFileData;
}

declare type HasteMapStatic<S = SerializableModuleMap> = {
  getCacheFilePath(
    tmpdir: string,
    name: string,
    ...extra: Array<string>
  ): string;
  getModuleMapFromJSON(json: S): IModuleMap<S>;
};

declare type HasteRegExp = RegExp | ((str: string) => boolean);

declare type HType = {
  ID: 0;
  MTIME: 1;
  SIZE: 2;
  VISITED: 3;
  DEPENDENCIES: 4;
  SHA1: 5;
  PATH: 0;
  TYPE: 1;
  MODULE: 0;
  PACKAGE: 1;
  GENERIC_PLATFORM: 'g';
  NATIVE_PLATFORM: 'native';
  DEPENDENCY_DELIM: '\0';
};

declare type HTypeValue = HType[keyof HType];

export declare interface IHasteFS {
  exists(path: string): boolean;
  getAbsoluteFileIterator(): Iterable<string>;
  getAllFiles(): Array<string>;
  getDependencies(file: string): Array<string> | null;
  getSize(path: string): number | null;
  matchFiles(pattern: RegExp | string): Array<string>;
  matchFilesWithGlob(
    globs: ReadonlyArray<string>,
    root: string | null,
  ): Set<string>;
  getModuleName(file: string): string | null;
}

export declare interface IHasteMap {
  on(eventType: 'change', handler: (event: ChangeEvent) => void): void;
  build(): Promise<{
    hasteFS: IHasteFS;
    moduleMap: IModuleMap;
  }>;
}

declare type IJestHasteMap = HasteMapStatic & {
  create(options: Options): Promise<IHasteMap>;
  getStatic(config: Config.ProjectConfig): HasteMapStatic;
};

export declare interface IModuleMap<S = SerializableModuleMap> {
  getModule(
    name: string,
    platform?: string | null,
    supportsNativePlatform?: boolean | null,
    type?: HTypeValue | null,
  ): string | null;
  getPackage(
    name: string,
    platform: string | null | undefined,
    _supportsNativePlatform: boolean | null,
  ): string | null;
  getMockModule(name: string): string | undefined;
  getRawModuleMap(): RawModuleMap;
  toJSON(): S;
}

declare const JestHasteMap: IJestHasteMap;
export default JestHasteMap;

declare type MockData = Map<string, string>;

export declare const ModuleMap: {
  create: (rootPath: string) => IModuleMap;
};

declare class ModuleMap_2 implements IModuleMap {
  static DuplicateHasteCandidatesError: typeof DuplicateHasteCandidatesError;
  private readonly _raw;
  private json;
  private static mapToArrayRecursive;
  private static mapFromArrayRecursive;
  constructor(raw: RawModuleMap);
  getModule(
    name: string,
    platform?: string | null,
    supportsNativePlatform?: boolean | null,
    type?: HTypeValue | null,
  ): string | null;
  getPackage(
    name: string,
    platform: string | null | undefined,
    _supportsNativePlatform: boolean | null,
  ): string | null;
  getMockModule(name: string): string | undefined;
  getRawModuleMap(): RawModuleMap;
  toJSON(): SerializableModuleMap;
  static fromJSON(serializableModuleMap: SerializableModuleMap): ModuleMap_2;
  /**
   * When looking up a module's data, we walk through each eligible platform for
   * the query. For each platform, we want to check if there are known
   * duplicates for that name+platform pair. The duplication logic normally
   * removes elements from the `map` object, but we want to check upfront to be
   * extra sure. If metadata exists both in the `duplicates` object and the
   * `map`, this would be a bug.
   */
  private _getModuleMetadata;
  private _assertNoDuplicates;
  static create(rootDir: string): ModuleMap_2;
}

declare type ModuleMapData = Map<string, ModuleMapItem>;

declare type ModuleMapItem = {
  [platform: string]: ModuleMetaData;
};

declare type ModuleMetaData = [path: string, type: number];

declare type Options = {
  cacheDirectory?: string;
  computeDependencies?: boolean;
  computeSha1?: boolean;
  console?: Console;
  dependencyExtractor?: string | null;
  enableSymlinks?: boolean;
  extensions: Array<string>;
  forceNodeFilesystemAPI?: boolean;
  hasteImplModulePath?: string;
  hasteMapModulePath?: string;
  id: string;
  ignorePattern?: HasteRegExp;
  maxWorkers: number;
  mocksPattern?: string;
  platforms: Array<string>;
  resetCache?: boolean;
  retainAllFiles: boolean;
  rootDir: string;
  roots: Array<string>;
  skipPackageJson?: boolean;
  throwOnModuleCollision?: boolean;
  useWatchman?: boolean;
  watch?: boolean;
  workerThreads?: boolean;
};

declare type RawModuleMap = {
  rootDir: string;
  duplicates: DuplicatesIndex;
  map: ModuleMapData;
  mocks: MockData;
};

export declare type SerializableModuleMap = {
  duplicates: ReadonlyArray<[string, [string, [string, [string, number]]]]>;
  map: ReadonlyArray<[string, ValueType<ModuleMapData>]>;
  mocks: ReadonlyArray<[string, ValueType<MockData>]>;
  rootDir: string;
};

declare type ValueType<T> = T extends Map<string, infer V> ? V : never;

export {};


---

File name: node_modules\babel-jest\node_modules\jest-haste-map\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./package.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"jest-haste-map","version":"30.0.1","repository":{"type":"git","url":"https://github.com/jestjs/jest.git","directory":"packages/jest-haste-map"},"license":"MIT","main":"./build/index.js","types":"./build/index.d.ts","exports":{".":{"types":"./build/index.d.ts","require":"./build/index.js","import":"./build/index.mjs","default":"./build/index.js"},"./package.json":"./package.json"},"dependencies":{"@jest/types":"workspace:*","@types/node":"*","anymatch":"^3.1.3","fb-watchman":"^2.0.2","graceful-fs":"^4.2.11","jest-regex-util":"workspace:*","jest-util":"workspace:*","jest-worker":"workspace:*","micromatch":"^4.0.8","walker":"^1.0.8"},"devDependencies":{"@types/fb-watchman":"^2.0.5","@types/graceful-fs":"^4.1.9","@types/micromatch":"^4.0.9","slash":"^3.0.0"},"optionalDependencies":{"fsevents":"^2.3.3"},"engines":{"node":"^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"},"publishConfig":{"access":"public"}}');

/***/ }),

/***/ "./src/HasteFS.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _jestUtil() {
  const data = require("jest-util");
  _jestUtil = function () {
    return data;
  };
  return data;
}
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var fastPath = _interopRequireWildcard(__webpack_require__("./src/lib/fast_path.ts"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

class HasteFS {
  _rootDir;
  _files;
  constructor({
    rootDir,
    files
  }) {
    this._rootDir = rootDir;
    this._files = files;
  }
  getModuleName(file) {
    const fileMetadata = this._getFileData(file);
    return fileMetadata && fileMetadata[_constants.default.ID] || null;
  }
  getSize(file) {
    const fileMetadata = this._getFileData(file);
    return fileMetadata && fileMetadata[_constants.default.SIZE] || null;
  }
  getDependencies(file) {
    const fileMetadata = this._getFileData(file);
    if (fileMetadata) {
      return fileMetadata[_constants.default.DEPENDENCIES] ? fileMetadata[_constants.default.DEPENDENCIES].split(_constants.default.DEPENDENCY_DELIM) : [];
    } else {
      return null;
    }
  }
  getSha1(file) {
    const fileMetadata = this._getFileData(file);
    return fileMetadata && fileMetadata[_constants.default.SHA1] || null;
  }
  exists(file) {
    return this._getFileData(file) != null;
  }
  getAllFiles() {
    return [...this.getAbsoluteFileIterator()];
  }
  getFileIterator() {
    return this._files.keys();
  }
  *getAbsoluteFileIterator() {
    for (const file of this.getFileIterator()) {
      yield fastPath.resolve(this._rootDir, file);
    }
  }
  matchFiles(pattern) {
    if (!(pattern instanceof RegExp)) {
      pattern = new RegExp(pattern);
    }
    const files = [];
    for (const file of this.getAbsoluteFileIterator()) {
      if (pattern.test(file)) {
        files.push(file);
      }
    }
    return files;
  }
  matchFilesWithGlob(globs, root) {
    const files = new Set();
    const matcher = (0, _jestUtil().globsToMatcher)(globs);
    for (const file of this.getAbsoluteFileIterator()) {
      const filePath = root ? fastPath.relative(root, file) : file;
      if (matcher((0, _jestUtil().replacePathSepForGlob)(filePath))) {
        files.add(file);
      }
    }
    return files;
  }
  _getFileData(file) {
    const relativePath = fastPath.relative(this._rootDir, file);
    return this._files.get(relativePath);
  }
}
exports["default"] = HasteFS;

/***/ }),

/***/ "./src/ModuleMap.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var fastPath = _interopRequireWildcard(__webpack_require__("./src/lib/fast_path.ts"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const EMPTY_OBJ = {};
const EMPTY_MAP = new Map();
class ModuleMap {
  static DuplicateHasteCandidatesError;
  _raw;
  json;
  static mapToArrayRecursive(map) {
    let arr = [...map];
    if (arr[0] && arr[0][1] instanceof Map) {
      arr = arr.map(el => [el[0], this.mapToArrayRecursive(el[1])]);
    }
    return arr;
  }
  static mapFromArrayRecursive(arr) {
    if (arr[0] && Array.isArray(arr[1])) {
      arr = arr.map(el => [el[0], this.mapFromArrayRecursive(el[1])]);
    }
    return new Map(arr);
  }
  constructor(raw) {
    this._raw = raw;
  }
  getModule(name, platform, supportsNativePlatform, type) {
    if (type == null) {
      type = _constants.default.MODULE;
    }
    const module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);
    if (module && module[_constants.default.TYPE] === type) {
      const modulePath = module[_constants.default.PATH];
      return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);
    }
    return null;
  }
  getPackage(name, platform, _supportsNativePlatform) {
    return this.getModule(name, platform, null, _constants.default.PACKAGE);
  }
  getMockModule(name) {
    const mockPath = this._raw.mocks.get(name) || this._raw.mocks.get(`${name}/index`);
    return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);
  }
  getRawModuleMap() {
    return {
      duplicates: this._raw.duplicates,
      map: this._raw.map,
      mocks: this._raw.mocks,
      rootDir: this._raw.rootDir
    };
  }
  toJSON() {
    if (!this.json) {
      this.json = {
        duplicates: ModuleMap.mapToArrayRecursive(this._raw.duplicates),
        map: [...this._raw.map],
        mocks: [...this._raw.mocks],
        rootDir: this._raw.rootDir
      };
    }
    return this.json;
  }
  static fromJSON(serializableModuleMap) {
    return new ModuleMap({
      duplicates: ModuleMap.mapFromArrayRecursive(serializableModuleMap.duplicates),
      map: new Map(serializableModuleMap.map),
      mocks: new Map(serializableModuleMap.mocks),
      rootDir: serializableModuleMap.rootDir
    });
  }

  /**
   * When looking up a module's data, we walk through each eligible platform for
   * the query. For each platform, we want to check if there are known
   * duplicates for that name+platform pair. The duplication logic normally
   * removes elements from the `map` object, but we want to check upfront to be
   * extra sure. If metadata exists both in the `duplicates` object and the
   * `map`, this would be a bug.
   */
  _getModuleMetadata(name, platform, supportsNativePlatform) {
    const map = this._raw.map.get(name) || EMPTY_OBJ;
    const dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;
    if (platform != null) {
      this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap.get(platform));
      if (map[platform] != null) {
        return map[platform];
      }
    }
    if (supportsNativePlatform) {
      this._assertNoDuplicates(name, _constants.default.NATIVE_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.NATIVE_PLATFORM));
      if (map[_constants.default.NATIVE_PLATFORM]) {
        return map[_constants.default.NATIVE_PLATFORM];
      }
    }
    this._assertNoDuplicates(name, _constants.default.GENERIC_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.GENERIC_PLATFORM));
    if (map[_constants.default.GENERIC_PLATFORM]) {
      return map[_constants.default.GENERIC_PLATFORM];
    }
    return null;
  }
  _assertNoDuplicates(name, platform, supportsNativePlatform, relativePathSet) {
    if (relativePathSet == null) {
      return;
    }
    // Force flow refinement
    const previousSet = relativePathSet;
    const duplicates = new Map();
    for (const [relativePath, type] of previousSet) {
      const duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);
      duplicates.set(duplicatePath, type);
    }
    throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicates);
  }
  static create(rootDir) {
    return new ModuleMap({
      duplicates: new Map(),
      map: new Map(),
      mocks: new Map(),
      rootDir
    });
  }
}
exports["default"] = ModuleMap;
class DuplicateHasteCandidatesError extends Error {
  hasteName;
  platform;
  supportsNativePlatform;
  duplicatesSet;
  constructor(name, platform, supportsNativePlatform, duplicatesSet) {
    const platformMessage = getPlatformMessage(platform);
    super(`The name \`${name}\` was looked up in the Haste module map. It ` + 'cannot be resolved, because there exists several different ' + 'files, or packages, that provide a module for ' + `that particular name and platform. ${platformMessage} You must ` + `delete or exclude files until there remains only one of these:\n\n${[...duplicatesSet].map(([dupFilePath, dupFileType]) => `  * \`${dupFilePath}\` (${getTypeMessage(dupFileType)})\n`).sort().join('')}`);
    this.hasteName = name;
    this.platform = platform;
    this.supportsNativePlatform = supportsNativePlatform;
    this.duplicatesSet = duplicatesSet;
  }
}
function getPlatformMessage(platform) {
  if (platform === _constants.default.GENERIC_PLATFORM) {
    return 'The platform is generic (no extension).';
  }
  return `The platform extension is \`${platform}\`.`;
}
function getTypeMessage(type) {
  switch (type) {
    case _constants.default.MODULE:
      return 'module';
    case _constants.default.PACKAGE:
      return 'package';
  }
  return 'unknown';
}
ModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;

/***/ }),

/***/ "./src/constants.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * This file exports a set of constants that are used for Jest's haste map
 * serialization. On very large repositories, the haste map cache becomes very
 * large to the point where it is the largest overhead in starting up Jest.
 *
 * This constant key map allows to keep the map smaller without having to build
 * a custom serialization library.
 */

/* eslint-disable sort-keys */
const constants = {
  /* dependency serialization */
  DEPENDENCY_DELIM: '\0',
  /* file map attributes */
  ID: 0,
  MTIME: 1,
  SIZE: 2,
  VISITED: 3,
  DEPENDENCIES: 4,
  SHA1: 5,
  /* module map attributes */
  PATH: 0,
  TYPE: 1,
  /* module types */
  MODULE: 0,
  PACKAGE: 1,
  /* platforms */
  GENERIC_PLATFORM: 'g',
  NATIVE_PLATFORM: 'native'
};
/* eslint-enable */
var _default = exports["default"] = constants;

/***/ }),

/***/ "./src/crawlers/node.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.nodeCrawl = nodeCrawl;
function _child_process() {
  const data = require("child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var fastPath = _interopRequireWildcard(__webpack_require__("./src/lib/fast_path.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

async function hasNativeFindSupport(forceNodeFilesystemAPI) {
  if (forceNodeFilesystemAPI) {
    return false;
  }
  try {
    return await new Promise(resolve => {
      // Check the find binary supports the non-POSIX -iname parameter wrapped in parens.
      const args = ['.', '-type', 'f', '(', '-iname', '*.ts', '-o', '-iname', '*.js', ')'];
      const child = (0, _child_process().spawn)('find', args, {
        cwd: __dirname
      });
      child.on('error', () => {
        resolve(false);
      });
      child.on('exit', code => {
        resolve(code === 0);
      });
    });
  } catch {
    return false;
  }
}
function find(roots, extensions, ignore, enableSymlinks, callback) {
  const result = [];
  let activeCalls = 0;
  function search(directory) {
    activeCalls++;
    fs().readdir(directory, {
      withFileTypes: true
    }, (err, entries) => {
      activeCalls--;
      if (err) {
        if (activeCalls === 0) {
          callback(result);
        }
        return;
      }
      for (const entry of entries) {
        const file = path().join(directory, entry.name);
        if (ignore(file)) {
          continue;
        }
        if (entry.isSymbolicLink()) {
          continue;
        }
        if (entry.isDirectory()) {
          search(file);
          continue;
        }
        activeCalls++;
        const stat = enableSymlinks ? fs().stat : fs().lstat;
        stat(file, (err, stat) => {
          activeCalls--;

          // This logic is unnecessary for node > v10.10, but leaving it in
          // since we need it for backwards-compatibility still.
          if (!err && stat && !stat.isSymbolicLink()) {
            if (stat.isDirectory()) {
              search(file);
            } else {
              const ext = path().extname(file).slice(1);
              if (extensions.includes(ext)) {
                result.push([file, stat.mtime.getTime(), stat.size]);
              }
            }
          }
          if (activeCalls === 0) {
            callback(result);
          }
        });
      }
      if (activeCalls === 0) {
        callback(result);
      }
    });
  }
  if (roots.length > 0) {
    for (const root of roots) search(root);
  } else {
    callback(result);
  }
}
function findNative(roots, extensions, ignore, enableSymlinks, callback) {
  const args = [...roots];
  if (enableSymlinks) {
    args.push('(', '-type', 'f', '-o', '-type', 'l', ')');
  } else {
    args.push('-type', 'f');
  }
  if (extensions.length > 0) {
    args.push('(');
  }
  for (const [index, ext] of extensions.entries()) {
    if (index) {
      args.push('-o');
    }
    args.push('-iname', `*.${ext}`);
  }
  if (extensions.length > 0) {
    args.push(')');
  }
  const child = (0, _child_process().spawn)('find', args);
  let stdout = '';
  if (child.stdout === null) {
    throw new Error('stdout is null - this should never happen. Please open up an issue at https://github.com/jestjs/jest');
  }
  child.stdout.setEncoding('utf8');
  child.stdout.on('data', data => stdout += data);
  child.stdout.on('close', () => {
    const lines = stdout.trim().split('\n').filter(x => !ignore(x));
    const result = [];
    let count = lines.length;
    if (count) {
      for (const path of lines) {
        fs().stat(path, (err, stat) => {
          // Filter out symlinks that describe directories
          if (!err && stat && !stat.isDirectory()) {
            result.push([path, stat.mtime.getTime(), stat.size]);
          }
          if (--count === 0) {
            callback(result);
          }
        });
      }
    } else {
      callback([]);
    }
  });
}
async function nodeCrawl(options) {
  const {
    data,
    extensions,
    forceNodeFilesystemAPI,
    ignore,
    rootDir,
    enableSymlinks,
    roots
  } = options;
  const useNativeFind = await hasNativeFindSupport(forceNodeFilesystemAPI);
  return new Promise(resolve => {
    const callback = list => {
      const files = new Map();
      const removedFiles = new Map(data.files);
      for (const fileData of list) {
        const [filePath, mtime, size] = fileData;
        const relativeFilePath = fastPath.relative(rootDir, filePath);
        const existingFile = data.files.get(relativeFilePath);
        if (existingFile && existingFile[_constants.default.MTIME] === mtime) {
          files.set(relativeFilePath, existingFile);
        } else {
          // See ../constants.js; SHA-1 will always be null and fulfilled later.
          files.set(relativeFilePath, ['', mtime, size, 0, '', null]);
        }
        removedFiles.delete(relativeFilePath);
      }
      data.files = files;
      resolve({
        hasteMap: data,
        removedFiles
      });
    };
    if (useNativeFind) {
      findNative(roots, extensions, ignore, enableSymlinks, callback);
    } else {
      find(roots, extensions, ignore, enableSymlinks, callback);
    }
  });
}

/***/ }),

/***/ "./src/crawlers/watchman.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.watchmanCrawl = watchmanCrawl;
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function watchman() {
  const data = _interopRequireWildcard(require("fb-watchman"));
  watchman = function () {
    return data;
  };
  return data;
}
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var fastPath = _interopRequireWildcard(__webpack_require__("./src/lib/fast_path.ts"));
var _normalizePathSep = _interopRequireDefault(__webpack_require__("./src/lib/normalizePathSep.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';
function watchmanError(error) {
  error.message = `Watchman error: ${error.message.trim()}. Make sure watchman ` + `is running for this project. See ${watchmanURL}.`;
  return error;
}

/**
 * Wrap watchman capabilityCheck method as a promise.
 *
 * @param client watchman client
 * @param caps capabilities to verify
 * @returns a promise resolving to a list of verified capabilities
 */
async function capabilityCheck(client, caps) {
  return new Promise((resolve, reject) => {
    client.capabilityCheck(
    // @ts-expect-error: incorrectly typed
    caps, (error, response) => {
      if (error) {
        reject(error);
      } else {
        resolve(response);
      }
    });
  });
}
async function watchmanCrawl(options) {
  const fields = ['name', 'exists', 'mtime_ms', 'size'];
  const {
    data,
    extensions,
    ignore,
    rootDir,
    roots
  } = options;
  const defaultWatchExpression = ['allof', ['type', 'f']];
  const clocks = data.clocks;
  const client = new (watchman().Client)();

  // https://facebook.github.io/watchman/docs/capabilities.html
  // Check adds about ~28ms
  const capabilities = await capabilityCheck(client, {
    // If a required capability is missing then an error will be thrown,
    // we don't need this assertion, so using optional instead.
    optional: ['suffix-set']
  });
  if (capabilities?.capabilities['suffix-set']) {
    // If available, use the optimized `suffix-set` operation:
    // https://facebook.github.io/watchman/docs/expr/suffix.html#suffix-set
    defaultWatchExpression.push(['suffix', extensions]);
  } else {
    // Otherwise use the older and less optimal suffix tuple array
    defaultWatchExpression.push(['anyof', ...extensions.map(extension => ['suffix', extension])]);
  }
  let clientError;
  client.on('error', error => clientError = watchmanError(error));
  const cmd = (...args) => new Promise((resolve, reject) =>
  // @ts-expect-error: client is typed strictly, but incomplete
  client.command(args, (error, result) => error ? reject(watchmanError(error)) : resolve(result)));
  if (options.computeSha1) {
    const {
      capabilities
    } = await cmd('list-capabilities');
    if (capabilities.includes('field-content.sha1hex')) {
      fields.push('content.sha1hex');
    }
  }
  async function getWatchmanRoots(roots) {
    const watchmanRoots = new Map();
    await Promise.all(roots.map(async root => {
      const response = await cmd('watch-project', root);
      const existing = watchmanRoots.get(response.watch);
      // A root can only be filtered if it was never seen with a
      // relative_path before.
      const canBeFiltered = !existing || existing.length > 0;
      if (canBeFiltered) {
        if (response.relative_path) {
          watchmanRoots.set(response.watch, [...(existing || []), response.relative_path]);
        } else {
          // Make the filter directories an empty array to signal that this
          // root was already seen and needs to be watched for all files or
          // directories.
          watchmanRoots.set(response.watch, []);
        }
      }
    }));
    return watchmanRoots;
  }
  async function queryWatchmanForDirs(rootProjectDirMappings) {
    const results = new Map();
    let isFresh = false;
    await Promise.all([...rootProjectDirMappings].map(async ([root, directoryFilters]) => {
      const expression = [...defaultWatchExpression];
      const glob = [];
      if (directoryFilters.length > 0) {
        expression.push(['anyof', ...directoryFilters.map(dir => ['dirname', dir])]);
        for (const directory of directoryFilters) {
          for (const extension of extensions) {
            glob.push(`${directory}/**/*.${extension}`);
          }
        }
      } else {
        for (const extension of extensions) {
          glob.push(`**/*.${extension}`);
        }
      }

      // Jest is only going to store one type of clock; a string that
      // represents a local clock. However, the Watchman crawler supports
      // a second type of clock that can be written by automation outside of
      // Jest, called an "scm query", which fetches changed files based on
      // source control mergebases. The reason this is necessary is because
      // local clocks are not portable across systems, but scm queries are.
      // By using scm queries, we can create the haste map on a different
      // system and import it, transforming the clock into a local clock.
      const since = clocks.get(fastPath.relative(rootDir, root));
      const query = since === undefined ?
      // Use the `since` generator if we have a clock available
      {
        expression,
        fields,
        glob,
        glob_includedotfiles: true
      } :
      // Otherwise use the `glob` filter
      {
        expression,
        fields,
        since
      };
      const response = await cmd('query', root, query);
      if ('warning' in response) {
        console.warn('watchman warning:', response.warning);
      }

      // When a source-control query is used, we ignore the "is fresh"
      // response from Watchman because it will be true despite the query
      // being incremental.
      const isSourceControlQuery = typeof since !== 'string' && since?.scm?.['mergebase-with'] !== undefined;
      if (!isSourceControlQuery) {
        isFresh = isFresh || response.is_fresh_instance;
      }
      results.set(root, response);
    }));
    return {
      isFresh,
      results
    };
  }
  let files = data.files;
  let removedFiles = new Map();
  const changedFiles = new Map();
  let results;
  let isFresh = false;
  try {
    const watchmanRoots = await getWatchmanRoots(roots);
    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots);

    // Reset the file map if watchman was restarted and sends us a list of
    // files.
    if (watchmanFileResults.isFresh) {
      files = new Map();
      removedFiles = new Map(data.files);
      isFresh = true;
    }
    results = watchmanFileResults.results;
  } finally {
    client.end();
  }
  if (clientError) {
    throw clientError;
  }
  for (const [watchRoot, response] of results) {
    const fsRoot = (0, _normalizePathSep.default)(watchRoot);
    const relativeFsRoot = fastPath.relative(rootDir, fsRoot);
    clocks.set(relativeFsRoot,
    // Ensure we persist only the local clock.
    typeof response.clock === 'string' ? response.clock : response.clock.clock);
    for (const fileData of response.files) {
      const filePath = fsRoot + path().sep + (0, _normalizePathSep.default)(fileData.name);
      const relativeFilePath = fastPath.relative(rootDir, filePath);
      const existingFileData = data.files.get(relativeFilePath);

      // If watchman is fresh, the removed files map starts with all files
      // and we remove them as we verify they still exist.
      if (isFresh && existingFileData && fileData.exists) {
        removedFiles.delete(relativeFilePath);
      }
      if (!fileData.exists) {
        // No need to act on files that do not exist and were not tracked.
        if (existingFileData) {
          files.delete(relativeFilePath);

          // If watchman is not fresh, we will know what specific files were
          // deleted since we last ran and can track only those files.
          if (!isFresh) {
            removedFiles.set(relativeFilePath, existingFileData);
          }
        }
      } else if (!ignore(filePath)) {
        const mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();
        const size = fileData.size;
        let sha1hex = fileData['content.sha1hex'];
        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {
          sha1hex = undefined;
        }
        let nextData;
        if (existingFileData && existingFileData[_constants.default.MTIME] === mtime) {
          nextData = existingFileData;
        } else if (existingFileData && sha1hex && existingFileData[_constants.default.SHA1] === sha1hex) {
          nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];
        } else {
          // See ../constants.ts
          nextData = ['', mtime, size, 0, '', sha1hex ?? null];
        }
        files.set(relativeFilePath, nextData);
        changedFiles.set(relativeFilePath, nextData);
      }
    }
  }
  data.files = files;
  return {
    changedFiles: isFresh ? undefined : changedFiles,
    hasteMap: data,
    removedFiles
  };
}

/***/ }),

/***/ "./src/getMockName.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const MOCKS_PATTERN = `${path().sep}__mocks__${path().sep}`;
const getMockName = filePath => {
  const mockPath = filePath.split(MOCKS_PATTERN)[1];
  return mockPath.slice(0, mockPath.lastIndexOf(path().extname(mockPath))).replaceAll('\\', '/');
};
var _default = exports["default"] = getMockName;

/***/ }),

/***/ "./src/lib/fast_path.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.relative = relative;
exports.resolve = resolve;
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// rootDir and filename must be absolute paths (resolved)
function relative(rootDir, filename) {
  return filename.indexOf(rootDir + path().sep) === 0 ? filename.slice(rootDir.length + 1) : path().relative(rootDir, filename);
}
const INDIRECTION_FRAGMENT = `..${path().sep}`;

// rootDir must be an absolute path and relativeFilename must be simple
// (e.g.: foo/bar or ../foo/bar, but never ./foo or foo/../bar)
function resolve(rootDir, relativeFilename) {
  return relativeFilename.indexOf(INDIRECTION_FRAGMENT) === 0 ? path().resolve(rootDir, relativeFilename) : rootDir + path().sep + relativeFilename;
}

/***/ }),

/***/ "./src/lib/getPlatformExtension.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getPlatformExtension;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const SUPPORTED_PLATFORM_EXTS = new Set(['android', 'ios', 'native', 'web']);

// Extract platform extension: index.ios.js -> ios
function getPlatformExtension(file, platforms) {
  const last = file.lastIndexOf('.');
  const secondToLast = file.lastIndexOf('.', last - 1);
  if (secondToLast === -1) {
    return null;
  }
  const platform = file.slice(secondToLast + 1, last);
  // If an overriding platform array is passed, check that first

  if (platforms && platforms.includes(platform)) {
    return platform;
  }
  return SUPPORTED_PLATFORM_EXTS.has(platform) ? platform : null;
}

/***/ }),

/***/ "./src/lib/isWatchmanInstalled.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isWatchmanInstalled;
function _child_process() {
  const data = require("child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require("util");
  _util = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

async function isWatchmanInstalled() {
  try {
    await (0, _util().promisify)(_child_process().execFile)('watchman', ['--version']);
    return true;
  } catch {
    return false;
  }
}

/***/ }),

/***/ "./src/lib/normalizePathSep.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

let normalizePathSep;
if (path().sep === '/') {
  normalizePathSep = filePath => filePath;
} else {
  normalizePathSep = filePath => filePath.replaceAll('/', path().sep);
}
var _default = exports["default"] = normalizePathSep;

/***/ }),

/***/ "./src/watchers/FSEventsWatcher.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FSEventsWatcher = void 0;
function _events() {
  const data = require("events");
  _events = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _anymatch() {
  const data = _interopRequireDefault(require("anymatch"));
  _anymatch = function () {
    return data;
  };
  return data;
}
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
function _micromatch() {
  const data = _interopRequireDefault(require("micromatch"));
  _micromatch = function () {
    return data;
  };
  return data;
}
function _walker() {
  const data = _interopRequireDefault(require("walker"));
  _walker = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

// @ts-expect-error -- no types

// eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment
// @ts-ignore: this is for CI which runs linux and might not have this
let fsevents = null;
try {
  fsevents = require('fsevents');
} catch {
  // Optional dependency, only supported on Darwin.
}
const CHANGE_EVENT = 'change';
const DELETE_EVENT = 'delete';
const ADD_EVENT = 'add';
const ALL_EVENT = 'all';
/**
 * Export `FSEventsWatcher` class.
 * Watches `dir`.
 */
class FSEventsWatcher extends _events().EventEmitter {
  root;
  ignored;
  glob;
  dot;
  hasIgnore;
  doIgnore;
  fsEventsWatchStopper;
  _tracked;
  static isSupported() {
    return fsevents !== null;
  }
  static normalizeProxy(callback) {
    return (filepath, stats) => callback(path().normalize(filepath), stats);
  }
  static recReaddir(dir, dirCallback, fileCallback, endCallback, errorCallback, ignored) {
    (0, _walker().default)(dir).filterDir(currentDir => !ignored || !(0, _anymatch().default)(ignored, currentDir)).on('dir', FSEventsWatcher.normalizeProxy(dirCallback)).on('file', FSEventsWatcher.normalizeProxy(fileCallback)).on('error', errorCallback).on('end', () => {
      endCallback();
    });
  }
  constructor(dir, opts) {
    if (!fsevents) {
      throw new Error('`fsevents` unavailable (this watcher can only be used on Darwin)');
    }
    super();
    this.dot = opts.dot || false;
    this.ignored = opts.ignored;
    this.glob = Array.isArray(opts.glob) ? opts.glob : [opts.glob];
    this.hasIgnore = Boolean(opts.ignored) && !(Array.isArray(opts) && opts.length > 0);
    this.doIgnore = opts.ignored ? (0, _anymatch().default)(opts.ignored) : () => false;
    this.root = path().resolve(dir);
    this.fsEventsWatchStopper = fsevents.watch(this.root, this.handleEvent.bind(this));
    this._tracked = new Set();
    FSEventsWatcher.recReaddir(this.root, filepath => {
      this._tracked.add(filepath);
    }, filepath => {
      this._tracked.add(filepath);
    }, this.emit.bind(this, 'ready'), this.emit.bind(this, 'error'), this.ignored);
  }

  /**
   * End watching.
   */
  async close(callback) {
    await this.fsEventsWatchStopper();
    this.removeAllListeners();
    if (typeof callback === 'function') {
      process.nextTick(() => callback());
    }
  }
  isFileIncluded(relativePath) {
    if (this.doIgnore(relativePath)) {
      return false;
    }
    return this.glob.length > 0 ? (0, _micromatch().default)([relativePath], this.glob, {
      dot: this.dot
    }).length > 0 : this.dot || (0, _micromatch().default)([relativePath], '**/*').length > 0;
  }
  handleEvent(filepath) {
    const relativePath = path().relative(this.root, filepath);
    if (!this.isFileIncluded(relativePath)) {
      return;
    }
    fs().lstat(filepath, (error, stat) => {
      if (error && error.code !== 'ENOENT') {
        this.emit('error', error);
        return;
      }
      if (error) {
        // Ignore files that aren't tracked and don't exist.
        if (!this._tracked.has(filepath)) {
          return;
        }
        this._emit(DELETE_EVENT, relativePath);
        this._tracked.delete(filepath);
        return;
      }
      if (this._tracked.has(filepath)) {
        this._emit(CHANGE_EVENT, relativePath, stat);
      } else {
        this._tracked.add(filepath);
        this._emit(ADD_EVENT, relativePath, stat);
      }
    });
  }

  /**
   * Emit events.
   */
  _emit(type, file, stat) {
    this.emit(type, file, this.root, stat);
    this.emit(ALL_EVENT, type, file, this.root, stat);
  }
}
exports.FSEventsWatcher = FSEventsWatcher;

/***/ }),

/***/ "./src/watchers/NodeWatcher.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// vendored from https://github.com/amasad/sane/blob/64ff3a870c42e84f744086884bf55a4f9c22d376/src/node_watcher.js



const EventEmitter = (__webpack_require__("events").EventEmitter);
const fs = require('fs');
const platform = (__webpack_require__("os").platform)();
const path = require('path');
const common = __webpack_require__("./src/watchers/common.js");

/**
 * Constants
 */

const DEFAULT_DELAY = common.DEFAULT_DELAY;
const CHANGE_EVENT = common.CHANGE_EVENT;
const DELETE_EVENT = common.DELETE_EVENT;
const ADD_EVENT = common.ADD_EVENT;
const ALL_EVENT = common.ALL_EVENT;

/**
 * Export `NodeWatcher` class.
 * Watches `dir`.
 *
 * @class NodeWatcher
 * @param {String} dir
 * @param {Object} opts
 * @public
 */

module.exports = class NodeWatcher extends EventEmitter {
  constructor(dir, opts) {
    super();

    common.assignOptions(this, opts);

    this.watched = Object.create(null);
    this.changeTimers = Object.create(null);
    this.dirRegistry = Object.create(null);
    this.root = path.resolve(dir);
    this.watchdir = this.watchdir.bind(this);
    this.register = this.register.bind(this);
    this.checkedEmitError = this.checkedEmitError.bind(this);

    this.watchdir(this.root);
    common.recReaddir(
      this.root,
      this.watchdir,
      this.register,
      this.emit.bind(this, 'ready'),
      this.checkedEmitError,
      this.ignored,
    );
  }

  /**
   * Register files that matches our globs to know what to type of event to
   * emit in the future.
   *
   * Registry looks like the following:
   *
   *  dirRegister => Map {
   *    dirpath => Map {
   *       filename => true
   *    }
   *  }
   *
   * @param {string} filepath
   * @return {boolean} whether or not we have registered the file.
   * @private
   */

  register(filepath) {
    const relativePath = path.relative(this.root, filepath);
    if (
      !common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)
    ) {
      return false;
    }

    const dir = path.dirname(filepath);
    if (!this.dirRegistry[dir]) {
      this.dirRegistry[dir] = Object.create(null);
    }

    const filename = path.basename(filepath);
    this.dirRegistry[dir][filename] = true;

    return true;
  }

  /**
   * Removes a file from the registry.
   *
   * @param {string} filepath
   * @private
   */

  unregister(filepath) {
    const dir = path.dirname(filepath);
    if (this.dirRegistry[dir]) {
      const filename = path.basename(filepath);
      delete this.dirRegistry[dir][filename];
    }
  }

  /**
   * Removes a dir from the registry.
   *
   * @param {string} dirpath
   * @private
   */

  unregisterDir(dirpath) {
    if (this.dirRegistry[dirpath]) {
      delete this.dirRegistry[dirpath];
    }
  }

  /**
   * Checks if a file or directory exists in the registry.
   *
   * @param {string} fullpath
   * @return {boolean}
   * @private
   */

  registered(fullpath) {
    const dir = path.dirname(fullpath);
    return (
      this.dirRegistry[fullpath] ||
      (this.dirRegistry[dir] && this.dirRegistry[dir][path.basename(fullpath)])
    );
  }

  /**
   * Emit "error" event if it's not an ignorable event
   *
   * @param error
   * @private
   */
  checkedEmitError(error) {
    if (!isIgnorableFileError(error)) {
      this.emit('error', error);
    }
  }

  /**
   * Watch a directory.
   *
   * @param {string} dir
   * @private
   */

  watchdir(dir) {
    if (this.watched[dir]) {
      return;
    }

    const watcher = fs.watch(
      dir,
      {persistent: true},
      this.normalizeChange.bind(this, dir),
    );
    this.watched[dir] = watcher;

    watcher.on('error', this.checkedEmitError);

    if (this.root !== dir) {
      this.register(dir);
    }
  }

  /**
   * Stop watching a directory.
   *
   * @param {string} dir
   * @private
   */

  stopWatching(dir) {
    if (this.watched[dir]) {
      this.watched[dir].close();
      delete this.watched[dir];
    }
  }

  /**
   * End watching.
   *
   * @public
   */

  close() {
    for (const key of Object.keys(this.watched)) this.stopWatching(key);
    this.removeAllListeners();

    return Promise.resolve();
  }

  /**
   * On some platforms, as pointed out on the fs docs (most likely just win32)
   * the file argument might be missing from the fs event. Try to detect what
   * change by detecting if something was deleted or the most recent file change.
   *
   * @param {string} dir
   * @param {string} event
   * @param {string} file
   * @public
   */

  detectChangedFile(dir, event, callback) {
    if (!this.dirRegistry[dir]) {
      return;
    }

    let found = false;
    let closest = {mtime: 0};
    let c = 0;
    // eslint-disable-next-line unicorn/no-array-for-each
    Object.keys(this.dirRegistry[dir]).forEach((file, i, arr) => {
      fs.lstat(path.join(dir, file), (error, stat) => {
        if (found) {
          return;
        }

        if (error) {
          if (isIgnorableFileError(error)) {
            found = true;
            callback(file);
          } else {
            this.emit('error', error);
          }
        } else {
          if (stat.mtime > closest.mtime) {
            stat.file = file;
            closest = stat;
          }
          if (arr.length === ++c) {
            callback(closest.file);
          }
        }
      });
    });
  }

  /**
   * Normalize fs events and pass it on to be processed.
   *
   * @param {string} dir
   * @param {string} event
   * @param {string} file
   * @public
   */

  normalizeChange(dir, event, file) {
    if (file) {
      this.processChange(dir, event, path.normalize(file));
    } else {
      this.detectChangedFile(dir, event, actualFile => {
        if (actualFile) {
          this.processChange(dir, event, actualFile);
        }
      });
    }
  }

  /**
   * Process changes.
   *
   * @param {string} dir
   * @param {string} event
   * @param {string} file
   * @public
   */

  processChange(dir, event, file) {
    const fullPath = path.join(dir, file);
    const relativePath = path.join(path.relative(this.root, dir), file);

    fs.lstat(fullPath, (error, stat) => {
      if (error && error.code !== 'ENOENT') {
        this.emit('error', error);
      } else if (!error && stat.isDirectory()) {
        // win32 emits usless change events on dirs.
        if (event !== 'change') {
          this.watchdir(fullPath);
          if (
            common.isFileIncluded(
              this.globs,
              this.dot,
              this.doIgnore,
              relativePath,
            )
          ) {
            this.emitEvent(ADD_EVENT, relativePath, stat);
          }
        }
      } else {
        const registered = this.registered(fullPath);
        if (error && error.code === 'ENOENT') {
          this.unregister(fullPath);
          this.stopWatching(fullPath);
          this.unregisterDir(fullPath);
          if (registered) {
            this.emitEvent(DELETE_EVENT, relativePath);
          }
        } else if (registered) {
          this.emitEvent(CHANGE_EVENT, relativePath, stat);
        } else {
          if (this.register(fullPath)) {
            this.emitEvent(ADD_EVENT, relativePath, stat);
          }
        }
      }
    });
  }

  /**
   * Triggers a 'change' event after debounding it to take care of duplicate
   * events on os x.
   *
   * @private
   */

  emitEvent(type, file, stat) {
    const key = `${type}-${file}`;
    const addKey = `${ADD_EVENT}-${file}`;
    if (type === CHANGE_EVENT && this.changeTimers[addKey]) {
      // Ignore the change event that is immediately fired after an add event.
      // (This happens on Linux).
      return;
    }
    clearTimeout(this.changeTimers[key]);
    this.changeTimers[key] = setTimeout(() => {
      delete this.changeTimers[key];
      if (type === ADD_EVENT && stat.isDirectory()) {
        // Recursively emit add events and watch for sub-files/folders
        common.recReaddir(
          path.resolve(this.root, file),
          function emitAddDir(dir, stats) {
            this.watchdir(dir);
            this.rawEmitEvent(ADD_EVENT, path.relative(this.root, dir), stats);
          }.bind(this),
          function emitAddFile(file, stats) {
            this.register(file);
            this.rawEmitEvent(ADD_EVENT, path.relative(this.root, file), stats);
          }.bind(this),
          function endCallback() {},
          this.checkedEmitError,
          this.ignored,
        );
      } else {
        this.rawEmitEvent(type, file, stat);
      }
    }, DEFAULT_DELAY);
  }

  /**
   * Actually emit the events
   */
  rawEmitEvent(type, file, stat) {
    this.emit(type, file, this.root, stat);
    this.emit(ALL_EVENT, type, file, this.root, stat);
  }
};
/**
 * Determine if a given FS error can be ignored
 *
 * @private
 */
function isIgnorableFileError(error) {
  return (
    error.code === 'ENOENT' ||
    // Workaround Windows node issue #4337.
    (error.code === 'EPERM' && platform === 'win32')
  );
}


/***/ }),

/***/ "./src/watchers/RecrawlWarning.js":
/***/ ((module) => {

// vendored from https://github.com/amasad/sane/blob/64ff3a870c42e84f744086884bf55a4f9c22d376/src/utils/recrawl-warning-dedupe.js



class RecrawlWarning {
  constructor(root, count) {
    this.root = root;
    this.count = count;
  }

  static findByRoot(root) {
    for (let i = 0; i < this.RECRAWL_WARNINGS.length; i++) {
      const warning = this.RECRAWL_WARNINGS[i];
      if (warning.root === root) {
        return warning;
      }
    }

    return undefined;
  }

  static isRecrawlWarningDupe(warningMessage) {
    if (typeof warningMessage !== 'string') {
      return false;
    }
    const match = warningMessage.match(this.REGEXP);
    if (!match) {
      return false;
    }
    const count = Number(match[1]);
    const root = match[2];

    const warning = this.findByRoot(root);

    if (warning) {
      // only keep the highest count, assume count to either stay the same or
      // increase.
      if (warning.count >= count) {
        return true;
      } else {
        // update the existing warning to the latest (highest) count
        warning.count = count;
        return false;
      }
    } else {
      this.RECRAWL_WARNINGS.push(new RecrawlWarning(root, count));
      return false;
    }
  }
}

RecrawlWarning.RECRAWL_WARNINGS = [];
RecrawlWarning.REGEXP =
  /Recrawled this watch (\d+) times, most recently because:\n([^:]+)/;

module.exports = RecrawlWarning;


/***/ }),

/***/ "./src/watchers/WatchmanWatcher.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ WatchmanWatcher)
});

;// external "assert"
const external_assert_namespaceObject = require("assert");
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__("events");
;// external "path"
const external_path_namespaceObject = require("path");
;// external "fb-watchman"
const external_fb_watchman_namespaceObject = require("fb-watchman");
var external_fb_watchman_default = /*#__PURE__*/__webpack_require__.n(external_fb_watchman_namespaceObject);
;// external "graceful-fs"
const external_graceful_fs_namespaceObject = require("graceful-fs");
var external_graceful_fs_default = /*#__PURE__*/__webpack_require__.n(external_graceful_fs_namespaceObject);
// EXTERNAL MODULE: ./src/watchers/RecrawlWarning.js
var RecrawlWarning = __webpack_require__("./src/watchers/RecrawlWarning.js");
var RecrawlWarning_default = /*#__PURE__*/__webpack_require__.n(RecrawlWarning);
// EXTERNAL MODULE: ./src/watchers/common.js
var common = __webpack_require__("./src/watchers/common.js");
;// ./src/watchers/WatchmanWatcher.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */









const CHANGE_EVENT = common.CHANGE_EVENT;
const DELETE_EVENT = common.DELETE_EVENT;
const ADD_EVENT = common.ADD_EVENT;
const ALL_EVENT = common.ALL_EVENT;
const SUB_NAME = 'sane-sub';

/**
 * Watches `dir`.
 *
 * @class PollWatcher
 * @param String dir
 * @param {Object} opts
 * @public
 */

function WatchmanWatcher(dir, opts) {
  common.assignOptions(this, opts);
  this.root = external_path_namespaceObject.resolve(dir);
  this.init();
}

Object.setPrototypeOf(WatchmanWatcher.prototype, external_events_.EventEmitter.prototype);

/**
 * Run the watchman `watch` command on the root and subscribe to changes.
 *
 * @private
 */

WatchmanWatcher.prototype.init = function () {
  if (this.client) {
    this.client.removeAllListeners();
  }

  const self = this;
  this.client = new (external_fb_watchman_default()).Client();
  this.client.on('error', error => {
    self.emit('error', error);
  });
  this.client.on('subscription', this.handleChangeEvent.bind(this));
  this.client.on('end', () => {
    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');
    self.init();
  });

  this.watchProjectInfo = null;

  function getWatchRoot() {
    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;
  }

  function onCapability(error, resp) {
    if (handleError(self, error)) {
      // The Watchman watcher is unusable on this system, we cannot continue
      return;
    }

    handleWarning(resp);

    self.capabilities = resp.capabilities;

    if (self.capabilities.relative_root) {
      self.client.command(['watch-project', getWatchRoot()], onWatchProject);
    } else {
      self.client.command(['watch', getWatchRoot()], onWatch);
    }
  }

  function onWatchProject(error, resp) {
    if (handleError(self, error)) {
      return;
    }

    handleWarning(resp);

    self.watchProjectInfo = {
      relativePath: resp.relative_path ?? '',
      root: resp.watch,
    };

    self.client.command(['clock', getWatchRoot()], onClock);
  }

  function onWatch(error, resp) {
    if (handleError(self, error)) {
      return;
    }

    handleWarning(resp);

    self.client.command(['clock', getWatchRoot()], onClock);
  }

  function onClock(error, resp) {
    if (handleError(self, error)) {
      return;
    }

    handleWarning(resp);

    const options = {
      fields: ['name', 'exists', 'new'],
      since: resp.clock,
    };

    // If the server has the wildmatch capability available it supports
    // the recursive **/*.foo style match and we can offload our globs
    // to the watchman server.  This saves both on data size to be
    // communicated back to us and compute for evaluating the globs
    // in our node process.
    if (self.capabilities.wildmatch) {
      if (self.globs.length === 0) {
        if (!self.dot) {
          // Make sure we honor the dot option if even we're not using globs.
          options.expression = [
            'match',
            '**',
            'wholename',
            {
              includedotfiles: false,
            },
          ];
        }
      } else {
        options.expression = ['anyof'];
        for (const i in self.globs) {
          options.expression.push([
            'match',
            self.globs[i],
            'wholename',
            {
              includedotfiles: self.dot,
            },
          ]);
        }
      }
    }

    if (self.capabilities.relative_root) {
      options.relative_root = self.watchProjectInfo.relativePath;
    }

    self.client.command(
      ['subscribe', getWatchRoot(), SUB_NAME, options],
      onSubscribe,
    );
  }

  function onSubscribe(error, resp) {
    if (handleError(self, error)) {
      return;
    }

    handleWarning(resp);

    self.emit('ready');
  }

  self.client.capabilityCheck(
    {
      optional: ['wildmatch', 'relative_root'],
    },
    onCapability,
  );
};

/**
 * Handles a change event coming from the subscription.
 *
 * @param {Object} resp
 * @private
 */

WatchmanWatcher.prototype.handleChangeEvent = function (resp) {
  external_assert_namespaceObject.strict.equal(resp.subscription, SUB_NAME, 'Invalid subscription event.');
  if (resp.is_fresh_instance) {
    this.emit('fresh_instance');
  }
  if (resp.is_fresh_instance) {
    this.emit('fresh_instance');
  }
  if (Array.isArray(resp.files)) {
    for (const file of resp.files) this.handleFileChange(file);
  }
};

/**
 * Handles a single change event record.
 *
 * @param {Object} changeDescriptor
 * @private
 */

WatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {
  const self = this;
  let absPath;
  let relativePath;

  if (this.capabilities.relative_root) {
    relativePath = changeDescriptor.name;
    absPath = external_path_namespaceObject.join(
      this.watchProjectInfo.root,
      this.watchProjectInfo.relativePath,
      relativePath,
    );
  } else {
    absPath = external_path_namespaceObject.join(this.root, changeDescriptor.name);
    relativePath = changeDescriptor.name;
  }

  if (
    !(self.capabilities.wildmatch && !this.hasIgnore) &&
    !common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)
  ) {
    return;
  }

  if (changeDescriptor.exists) {
    external_graceful_fs_default().lstat(absPath, (error, stat) => {
      // Files can be deleted between the event and the lstat call
      // the most reliable thing to do here is to ignore the event.
      if (error && error.code === 'ENOENT') {
        return;
      }

      if (handleError(self, error)) {
        return;
      }

      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT;

      // Change event on dirs are mostly useless.
      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {
        self.emitEvent(eventType, relativePath, self.root, stat);
      }
    });
  } else {
    self.emitEvent(DELETE_EVENT, relativePath, self.root);
  }
};

/**
 * Dispatches the event.
 *
 * @param {string} eventType
 * @param {string} filepath
 * @param {string} root
 * @param {fs.Stat} stat
 * @private
 */

WatchmanWatcher.prototype.emitEvent = function (
  eventType,
  filepath,
  root,
  stat,
) {
  this.emit(eventType, filepath, root, stat);
  this.emit(ALL_EVENT, eventType, filepath, root, stat);
};

/**
 * Closes the watcher.
 *
 */

WatchmanWatcher.prototype.close = function () {
  this.client.removeAllListeners();
  this.client.end();
  return Promise.resolve();
};

/**
 * Handles an error and returns true if exists.
 *
 * @param {WatchmanWatcher} self
 * @param {Error} error
 * @private
 */

function handleError(self, error) {
  if (error == null) {
    return false;
  } else {
    self.emit('error', error);
    return true;
  }
}

/**
 * Handles a warning in the watchman resp object.
 *
 * @param {object} resp
 * @private
 */

function handleWarning(resp) {
  if ('warning' in resp) {
    if (RecrawlWarning_default().isRecrawlWarningDupe(resp.warning)) {
      return true;
    }
    console.warn(resp.warning);
    return true;
  } else {
    return false;
  }
}


/***/ }),

/***/ "./src/watchers/common.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// vendored from https://github.com/amasad/sane/blob/64ff3a870c42e84f744086884bf55a4f9c22d376/src/common.js



const platform = (__webpack_require__("os").platform)();
const path = require('path');
const anymatch = require('anymatch');
const micromatch = require('micromatch');
const walker = require('walker');

/**
 * Constants
 */

exports.DEFAULT_DELAY = 100;
exports.CHANGE_EVENT = 'change';
exports.DELETE_EVENT = 'delete';
exports.ADD_EVENT = 'add';
exports.ALL_EVENT = 'all';

/**
 * Assigns options to the watcher.
 *
 * @param {NodeWatcher|PollWatcher|WatchmanWatcher} watcher
 * @param {?object} opts
 * @return {boolean}
 * @public
 */

exports.assignOptions = function (watcher, opts) {
  opts = opts || {};
  watcher.globs = opts.glob || [];
  watcher.dot = opts.dot || false;
  watcher.ignored = opts.ignored || false;

  if (!Array.isArray(watcher.globs)) {
    watcher.globs = [watcher.globs];
  }
  watcher.hasIgnore =
    Boolean(opts.ignored) && !(Array.isArray(opts) && opts.length > 0);
  watcher.doIgnore = opts.ignored ? anymatch(opts.ignored) : () => false;

  if (opts.watchman && opts.watchmanPath) {
    watcher.watchmanPath = opts.watchmanPath;
  }

  return opts;
};

/**
 * Checks a file relative path against the globs array.
 *
 * @param {array} globs
 * @param {string} relativePath
 * @return {boolean}
 * @public
 */

exports.isFileIncluded = function (globs, dot, doIgnore, relativePath) {
  if (doIgnore(relativePath)) {
    return false;
  }
  return globs.length > 0
    ? micromatch.some(relativePath, globs, {dot})
    : // eslint-disable-next-line unicorn/no-array-method-this-argument
      dot || micromatch.some(relativePath, '**/*');
};

/**
 * Traverse a directory recursively calling `callback` on every directory.
 *
 * @param {string} dir
 * @param {function} dirCallback
 * @param {function} fileCallback
 * @param {function} endCallback
 * @param {*} ignored
 * @public
 */

exports.recReaddir = function (
  dir,
  dirCallback,
  fileCallback,
  endCallback,
  errorCallback,
  ignored,
) {
  walker(dir)
    .filterDir(currentDir => !anymatch(ignored, currentDir))
    .on('dir', normalizeProxy(dirCallback))
    .on('file', normalizeProxy(fileCallback))
    .on('error', errorCallback)
    .on('end', () => {
      if (platform === 'win32') {
        setTimeout(endCallback, 1000);
      } else {
        endCallback();
      }
    });
};

/**
 * Returns a callback that when called will normalize a path and call the
 * original callback
 *
 * @param {function} callback
 * @return {function}
 * @private
 */

function normalizeProxy(callback) {
  return (filepath, stats) => callback(path.normalize(filepath), stats);
}


/***/ }),

/***/ "events":
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "os":
/***/ ((module) => {

module.exports = require("os");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.ModuleMap = exports.DuplicateError = void 0;
function _crypto() {
  const data = require("crypto");
  _crypto = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("events");
  _events = function () {
    return data;
  };
  return data;
}
function _os() {
  const data = require("os");
  _os = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _v() {
  const data = require("v8");
  _v = function () {
    return data;
  };
  return data;
}
function _gracefulFs() {
  const data = require("graceful-fs");
  _gracefulFs = function () {
    return data;
  };
  return data;
}
function _jestRegexUtil() {
  const data = require("jest-regex-util");
  _jestRegexUtil = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require("jest-util");
  _jestUtil = function () {
    return data;
  };
  return data;
}
function _jestWorker() {
  const data = require("jest-worker");
  _jestWorker = function () {
    return data;
  };
  return data;
}
var _HasteFS = _interopRequireDefault(__webpack_require__("./src/HasteFS.ts"));
var _ModuleMap = _interopRequireDefault(__webpack_require__("./src/ModuleMap.ts"));
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var _node = __webpack_require__("./src/crawlers/node.ts");
var _watchman = __webpack_require__("./src/crawlers/watchman.ts");
var _getMockName = _interopRequireDefault(__webpack_require__("./src/getMockName.ts"));
var fastPath = _interopRequireWildcard(__webpack_require__("./src/lib/fast_path.ts"));
var _getPlatformExtension = _interopRequireDefault(__webpack_require__("./src/lib/getPlatformExtension.ts"));
var _isWatchmanInstalled = _interopRequireDefault(__webpack_require__("./src/lib/isWatchmanInstalled.ts"));
var _normalizePathSep = _interopRequireDefault(__webpack_require__("./src/lib/normalizePathSep.ts"));
var _FSEventsWatcher = __webpack_require__("./src/watchers/FSEventsWatcher.ts");
var _NodeWatcher = _interopRequireDefault(__webpack_require__("./src/watchers/NodeWatcher.js"));
var _WatchmanWatcher = _interopRequireDefault(__webpack_require__("./src/watchers/WatchmanWatcher.js"));
var _worker = require("./worker");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/jestjs/jest/pull/10919

// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/jestjs/jest/pull/5387

// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't
// understand `require`.
const {
  version: VERSION
} = __webpack_require__("./package.json");
let isWatchmanInstalledPromise;
const ModuleMap = exports.ModuleMap = _ModuleMap.default;
const CHANGE_INTERVAL = 30;
const MAX_WAIT_TIME = 240_000;
const NODE_MODULES = `${path().sep}node_modules${path().sep}`;
const PACKAGE_JSON = `${path().sep}package.json`;
const VCS_DIRECTORIES = ['.git', '.hg', '.sl'].map(vcs => (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep)).join('|');
/**
 * HasteMap is a JavaScript implementation of Facebook's haste module system.
 *
 * This implementation is inspired by https://github.com/facebook/node-haste
 * and was built with for high-performance in large code repositories with
 * hundreds of thousands of files. This implementation is scalable and provides
 * predictable performance.
 *
 * Because the haste map creation and synchronization is critical to startup
 * performance and most tasks are blocked by I/O this class makes heavy use of
 * synchronous operations. It uses worker processes for parallelizing file
 * access and metadata extraction.
 *
 * The data structures created by `jest-haste-map` can be used directly from the
 * cache without further processing. The metadata objects in the `files` and
 * `map` objects contain cross-references: a metadata object from one can look
 * up the corresponding metadata object in the other map. Note that in most
 * projects, the number of files will be greater than the number of haste
 * modules one module can refer to many files based on platform extensions.
 *
 * type HasteMap = {
 *   clocks: WatchmanClocks,
 *   files: {[filepath: string]: FileMetaData},
 *   map: {[id: string]: ModuleMapItem},
 *   mocks: {[id: string]: string},
 * }
 *
 * // Watchman clocks are used for query synchronization and file system deltas.
 * type WatchmanClocks = {[filepath: string]: string};
 *
 * type FileMetaData = {
 *   id: ?string, // used to look up module metadata objects in `map`.
 *   mtime: number, // check for outdated files.
 *   size: number, // size of the file in bytes.
 *   visited: boolean, // whether the file has been parsed or not.
 *   dependencies: Array<string>, // all relative dependencies of this file.
 *   sha1: ?string, // SHA-1 of the file, if requested via options.
 * };
 *
 * // Modules can be targeted to a specific platform based on the file name.
 * // Example: platform.ios.js and Platform.android.js will both map to the same
 * // `Platform` module. The platform should be specified during resolution.
 * type ModuleMapItem = {[platform: string]: ModuleMetaData};
 *
 * //
 * type ModuleMetaData = {
 *   path: string, // the path to look up the file object in `files`.
 *   type: string, // the module type (either `package` or `module`).
 * };
 *
 * Note that the data structures described above are conceptual only. The actual
 * implementation uses arrays and constant keys for metadata storage. Instead of
 * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real
 * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space
 * and reduce parse and write time of a big JSON blob.
 *
 * The HasteMap is created as follows:
 *  1. read data from the cache or create an empty structure.
 *
 *  2. crawl the file system.
 *     * empty cache: crawl the entire file system.
 *     * cache available:
 *       * if watchman is available: get file system delta changes.
 *       * if watchman is unavailable: crawl the entire file system.
 *     * build metadata objects for every file. This builds the `files` part of
 *       the `HasteMap`.
 *
 *  3. parse and extract metadata from changed files.
 *     * this is done in parallel over worker processes to improve performance.
 *     * the worst case is to parse all files.
 *     * the best case is no file system access and retrieving all data from
 *       the cache.
 *     * the average case is a small number of changed files.
 *
 *  4. serialize the new `HasteMap` in a cache file.
 *     Worker processes can directly access the cache through `HasteMap.read()`.
 *
 */
class HasteMap extends _events().EventEmitter {
  _buildPromise = null;
  _cachePath = '';
  _changeInterval;
  _console;
  _options;
  _watchers = [];
  _worker = null;
  static getStatic(config) {
    if (config.haste.hasteMapModulePath) {
      return require(config.haste.hasteMapModulePath);
    }
    return HasteMap;
  }
  static async create(options) {
    if (options.hasteMapModulePath) {
      const CustomHasteMap = require(options.hasteMapModulePath);
      return new CustomHasteMap(options);
    }
    const hasteMap = new HasteMap(options);
    await hasteMap.setupCachePath(options);
    return hasteMap;
  }
  constructor(options) {
    super();
    this._options = {
      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),
      computeDependencies: options.computeDependencies ?? true,
      computeSha1: options.computeSha1 || false,
      dependencyExtractor: options.dependencyExtractor || null,
      enableSymlinks: options.enableSymlinks || false,
      extensions: options.extensions,
      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,
      hasteImplModulePath: options.hasteImplModulePath,
      id: options.id,
      maxWorkers: options.maxWorkers,
      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,
      platforms: options.platforms,
      resetCache: options.resetCache,
      retainAllFiles: options.retainAllFiles,
      rootDir: options.rootDir,
      roots: [...new Set(options.roots)],
      skipPackageJson: !!options.skipPackageJson,
      throwOnModuleCollision: !!options.throwOnModuleCollision,
      useWatchman: options.useWatchman ?? true,
      watch: !!options.watch,
      workerThreads: options.workerThreads
    };
    this._console = options.console || globalThis.console;
    if (options.ignorePattern) {
      if (options.ignorePattern instanceof RegExp) {
        this._options.ignorePattern = new RegExp(`${options.ignorePattern.source}|${VCS_DIRECTORIES}`, options.ignorePattern.flags);
      } else {
        throw new TypeError('jest-haste-map: the `ignorePattern` option must be a RegExp');
      }
    } else {
      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);
    }
    if (this._options.enableSymlinks && this._options.useWatchman) {
      throw new Error('jest-haste-map: enableSymlinks config option was set, but ' + 'is incompatible with watchman.\n' + 'Set either `enableSymlinks` to false or `useWatchman` to false.');
    }
  }
  async setupCachePath(options) {
    const rootDirHash = (0, _crypto().createHash)('sha1').update(options.rootDir).digest('hex').slice(0, 32);
    let hasteImplHash = '';
    let dependencyExtractorHash = '';
    if (options.hasteImplModulePath) {
      const hasteImpl = require(options.hasteImplModulePath);
      if (hasteImpl.getCacheKey) {
        hasteImplHash = String(hasteImpl.getCacheKey());
      }
    }
    if (options.dependencyExtractor) {
      const dependencyExtractor = await (0, _jestUtil().requireOrImportModule)(options.dependencyExtractor, false);
      if (dependencyExtractor.getCacheKey) {
        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());
      }
    }
    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.id}-${rootDirHash}`, VERSION, this._options.id, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash, this._options.computeDependencies.toString());
  }
  static getCacheFilePath(tmpdir, id, ...extra) {
    const hash = (0, _crypto().createHash)('sha1').update(extra.join(''));
    return path().join(tmpdir, `${id.replaceAll(/\W/g, '-')}-${hash.digest('hex').slice(0, 32)}`);
  }
  static getModuleMapFromJSON(json) {
    return _ModuleMap.default.fromJSON(json);
  }
  getCacheFilePath() {
    return this._cachePath;
  }
  build() {
    if (!this._buildPromise) {
      this._buildPromise = (async () => {
        const data = await this._buildFileMap();

        // Persist when we don't know if files changed (changedFiles undefined)
        // or when we know a file was changed or deleted.
        let hasteMap;
        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {
          hasteMap = await this._buildHasteMap(data);
          this._persist(hasteMap);
        } else {
          hasteMap = data.hasteMap;
        }
        const rootDir = this._options.rootDir;
        const hasteFS = new _HasteFS.default({
          files: hasteMap.files,
          rootDir
        });
        const moduleMap = new _ModuleMap.default({
          duplicates: hasteMap.duplicates,
          map: hasteMap.map,
          mocks: hasteMap.mocks,
          rootDir
        });
        const __hasteMapForTest =  false || null;
        await this._watch(hasteMap);
        return {
          __hasteMapForTest,
          hasteFS,
          moduleMap
        };
      })();
    }
    return this._buildPromise;
  }

  /**
   * 1. read data from the cache or create an empty structure.
   */
  read() {
    let hasteMap;
    try {
      hasteMap = (0, _v().deserialize)((0, _gracefulFs().readFileSync)(this._cachePath));
    } catch {
      hasteMap = this._createEmptyMap();
    }
    return hasteMap;
  }
  readModuleMap() {
    const data = this.read();
    return new _ModuleMap.default({
      duplicates: data.duplicates,
      map: data.map,
      mocks: data.mocks,
      rootDir: this._options.rootDir
    });
  }

  /**
   * 2. crawl the file system.
   */
  async _buildFileMap() {
    let hasteMap;
    try {
      const read = this._options.resetCache ? this._createEmptyMap : this.read;
      hasteMap = read.call(this);
    } catch {
      hasteMap = this._createEmptyMap();
    }
    return this._crawl(hasteMap);
  }

  /**
   * 3. parse and extract metadata from changed files.
   */
  _processFile(hasteMap, map, mocks, filePath, workerOptions) {
    const rootDir = this._options.rootDir;
    const setModule = (id, module) => {
      let moduleMap = map.get(id);
      if (!moduleMap) {
        moduleMap = Object.create(null);
        map.set(id, moduleMap);
      }
      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;
      const existingModule = moduleMap[platform];
      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {
        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';
        this._console[method]([`jest-haste-map: Haste module naming collision: ${id}`, '  The following files share their name; please adjust your hasteImpl:', `    * <rootDir>${path().sep}${existingModule[_constants.default.PATH]}`, `    * <rootDir>${path().sep}${module[_constants.default.PATH]}`, ''].join('\n'));
        if (this._options.throwOnModuleCollision) {
          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);
        }

        // We do NOT want consumers to use a module that is ambiguous.
        delete moduleMap[platform];
        if (Object.keys(moduleMap).length === 1) {
          map.delete(id);
        }
        let dupsByPlatform = hasteMap.duplicates.get(id);
        if (dupsByPlatform == null) {
          dupsByPlatform = new Map();
          hasteMap.duplicates.set(id, dupsByPlatform);
        }
        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);
        dupsByPlatform.set(platform, dups);
        return;
      }
      const dupsByPlatform = hasteMap.duplicates.get(id);
      if (dupsByPlatform != null) {
        const dups = dupsByPlatform.get(platform);
        if (dups != null) {
          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);
        }
        return;
      }
      moduleMap[platform] = module;
    };
    const relativeFilePath = fastPath.relative(rootDir, filePath);
    const fileMetadata = hasteMap.files.get(relativeFilePath);
    if (!fileMetadata) {
      throw new Error('jest-haste-map: File to process was not found in the haste map.');
    }
    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);
    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1];

    // Callback called when the response from the worker is successful.
    const workerReply = metadata => {
      // `1` for truthy values instead of `true` to save cache space.
      fileMetadata[_constants.default.VISITED] = 1;
      const metadataId = metadata.id;
      const metadataModule = metadata.module;
      if (metadataId && metadataModule) {
        fileMetadata[_constants.default.ID] = metadataId;
        setModule(metadataId, metadataModule);
      }
      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';
      if (computeSha1) {
        fileMetadata[_constants.default.SHA1] = metadata.sha1;
      }
    };

    // Callback called when the response from the worker is an error.
    const workerError = error => {
      if (typeof error !== 'object' || !error.message || !error.stack) {
        error = new Error(error);
        error.stack = ''; // Remove stack for stack-less errors.
      }
      if (!['ENOENT', 'EACCES'].includes(error.code)) {
        throw error;
      }

      // If a file cannot be read we remove it from the file list and
      // ignore the failure silently.
      hasteMap.files.delete(relativeFilePath);
    };

    // If we retain all files in the virtual HasteFS representation, we avoid
    // reading them if they aren't important (node_modules).
    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {
      if (computeSha1) {
        return this._getWorker(workerOptions).getSha1({
          computeDependencies: this._options.computeDependencies,
          computeSha1,
          dependencyExtractor: this._options.dependencyExtractor,
          filePath,
          hasteImplModulePath: this._options.hasteImplModulePath,
          rootDir
        }).then(workerReply, workerError);
      }
      return null;
    }
    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
      const mockPath = (0, _getMockName.default)(filePath);
      const existingMockPath = mocks.get(mockPath);
      if (existingMockPath) {
        const secondMockPath = fastPath.relative(rootDir, filePath);
        if (existingMockPath !== secondMockPath) {
          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';
          this._console[method]([`jest-haste-map: duplicate manual mock found: ${mockPath}`, '  The following files share their name; please delete one of them:', `    * <rootDir>${path().sep}${existingMockPath}`, `    * <rootDir>${path().sep}${secondMockPath}`, ''].join('\n'));
          if (this._options.throwOnModuleCollision) {
            throw new DuplicateError(existingMockPath, secondMockPath);
          }
        }
      }
      mocks.set(mockPath, relativeFilePath);
    }
    if (fileMetadata[_constants.default.VISITED]) {
      if (!fileMetadata[_constants.default.ID]) {
        return null;
      }
      if (moduleMetadata != null) {
        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;
        const module = moduleMetadata[platform];
        if (module == null) {
          return null;
        }
        const moduleId = fileMetadata[_constants.default.ID];
        let modulesByPlatform = map.get(moduleId);
        if (!modulesByPlatform) {
          modulesByPlatform = Object.create(null);
          map.set(moduleId, modulesByPlatform);
        }
        modulesByPlatform[platform] = module;
        return null;
      }
    }
    return this._getWorker(workerOptions).worker({
      computeDependencies: this._options.computeDependencies,
      computeSha1,
      dependencyExtractor: this._options.dependencyExtractor,
      filePath,
      hasteImplModulePath: this._options.hasteImplModulePath,
      rootDir
    }).then(workerReply, workerError);
  }
  _buildHasteMap(data) {
    const {
      removedFiles,
      changedFiles,
      hasteMap
    } = data;

    // If any files were removed or we did not track what files changed, process
    // every file looking for changes. Otherwise, process only changed files.
    let map;
    let mocks;
    let filesToProcess;
    if (changedFiles === undefined || removedFiles.size > 0) {
      map = new Map();
      mocks = new Map();
      filesToProcess = hasteMap.files;
    } else {
      map = hasteMap.map;
      mocks = hasteMap.mocks;
      filesToProcess = changedFiles;
    }
    for (const [relativeFilePath, fileMetadata] of removedFiles) {
      this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);
    }
    const promises = [];
    for (const relativeFilePath of filesToProcess.keys()) {
      if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {
        continue;
      }
      // SHA-1, if requested, should already be present thanks to the crawler.
      const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);
      const promise = this._processFile(hasteMap, map, mocks, filePath);
      if (promise) {
        promises.push(promise);
      }
    }
    return Promise.all(promises).then(() => {
      this._cleanup();
      hasteMap.map = map;
      hasteMap.mocks = mocks;
      return hasteMap;
    }, error => {
      this._cleanup();
      throw error;
    });
  }
  _cleanup() {
    const worker = this._worker;
    if (worker && 'end' in worker) {
      worker.end();
    }
    this._worker = null;
  }

  /**
   * 4. serialize the new `HasteMap` in a cache file.
   */
  _persist(hasteMap) {
    (0, _gracefulFs().writeFileSync)(this._cachePath, (0, _v().serialize)(hasteMap));
  }

  /**
   * Creates workers or parses files and extracts metadata in-process.
   */
  _getWorker(options) {
    if (!this._worker) {
      if (options?.forceInBand || this._options.maxWorkers <= 1) {
        this._worker = {
          getSha1: _worker.getSha1,
          worker: _worker.worker
        };
      } else {
        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {
          enableWorkerThreads: this._options.workerThreads,
          exposedMethods: ['getSha1', 'worker'],
          forkOptions: {
            serialization: 'json'
          },
          maxRetries: 3,
          numWorkers: this._options.maxWorkers
        });
      }
    }
    return this._worker;
  }
  async _crawl(hasteMap) {
    const options = this._options;
    const ignore = this._ignore.bind(this);
    const crawl = (await this._shouldUseWatchman()) ? _watchman.watchmanCrawl : _node.nodeCrawl;
    const crawlerOptions = {
      computeSha1: options.computeSha1,
      data: hasteMap,
      enableSymlinks: options.enableSymlinks,
      extensions: options.extensions,
      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
      ignore,
      rootDir: options.rootDir,
      roots: options.roots
    };
    const retry = retryError => {
      if (crawl === _watchman.watchmanCrawl) {
        this._console.warn('jest-haste-map: Watchman crawl failed. Retrying once with node ' + 'crawler.\n' + "  Usually this happens when watchman isn't running. Create an " + "empty `.watchmanconfig` file in your project's root folder or " + 'initialize a git or hg repository in your project.\n' + `  ${retryError}`);
        return (0, _node.nodeCrawl)(crawlerOptions).catch(error => {
          throw new Error('Crawler retry failed:\n' + `  Original error: ${retryError.message}\n` + `  Retry error: ${error.message}\n`);
        });
      }
      throw retryError;
    };
    try {
      return await crawl(crawlerOptions);
    } catch (error) {
      return retry(error);
    }
  }

  /**
   * Watch mode
   */
  async _watch(hasteMap) {
    if (!this._options.watch) {
      return;
    }

    // In watch mode, we'll only warn about module collisions and we'll retain
    // all files, even changes to node_modules.
    this._options.throwOnModuleCollision = false;
    this._options.retainAllFiles = true;

    // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher
    const Watcher = (await this._shouldUseWatchman()) ? _WatchmanWatcher.default : _FSEventsWatcher.FSEventsWatcher.isSupported() ? _FSEventsWatcher.FSEventsWatcher : _NodeWatcher.default;
    const extensions = this._options.extensions;
    const ignorePattern = this._options.ignorePattern;
    const rootDir = this._options.rootDir;
    let changeQueue = Promise.resolve();
    let eventsQueue = [];
    // We only need to copy the entire haste map once on every "frame".
    let mustCopy = true;
    const createWatcher = root => {
      const watcher = new Watcher(root, {
        dot: true,
        glob: extensions.map(extension => `**/*.${extension}`),
        ignored: ignorePattern
      });
      return new Promise((resolve, reject) => {
        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);
        watcher.once('ready', () => {
          clearTimeout(rejectTimeout);
          watcher.on('all', onChange);
          resolve(watcher);
        });
      });
    };
    const emitChange = () => {
      if (eventsQueue.length > 0) {
        mustCopy = true;
        const changeEvent = {
          eventsQueue,
          hasteFS: new _HasteFS.default({
            files: hasteMap.files,
            rootDir
          }),
          moduleMap: new _ModuleMap.default({
            duplicates: hasteMap.duplicates,
            map: hasteMap.map,
            mocks: hasteMap.mocks,
            rootDir
          })
        };
        this.emit('change', changeEvent);
        eventsQueue = [];
      }
    };
    const onChange = (type, filePath, root, stat) => {
      filePath = path().join(root, (0, _normalizePathSep.default)(filePath));
      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {
        return;
      }
      const relativeFilePath = fastPath.relative(rootDir, filePath);
      const fileMetadata = hasteMap.files.get(relativeFilePath);

      // The file has been accessed, not modified
      if (type === 'change' && fileMetadata && stat && fileMetadata[_constants.default.MTIME] === stat.mtime.getTime()) {
        return;
      }
      changeQueue = changeQueue.then(() => {
        // If we get duplicate events for the same file, ignore them.
        if (eventsQueue.some(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {
          return null;
        }
        if (mustCopy) {
          mustCopy = false;
          hasteMap = {
            clocks: new Map(hasteMap.clocks),
            duplicates: new Map(hasteMap.duplicates),
            files: new Map(hasteMap.files),
            map: new Map(hasteMap.map),
            mocks: new Map(hasteMap.mocks)
          };
        }
        const add = () => {
          eventsQueue.push({
            filePath,
            stat,
            type
          });
          return null;
        };
        const fileMetadata = hasteMap.files.get(relativeFilePath);

        // If it's not an addition, delete the file and all its metadata
        if (fileMetadata != null) {
          const moduleName = fileMetadata[_constants.default.ID];
          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;
          hasteMap.files.delete(relativeFilePath);
          let moduleMap = hasteMap.map.get(moduleName);
          if (moduleMap != null) {
            // We are forced to copy the object because jest-haste-map exposes
            // the map as an immutable entity.
            moduleMap = copy(moduleMap);
            delete moduleMap[platform];
            if (Object.keys(moduleMap).length === 0) {
              hasteMap.map.delete(moduleName);
            } else {
              hasteMap.map.set(moduleName, moduleMap);
            }
          }
          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
            const mockName = (0, _getMockName.default)(filePath);
            hasteMap.mocks.delete(mockName);
          }
          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);
        }

        // If the file was added or changed,
        // parse it and update the haste map.
        if (type === 'add' || type === 'change') {
          (0, _jestUtil().invariant)(stat, 'since the file exists or changed, it should have stats');
          const fileMetadata = ['', stat.mtime.getTime(), stat.size, 0, '', null];
          hasteMap.files.set(relativeFilePath, fileMetadata);
          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {
            forceInBand: true
          });
          // Cleanup
          this._cleanup();
          if (promise) {
            return promise.then(add);
          } else {
            // If a file in node_modules has changed,
            // emit an event regardless.
            add();
          }
        } else {
          add();
        }
        return null;
      }).catch(error => {
        this._console.error(`jest-haste-map: watch error:\n  ${error.stack}\n`);
      });
    };
    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {
      this._watchers = watchers;
    });
  }

  /**
   * This function should be called when the file under `filePath` is removed
   * or changed. When that happens, we want to figure out if that file was
   * part of a group of files that had the same ID. If it was, we want to
   * remove it from the group. Furthermore, if there is only one file
   * remaining in the group, then we want to restore that single file as the
   * correct resolution for its ID, and cleanup the duplicates index.
   */
  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {
    let dupsByPlatform = hasteMap.duplicates.get(moduleName);
    if (dupsByPlatform == null) {
      return;
    }
    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;
    let dups = dupsByPlatform.get(platform);
    if (dups == null) {
      return;
    }
    dupsByPlatform = copyMap(dupsByPlatform);
    hasteMap.duplicates.set(moduleName, dupsByPlatform);
    dups = copyMap(dups);
    dupsByPlatform.set(platform, dups);
    dups.delete(relativeFilePath);
    if (dups.size !== 1) {
      return;
    }
    const uniqueModule = dups.entries().next().value;
    if (!uniqueModule) {
      return;
    }
    let dedupMap = hasteMap.map.get(moduleName);
    if (!dedupMap) {
      dedupMap = Object.create(null);
      hasteMap.map.set(moduleName, dedupMap);
    }
    dedupMap[platform] = uniqueModule;
    dupsByPlatform.delete(platform);
    if (dupsByPlatform.size === 0) {
      hasteMap.duplicates.delete(moduleName);
    }
  }
  async end() {
    if (this._changeInterval) {
      clearInterval(this._changeInterval);
    }
    if (this._watchers.length === 0) {
      return;
    }
    await Promise.all(this._watchers.map(watcher => watcher.close()));
    this._watchers = [];
  }

  /**
   * Helpers
   */
  _ignore(filePath) {
    const ignorePattern = this._options.ignorePattern;
    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);
    return ignoreMatched || !this._options.retainAllFiles && filePath.includes(NODE_MODULES);
  }
  async _shouldUseWatchman() {
    if (!this._options.useWatchman) {
      return false;
    }
    if (!isWatchmanInstalledPromise) {
      isWatchmanInstalledPromise = (0, _isWatchmanInstalled.default)();
    }
    return isWatchmanInstalledPromise;
  }
  _createEmptyMap() {
    return {
      clocks: new Map(),
      duplicates: new Map(),
      files: new Map(),
      map: new Map(),
      mocks: new Map()
    };
  }
  static H = _constants.default;
}
class DuplicateError extends Error {
  mockPath1;
  mockPath2;
  constructor(mockPath1, mockPath2) {
    super('Duplicated files or mocks. Please check the console for more info');
    this.mockPath1 = mockPath1;
    this.mockPath2 = mockPath2;
  }
}
exports.DuplicateError = DuplicateError;
function copy(object) {
  return Object.assign(Object.create(null), object);
}
function copyMap(input) {
  return new Map(input);
}

// Export the smallest API surface required by Jest

const JestHasteMap = HasteMap;
var _default = exports["default"] = JestHasteMap;
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\jest-haste-map\build\worker.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/blacklist.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This list is compiled after the MDN list of the most common MIME types (see
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/
// Complete_list_of_MIME_types).
//
// Only MIME types starting with "image/", "video/", "audio/" and "font/" are
// reflected in the list. Adding "application/" is too risky since some text
// file formats (like ".js" and ".json") have an "application/" MIME type.
//
// Feel free to add any extensions that cannot be a Haste module.

const extensions = new Set([
// JSONs are never haste modules, except for "package.json", which is handled.
'.json',
// Image extensions.
'.bmp', '.gif', '.ico', '.jpeg', '.jpg', '.png', '.svg', '.tiff', '.tif', '.webp',
// Video extensions.
'.avi', '.mp4', '.mpeg', '.mpg', '.ogv', '.webm', '.3gp', '.3g2',
// Audio extensions.
'.aac', '.midi', '.mid', '.mp3', '.oga', '.wav', '.3gp', '.3g2',
// Font extensions.
'.eot', '.otf', '.ttf', '.woff', '.woff2']);
var _default = exports["default"] = extensions;

/***/ }),

/***/ "./src/constants.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * This file exports a set of constants that are used for Jest's haste map
 * serialization. On very large repositories, the haste map cache becomes very
 * large to the point where it is the largest overhead in starting up Jest.
 *
 * This constant key map allows to keep the map smaller without having to build
 * a custom serialization library.
 */

/* eslint-disable sort-keys */
const constants = {
  /* dependency serialization */
  DEPENDENCY_DELIM: '\0',
  /* file map attributes */
  ID: 0,
  MTIME: 1,
  SIZE: 2,
  VISITED: 3,
  DEPENDENCIES: 4,
  SHA1: 5,
  /* module map attributes */
  PATH: 0,
  TYPE: 1,
  /* module types */
  MODULE: 0,
  PACKAGE: 1,
  /* platforms */
  GENERIC_PLATFORM: 'g',
  NATIVE_PLATFORM: 'native'
};
/* eslint-enable */
var _default = exports["default"] = constants;

/***/ }),

/***/ "./src/lib/dependencyExtractor.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.extractor = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const NOT_A_DOT = '(?<!\\.\\s*)';
const CAPTURE_STRING_LITERAL = pos => `([\`'"])([^'"\`]*?)(?:\\${pos})`;
const WORD_SEPARATOR = '\\b';
const LEFT_PARENTHESIS = '\\(';
const RIGHT_PARENTHESIS = '\\)';
const WHITESPACE = '\\s*';
const OPTIONAL_COMMA = '(:?,\\s*)?';
function createRegExp(parts, flags) {
  return new RegExp(parts.join(''), flags);
}
function alternatives(...parts) {
  return `(?:${parts.join('|')})`;
}
function functionCallStart(...names) {
  return [NOT_A_DOT, WORD_SEPARATOR, alternatives(...names), WHITESPACE, LEFT_PARENTHESIS, WHITESPACE];
}
const BLOCK_COMMENT_RE = /\/\*[^]*?\*\//g;
const LINE_COMMENT_RE = /\/\/.*/g;
const REQUIRE_OR_DYNAMIC_IMPORT_RE = createRegExp([...functionCallStart('require', 'import'), CAPTURE_STRING_LITERAL(1), WHITESPACE, OPTIONAL_COMMA, RIGHT_PARENTHESIS], 'g');
const IMPORT_OR_EXPORT_RE = createRegExp(['\\b(?:import|export)\\s+(?!type(?:of)?\\s+)(?:[^\'"]+\\s+from\\s+)?', CAPTURE_STRING_LITERAL(1)], 'g');
const JEST_EXTENSIONS_RE = createRegExp([...functionCallStart('jest\\s*\\.\\s*(?:requireActual|requireMock|createMockFromModule)'), CAPTURE_STRING_LITERAL(1), WHITESPACE, OPTIONAL_COMMA, RIGHT_PARENTHESIS], 'g');
const extractor = exports.extractor = {
  extract(code) {
    const dependencies = new Set();
    const addDependency = (match, _, dep) => {
      dependencies.add(dep);
      return match;
    };
    code.replaceAll(BLOCK_COMMENT_RE, '').replaceAll(LINE_COMMENT_RE, '').replace(IMPORT_OR_EXPORT_RE, addDependency).replace(REQUIRE_OR_DYNAMIC_IMPORT_RE, addDependency).replace(JEST_EXTENSIONS_RE, addDependency);
    return dependencies;
  }
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSha1 = getSha1;
exports.worker = worker;
function _crypto() {
  const data = require("crypto");
  _crypto = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require("jest-util");
  _jestUtil = function () {
    return data;
  };
  return data;
}
var _blacklist = _interopRequireDefault(__webpack_require__("./src/blacklist.ts"));
var _constants = _interopRequireDefault(__webpack_require__("./src/constants.ts"));
var _dependencyExtractor = __webpack_require__("./src/lib/dependencyExtractor.ts");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const PACKAGE_JSON = `${path().sep}package.json`;
function sha1hex(content) {
  return (0, _crypto().createHash)('sha1').update(content).digest('hex');
}
async function worker(data) {
  const hasteImpl = data.hasteImplModulePath ? require(data.hasteImplModulePath) : null;
  let content;
  let dependencies;
  let id;
  let module;
  let sha1;
  const {
    computeDependencies,
    computeSha1,
    rootDir,
    filePath
  } = data;
  const getContent = () => {
    if (content === undefined) {
      content = fs().readFileSync(filePath, 'utf8');
    }
    return content;
  };
  if (filePath.endsWith(PACKAGE_JSON)) {
    // Process a package.json that is returned as a PACKAGE type with its name.
    try {
      const fileData = JSON.parse(getContent());
      if (fileData.name) {
        const relativeFilePath = path().relative(rootDir, filePath);
        id = fileData.name;
        module = [relativeFilePath, _constants.default.PACKAGE];
      }
    } catch (error) {
      throw new Error(`Cannot parse ${filePath} as JSON: ${error.message}`);
    }
  } else if (!_blacklist.default.has(filePath.slice(filePath.lastIndexOf('.')))) {
    // Process a random file that is returned as a MODULE.
    if (hasteImpl) {
      id = hasteImpl.getHasteName(filePath);
    }
    if (computeDependencies) {
      const content = getContent();
      const extractor = data.dependencyExtractor ? await (0, _jestUtil().requireOrImportModule)(data.dependencyExtractor, false) : _dependencyExtractor.extractor;
      dependencies = [...extractor.extract(content, filePath, _dependencyExtractor.extractor.extract)];
    }
    if (id) {
      const relativeFilePath = path().relative(rootDir, filePath);
      module = [relativeFilePath, _constants.default.MODULE];
    }
  }

  // If a SHA-1 is requested on update, compute it.
  if (computeSha1) {
    sha1 = sha1hex(content || fs().readFileSync(filePath));
  }
  return {
    dependencies,
    id,
    module,
    sha1
  };
}
async function getSha1(data) {
  const sha1 = data.computeSha1 ? sha1hex(fs().readFileSync(data.filePath)) : null;
  return {
    dependencies: undefined,
    id: undefined,
    module: undefined,
    sha1
  };
}
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\jest-haste-map\package.json

Code:
{
  "name": "jest-haste-map",
  "version": "30.0.2",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-haste-map"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.0.1",
    "@types/node": "*",
    "anymatch": "^3.1.3",
    "fb-watchman": "^2.0.2",
    "graceful-fs": "^4.2.11",
    "jest-regex-util": "30.0.1",
    "jest-util": "30.0.2",
    "jest-worker": "30.0.2",
    "micromatch": "^4.0.8",
    "walker": "^1.0.8"
  },
  "devDependencies": {
    "@types/fb-watchman": "^2.0.5",
    "@types/graceful-fs": "^4.1.9",
    "@types/micromatch": "^4.0.9",
    "slash": "^3.0.0"
  },
  "optionalDependencies": {
    "fsevents": "^2.3.3"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "393acbfac31f64bb38dff23c89224797caded83c"
}


---

File name: node_modules\babel-jest\node_modules\jest-haste-map\README.md

Code:
# jest-haste-map

`jest-haste-map` is a module used by Jest, a popular JavaScript testing framework, to create a fast lookup of files in a project. It helps Jest efficiently locate and track changes in files during testing, making it particularly useful for large projects with many files.

## why jest-haste-map ?

- **Parallel crawling and analysis:** jest-haste-map crawls the entire project, extracts dependencies, and analyzes files in parallel across worker processes.This can significantly improve the performance of the map building process.
- **Cached file system:** jest-haste-map keeps a cache of the file system in memory and on disk. This allows for fast file related operations, such as resolving module imports and checking for changes.
- **Minimal work**: jest-haste-map only does the minimal amount of work necessary when files change. (If you are using [watchman](https://facebook.github.io/watchman/) (recommended for large projects), Jest will ask watchman for changed files instead of crawling the file system. This is very fast even if you have tens of thousands of files.)
- **File system watching:** jest-haste-map can watch the file system for changes. This is useful for building interactive tools, such as watch mode.

## Installation

with npm :

```bash
npm install jest-haste-map --save-dev
```

with yarn :

```bash
yarn add jest-haste-map --dev
```

## usage

`jest-haste-map` is compatible with both `ES modules` and `CommonJS`

### simple usage

```javascript
const map = new HasteMap.default({
  // options
});
```

### Example usage (get all files with .js extension in the project)

```javascript
import HasteMap from 'jest-haste-map';
import os from 'os';
import {dirname} from 'path';
import {fileURLToPath} from 'url';

const root = dirname(fileURLToPath(import.meta.url));

const map = new HasteMap.default({
  id: 'myproject', //Used for caching.
  extensions: ['js'], // Tells jest-haste-map to only crawl .js files.
  maxWorkers: os.availableParallelism(), //Parallelizes across all available CPUs.
  platforms: [], // This is only used for React Native, you can leave it empty.
  roots: [root], // Can be used to only search a subset of files within `rootDir`
  retainAllFiles: true,
  rootDir: root, //The project root.
});

const {hasteFS} = await map.build();

const files = hasteFS.getAllFiles();

console.log(files);
```

### options

| Option                 | Type                | Required | Default Value |
| ---------------------- | ------------------- | -------- | ------------- |
| cacheDirectory         | string              | No       | `os.tmpdir()` |
| computeDependencies    | boolean             | No       | `true`        |
| computeSha1            | boolean             | No       | `false`       |
| console                | Console             | No       | -             |
| dependencyExtractor    | string \| null      | No       | `null`        |
| enableSymlinks         | boolean             | No       | `false`       |
| extensions             | Array&lt;string&gt; | Yes      | -             |
| forceNodeFilesystemAPI | boolean             | Yes      | -             |
| hasteImplModulePath    | string              | Yes      | -             |
| hasteMapModulePath     | string              | Yes      | -             |
| id                     | string              | Yes      | -             |
| ignorePattern          | HasteRegExp         | No       | -             |
| maxWorkers             | number              | Yes      | -             |
| mocksPattern           | string              | No       | -             |
| platforms              | Array&lt;string&gt; | Yes      | -             |
| resetCache             | boolean             | No       | -             |
| retainAllFiles         | boolean             | Yes      | -             |
| rootDir                | string              | Yes      | -             |
| roots                  | Array&lt;string&gt; | Yes      | -             |
| skipPackageJson        | boolean             | Yes      | -             |
| throwOnModuleCollision | boolean             | Yes      | -             |
| useWatchman            | boolean             | No       | `true`        |

For more, you can check [github](https://github.com/jestjs/jest/tree/main/packages/jest-haste-map)


---

File name: node_modules\babel-jest\node_modules\jest-regex-util\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
export declare const escapePathForRegex: (dir: string) => string;

export declare const escapeStrForRegex: (string: string) => string;

export declare const replacePathSepForRegex: (string: string) => string;

export {};


---

File name: node_modules\babel-jest\node_modules\jest-regex-util\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.replacePathSepForRegex = exports.escapeStrForRegex = exports.escapePathForRegex = void 0;
var _path = require("path");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

const escapePathForRegex = dir => {
  if (_path.sep === '\\') {
    // Replace "\" with "/" so it's not escaped by escapeStrForRegex.
    // replacePathSepForRegex will convert it back.
    dir = dir.replaceAll('\\', '/');
  }
  return replacePathSepForRegex(escapeStrForRegex(dir));
};
exports.escapePathForRegex = escapePathForRegex;
const escapeStrForRegex = string => string.replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&');
exports.escapeStrForRegex = escapeStrForRegex;
const replacePathSepForRegex = string => {
  if (_path.sep === '\\') {
    return string.replaceAll(/(\/|(.)?\\(?![$()*+.?[\\\]^{|}]))/g, (_match, _, p2) => p2 && p2 !== '\\' ? `${p2}\\\\` : '\\\\');
  }
  return string;
};
exports.replacePathSepForRegex = replacePathSepForRegex;
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\jest-regex-util\package.json

Code:
{
  "name": "jest-regex-util",
  "version": "30.0.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-regex-util"
  },
  "devDependencies": {
    "@types/node": "*"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "5ce865b4060189fe74cd486544816c079194a0f7"
}


---

File name: node_modules\babel-jest\node_modules\jest-util\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {WriteStream} from 'tty';
import {Config, Global as Global_2} from '@jest/types';

declare const ARROW = ' \u203A ';

/**
 * Whether the given value has properties that can be deleted (regardless of protection).
 *
 * @param value The given value.
 */
export declare function canDeleteProperties(value: unknown): value is object;

declare const CLEAR: string;

export declare function clearLine(stream: WriteStream): void;

export declare function convertDescriptorToString(
  descriptor: Global_2.BlockNameLike | undefined,
): string;

export declare function createDirectory(path: string): void;

export declare function deepCyclicCopy<T>(
  value: T,
  options?: DeepCyclicCopyOptions,
  cycles?: WeakMap<any, any>,
): T;

declare type DeepCyclicCopyOptions = {
  blacklist?: Set<string>;
  keepPrototype?: boolean;
};

/**
 * Deletes all the properties from the given value (if it's an object),
 * unless the value was protected via {@link #protectProperties}.
 *
 * @param value the given value.
 */
export declare function deleteProperties(value: unknown): void;

/**
 *  - <b>off</b>: deletion is completely turned off.
 *  - <b>soft</b>: doesn't delete objects, but instead wraps their getter/setter with a deprecation warning.
 *  - <b>on</b>: actually delete objects (using `delete`).
 */
export declare type DeletionMode = 'soft' | 'off' | 'on';

export declare class ErrorWithStack extends Error {
  constructor(
    message: string | undefined,
    callsite: (...args: Array<any>) => unknown,
    stackLimit?: number,
  );
}

export declare function formatTime(
  time: number,
  prefixPower?: number,
  padLeftLength?: number,
): string;

/**
 * Converts a list of globs into a function that matches a path against the
 * globs.
 *
 * Every time picomatch is called, it will parse the glob strings and turn
 * them into regexp instances. Instead of calling picomatch repeatedly with
 * the same globs, we can use this function which will build the picomatch
 * matchers ahead of time and then have an optimized path for determining
 * whether an individual path matches.
 *
 * This function is intended to match the behavior of `micromatch()`.
 *
 * @example
 * const isMatch = globsToMatcher(['*.js', '!*.test.js']);
 * isMatch('pizza.js'); // true
 * isMatch('pizza.test.js'); // false
 */
export declare function globsToMatcher(globs: Array<string>): Matcher;

declare const ICONS: {
  failed: string;
  pending: string;
  success: string;
  todo: string;
};

/**
 * Initializes the garbage collection utils with the given deletion mode.
 *
 * @param globalObject the global object on which to store the deletion mode.
 * @param deletionMode the deletion mode to use.
 */
export declare function initializeGarbageCollectionUtils(
  globalObject: typeof globalThis,
  deletionMode: DeletionMode,
): void;

export declare function installCommonGlobals(
  globalObject: typeof globalThis,
  globals: Config.ConfigGlobals,
  garbageCollectionDeletionMode?: DeletionMode,
): typeof globalThis & Config.ConfigGlobals;

export declare function interopRequireDefault(obj: any): any;

export declare function invariant(
  condition: unknown,
  message?: string,
): asserts condition;

export declare const isInteractive: boolean;

export declare function isNonNullable<T>(value: T): value is NonNullable<T>;

export declare function isPromise<T = unknown>(
  candidate: unknown,
): candidate is PromiseLike<T>;

declare type Matcher = (str: string) => boolean;

export declare function pluralize(
  word: string,
  count: number,
  ending?: string,
): string;

declare namespace preRunMessage {
  export {print_2 as print, remove};
}
export {preRunMessage};

declare function print_2(stream: WriteStream): void;

/**
 * Protects the given value from being deleted by {@link #deleteProperties}.
 *
 * @param value The given value.
 * @param properties If the array contains any property,
 * then only these properties will be protected; otherwise if the array is empty,
 * all properties will be protected.
 * @param depth Determines how "deep" the protection should be.
 * A value of 0 means that only the top-most properties will be protected,
 * while a value larger than 0 means that deeper levels of nesting will be protected as well.
 */
export declare function protectProperties<T>(
  value: T,
  properties?: Array<keyof T>,
  depth?: number,
): boolean;

declare function remove(stream: WriteStream): void;

export declare function replacePathSepForGlob(path: string): string;

export declare function requireOrImportModule<T>(
  filePath: string,
  applyInteropRequireDefault?: boolean,
): Promise<T>;

export declare function setGlobal(
  globalToMutate: typeof globalThis | Global_2.Global,
  key: string | symbol,
  value: unknown,
  afterTeardown?: 'clean' | 'retain',
): void;

declare namespace specialChars {
  export {ARROW, ICONS, CLEAR};
}
export {specialChars};

export declare function tryRealpath(path: string): string;

export {};


---

File name: node_modules\babel-jest\node_modules\jest-util\build\index.js

Code:
/*!
 * /**
 *  * Copyright (c) Meta Platforms, Inc. and affiliates.
 *  *
 *  * This source code is licensed under the MIT license found in the
 *  * LICENSE file in the root directory of this source tree.
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ErrorWithStack.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

class ErrorWithStack extends Error {
  constructor(message, callsite, stackLimit) {
    // Ensure we have a large stack length so we get full details.
    const originalStackLimit = Error.stackTraceLimit;
    if (stackLimit) {
      Error.stackTraceLimit = Math.max(stackLimit, originalStackLimit || 10);
    }
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, callsite);
    }
    Error.stackTraceLimit = originalStackLimit;
  }
}
exports["default"] = ErrorWithStack;

/***/ }),

/***/ "./src/clearLine.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = clearLine;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function clearLine(stream) {
  if (stream.isTTY) {
    stream.write('\u001B[999D\u001B[K');
  }
}

/***/ }),

/***/ "./src/convertDescriptorToString.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = convertDescriptorToString;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function convertDescriptorToString(descriptor) {
  switch (typeof descriptor) {
    case 'function':
      if (descriptor.name) {
        return descriptor.name;
      }
      break;
    case 'number':
    case 'undefined':
      return `${descriptor}`;
    case 'string':
      return descriptor;
  }
  throw new Error(`Invalid first argument, ${descriptor}. It must be a named class, named function, number, or string.`);
}

/***/ }),

/***/ "./src/createDirectory.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createDirectory;
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function createDirectory(path) {
  try {
    fs().mkdirSync(path, {
      recursive: true
    });
  } catch (error) {
    if (error.code !== 'EEXIST') {
      throw error;
    }
  }
}

/***/ }),

/***/ "./src/createProcessObject.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createProcessObject;
var _deepCyclicCopy = _interopRequireDefault(__webpack_require__("./src/deepCyclicCopy.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const BLACKLIST = new Set(['env', 'mainModule', '_events']);
const isWin32 = process.platform === 'win32';
const proto = Object.getPrototypeOf(process.env);

// The "process.env" object has a bunch of particularities: first, it does not
// directly extend from Object; second, it converts any assigned value to a
// string; and third, it is case-insensitive in Windows. We use a proxy here to
// mimic it (see https://nodejs.org/api/process.html#process_process_env).

function createProcessEnv() {
  const real = Object.create(proto);
  const lookup = {};
  function deletePropertyWin32(_target, key) {
    for (const name in real) {
      if (Object.prototype.hasOwnProperty.call(real, name)) {
        if (typeof key === 'string') {
          if (name.toLowerCase() === key.toLowerCase()) {
            delete real[name];
            delete lookup[name.toLowerCase()];
          }
        } else {
          if (key === name) {
            delete real[name];
            delete lookup[name];
          }
        }
      }
    }
    return true;
  }
  function deleteProperty(_target, key) {
    delete real[key];
    delete lookup[key];
    return true;
  }
  function getProperty(_target, key) {
    return real[key];
  }
  function getPropertyWin32(_target, key) {
    if (typeof key === 'string') {
      return lookup[key in proto ? key : key.toLowerCase()];
    } else {
      return real[key];
    }
  }
  const proxy = new Proxy(real, {
    deleteProperty: isWin32 ? deletePropertyWin32 : deleteProperty,
    get: isWin32 ? getPropertyWin32 : getProperty,
    set(_target, key, value) {
      const strValue = `${value}`;
      if (typeof key === 'string') {
        lookup[key.toLowerCase()] = strValue;
      }
      real[key] = strValue;
      return true;
    }
  });
  return Object.assign(proxy, process.env);
}
function createProcessObject() {
  const process = require('process');
  const newProcess = (0, _deepCyclicCopy.default)(process, {
    blacklist: BLACKLIST,
    keepPrototype: true
  });
  try {
    // This fails on Node 12, but it's already set to 'process'
    newProcess[Symbol.toStringTag] = 'process';
  } catch (error) {
    // Make sure it's actually set instead of potentially ignoring errors
    if (newProcess[Symbol.toStringTag] !== 'process') {
      error.message = `Unable to set toStringTag on process. Please open up an issue at https://github.com/jestjs/jest\n\n${error.message}`;
      throw error;
    }
  }

  // Sequentially execute all constructors over the object.
  let proto = process;
  while (proto = Object.getPrototypeOf(proto)) {
    if (typeof proto.constructor === 'function') {
      proto.constructor.call(newProcess);
    }
  }
  newProcess.env = createProcessEnv();
  newProcess.send = () => true;
  Object.defineProperty(newProcess, 'domain', {
    get() {
      return process.domain;
    }
  });
  return newProcess;
}

/***/ }),

/***/ "./src/deepCyclicCopy.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = deepCyclicCopy;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const EMPTY = new Set();
function deepCyclicCopy(value, options, cycles = new WeakMap()) {
  options = {
    blacklist: EMPTY,
    keepPrototype: false,
    ...options
  };
  if (typeof value !== 'object' || value === null || Buffer.isBuffer(value)) {
    return value;
  } else if (cycles.has(value)) {
    return cycles.get(value);
  } else if (Array.isArray(value)) {
    return deepCyclicCopyArray(value, options, cycles);
  } else {
    return deepCyclicCopyObject(value, options, cycles);
  }
}
function deepCyclicCopyObject(object, options, cycles) {
  const newObject = options.keepPrototype ? Object.create(Object.getPrototypeOf(object)) : {};
  const descriptors = Object.getOwnPropertyDescriptors(object);
  cycles.set(object, newObject);
  for (const key of Object.keys(descriptors)) {
    if (options.blacklist && options.blacklist.has(key)) {
      delete descriptors[key];
      continue;
    }
    const descriptor = descriptors[key];
    if (descriptor.value !== undefined) {
      descriptor.value = deepCyclicCopy(descriptor.value, {
        blacklist: EMPTY,
        keepPrototype: options.keepPrototype
      }, cycles);
    }
    descriptor.configurable = true;
  }
  return Object.defineProperties(newObject, descriptors);
}
function deepCyclicCopyArray(array, options, cycles) {
  const newArray = options.keepPrototype ? new (Object.getPrototypeOf(array).constructor)(array.length) : [];
  const length = array.length;
  cycles.set(array, newArray);
  for (let i = 0; i < length; i++) {
    newArray[i] = deepCyclicCopy(array[i], {
      blacklist: EMPTY,
      keepPrototype: options.keepPrototype
    }, cycles);
  }
  return newArray;
}

/***/ }),

/***/ "./src/formatTime.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatTime;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function formatTime(time, prefixPower = -3, padLeftLength = 0) {
  const prefixes = ['n', '', 'm', ''];
  const prefixIndex = Math.max(0, Math.min(Math.trunc(prefixPower / 3) + prefixes.length - 1, prefixes.length - 1));
  return `${String(time).padStart(padLeftLength)} ${prefixes[prefixIndex]}s`;
}

/***/ }),

/***/ "./src/garbage-collection-utils.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.canDeleteProperties = canDeleteProperties;
exports.deleteProperties = deleteProperties;
exports.initializeGarbageCollectionUtils = initializeGarbageCollectionUtils;
exports.protectProperties = protectProperties;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * The symbol that is set on the global object to store the deletion mode.
 */
const DELETION_MODE_SYMBOL = Symbol.for('$$jest-deletion-mode');

/**
 * The symbol that is set on objects to protect them from deletion.
 *
 * If the value is an empty array, then all properties will be protected.
 * If the value is an array of strings or symbols, then only those properties will be protected.
 */
const PROTECT_SYMBOL = Symbol.for('$$jest-protect-from-deletion');

/**
 *  - <b>off</b>: deletion is completely turned off.
 *  - <b>soft</b>: doesn't delete objects, but instead wraps their getter/setter with a deprecation warning.
 *  - <b>on</b>: actually delete objects (using `delete`).
 */

/**
 * Initializes the garbage collection utils with the given deletion mode.
 *
 * @param globalObject the global object on which to store the deletion mode.
 * @param deletionMode the deletion mode to use.
 */
function initializeGarbageCollectionUtils(globalObject, deletionMode) {
  const currentMode = Reflect.get(globalObject, DELETION_MODE_SYMBOL);
  if (currentMode && currentMode !== deletionMode) {
    console.warn(_chalk().default.yellow(['[jest-util] garbage collection deletion mode already initialized, ignoring new mode', `  Current: '${currentMode}'`, `  Given: '${deletionMode}'`].join('\n')));
    return;
  }
  Reflect.set(globalObject, DELETION_MODE_SYMBOL, deletionMode);
}

/**
 * Deletes all the properties from the given value (if it's an object),
 * unless the value was protected via {@link #protectProperties}.
 *
 * @param value the given value.
 */
function deleteProperties(value) {
  if (getDeletionMode() !== 'off' && canDeleteProperties(value)) {
    const protectedKeys = getProtectedKeys(value, Reflect.get(value, PROTECT_SYMBOL));
    for (const key of Reflect.ownKeys(value)) {
      if (!protectedKeys.includes(key) && key !== PROTECT_SYMBOL) {
        deleteProperty(value, key);
      }
    }
  }
}

/**
 * Protects the given value from being deleted by {@link #deleteProperties}.
 *
 * @param value The given value.
 * @param properties If the array contains any property,
 * then only these properties will be protected; otherwise if the array is empty,
 * all properties will be protected.
 * @param depth Determines how "deep" the protection should be.
 * A value of 0 means that only the top-most properties will be protected,
 * while a value larger than 0 means that deeper levels of nesting will be protected as well.
 */
function protectProperties(value, properties = [], depth = 2) {
  if (getDeletionMode() === 'off') {
    return false;
  }

  // Reflect.get may cause deprecation warnings, so we disable them temporarily
  const originalEmitWarning = process.emitWarning;
  try {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    process.emitWarning = () => {};
    if (depth >= 0 && canDeleteProperties(value) && !Reflect.has(value, PROTECT_SYMBOL)) {
      const result = Reflect.defineProperty(value, PROTECT_SYMBOL, {
        configurable: true,
        enumerable: false,
        value: properties,
        writable: true
      });
      for (const key of getProtectedKeys(value, properties)) {
        try {
          const nested = Reflect.get(value, key);
          protectProperties(nested, [], depth - 1);
        } catch {
          // Reflect.get might fail in certain edge-cases
          // Instead of failing the entire process, we will skip the property.
        }
      }
      return result;
    }
    return false;
  } finally {
    process.emitWarning = originalEmitWarning;
  }
}

/**
 * Whether the given value has properties that can be deleted (regardless of protection).
 *
 * @param value The given value.
 */
function canDeleteProperties(value) {
  if (value !== null) {
    const type = typeof value;
    return type === 'object' || type === 'function';
  }
  return false;
}

/**
 * Deletes the property of the given key from the given object.
 *
 * @param obj the given object.
 * @param key the given key.
 * @param mode there are two possible modes of deletion:
 *  - <b>soft</b>: doesn't delete the object, but instead wraps its getter/setter with a deprecation warning.
 *  - <b>hard</b>: actually deletes the object (`delete`).
 *
 * @returns whether the deletion was successful or not.
 */
function deleteProperty(obj, key) {
  const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
  if (!descriptor?.configurable) {
    return false;
  }
  if (getDeletionMode() === 'on') {
    return Reflect.deleteProperty(obj, key);
  }
  const originalGetter = descriptor.get ?? (() => descriptor.value);
  const originalSetter = descriptor.set ?? (value => Reflect.set(obj, key, value));
  return Reflect.defineProperty(obj, key, {
    configurable: true,
    enumerable: descriptor.enumerable,
    get() {
      emitAccessWarning(obj, key);
      return originalGetter();
    },
    set(value) {
      emitAccessWarning(obj, key);
      return originalSetter(value);
    }
  });
}
function getDeletionMode() {
  return Reflect.get(globalThis, DELETION_MODE_SYMBOL) ?? 'off';
}
const warningCache = new WeakSet();
function emitAccessWarning(obj, key) {
  if (warningCache.has(obj)) {
    return;
  }
  const objName = obj?.constructor?.name ?? 'unknown';
  const propertyName = typeof key === 'symbol' ? key.description : key;
  process.emitWarning(`'${propertyName}' property was accessed on [${objName}] after it was soft deleted`, {
    code: 'JEST-01',
    detail: ['Jest deletes objects that were set on the global scope between test files to reduce memory leaks.', 'Currently it only "soft" deletes them and emits this warning if those objects were accessed after their deletion.', 'In future versions of Jest, this behavior will change to "on", which will likely fail tests.', 'You can change the behavior in your test configuration now to reduce memory usage.'].map(s => `  ${s}`).join('\n'),
    type: 'DeprecationWarning'
  });
  warningCache.add(obj);
}
function getProtectedKeys(value, properties) {
  if (properties === undefined) {
    return [];
  }
  const protectedKeys = properties.length > 0 ? properties : Reflect.ownKeys(value);
  return protectedKeys.filter(key => PROTECT_SYMBOL !== key);
}

/***/ }),

/***/ "./src/globsToMatcher.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = globsToMatcher;
function _picomatch() {
  const data = _interopRequireDefault(require("picomatch"));
  _picomatch = function () {
    return data;
  };
  return data;
}
var _replacePathSepForGlob = _interopRequireDefault(__webpack_require__("./src/replacePathSepForGlob.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const globsToMatchersMap = new Map();
const picomatchOptions = {
  dot: true
};

/**
 * Converts a list of globs into a function that matches a path against the
 * globs.
 *
 * Every time picomatch is called, it will parse the glob strings and turn
 * them into regexp instances. Instead of calling picomatch repeatedly with
 * the same globs, we can use this function which will build the picomatch
 * matchers ahead of time and then have an optimized path for determining
 * whether an individual path matches.
 *
 * This function is intended to match the behavior of `micromatch()`.
 *
 * @example
 * const isMatch = globsToMatcher(['*.js', '!*.test.js']);
 * isMatch('pizza.js'); // true
 * isMatch('pizza.test.js'); // false
 */
function globsToMatcher(globs) {
  if (globs.length === 0) {
    // Since there were no globs given, we can simply have a fast path here and
    // return with a very simple function.
    return () => false;
  }
  const matchers = globs.map(glob => {
    if (!globsToMatchersMap.has(glob)) {
      const isMatch = (0, _picomatch().default)(glob, picomatchOptions, true);
      const matcher = {
        isMatch,
        // Matchers that are negated have different behavior than matchers that
        // are not negated, so we need to store this information ahead of time.
        negated: isMatch.state.negated || !!isMatch.state.negatedExtglob
      };
      globsToMatchersMap.set(glob, matcher);
    }
    return globsToMatchersMap.get(glob);
  });
  return path => {
    const replacedPath = (0, _replacePathSepForGlob.default)(path);
    let kept = undefined;
    let negatives = 0;
    for (const matcher of matchers) {
      const {
        isMatch,
        negated
      } = matcher;
      if (negated) {
        negatives++;
      }
      const matched = isMatch(replacedPath);
      if (!matched && negated) {
        // The path was not matched, and the matcher is a negated matcher, so we
        // want to omit the path. This means that the negative matcher is
        // filtering the path out.
        kept = false;
      } else if (matched && !negated) {
        // The path was matched, and the matcher is not a negated matcher, so we
        // want to keep the path.
        kept = true;
      }
    }

    // If all of the globs were negative globs, then we want to include the path
    // as long as it was not explicitly not kept. Otherwise only include
    // the path if it was kept. This allows sets of globs that are all negated
    // to allow some paths to be matched, while sets of globs that are mixed
    // negated and non-negated to cause the negated matchers to only omit paths
    // and not keep them.
    return negatives === matchers.length ? kept !== false : !!kept;
  };
}

/***/ }),

/***/ "./src/installCommonGlobals.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = installCommonGlobals;
function fs() {
  const data = _interopRequireWildcard(require("graceful-fs"));
  fs = function () {
    return data;
  };
  return data;
}
var _createProcessObject = _interopRequireDefault(__webpack_require__("./src/createProcessObject.ts"));
var _deepCyclicCopy = _interopRequireDefault(__webpack_require__("./src/deepCyclicCopy.ts"));
var _garbageCollectionUtils = __webpack_require__("./src/garbage-collection-utils.ts");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const DTRACE = Object.keys(globalThis).filter(key => key.startsWith('DTRACE'));
function installCommonGlobals(globalObject, globals, garbageCollectionDeletionMode) {
  globalObject.process = (0, _createProcessObject.default)();
  const symbol = globalObject.Symbol;
  // Keep a reference to some globals that Jest needs
  Object.defineProperties(globalObject, {
    [symbol.for('jest-native-promise')]: {
      enumerable: false,
      value: Promise,
      writable: false
    },
    [symbol.for('jest-native-now')]: {
      enumerable: false,
      value: globalObject.Date.now.bind(globalObject.Date),
      writable: false
    },
    [symbol.for('jest-native-read-file')]: {
      enumerable: false,
      value: fs().readFileSync.bind(fs()),
      writable: false
    },
    [symbol.for('jest-native-write-file')]: {
      enumerable: false,
      value: fs().writeFileSync.bind(fs()),
      writable: false
    },
    [symbol.for('jest-native-exists-file')]: {
      enumerable: false,
      value: fs().existsSync.bind(fs()),
      writable: false
    },
    'jest-symbol-do-not-touch': {
      enumerable: false,
      value: symbol,
      writable: false
    }
  });

  // Forward some APIs.
  for (const dtrace of DTRACE) {
    // @ts-expect-error: no index
    globalObject[dtrace] = function (...args) {
      // @ts-expect-error: no index
      return globalThis[dtrace].apply(this, args);
    };
  }
  if (garbageCollectionDeletionMode) {
    (0, _garbageCollectionUtils.initializeGarbageCollectionUtils)(globalObject, garbageCollectionDeletionMode);
  }
  return Object.assign(globalObject, (0, _deepCyclicCopy.default)(globals));
}

/***/ }),

/***/ "./src/interopRequireDefault.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = interopRequireDefault;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// copied from https://github.com/babel/babel/blob/56044c7851d583d498f919e9546caddf8f80a72f/packages/babel-helpers/src/helpers.js#L558-L562
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./src/invariant.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = invariant;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function invariant(condition, message = '') {
  if (!condition) {
    throw new Error(message);
  }
}

/***/ }),

/***/ "./src/isInteractive.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _ciInfo() {
  const data = require("ci-info");
  _ciInfo = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function checkIsInteractive() {
  if (_ciInfo().isCI) {
    return false;
  }

  // this can happen in a browser with polyfills: https://github.com/defunctzombie/node-process/issues/41
  if (process.stdout == null) {
    return false;
  }
  if (process.stdout.isTTY) {
    return process.env.TERM !== 'dumb';
  }
  return false;
}
const isInteractive = checkIsInteractive();
var _default = exports["default"] = isInteractive;

/***/ }),

/***/ "./src/isNonNullable.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isNonNullable;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function isNonNullable(value) {
  return value != null;
}

/***/ }),

/***/ "./src/isPromise.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isPromise;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function isPromise(candidate) {
  return candidate != null && (typeof candidate === 'object' || typeof candidate === 'function') && typeof candidate.then === 'function';
}

/***/ }),

/***/ "./src/pluralize.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = pluralize;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function pluralize(word, count, ending = 's') {
  return `${count} ${word}${count === 1 ? '' : ending}`;
}

/***/ }),

/***/ "./src/preRunMessage.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.print = print;
exports.remove = remove;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
var _clearLine = _interopRequireDefault(__webpack_require__("./src/clearLine.ts"));
var _isInteractive = _interopRequireDefault(__webpack_require__("./src/isInteractive.ts"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function print(stream) {
  if (_isInteractive.default) {
    stream.write(_chalk().default.bold.dim('Determining test suites to run...'));
  }
}
function remove(stream) {
  if (_isInteractive.default) {
    (0, _clearLine.default)(stream);
  }
}

/***/ }),

/***/ "./src/replacePathSepForGlob.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = replacePathSepForGlob;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function replacePathSepForGlob(path) {
  return path.replaceAll(/\\(?![$()+.?^{}])/g, '/');
}

/***/ }),

/***/ "./src/requireOrImportModule.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = requireOrImportModule;
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _url() {
  const data = require("url");
  _url = function () {
    return data;
  };
  return data;
}
var _interopRequireDefault = _interopRequireDefault2(__webpack_require__("./src/interopRequireDefault.ts"));
function _interopRequireDefault2(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

async function importModule(filePath, applyInteropRequireDefault) {
  try {
    const moduleUrl = (0, _url().pathToFileURL)(filePath);

    // node `import()` supports URL, but TypeScript doesn't know that
    const importedModule = await import(/* webpackIgnore: true */moduleUrl.href);
    if (!applyInteropRequireDefault) {
      return importedModule;
    }
    if (!importedModule.default) {
      throw new Error(`Jest: Failed to load ESM at ${filePath} - did you use a default export?`);
    }
    return importedModule.default;
  } catch (error) {
    if (error.message === 'Not supported') {
      throw new Error(`Jest: Your version of Node does not support dynamic import - please enable it or use a .cjs file extension for file ${filePath}`);
    }
    throw error;
  }
}
async function requireOrImportModule(filePath, applyInteropRequireDefault = true) {
  if (!(0, _path().isAbsolute)(filePath) && filePath[0] === '.') {
    throw new Error(`Jest: requireOrImportModule path must be absolute, was "${filePath}"`);
  }
  try {
    if (filePath.endsWith('.mjs')) {
      return importModule(filePath, applyInteropRequireDefault);
    }
    const requiredModule = require(filePath);
    if (!applyInteropRequireDefault) {
      return requiredModule;
    }
    return (0, _interopRequireDefault.default)(requiredModule).default;
  } catch (error) {
    if (error.code === 'ERR_REQUIRE_ESM' || error.code === 'ERR_REQUIRE_ASYNC_MODULE') {
      return importModule(filePath, applyInteropRequireDefault);
    } else {
      throw error;
    }
  }
}

/***/ }),

/***/ "./src/setGlobal.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setGlobal;
var _garbageCollectionUtils = __webpack_require__("./src/garbage-collection-utils.ts");
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function setGlobal(globalToMutate, key, value, afterTeardown = 'clean') {
  Reflect.set(globalToMutate, key, value);
  if (afterTeardown === 'retain' && (0, _garbageCollectionUtils.canDeleteProperties)(value)) {
    (0, _garbageCollectionUtils.protectProperties)(value);
  }
}

/***/ }),

/***/ "./src/specialChars.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ICONS = exports.CLEAR = exports.ARROW = void 0;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const isWindows = process.platform === 'win32';
const ARROW = exports.ARROW = ' \u203A ';
const ICONS = exports.ICONS = {
  failed: isWindows ? '\u00D7' : '\u2715',
  pending: '\u25CB',
  success: isWindows ? '\u221A' : '\u2713',
  todo: '\u270E'
};
const CLEAR = exports.CLEAR = isWindows ? '\u001B[2J\u001B[0f' : '\u001B[2J\u001B[3J\u001B[H';

/***/ }),

/***/ "./src/tryRealpath.ts":
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = tryRealpath;
function _gracefulFs() {
  const data = require("graceful-fs");
  _gracefulFs = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function tryRealpath(path) {
  try {
    path = _gracefulFs().realpathSync.native(path);
  } catch (error) {
    if (error.code !== 'ENOENT' && error.code !== 'EISDIR') {
      throw error;
    }
  }
  return path;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ErrorWithStack", ({
  enumerable: true,
  get: function () {
    return _ErrorWithStack.default;
  }
}));
Object.defineProperty(exports, "canDeleteProperties", ({
  enumerable: true,
  get: function () {
    return _garbageCollectionUtils.canDeleteProperties;
  }
}));
Object.defineProperty(exports, "clearLine", ({
  enumerable: true,
  get: function () {
    return _clearLine.default;
  }
}));
Object.defineProperty(exports, "convertDescriptorToString", ({
  enumerable: true,
  get: function () {
    return _convertDescriptorToString.default;
  }
}));
Object.defineProperty(exports, "createDirectory", ({
  enumerable: true,
  get: function () {
    return _createDirectory.default;
  }
}));
Object.defineProperty(exports, "deepCyclicCopy", ({
  enumerable: true,
  get: function () {
    return _deepCyclicCopy.default;
  }
}));
Object.defineProperty(exports, "deleteProperties", ({
  enumerable: true,
  get: function () {
    return _garbageCollectionUtils.deleteProperties;
  }
}));
Object.defineProperty(exports, "formatTime", ({
  enumerable: true,
  get: function () {
    return _formatTime.default;
  }
}));
Object.defineProperty(exports, "globsToMatcher", ({
  enumerable: true,
  get: function () {
    return _globsToMatcher.default;
  }
}));
Object.defineProperty(exports, "initializeGarbageCollectionUtils", ({
  enumerable: true,
  get: function () {
    return _garbageCollectionUtils.initializeGarbageCollectionUtils;
  }
}));
Object.defineProperty(exports, "installCommonGlobals", ({
  enumerable: true,
  get: function () {
    return _installCommonGlobals.default;
  }
}));
Object.defineProperty(exports, "interopRequireDefault", ({
  enumerable: true,
  get: function () {
    return _interopRequireDefault.default;
  }
}));
Object.defineProperty(exports, "invariant", ({
  enumerable: true,
  get: function () {
    return _invariant.default;
  }
}));
Object.defineProperty(exports, "isInteractive", ({
  enumerable: true,
  get: function () {
    return _isInteractive.default;
  }
}));
Object.defineProperty(exports, "isNonNullable", ({
  enumerable: true,
  get: function () {
    return _isNonNullable.default;
  }
}));
Object.defineProperty(exports, "isPromise", ({
  enumerable: true,
  get: function () {
    return _isPromise.default;
  }
}));
Object.defineProperty(exports, "pluralize", ({
  enumerable: true,
  get: function () {
    return _pluralize.default;
  }
}));
exports.preRunMessage = void 0;
Object.defineProperty(exports, "protectProperties", ({
  enumerable: true,
  get: function () {
    return _garbageCollectionUtils.protectProperties;
  }
}));
Object.defineProperty(exports, "replacePathSepForGlob", ({
  enumerable: true,
  get: function () {
    return _replacePathSepForGlob.default;
  }
}));
Object.defineProperty(exports, "requireOrImportModule", ({
  enumerable: true,
  get: function () {
    return _requireOrImportModule.default;
  }
}));
Object.defineProperty(exports, "setGlobal", ({
  enumerable: true,
  get: function () {
    return _setGlobal.default;
  }
}));
exports.specialChars = void 0;
Object.defineProperty(exports, "tryRealpath", ({
  enumerable: true,
  get: function () {
    return _tryRealpath.default;
  }
}));
var preRunMessage = _interopRequireWildcard(__webpack_require__("./src/preRunMessage.ts"));
exports.preRunMessage = preRunMessage;
var specialChars = _interopRequireWildcard(__webpack_require__("./src/specialChars.ts"));
exports.specialChars = specialChars;
var _clearLine = _interopRequireDefault2(__webpack_require__("./src/clearLine.ts"));
var _createDirectory = _interopRequireDefault2(__webpack_require__("./src/createDirectory.ts"));
var _ErrorWithStack = _interopRequireDefault2(__webpack_require__("./src/ErrorWithStack.ts"));
var _installCommonGlobals = _interopRequireDefault2(__webpack_require__("./src/installCommonGlobals.ts"));
var _interopRequireDefault = _interopRequireDefault2(__webpack_require__("./src/interopRequireDefault.ts"));
var _isInteractive = _interopRequireDefault2(__webpack_require__("./src/isInteractive.ts"));
var _isPromise = _interopRequireDefault2(__webpack_require__("./src/isPromise.ts"));
var _setGlobal = _interopRequireDefault2(__webpack_require__("./src/setGlobal.ts"));
var _deepCyclicCopy = _interopRequireDefault2(__webpack_require__("./src/deepCyclicCopy.ts"));
var _convertDescriptorToString = _interopRequireDefault2(__webpack_require__("./src/convertDescriptorToString.ts"));
var _replacePathSepForGlob = _interopRequireDefault2(__webpack_require__("./src/replacePathSepForGlob.ts"));
var _globsToMatcher = _interopRequireDefault2(__webpack_require__("./src/globsToMatcher.ts"));
var _pluralize = _interopRequireDefault2(__webpack_require__("./src/pluralize.ts"));
var _formatTime = _interopRequireDefault2(__webpack_require__("./src/formatTime.ts"));
var _tryRealpath = _interopRequireDefault2(__webpack_require__("./src/tryRealpath.ts"));
var _requireOrImportModule = _interopRequireDefault2(__webpack_require__("./src/requireOrImportModule.ts"));
var _invariant = _interopRequireDefault2(__webpack_require__("./src/invariant.ts"));
var _isNonNullable = _interopRequireDefault2(__webpack_require__("./src/isNonNullable.ts"));
var _garbageCollectionUtils = __webpack_require__("./src/garbage-collection-utils.ts");
function _interopRequireDefault2(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
})();

module.exports = __webpack_exports__;
/******/ })()
;

---

File name: node_modules\babel-jest\node_modules\jest-util\package.json

Code:
{
  "name": "jest-util",
  "version": "30.0.2",
  "repository": {
    "type": "git",
    "url": "https://github.com/jestjs/jest.git",
    "directory": "packages/jest-util"
  },
  "license": "MIT",
  "main": "./build/index.js",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "require": "./build/index.js",
      "import": "./build/index.mjs",
      "default": "./build/index.js"
    },
    "./package.json": "./package.json"
  },
  "dependencies": {
    "@jest/types": "30.0.1",
    "@types/node": "*",
    "chalk": "^4.1.2",
    "ci-info": "^4.2.0",
    "graceful-fs": "^4.2.11",
    "picomatch": "^4.0.2"
  },
  "devDependencies": {
    "@types/graceful-fs": "^4.1.9",
    "@types/picomatch": "^4.0.0",
    "lodash": "^4.17.19"
  },
  "engines": {
    "node": "^18.14.0 || ^20.0.0 || ^22.0.0 || >=24.0.0"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "393acbfac31f64bb38dff23c89224797caded83c"
}


---

File name: node_modules\babel-jest\node_modules\jest-util\Readme.md

Code:
# `@jest/utils`

This packages is a collection of utilities and helper functions

## `ErrorWithStack`

This custom error class can be useful when you need to capture the stack trace of an error and provide additional context to the error message. By default, JavaScript errors only capture the stack trace when they are thrown, but this class allows you to capture the stack trace at any point in your code by calling its constructor.

## `clearLine`

It ensures that the clearing operation is only performed when running in a terminal environment, and not when the output is redirected to a file or another non-terminal destination.

## `convertDescriptorToString`

It defines a function named `convertDescriptorToString` that takes a descriptor as input and converts it to a string based on its type. It handles various types such as functions, numbers, strings, and undefined values. If the input doesn't match any of these types, it throws an error with a descriptive message.

## `createDirectory`

It creates new directory and also allows creation of nested directories.

## `deepCyclicCopy`

The `deepCyclicCopy` function provides deep copying of JavaScript objects and arrays, including handling circular references. It offers optional customization through a `DeepCyclicCopyOptions` parameter, allowing users to blacklist properties and preserve object prototypes. The function returns a completely independent deep copy of the input data structure.

## `formatTime`

This function is useful for formatting time values with appropriate SI unit prefixes for readability. It expresses time in various units (e.g., milliseconds, microseconds, nanoseconds) while ensuring the formatting is consistent and human-readable.

## `globsToMatcher`

The code efficiently converts a list of glob patterns into a reusable function for matching paths against those patterns, considering negated patterns and optimizing for performance.

## `installCommonGlobals`

Sets up various global variables and functions needed by the Jest testing framework. It ensures that these globals are properly set up for testing scenarios while maintaining compatibility with the environment's global object.

## `interopRequireDefault`

Provides a way to ensure compatibility between ES modules and CommonJS modules by handling the default export behavior appropriately.

## `invariant`

It is a utility used for asserting that a given condition is true. It's often used as a debugging aid during development to catch situations where an expected condition is not met.

## `isInteractive`

Checks whether the current environment is suitable for interactive terminal interactions.

## `isNonNullable`

Used to narrow down the type of a variable within a TypeScript code block, ensuring that it is safe to assume that the value is non-nullable. This can help avoid runtime errors related to null or undefined values.

## `isPromise`

It helps in order to determine whether a given value conforms to the structure of a Promise-like object, which typically has a `then` method. This can be useful when working with asynchronous code to ensure dealing with promises correctly.

## `pluralize`

This function is used to easily generate grammatically correct phrases in text output that depend on the count of items. It ensures that the word is correctly pluralized when needed.

## `preRunMessage`

These functions are intended for use in interactive command-line tools or scripts which provide informative messages to the user while ensuring a clean and responsive interface.

## `replacePathSepForGlob`

The function takes a string `path` as input and replaces backslashes ('\\') with forward slashes ('/') in the path. Used to normalize file paths to be compatible with glob patterns, ensuring consistency in path representation for different operating systems.

## `requireOrImportModule`

This function provides a unified way to load modules regardless of whether they use CommonJS or ESM syntax. It ensures that the default export is applied consistently when needed, allowing users to work with modules that might use different module systems.

## `setGlobal`

Used to set properties with specified values within a global object. It is designed to work in both browser-like and Node.js environments by accepting different types of global objects as input.

## `specialChars`

It defines constants and conditional values for handling platform-specific behaviors in a terminal environment. It determines if the current platform is Windows ('win32') and sets up constants for various symbols and terminal screen clearing escape sequences accordingly, ensuring proper display and behavior on both Windows and non-Windows operating systems.

## `TestPathPatterns`

This class takes test patterns and provides the API for deciding if a test matches any of the patterns.

## `tryRealpath`

Used to resolve the real path of a given path, but if the path doesn't exist or is a directory, it doesn't throw an error and returns the original path string. This can be useful for gracefully handling path resolution in scenarios where some paths might not exist or might be directories.


---

File name: node_modules\babel-jest\node_modules\jest-worker\build\index.d.ts

Code:
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {ForkOptions} from 'child_process';
import {ResourceLimits} from 'worker_threads';

declare const CHILD_MESSAGE_CALL = 1;

declare const CHILD_MESSAGE_CALL_SETUP = 4;

declare const CHILD_MESSAGE_END = 2;

declare const CHILD_MESSAGE_INITIALIZE = 0;

declare const CHILD_MESSAGE_MEM_USAGE = 3;

declare type ChildMessage =
  | ChildMessageInitialize
  | ChildMessageCall
  | ChildMessageEnd
  | ChildMessageMemUsage
  | ChildMessageCallSetup;

declare type ChildMessageCall = [
  type: typeof CHILD_MESSAGE_CALL,
  isProcessed: boolean,
  methodName: string,
  args: Array<unknown>,
];

declare type ChildMessageCallSetup = [type: typeof CHILD_MESSAGE_CALL_SETUP];

declare type ChildMessageEnd = [
  type: typeof CHILD_MESSAGE_END,
  isProcessed: boolean,
];

declare type ChildMessageInitialize = [
  type: typeof CHILD_MESSAGE_INITIALIZE,
  isProcessed: boolean,
  fileName: string,
  setupArgs: Array<unknown>,
  workerId: string | undefined,
];

declare type ChildMessageMemUsage = [type: typeof CHILD_MESSAGE_MEM_USAGE];

declare type ComputeTaskPriorityCallback = (
  method: string,
  ...args: Array<unknown>
) => number;

declare type ExcludeReservedKeys<K> = Exclude<K, ReservedKeys>;

/**
 * First-in, First-out task queue that manages a dedicated pool
 * for each worker as well as a shared queue. The FIFO ordering is guaranteed
 * across the worker specific and shared queue.
 */
export declare class FifoQueue implements TaskQueue {
  private _workerQueues;
  private readonly _sharedQueue;
  enqueue(task: QueueChildMessage, workerId?: number): void;
  dequeue(workerId: number): QueueChildMessage | null;
}

declare type FunctionLike = (...args: any) => unknown;

declare type HeapItem = {
  priority: number;
};

export declare type JestWorkerFarm<T extends Record<string, unknown>> =
  Worker_2 & WorkerModule<T>;

export declare function messageParent(
  message: unknown,
  parentProcess?: NodeJS.Process,
): void;

declare type MethodLikeKeys<T> = {
  [K in keyof T]: T[K] extends FunctionLike ? K : never;
}[keyof T];

declare class MinHeap<TItem extends HeapItem> {
  private readonly _heap;
  peek(): TItem | null;
  add(item: TItem): void;
  poll(): TItem | null;
}

declare type OnCustomMessage = (message: Array<unknown> | unknown) => void;

declare type OnEnd = (err: Error | null, result: unknown) => void;

declare type OnStart = (worker: WorkerInterface) => void;

declare type OnStateChangeHandler = (
  state: WorkerStates,
  oldState: WorkerStates,
) => void;

declare type PoolExitResult = {
  forceExited: boolean;
};

/**
 * Priority queue that processes tasks in natural ordering (lower priority first)
 * according to the priority computed by the function passed in the constructor.
 *
 * FIFO ordering isn't guaranteed for tasks with the same priority.
 *
 * Worker specific tasks with the same priority as a non-worker specific task
 * are always processed first.
 */
export declare class PriorityQueue implements TaskQueue {
  private readonly _computePriority;
  private _queue;
  private readonly _sharedQueue;
  constructor(_computePriority: ComputeTaskPriorityCallback);
  enqueue(task: QueueChildMessage, workerId?: number): void;
  _enqueue(task: QueueChildMessage, queue: MinHeap<QueueItem>): void;
  dequeue(workerId: number): QueueChildMessage | null;
  _getWorkerQueue(workerId: number): MinHeap<QueueItem>;
}

export declare interface PromiseWithCustomMessage<T> extends Promise<T> {
  UNSTABLE_onCustomMessage?: (listener: OnCustomMessage) => () => void;
}

declare type Promisify<T extends FunctionLike> =
  ReturnType<T> extends Promise<infer R>
    ? (...args: Parameters<T>) => Promise<R>
    : (...args: Parameters<T>) => Promise<ReturnType<T>>;

declare type QueueChildMessage = {
  request: ChildMessageCall;
  onStart: OnStart;
  onEnd: OnEnd;
  onCustomMessage: OnCustomMessage;
};

declare type QueueItem = {
  task: QueueChildMessage;
  priority: number;
};

declare type ReservedKeys =
  | 'end'
  | 'getStderr'
  | 'getStdout'
  | 'setup'
  | 'teardown';

export declare interface TaskQueue {
  /**
   * Enqueues the task in the queue for the specified worker or adds it to the
   * queue shared by all workers
   * @param task the task to queue
   * @param workerId the id of the worker that should process this task or undefined
   * if there's no preference.
   */
  enqueue(task: QueueChildMessage, workerId?: number): void;
  /**
   * Dequeues the next item from the queue for the specified worker
   * @param workerId the id of the worker for which the next task should be retrieved
   */
  dequeue(workerId: number): QueueChildMessage | null;
}

/**
 * The Jest farm (publicly called "Worker") is a class that allows you to queue
 * methods across multiple child processes, in order to parallelize work. This
 * is done by providing an absolute path to a module that will be loaded on each
 * of the child processes, and bridged to the main process.
 *
 * Bridged methods are specified by using the "exposedMethods" property of the
 * "options" object. This is an array of strings, where each of them corresponds
 * to the exported name in the loaded module.
 *
 * You can also control the amount of workers by using the "numWorkers" property
 * of the "options" object, and the settings passed to fork the process through
 * the "forkOptions" property. The amount of workers defaults to the amount of
 * CPUS minus one.
 *
 * Queueing calls can be done in two ways:
 *   - Standard method: calls will be redirected to the first available worker,
 *     so they will get executed as soon as they can.
 *
 *   - Sticky method: if a "computeWorkerKey" method is provided within the
 *     config, the resulting string of this method will be used as a key.
 *     Every time this key is returned, it is guaranteed that your job will be
 *     processed by the same worker. This is specially useful if your workers
 *     are caching results.
 */
declare class Worker_2 {
  private _ending;
  private readonly _farm;
  private readonly _options;
  private readonly _workerPool;
  constructor(workerPath: string | URL, options?: WorkerFarmOptions);
  private _bindExposedWorkerMethods;
  private _callFunctionWithArgs;
  getStderr(): NodeJS.ReadableStream;
  getStdout(): NodeJS.ReadableStream;
  start(): Promise<void>;
  end(): Promise<PoolExitResult>;
}
export {Worker_2 as Worker};

declare type WorkerCallback = (
  workerId: number,
  request: ChildMessage,
  onStart: OnStart,
  onEnd: OnEnd,
  onCustomMessage: OnCustomMessage,
) => void;

declare enum WorkerEvents {
  STATE_CHANGE = 'state-change',
}

export declare type WorkerFarmOptions = {
  computeWorkerKey?: (method: string, ...args: Array<unknown>) => string | null;
  enableWorkerThreads?: boolean;
  exposedMethods?: ReadonlyArray<string>;
  forkOptions?: ForkOptions;
  maxRetries?: number;
  numWorkers?: number;
  resourceLimits?: ResourceLimits;
  setupArgs?: Array<unknown>;
  taskQueue?: TaskQueue;
  WorkerPool?: new (
    workerPath: string,
    options?: WorkerPoolOptions,
  ) => WorkerPoolInterface;
  workerSchedulingPolicy?: WorkerSchedulingPolicy;
  idleMemoryLimit?: number;
};

declare interface WorkerInterface {
  get state(): WorkerStates;
  send(
    request: ChildMessage,
    onProcessStart: OnStart,
    onProcessEnd: OnEnd,
    onCustomMessage: OnCustomMessage,
  ): void;
  waitForExit(): Promise<void>;
  forceExit(): void;
  getWorkerId(): number;
  getStderr(): NodeJS.ReadableStream | null;
  getStdout(): NodeJS.ReadableStream | null;
  /**
   * Some system level identifier for the worker. IE, process id, thread id, etc.
   */
  getWorkerSystemId(): number;
  getMemoryUsage(): Promise<number | null>;
  /**
   * Checks to see if the child worker is actually running.
   */
  isWorkerRunning(): boolean;
  /**
   * When the worker child is started and ready to start handling requests.
   *
   * @remarks
   * This mostly exists to help with testing so that you don't check the status
   * of things like isWorkerRunning before it actually is.
   */
  waitForWorkerReady(): Promise<void>;
}

declare type WorkerModule<T> = {
  [K in keyof T as Extract<
    ExcludeReservedKeys<K>,
    MethodLikeKeys<T>
  >]: T[K] extends FunctionLike ? Promisify<T[K]> : never;
};

declare type WorkerOptions_2 = {
  forkOptions: ForkOptions;
  resourceLimits: ResourceLimits;
  setupArgs: Array<unknown>;
  maxRetries: number;
  workerId: number;
  workerData?: unknown;
  workerPath: string;
  /**
   * After a job has executed the memory usage it should return to.
   *
   * @remarks
   * Note this is different from ResourceLimits in that it checks at idle, after
   * a job is complete. So you could have a resource limit of 500MB but an idle
   * limit of 50MB. The latter will only trigger if after a job has completed the
   * memory usage hasn't returned back down under 50MB.
   */
  idleMemoryLimit?: number;
  /**
   * This mainly exists so the path can be changed during testing.
   * https://github.com/jestjs/jest/issues/9543
   */
  childWorkerPath?: string;
  /**
   * This is useful for debugging individual tests allowing you to see
   * the raw output of the worker.
   */
  silent?: boolean;
  /**
   * Used to immediately bind event handlers.
   */
  on?: {
    [WorkerEvents.STATE_CHANGE]:
      | OnStateChangeHandler
      | ReadonlyArray<OnStateChangeHandler>;
  };
};

export declare interface WorkerPoolInterface {
  getStderr(): NodeJS.ReadableStream;
  getStdout(): NodeJS.ReadableStream;
  getWorkers(): Array<WorkerInterface>;
  createWorker(options: WorkerOptions_2): WorkerInterface;
  send: WorkerCallback;
  start(): Promise<void>;
  end(): Promise<PoolExitResult>;
}

export declare type WorkerPoolOptions = {
  setupArgs: Array<unknown>;
  forkOptions: ForkOptions;
  resourceLimits: ResourceLimits;
  maxRetries: number;
  numWorkers: number;
  enableWorkerThreads: boolean;
  idleMemoryLimit?: number;
};

declare type WorkerSchedulingPolicy = 'round-robin' | 'in-order';

declare enum WorkerStates {
  STARTING = 'starting',
  OK = 'ok',
  OUT_OF_MEMORY = 'oom',
  RESTARTING = 'restarting',
  SHUTTING_DOWN = 'shutting-down',
  SHUT_DOWN = 'shut-down',
}

export {};


---

