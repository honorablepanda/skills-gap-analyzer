File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\function\function.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import type { Ensure } from '../helpers/index';
import type { TReadonlyOptional } from '../readonly-optional/index';
import type { TReadonly } from '../readonly/index';
import type { TOptional } from '../optional/index';
import { Kind } from '../symbols/index';
type StaticReturnType<U extends TSchema, P extends unknown[]> = Static<U, P>;
type StaticParameter<T extends TSchema, P extends unknown[]> = T extends TReadonlyOptional<T> ? [Readonly<Static<T, P>>?] : T extends TReadonly<T> ? [Readonly<Static<T, P>>] : T extends TOptional<T> ? [Static<T, P>?] : [
    Static<T, P>
];
type StaticParameters<T extends TSchema[], P extends unknown[], Acc extends unknown[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? StaticParameters<R, P, [...Acc, ...StaticParameter<L, P>]> : Acc);
type StaticFunction<T extends TSchema[], U extends TSchema, P extends unknown[]> = Ensure<(...param: StaticParameters<T, P>) => StaticReturnType<U, P>>;
export interface TFunction<T extends TSchema[] = TSchema[], U extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Function';
    static: StaticFunction<T, U, this['params']>;
    type: 'Function';
    parameters: T;
    returns: U;
}
/** `[JavaScript]` Creates a Function type */
export declare function Function<T extends TSchema[], U extends TSchema>(parameters: [...T], returns: U, options?: SchemaOptions): TFunction<T, U>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\function\function.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = Function;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Function type */
function Function(parameters, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Function', type: 'Function', parameters, returns }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\function\index.d.ts

Code:
export * from './function';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\function\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./function"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\index.d.ts

Code:
export * as KindGuard from './kind';
export * as TypeGuard from './type';
export * as ValueGuard from './value';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueGuard = exports.TypeGuard = exports.KindGuard = void 0;
exports.KindGuard = require("./kind");
exports.TypeGuard = require("./type");
exports.ValueGuard = require("./value");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\kind.d.ts

Code:
import { Kind, Hint, TransformKind } from '../symbols/index';
import { TransformOptions } from '../transform/index';
import type { TAny } from '../any/index';
import type { TArgument } from '../argument/index';
import type { TArray } from '../array/index';
import type { TAsyncIterator } from '../async-iterator/index';
import type { TBoolean } from '../boolean/index';
import type { TComputed } from '../computed/index';
import type { TBigInt } from '../bigint/index';
import type { TConstructor } from '../constructor/index';
import type { TFunction } from '../function/index';
import type { TImport } from '../module/index';
import type { TInteger } from '../integer/index';
import type { TIntersect } from '../intersect/index';
import type { TIterator } from '../iterator/index';
import type { TLiteral, TLiteralValue } from '../literal/index';
import type { TMappedKey, TMappedResult } from '../mapped/index';
import type { TNever } from '../never/index';
import type { TNot } from '../not/index';
import type { TNull } from '../null/index';
import type { TNumber } from '../number/index';
import type { TObject, TProperties } from '../object/index';
import type { TOptional } from '../optional/index';
import type { TPromise } from '../promise/index';
import type { TReadonly } from '../readonly/index';
import type { TRecord } from '../record/index';
import type { TRef } from '../ref/index';
import type { TRegExp } from '../regexp/index';
import type { TSchema } from '../schema/index';
import type { TString } from '../string/index';
import type { TSymbol } from '../symbol/index';
import type { TTemplateLiteral } from '../template-literal/index';
import type { TTuple } from '../tuple/index';
import type { TUint8Array } from '../uint8array/index';
import type { TUndefined } from '../undefined/index';
import type { TUnknown } from '../unknown/index';
import type { TUnion } from '../union/index';
import type { TUnsafe } from '../unsafe/index';
import type { TVoid } from '../void/index';
import type { TDate } from '../date/index';
import type { TThis } from '../recursive/index';
/** `[Kind-Only]` Returns true if this value has a Readonly symbol */
export declare function IsReadonly<T extends TSchema>(value: T): value is TReadonly<T>;
/** `[Kind-Only]` Returns true if this value has a Optional symbol */
export declare function IsOptional<T extends TSchema>(value: T): value is TOptional<T>;
/** `[Kind-Only]` Returns true if the given value is TAny */
export declare function IsAny(value: unknown): value is TAny;
/** `[Kind-Only]` Returns true if the given value is TArgument */
export declare function IsArgument(value: unknown): value is TArgument;
/** `[Kind-Only]` Returns true if the given value is TArray */
export declare function IsArray(value: unknown): value is TArray;
/** `[Kind-Only]` Returns true if the given value is TAsyncIterator */
export declare function IsAsyncIterator(value: unknown): value is TAsyncIterator;
/** `[Kind-Only]` Returns true if the given value is TBigInt */
export declare function IsBigInt(value: unknown): value is TBigInt;
/** `[Kind-Only]` Returns true if the given value is TBoolean */
export declare function IsBoolean(value: unknown): value is TBoolean;
/** `[Kind-Only]` Returns true if the given value is TComputed */
export declare function IsComputed(value: unknown): value is TComputed;
/** `[Kind-Only]` Returns true if the given value is TConstructor */
export declare function IsConstructor(value: unknown): value is TConstructor;
/** `[Kind-Only]` Returns true if the given value is TDate */
export declare function IsDate(value: unknown): value is TDate;
/** `[Kind-Only]` Returns true if the given value is TFunction */
export declare function IsFunction(value: unknown): value is TFunction;
/** `[Kind-Only]` Returns true if the given value is TInteger */
export declare function IsImport(value: unknown): value is TImport;
/** `[Kind-Only]` Returns true if the given value is TInteger */
export declare function IsInteger(value: unknown): value is TInteger;
/** `[Kind-Only]` Returns true if the given schema is TProperties */
export declare function IsProperties(value: unknown): value is TProperties;
/** `[Kind-Only]` Returns true if the given value is TIntersect */
export declare function IsIntersect(value: unknown): value is TIntersect;
/** `[Kind-Only]` Returns true if the given value is TIterator */
export declare function IsIterator(value: unknown): value is TIterator;
/** `[Kind-Only]` Returns true if the given value is a TKind with the given name. */
export declare function IsKindOf<T extends string>(value: unknown, kind: T): value is Record<PropertyKey, unknown> & {
    [Kind]: T;
};
/** `[Kind-Only]` Returns true if the given value is TLiteral<string> */
export declare function IsLiteralString(value: unknown): value is TLiteral<string>;
/** `[Kind-Only]` Returns true if the given value is TLiteral<number> */
export declare function IsLiteralNumber(value: unknown): value is TLiteral<number>;
/** `[Kind-Only]` Returns true if the given value is TLiteral<boolean> */
export declare function IsLiteralBoolean(value: unknown): value is TLiteral<boolean>;
/** `[Kind-Only]` Returns true if the given value is TLiteralValue */
export declare function IsLiteralValue(value: unknown): value is TLiteralValue;
/** `[Kind-Only]` Returns true if the given value is TLiteral */
export declare function IsLiteral(value: unknown): value is TLiteral;
/** `[Kind-Only]` Returns true if the given value is a TMappedKey */
export declare function IsMappedKey(value: unknown): value is TMappedKey;
/** `[Kind-Only]` Returns true if the given value is TMappedResult */
export declare function IsMappedResult(value: unknown): value is TMappedResult;
/** `[Kind-Only]` Returns true if the given value is TNever */
export declare function IsNever(value: unknown): value is TNever;
/** `[Kind-Only]` Returns true if the given value is TNot */
export declare function IsNot(value: unknown): value is TNot;
/** `[Kind-Only]` Returns true if the given value is TNull */
export declare function IsNull(value: unknown): value is TNull;
/** `[Kind-Only]` Returns true if the given value is TNumber */
export declare function IsNumber(value: unknown): value is TNumber;
/** `[Kind-Only]` Returns true if the given value is TObject */
export declare function IsObject(value: unknown): value is TObject;
/** `[Kind-Only]` Returns true if the given value is TPromise */
export declare function IsPromise(value: unknown): value is TPromise;
/** `[Kind-Only]` Returns true if the given value is TRecord */
export declare function IsRecord(value: unknown): value is TRecord;
/** `[Kind-Only]` Returns true if this value is TRecursive */
export declare function IsRecursive(value: unknown): value is {
    [Hint]: 'Recursive';
};
/** `[Kind-Only]` Returns true if the given value is TRef */
export declare function IsRef(value: unknown): value is TRef;
/** `[Kind-Only]` Returns true if the given value is TRegExp */
export declare function IsRegExp(value: unknown): value is TRegExp;
/** `[Kind-Only]` Returns true if the given value is TString */
export declare function IsString(value: unknown): value is TString;
/** `[Kind-Only]` Returns true if the given value is TSymbol */
export declare function IsSymbol(value: unknown): value is TSymbol;
/** `[Kind-Only]` Returns true if the given value is TTemplateLiteral */
export declare function IsTemplateLiteral(value: unknown): value is TTemplateLiteral;
/** `[Kind-Only]` Returns true if the given value is TThis */
export declare function IsThis(value: unknown): value is TThis;
/** `[Kind-Only]` Returns true of this value is TTransform */
export declare function IsTransform(value: unknown): value is {
    [TransformKind]: TransformOptions;
};
/** `[Kind-Only]` Returns true if the given value is TTuple */
export declare function IsTuple(value: unknown): value is TTuple;
/** `[Kind-Only]` Returns true if the given value is TUndefined */
export declare function IsUndefined(value: unknown): value is TUndefined;
/** `[Kind-Only]` Returns true if the given value is TUnion */
export declare function IsUnion(value: unknown): value is TUnion;
/** `[Kind-Only]` Returns true if the given value is TUint8Array */
export declare function IsUint8Array(value: unknown): value is TUint8Array;
/** `[Kind-Only]` Returns true if the given value is TUnknown */
export declare function IsUnknown(value: unknown): value is TUnknown;
/** `[Kind-Only]` Returns true if the given value is a raw TUnsafe */
export declare function IsUnsafe(value: unknown): value is TUnsafe<unknown>;
/** `[Kind-Only]` Returns true if the given value is TVoid */
export declare function IsVoid(value: unknown): value is TVoid;
/** `[Kind-Only]` Returns true if the given value is TKind */
export declare function IsKind(value: unknown): value is Record<PropertyKey, unknown> & {
    [Kind]: string;
};
/** `[Kind-Only]` Returns true if the given value is TSchema */
export declare function IsSchema(value: unknown): value is TSchema;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\kind.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IsReadonly = IsReadonly;
exports.IsOptional = IsOptional;
exports.IsAny = IsAny;
exports.IsArgument = IsArgument;
exports.IsArray = IsArray;
exports.IsAsyncIterator = IsAsyncIterator;
exports.IsBigInt = IsBigInt;
exports.IsBoolean = IsBoolean;
exports.IsComputed = IsComputed;
exports.IsConstructor = IsConstructor;
exports.IsDate = IsDate;
exports.IsFunction = IsFunction;
exports.IsImport = IsImport;
exports.IsInteger = IsInteger;
exports.IsProperties = IsProperties;
exports.IsIntersect = IsIntersect;
exports.IsIterator = IsIterator;
exports.IsKindOf = IsKindOf;
exports.IsLiteralString = IsLiteralString;
exports.IsLiteralNumber = IsLiteralNumber;
exports.IsLiteralBoolean = IsLiteralBoolean;
exports.IsLiteralValue = IsLiteralValue;
exports.IsLiteral = IsLiteral;
exports.IsMappedKey = IsMappedKey;
exports.IsMappedResult = IsMappedResult;
exports.IsNever = IsNever;
exports.IsNot = IsNot;
exports.IsNull = IsNull;
exports.IsNumber = IsNumber;
exports.IsObject = IsObject;
exports.IsPromise = IsPromise;
exports.IsRecord = IsRecord;
exports.IsRecursive = IsRecursive;
exports.IsRef = IsRef;
exports.IsRegExp = IsRegExp;
exports.IsString = IsString;
exports.IsSymbol = IsSymbol;
exports.IsTemplateLiteral = IsTemplateLiteral;
exports.IsThis = IsThis;
exports.IsTransform = IsTransform;
exports.IsTuple = IsTuple;
exports.IsUndefined = IsUndefined;
exports.IsUnion = IsUnion;
exports.IsUint8Array = IsUint8Array;
exports.IsUnknown = IsUnknown;
exports.IsUnsafe = IsUnsafe;
exports.IsVoid = IsVoid;
exports.IsKind = IsKind;
exports.IsSchema = IsSchema;
const ValueGuard = require("./value");
const index_1 = require("../symbols/index");
/** `[Kind-Only]` Returns true if this value has a Readonly symbol */
function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === 'Readonly';
}
/** `[Kind-Only]` Returns true if this value has a Optional symbol */
function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === 'Optional';
}
/** `[Kind-Only]` Returns true if the given value is TAny */
function IsAny(value) {
    return IsKindOf(value, 'Any');
}
/** `[Kind-Only]` Returns true if the given value is TArgument */
function IsArgument(value) {
    return IsKindOf(value, 'Argument');
}
/** `[Kind-Only]` Returns true if the given value is TArray */
function IsArray(value) {
    return IsKindOf(value, 'Array');
}
/** `[Kind-Only]` Returns true if the given value is TAsyncIterator */
function IsAsyncIterator(value) {
    return IsKindOf(value, 'AsyncIterator');
}
/** `[Kind-Only]` Returns true if the given value is TBigInt */
function IsBigInt(value) {
    return IsKindOf(value, 'BigInt');
}
/** `[Kind-Only]` Returns true if the given value is TBoolean */
function IsBoolean(value) {
    return IsKindOf(value, 'Boolean');
}
/** `[Kind-Only]` Returns true if the given value is TComputed */
function IsComputed(value) {
    return IsKindOf(value, 'Computed');
}
/** `[Kind-Only]` Returns true if the given value is TConstructor */
function IsConstructor(value) {
    return IsKindOf(value, 'Constructor');
}
/** `[Kind-Only]` Returns true if the given value is TDate */
function IsDate(value) {
    return IsKindOf(value, 'Date');
}
/** `[Kind-Only]` Returns true if the given value is TFunction */
function IsFunction(value) {
    return IsKindOf(value, 'Function');
}
/** `[Kind-Only]` Returns true if the given value is TInteger */
function IsImport(value) {
    return IsKindOf(value, 'Import');
}
/** `[Kind-Only]` Returns true if the given value is TInteger */
function IsInteger(value) {
    return IsKindOf(value, 'Integer');
}
/** `[Kind-Only]` Returns true if the given schema is TProperties */
function IsProperties(value) {
    return ValueGuard.IsObject(value);
}
/** `[Kind-Only]` Returns true if the given value is TIntersect */
function IsIntersect(value) {
    return IsKindOf(value, 'Intersect');
}
/** `[Kind-Only]` Returns true if the given value is TIterator */
function IsIterator(value) {
    return IsKindOf(value, 'Iterator');
}
/** `[Kind-Only]` Returns true if the given value is a TKind with the given name. */
function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
}
/** `[Kind-Only]` Returns true if the given value is TLiteral<string> */
function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
}
/** `[Kind-Only]` Returns true if the given value is TLiteral<number> */
function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
}
/** `[Kind-Only]` Returns true if the given value is TLiteral<boolean> */
function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
}
/** `[Kind-Only]` Returns true if the given value is TLiteralValue */
function IsLiteralValue(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
}
/** `[Kind-Only]` Returns true if the given value is TLiteral */
function IsLiteral(value) {
    return IsKindOf(value, 'Literal');
}
/** `[Kind-Only]` Returns true if the given value is a TMappedKey */
function IsMappedKey(value) {
    return IsKindOf(value, 'MappedKey');
}
/** `[Kind-Only]` Returns true if the given value is TMappedResult */
function IsMappedResult(value) {
    return IsKindOf(value, 'MappedResult');
}
/** `[Kind-Only]` Returns true if the given value is TNever */
function IsNever(value) {
    return IsKindOf(value, 'Never');
}
/** `[Kind-Only]` Returns true if the given value is TNot */
function IsNot(value) {
    return IsKindOf(value, 'Not');
}
/** `[Kind-Only]` Returns true if the given value is TNull */
function IsNull(value) {
    return IsKindOf(value, 'Null');
}
/** `[Kind-Only]` Returns true if the given value is TNumber */
function IsNumber(value) {
    return IsKindOf(value, 'Number');
}
/** `[Kind-Only]` Returns true if the given value is TObject */
function IsObject(value) {
    return IsKindOf(value, 'Object');
}
/** `[Kind-Only]` Returns true if the given value is TPromise */
function IsPromise(value) {
    return IsKindOf(value, 'Promise');
}
/** `[Kind-Only]` Returns true if the given value is TRecord */
function IsRecord(value) {
    return IsKindOf(value, 'Record');
}
/** `[Kind-Only]` Returns true if this value is TRecursive */
function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === 'Recursive';
}
/** `[Kind-Only]` Returns true if the given value is TRef */
function IsRef(value) {
    return IsKindOf(value, 'Ref');
}
/** `[Kind-Only]` Returns true if the given value is TRegExp */
function IsRegExp(value) {
    return IsKindOf(value, 'RegExp');
}
/** `[Kind-Only]` Returns true if the given value is TString */
function IsString(value) {
    return IsKindOf(value, 'String');
}
/** `[Kind-Only]` Returns true if the given value is TSymbol */
function IsSymbol(value) {
    return IsKindOf(value, 'Symbol');
}
/** `[Kind-Only]` Returns true if the given value is TTemplateLiteral */
function IsTemplateLiteral(value) {
    return IsKindOf(value, 'TemplateLiteral');
}
/** `[Kind-Only]` Returns true if the given value is TThis */
function IsThis(value) {
    return IsKindOf(value, 'This');
}
/** `[Kind-Only]` Returns true of this value is TTransform */
function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
}
/** `[Kind-Only]` Returns true if the given value is TTuple */
function IsTuple(value) {
    return IsKindOf(value, 'Tuple');
}
/** `[Kind-Only]` Returns true if the given value is TUndefined */
function IsUndefined(value) {
    return IsKindOf(value, 'Undefined');
}
/** `[Kind-Only]` Returns true if the given value is TUnion */
function IsUnion(value) {
    return IsKindOf(value, 'Union');
}
/** `[Kind-Only]` Returns true if the given value is TUint8Array */
function IsUint8Array(value) {
    return IsKindOf(value, 'Uint8Array');
}
/** `[Kind-Only]` Returns true if the given value is TUnknown */
function IsUnknown(value) {
    return IsKindOf(value, 'Unknown');
}
/** `[Kind-Only]` Returns true if the given value is a raw TUnsafe */
function IsUnsafe(value) {
    return IsKindOf(value, 'Unsafe');
}
/** `[Kind-Only]` Returns true if the given value is TVoid */
function IsVoid(value) {
    return IsKindOf(value, 'Void');
}
/** `[Kind-Only]` Returns true if the given value is TKind */
function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
}
/** `[Kind-Only]` Returns true if the given value is TSchema */
function IsSchema(value) {
    // prettier-ignore
    return (IsAny(value) ||
        IsArgument(value) ||
        IsArray(value) ||
        IsBoolean(value) ||
        IsBigInt(value) ||
        IsAsyncIterator(value) ||
        IsComputed(value) ||
        IsConstructor(value) ||
        IsDate(value) ||
        IsFunction(value) ||
        IsInteger(value) ||
        IsIntersect(value) ||
        IsIterator(value) ||
        IsLiteral(value) ||
        IsMappedKey(value) ||
        IsMappedResult(value) ||
        IsNever(value) ||
        IsNot(value) ||
        IsNull(value) ||
        IsNumber(value) ||
        IsObject(value) ||
        IsPromise(value) ||
        IsRecord(value) ||
        IsRef(value) ||
        IsRegExp(value) ||
        IsString(value) ||
        IsSymbol(value) ||
        IsTemplateLiteral(value) ||
        IsThis(value) ||
        IsTuple(value) ||
        IsUndefined(value) ||
        IsUnion(value) ||
        IsUint8Array(value) ||
        IsUnknown(value) ||
        IsUnsafe(value) ||
        IsVoid(value) ||
        IsKind(value));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\type.d.ts

Code:
import { Kind, Hint, TransformKind } from '../symbols/index';
import { TypeBoxError } from '../error/index';
import { TransformOptions } from '../transform/index';
import type { TAny } from '../any/index';
import type { TArgument } from '../argument/index';
import type { TArray } from '../array/index';
import type { TAsyncIterator } from '../async-iterator/index';
import type { TBoolean } from '../boolean/index';
import type { TComputed } from '../computed/index';
import type { TBigInt } from '../bigint/index';
import type { TConstructor } from '../constructor/index';
import type { TFunction } from '../function/index';
import type { TImport } from '../module/index';
import type { TInteger } from '../integer/index';
import type { TIntersect } from '../intersect/index';
import type { TIterator } from '../iterator/index';
import type { TLiteral, TLiteralValue } from '../literal/index';
import type { TMappedKey, TMappedResult } from '../mapped/index';
import type { TNever } from '../never/index';
import type { TNot } from '../not/index';
import type { TNull } from '../null/index';
import type { TNumber } from '../number/index';
import type { TObject, TProperties } from '../object/index';
import type { TOptional } from '../optional/index';
import type { TPromise } from '../promise/index';
import type { TReadonly } from '../readonly/index';
import type { TRecord } from '../record/index';
import type { TRef } from '../ref/index';
import type { TRegExp } from '../regexp/index';
import type { TSchema } from '../schema/index';
import type { TString } from '../string/index';
import type { TSymbol } from '../symbol/index';
import type { TTemplateLiteral } from '../template-literal/index';
import type { TTuple } from '../tuple/index';
import type { TUint8Array } from '../uint8array/index';
import type { TUndefined } from '../undefined/index';
import type { TUnion } from '../union/index';
import type { TUnknown } from '../unknown/index';
import type { TUnsafe } from '../unsafe/index';
import type { TVoid } from '../void/index';
import type { TDate } from '../date/index';
import type { TThis } from '../recursive/index';
export declare class TypeGuardUnknownTypeError extends TypeBoxError {
}
/** Returns true if this value has a Readonly symbol */
export declare function IsReadonly<T extends TSchema>(value: T): value is TReadonly<T>;
/** Returns true if this value has a Optional symbol */
export declare function IsOptional<T extends TSchema>(value: T): value is TOptional<T>;
/** Returns true if the given value is TAny */
export declare function IsAny(value: unknown): value is TAny;
/** Returns true if the given value is TArgument */
export declare function IsArgument(value: unknown): value is TArgument;
/** Returns true if the given value is TArray */
export declare function IsArray(value: unknown): value is TArray;
/** Returns true if the given value is TAsyncIterator */
export declare function IsAsyncIterator(value: unknown): value is TAsyncIterator;
/** Returns true if the given value is TBigInt */
export declare function IsBigInt(value: unknown): value is TBigInt;
/** Returns true if the given value is TBoolean */
export declare function IsBoolean(value: unknown): value is TBoolean;
/** Returns true if the given value is TComputed */
export declare function IsComputed(value: unknown): value is TComputed;
/** Returns true if the given value is TConstructor */
export declare function IsConstructor(value: unknown): value is TConstructor;
/** Returns true if the given value is TDate */
export declare function IsDate(value: unknown): value is TDate;
/** Returns true if the given value is TFunction */
export declare function IsFunction(value: unknown): value is TFunction;
/** Returns true if the given value is TImport */
export declare function IsImport(value: unknown): value is TImport;
/** Returns true if the given value is TInteger */
export declare function IsInteger(value: unknown): value is TInteger;
/** Returns true if the given schema is TProperties */
export declare function IsProperties(value: unknown): value is TProperties;
/** Returns true if the given value is TIntersect */
export declare function IsIntersect(value: unknown): value is TIntersect;
/** Returns true if the given value is TIterator */
export declare function IsIterator(value: unknown): value is TIterator;
/** Returns true if the given value is a TKind with the given name. */
export declare function IsKindOf<T extends string>(value: unknown, kind: T): value is Record<PropertyKey, unknown> & {
    [Kind]: T;
};
/** Returns true if the given value is TLiteral<string> */
export declare function IsLiteralString(value: unknown): value is TLiteral<string>;
/** Returns true if the given value is TLiteral<number> */
export declare function IsLiteralNumber(value: unknown): value is TLiteral<number>;
/** Returns true if the given value is TLiteral<boolean> */
export declare function IsLiteralBoolean(value: unknown): value is TLiteral<boolean>;
/** Returns true if the given value is TLiteral */
export declare function IsLiteral(value: unknown): value is TLiteral;
/** Returns true if the given value is a TLiteralValue */
export declare function IsLiteralValue(value: unknown): value is TLiteralValue;
/** Returns true if the given value is a TMappedKey */
export declare function IsMappedKey(value: unknown): value is TMappedKey;
/** Returns true if the given value is TMappedResult */
export declare function IsMappedResult(value: unknown): value is TMappedResult;
/** Returns true if the given value is TNever */
export declare function IsNever(value: unknown): value is TNever;
/** Returns true if the given value is TNot */
export declare function IsNot(value: unknown): value is TNot;
/** Returns true if the given value is TNull */
export declare function IsNull(value: unknown): value is TNull;
/** Returns true if the given value is TNumber */
export declare function IsNumber(value: unknown): value is TNumber;
/** Returns true if the given value is TObject */
export declare function IsObject(value: unknown): value is TObject;
/** Returns true if the given value is TPromise */
export declare function IsPromise(value: unknown): value is TPromise;
/** Returns true if the given value is TRecord */
export declare function IsRecord(value: unknown): value is TRecord;
/** Returns true if this value is TRecursive */
export declare function IsRecursive(value: unknown): value is {
    [Hint]: 'Recursive';
};
/** Returns true if the given value is TRef */
export declare function IsRef(value: unknown): value is TRef;
/** Returns true if the given value is TRegExp */
export declare function IsRegExp(value: unknown): value is TRegExp;
/** Returns true if the given value is TString */
export declare function IsString(value: unknown): value is TString;
/** Returns true if the given value is TSymbol */
export declare function IsSymbol(value: unknown): value is TSymbol;
/** Returns true if the given value is TTemplateLiteral */
export declare function IsTemplateLiteral(value: unknown): value is TTemplateLiteral;
/** Returns true if the given value is TThis */
export declare function IsThis(value: unknown): value is TThis;
/** Returns true of this value is TTransform */
export declare function IsTransform(value: unknown): value is {
    [TransformKind]: TransformOptions;
};
/** Returns true if the given value is TTuple */
export declare function IsTuple(value: unknown): value is TTuple;
/** Returns true if the given value is TUndefined */
export declare function IsUndefined(value: unknown): value is TUndefined;
/** Returns true if the given value is TUnion<Literal<string | number>[]> */
export declare function IsUnionLiteral(value: unknown): value is TUnion<TLiteral[]>;
/** Returns true if the given value is TUnion */
export declare function IsUnion(value: unknown): value is TUnion;
/** Returns true if the given value is TUint8Array */
export declare function IsUint8Array(value: unknown): value is TUint8Array;
/** Returns true if the given value is TUnknown */
export declare function IsUnknown(value: unknown): value is TUnknown;
/** Returns true if the given value is a raw TUnsafe */
export declare function IsUnsafe(value: unknown): value is TUnsafe<unknown>;
/** Returns true if the given value is TVoid */
export declare function IsVoid(value: unknown): value is TVoid;
/** Returns true if the given value is TKind */
export declare function IsKind(value: unknown): value is Record<PropertyKey, unknown> & {
    [Kind]: string;
};
/** Returns true if the given value is TSchema */
export declare function IsSchema(value: unknown): value is TSchema;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGuardUnknownTypeError = void 0;
exports.IsReadonly = IsReadonly;
exports.IsOptional = IsOptional;
exports.IsAny = IsAny;
exports.IsArgument = IsArgument;
exports.IsArray = IsArray;
exports.IsAsyncIterator = IsAsyncIterator;
exports.IsBigInt = IsBigInt;
exports.IsBoolean = IsBoolean;
exports.IsComputed = IsComputed;
exports.IsConstructor = IsConstructor;
exports.IsDate = IsDate;
exports.IsFunction = IsFunction;
exports.IsImport = IsImport;
exports.IsInteger = IsInteger;
exports.IsProperties = IsProperties;
exports.IsIntersect = IsIntersect;
exports.IsIterator = IsIterator;
exports.IsKindOf = IsKindOf;
exports.IsLiteralString = IsLiteralString;
exports.IsLiteralNumber = IsLiteralNumber;
exports.IsLiteralBoolean = IsLiteralBoolean;
exports.IsLiteral = IsLiteral;
exports.IsLiteralValue = IsLiteralValue;
exports.IsMappedKey = IsMappedKey;
exports.IsMappedResult = IsMappedResult;
exports.IsNever = IsNever;
exports.IsNot = IsNot;
exports.IsNull = IsNull;
exports.IsNumber = IsNumber;
exports.IsObject = IsObject;
exports.IsPromise = IsPromise;
exports.IsRecord = IsRecord;
exports.IsRecursive = IsRecursive;
exports.IsRef = IsRef;
exports.IsRegExp = IsRegExp;
exports.IsString = IsString;
exports.IsSymbol = IsSymbol;
exports.IsTemplateLiteral = IsTemplateLiteral;
exports.IsThis = IsThis;
exports.IsTransform = IsTransform;
exports.IsTuple = IsTuple;
exports.IsUndefined = IsUndefined;
exports.IsUnionLiteral = IsUnionLiteral;
exports.IsUnion = IsUnion;
exports.IsUint8Array = IsUint8Array;
exports.IsUnknown = IsUnknown;
exports.IsUnsafe = IsUnsafe;
exports.IsVoid = IsVoid;
exports.IsKind = IsKind;
exports.IsSchema = IsSchema;
const ValueGuard = require("./value");
const index_1 = require("../symbols/index");
const index_2 = require("../error/index");
class TypeGuardUnknownTypeError extends index_2.TypeBoxError {
}
exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
const KnownTypes = [
    'Argument',
    'Any',
    'Array',
    'AsyncIterator',
    'BigInt',
    'Boolean',
    'Computed',
    'Constructor',
    'Date',
    'Enum',
    'Function',
    'Integer',
    'Intersect',
    'Iterator',
    'Literal',
    'MappedKey',
    'MappedResult',
    'Not',
    'Null',
    'Number',
    'Object',
    'Promise',
    'Record',
    'Ref',
    'RegExp',
    'String',
    'Symbol',
    'TemplateLiteral',
    'This',
    'Tuple',
    'Undefined',
    'Union',
    'Uint8Array',
    'Unknown',
    'Void',
];
function IsPattern(value) {
    try {
        new RegExp(value);
        return true;
    }
    catch {
        return false;
    }
}
function IsControlCharacterFree(value) {
    if (!ValueGuard.IsString(value))
        return false;
    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
            return false;
        }
    }
    return true;
}
function IsAdditionalProperties(value) {
    return IsOptionalBoolean(value) || IsSchema(value);
}
function IsOptionalBigInt(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
}
function IsOptionalNumber(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
}
function IsOptionalBoolean(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
}
function IsOptionalString(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
}
function IsOptionalPattern(value) {
    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));
}
function IsOptionalFormat(value) {
    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));
}
function IsOptionalSchema(value) {
    return ValueGuard.IsUndefined(value) || IsSchema(value);
}
// ------------------------------------------------------------------
// Modifiers
// ------------------------------------------------------------------
/** Returns true if this value has a Readonly symbol */
function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === 'Readonly';
}
/** Returns true if this value has a Optional symbol */
function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === 'Optional';
}
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
/** Returns true if the given value is TAny */
function IsAny(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Any') &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TArgument */
function IsArgument(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Argument') &&
        ValueGuard.IsNumber(value.index));
}
/** Returns true if the given value is TArray */
function IsArray(value) {
    return (IsKindOf(value, 'Array') &&
        value.type === 'array' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items) &&
        IsOptionalNumber(value.minItems) &&
        IsOptionalNumber(value.maxItems) &&
        IsOptionalBoolean(value.uniqueItems) &&
        IsOptionalSchema(value.contains) &&
        IsOptionalNumber(value.minContains) &&
        IsOptionalNumber(value.maxContains));
}
/** Returns true if the given value is TAsyncIterator */
function IsAsyncIterator(value) {
    // prettier-ignore
    return (IsKindOf(value, 'AsyncIterator') &&
        value.type === 'AsyncIterator' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items));
}
/** Returns true if the given value is TBigInt */
function IsBigInt(value) {
    // prettier-ignore
    return (IsKindOf(value, 'BigInt') &&
        value.type === 'bigint' &&
        IsOptionalString(value.$id) &&
        IsOptionalBigInt(value.exclusiveMaximum) &&
        IsOptionalBigInt(value.exclusiveMinimum) &&
        IsOptionalBigInt(value.maximum) &&
        IsOptionalBigInt(value.minimum) &&
        IsOptionalBigInt(value.multipleOf));
}
/** Returns true if the given value is TBoolean */
function IsBoolean(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Boolean') &&
        value.type === 'boolean' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TComputed */
function IsComputed(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Computed') &&
        ValueGuard.IsString(value.target) &&
        ValueGuard.IsArray(value.parameters) &&
        value.parameters.every((schema) => IsSchema(schema)));
}
/** Returns true if the given value is TConstructor */
function IsConstructor(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Constructor') &&
        value.type === 'Constructor' &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsArray(value.parameters) &&
        value.parameters.every(schema => IsSchema(schema)) &&
        IsSchema(value.returns));
}
/** Returns true if the given value is TDate */
function IsDate(value) {
    return (IsKindOf(value, 'Date') &&
        value.type === 'Date' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximumTimestamp) &&
        IsOptionalNumber(value.exclusiveMinimumTimestamp) &&
        IsOptionalNumber(value.maximumTimestamp) &&
        IsOptionalNumber(value.minimumTimestamp) &&
        IsOptionalNumber(value.multipleOfTimestamp));
}
/** Returns true if the given value is TFunction */
function IsFunction(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Function') &&
        value.type === 'Function' &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsArray(value.parameters) &&
        value.parameters.every(schema => IsSchema(schema)) &&
        IsSchema(value.returns));
}
/** Returns true if the given value is TImport */
function IsImport(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Import') &&
        ValueGuard.HasPropertyKey(value, '$defs') &&
        ValueGuard.IsObject(value.$defs) &&
        IsProperties(value.$defs) &&
        ValueGuard.HasPropertyKey(value, '$ref') &&
        ValueGuard.IsString(value.$ref) &&
        value.$ref in value.$defs // required
    );
}
/** Returns true if the given value is TInteger */
function IsInteger(value) {
    return (IsKindOf(value, 'Integer') &&
        value.type === 'integer' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximum) &&
        IsOptionalNumber(value.exclusiveMinimum) &&
        IsOptionalNumber(value.maximum) &&
        IsOptionalNumber(value.minimum) &&
        IsOptionalNumber(value.multipleOf));
}
/** Returns true if the given schema is TProperties */
function IsProperties(value) {
    // prettier-ignore
    return (ValueGuard.IsObject(value) &&
        Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));
}
/** Returns true if the given value is TIntersect */
function IsIntersect(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Intersect') &&
        (ValueGuard.IsString(value.type) && value.type !== 'object' ? false : true) &&
        ValueGuard.IsArray(value.allOf) &&
        value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&
        IsOptionalString(value.type) &&
        (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TIterator */
function IsIterator(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Iterator') &&
        value.type === 'Iterator' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items));
}
/** Returns true if the given value is a TKind with the given name. */
function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
}
/** Returns true if the given value is TLiteral<string> */
function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
}
/** Returns true if the given value is TLiteral<number> */
function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
}
/** Returns true if the given value is TLiteral<boolean> */
function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
}
/** Returns true if the given value is TLiteral */
function IsLiteral(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Literal') &&
        IsOptionalString(value.$id) && IsLiteralValue(value.const));
}
/** Returns true if the given value is a TLiteralValue */
function IsLiteralValue(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
}
/** Returns true if the given value is a TMappedKey */
function IsMappedKey(value) {
    // prettier-ignore
    return (IsKindOf(value, 'MappedKey') &&
        ValueGuard.IsArray(value.keys) &&
        value.keys.every(key => ValueGuard.IsNumber(key) || ValueGuard.IsString(key)));
}
/** Returns true if the given value is TMappedResult */
function IsMappedResult(value) {
    // prettier-ignore
    return (IsKindOf(value, 'MappedResult') &&
        IsProperties(value.properties));
}
/** Returns true if the given value is TNever */
function IsNever(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Never') &&
        ValueGuard.IsObject(value.not) &&
        Object.getOwnPropertyNames(value.not).length === 0);
}
/** Returns true if the given value is TNot */
function IsNot(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Not') &&
        IsSchema(value.not));
}
/** Returns true if the given value is TNull */
function IsNull(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Null') &&
        value.type === 'null' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TNumber */
function IsNumber(value) {
    return (IsKindOf(value, 'Number') &&
        value.type === 'number' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximum) &&
        IsOptionalNumber(value.exclusiveMinimum) &&
        IsOptionalNumber(value.maximum) &&
        IsOptionalNumber(value.minimum) &&
        IsOptionalNumber(value.multipleOf));
}
/** Returns true if the given value is TObject */
function IsObject(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Object') &&
        value.type === 'object' &&
        IsOptionalString(value.$id) &&
        IsProperties(value.properties) &&
        IsAdditionalProperties(value.additionalProperties) &&
        IsOptionalNumber(value.minProperties) &&
        IsOptionalNumber(value.maxProperties));
}
/** Returns true if the given value is TPromise */
function IsPromise(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Promise') &&
        value.type === 'Promise' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.item));
}
/** Returns true if the given value is TRecord */
function IsRecord(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Record') &&
        value.type === 'object' &&
        IsOptionalString(value.$id) &&
        IsAdditionalProperties(value.additionalProperties) &&
        ValueGuard.IsObject(value.patternProperties) &&
        ((schema) => {
            const keys = Object.getOwnPropertyNames(schema.patternProperties);
            return (keys.length === 1 &&
                IsPattern(keys[0]) &&
                ValueGuard.IsObject(schema.patternProperties) &&
                IsSchema(schema.patternProperties[keys[0]]));
        })(value));
}
/** Returns true if this value is TRecursive */
function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === 'Recursive';
}
/** Returns true if the given value is TRef */
function IsRef(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Ref') &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsString(value.$ref));
}
/** Returns true if the given value is TRegExp */
function IsRegExp(value) {
    // prettier-ignore
    return (IsKindOf(value, 'RegExp') &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsString(value.source) &&
        ValueGuard.IsString(value.flags) &&
        IsOptionalNumber(value.maxLength) &&
        IsOptionalNumber(value.minLength));
}
/** Returns true if the given value is TString */
function IsString(value) {
    // prettier-ignore
    return (IsKindOf(value, 'String') &&
        value.type === 'string' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.minLength) &&
        IsOptionalNumber(value.maxLength) &&
        IsOptionalPattern(value.pattern) &&
        IsOptionalFormat(value.format));
}
/** Returns true if the given value is TSymbol */
function IsSymbol(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Symbol') &&
        value.type === 'symbol' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TTemplateLiteral */
function IsTemplateLiteral(value) {
    // prettier-ignore
    return (IsKindOf(value, 'TemplateLiteral') &&
        value.type === 'string' &&
        ValueGuard.IsString(value.pattern) &&
        value.pattern[0] === '^' &&
        value.pattern[value.pattern.length - 1] === '$');
}
/** Returns true if the given value is TThis */
function IsThis(value) {
    // prettier-ignore
    return (IsKindOf(value, 'This') &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsString(value.$ref));
}
/** Returns true of this value is TTransform */
function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
}
/** Returns true if the given value is TTuple */
function IsTuple(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Tuple') &&
        value.type === 'array' &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsNumber(value.minItems) &&
        ValueGuard.IsNumber(value.maxItems) &&
        value.minItems === value.maxItems &&
        (( // empty
        ValueGuard.IsUndefined(value.items) &&
            ValueGuard.IsUndefined(value.additionalItems) &&
            value.minItems === 0) || (ValueGuard.IsArray(value.items) &&
            value.items.every(schema => IsSchema(schema)))));
}
/** Returns true if the given value is TUndefined */
function IsUndefined(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Undefined') &&
        value.type === 'undefined' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TUnion<Literal<string | number>[]> */
function IsUnionLiteral(value) {
    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
/** Returns true if the given value is TUnion */
function IsUnion(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Union') &&
        IsOptionalString(value.$id) &&
        ValueGuard.IsObject(value) &&
        ValueGuard.IsArray(value.anyOf) &&
        value.anyOf.every(schema => IsSchema(schema)));
}
/** Returns true if the given value is TUint8Array */
function IsUint8Array(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Uint8Array') &&
        value.type === 'Uint8Array' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.minByteLength) &&
        IsOptionalNumber(value.maxByteLength));
}
/** Returns true if the given value is TUnknown */
function IsUnknown(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Unknown') &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is a raw TUnsafe */
function IsUnsafe(value) {
    return IsKindOf(value, 'Unsafe');
}
/** Returns true if the given value is TVoid */
function IsVoid(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Void') &&
        value.type === 'void' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TKind */
function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes.includes(value[index_1.Kind]);
}
/** Returns true if the given value is TSchema */
function IsSchema(value) {
    // prettier-ignore
    return (ValueGuard.IsObject(value)) && (IsAny(value) ||
        IsArgument(value) ||
        IsArray(value) ||
        IsBoolean(value) ||
        IsBigInt(value) ||
        IsAsyncIterator(value) ||
        IsComputed(value) ||
        IsConstructor(value) ||
        IsDate(value) ||
        IsFunction(value) ||
        IsInteger(value) ||
        IsIntersect(value) ||
        IsIterator(value) ||
        IsLiteral(value) ||
        IsMappedKey(value) ||
        IsMappedResult(value) ||
        IsNever(value) ||
        IsNot(value) ||
        IsNull(value) ||
        IsNumber(value) ||
        IsObject(value) ||
        IsPromise(value) ||
        IsRecord(value) ||
        IsRef(value) ||
        IsRegExp(value) ||
        IsString(value) ||
        IsSymbol(value) ||
        IsTemplateLiteral(value) ||
        IsThis(value) ||
        IsTuple(value) ||
        IsUndefined(value) ||
        IsUnion(value) ||
        IsUint8Array(value) ||
        IsUnknown(value) ||
        IsUnsafe(value) ||
        IsVoid(value) ||
        IsKind(value));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\value.d.ts

Code:
/** Returns true if this value has this property key */
export declare function HasPropertyKey<K extends PropertyKey>(value: Record<any, unknown>, key: K): value is Record<PropertyKey, unknown> & {
    [_ in K]: unknown;
};
/** Returns true if this value is an async iterator */
export declare function IsAsyncIterator(value: unknown): value is AsyncIterableIterator<unknown>;
/** Returns true if this value is an array */
export declare function IsArray(value: unknown): value is unknown[];
/** Returns true if this value is bigint */
export declare function IsBigInt(value: unknown): value is bigint;
/** Returns true if this value is a boolean */
export declare function IsBoolean(value: unknown): value is boolean;
/** Returns true if this value is a Date object */
export declare function IsDate(value: unknown): value is Date;
/** Returns true if this value is a function */
export declare function IsFunction(value: unknown): value is Function;
/** Returns true if this value is an iterator */
export declare function IsIterator(value: unknown): value is IterableIterator<unknown>;
/** Returns true if this value is null */
export declare function IsNull(value: unknown): value is null;
/** Returns true if this value is number */
export declare function IsNumber(value: unknown): value is number;
/** Returns true if this value is an object */
export declare function IsObject(value: unknown): value is Record<PropertyKey, unknown>;
/** Returns true if this value is RegExp */
export declare function IsRegExp(value: unknown): value is RegExp;
/** Returns true if this value is string */
export declare function IsString(value: unknown): value is string;
/** Returns true if this value is symbol */
export declare function IsSymbol(value: unknown): value is symbol;
/** Returns true if this value is a Uint8Array */
export declare function IsUint8Array(value: unknown): value is Uint8Array;
/** Returns true if this value is undefined */
export declare function IsUndefined(value: unknown): value is undefined;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\guard\value.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HasPropertyKey = HasPropertyKey;
exports.IsAsyncIterator = IsAsyncIterator;
exports.IsArray = IsArray;
exports.IsBigInt = IsBigInt;
exports.IsBoolean = IsBoolean;
exports.IsDate = IsDate;
exports.IsFunction = IsFunction;
exports.IsIterator = IsIterator;
exports.IsNull = IsNull;
exports.IsNumber = IsNumber;
exports.IsObject = IsObject;
exports.IsRegExp = IsRegExp;
exports.IsString = IsString;
exports.IsSymbol = IsSymbol;
exports.IsUint8Array = IsUint8Array;
exports.IsUndefined = IsUndefined;
// --------------------------------------------------------------------------
// PropertyKey
// --------------------------------------------------------------------------
/** Returns true if this value has this property key */
function HasPropertyKey(value, key) {
    return key in value;
}
// --------------------------------------------------------------------------
// Object Instances
// --------------------------------------------------------------------------
/** Returns true if this value is an async iterator */
function IsAsyncIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
/** Returns true if this value is an array */
function IsArray(value) {
    return Array.isArray(value);
}
/** Returns true if this value is bigint */
function IsBigInt(value) {
    return typeof value === 'bigint';
}
/** Returns true if this value is a boolean */
function IsBoolean(value) {
    return typeof value === 'boolean';
}
/** Returns true if this value is a Date object */
function IsDate(value) {
    return value instanceof globalThis.Date;
}
/** Returns true if this value is a function */
function IsFunction(value) {
    return typeof value === 'function';
}
/** Returns true if this value is an iterator */
function IsIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
/** Returns true if this value is null */
function IsNull(value) {
    return value === null;
}
/** Returns true if this value is number */
function IsNumber(value) {
    return typeof value === 'number';
}
/** Returns true if this value is an object */
function IsObject(value) {
    return typeof value === 'object' && value !== null;
}
/** Returns true if this value is RegExp */
function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
}
/** Returns true if this value is string */
function IsString(value) {
    return typeof value === 'string';
}
/** Returns true if this value is symbol */
function IsSymbol(value) {
    return typeof value === 'symbol';
}
/** Returns true if this value is a Uint8Array */
function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
}
/** Returns true if this value is undefined */
function IsUndefined(value) {
    return value === undefined;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\helpers\helpers.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TProperties } from '../object/index';
import type { TNever } from '../never/index';
export type TupleToIntersect<T extends any[]> = T extends [infer I] ? I : T extends [infer I, ...infer R] ? I & TupleToIntersect<R> : never;
export type TupleToUnion<T extends any[]> = {
    [K in keyof T]: T[K];
}[number];
export type UnionToIntersect<U> = (U extends unknown ? (arg: U) => 0 : never) extends (arg: infer I) => 0 ? I : never;
export type UnionLast<U> = UnionToIntersect<U extends unknown ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L : never;
export type UnionToTuple<U, Acc extends unknown[] = [], R = UnionLast<U>> = [U] extends [never] ? Acc : UnionToTuple<Exclude<U, R>, [Extract<U, R>, ...Acc]>;
export type Trim<T> = T extends `${' '}${infer U}` ? Trim<U> : T extends `${infer U}${' '}` ? Trim<U> : T;
export type Assert<T, E> = T extends E ? T : never;
export type Evaluate<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type Ensure<T> = T extends infer U ? U : never;
export type EmptyString = '';
export type ZeroString = '0';
type IncrementBase = {
    m: '9';
    t: '01';
    '0': '1';
    '1': '2';
    '2': '3';
    '3': '4';
    '4': '5';
    '5': '6';
    '6': '7';
    '7': '8';
    '8': '9';
    '9': '0';
};
type IncrementTake<T extends keyof IncrementBase> = IncrementBase[T];
type IncrementStep<T extends string> = T extends IncrementBase['m'] ? IncrementBase['t'] : T extends `${infer L extends keyof IncrementBase}${infer R}` ? L extends IncrementBase['m'] ? `${IncrementTake<L>}${IncrementStep<R>}` : `${IncrementTake<L>}${R}` : never;
type IncrementReverse<T extends string> = T extends `${infer L}${infer R}` ? `${IncrementReverse<R>}${L}` : T;
export type TIncrement<T extends string> = IncrementReverse<IncrementStep<IncrementReverse<T>>>;
/** Increments the given string value + 1 */
export declare function Increment<T extends string>(T: T): TIncrement<T>;
export type AssertProperties<T> = T extends TProperties ? T : TProperties;
export type AssertRest<T, E extends TSchema[] = TSchema[]> = T extends E ? T : [];
export type AssertType<T, E extends TSchema = TSchema> = T extends E ? T : TNever;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\helpers\helpers.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Increment = Increment;
/** Increments the given string value + 1 */
function Increment(T) {
    return (parseInt(T) + 1).toString();
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\helpers\index.d.ts

Code:
export * from './helpers';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\helpers\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./helpers"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\index.d.ts

Code:
export * from './any/index';
export * from './argument/index';
export * from './array/index';
export * from './async-iterator/index';
export * from './awaited/index';
export * from './bigint/index';
export * from './boolean/index';
export * from './clone/index';
export * from './composite/index';
export * from './const/index';
export * from './constructor/index';
export * from './constructor-parameters/index';
export * from './date/index';
export * from './discard/index';
export * from './enum/index';
export * from './error/index';
export * from './exclude/index';
export * from './extends/index';
export * from './extract/index';
export * from './function/index';
export * from './guard/index';
export * from './helpers/index';
export * from './indexed/index';
export * from './instance-type/index';
export * from './instantiate/index';
export * from './integer/index';
export * from './intersect/index';
export * from './intrinsic/index';
export * from './iterator/index';
export * from './keyof/index';
export * from './literal/index';
export * from './mapped/index';
export * from './module/index';
export * from './never/index';
export * from './not/index';
export * from './null/index';
export * from './number/index';
export * from './object/index';
export * from './omit/index';
export * from './optional/index';
export * from './parameters/index';
export * from './partial/index';
export * from './patterns/index';
export * from './pick/index';
export * from './promise/index';
export * from './readonly/index';
export * from './readonly-optional/index';
export * from './record/index';
export * from './recursive/index';
export * from './ref/index';
export * from './regexp/index';
export * from './registry/index';
export * from './required/index';
export * from './rest/index';
export * from './return-type/index';
export * from './schema/index';
export * from './sets/index';
export * from './static/index';
export * from './string/index';
export * from './symbol/index';
export * from './symbols/index';
export * from './template-literal/index';
export * from './transform/index';
export * from './tuple/index';
export * from './type/index';
export * from './uint8array/index';
export * from './undefined/index';
export * from './union/index';
export * from './unknown/index';
export * from './unsafe/index';
export * from './void/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./any/index"), exports);
__exportStar(require("./argument/index"), exports);
__exportStar(require("./array/index"), exports);
__exportStar(require("./async-iterator/index"), exports);
__exportStar(require("./awaited/index"), exports);
__exportStar(require("./bigint/index"), exports);
__exportStar(require("./boolean/index"), exports);
__exportStar(require("./clone/index"), exports);
__exportStar(require("./composite/index"), exports);
__exportStar(require("./const/index"), exports);
__exportStar(require("./constructor/index"), exports);
__exportStar(require("./constructor-parameters/index"), exports);
__exportStar(require("./date/index"), exports);
__exportStar(require("./discard/index"), exports);
__exportStar(require("./enum/index"), exports);
__exportStar(require("./error/index"), exports);
__exportStar(require("./exclude/index"), exports);
__exportStar(require("./extends/index"), exports);
__exportStar(require("./extract/index"), exports);
__exportStar(require("./function/index"), exports);
__exportStar(require("./guard/index"), exports);
__exportStar(require("./helpers/index"), exports);
__exportStar(require("./indexed/index"), exports);
__exportStar(require("./instance-type/index"), exports);
__exportStar(require("./instantiate/index"), exports);
__exportStar(require("./integer/index"), exports);
__exportStar(require("./intersect/index"), exports);
__exportStar(require("./intrinsic/index"), exports);
__exportStar(require("./iterator/index"), exports);
__exportStar(require("./keyof/index"), exports);
__exportStar(require("./literal/index"), exports);
__exportStar(require("./mapped/index"), exports);
__exportStar(require("./module/index"), exports);
__exportStar(require("./never/index"), exports);
__exportStar(require("./not/index"), exports);
__exportStar(require("./null/index"), exports);
__exportStar(require("./number/index"), exports);
__exportStar(require("./object/index"), exports);
__exportStar(require("./omit/index"), exports);
__exportStar(require("./optional/index"), exports);
__exportStar(require("./parameters/index"), exports);
__exportStar(require("./partial/index"), exports);
__exportStar(require("./patterns/index"), exports);
__exportStar(require("./pick/index"), exports);
__exportStar(require("./promise/index"), exports);
__exportStar(require("./readonly/index"), exports);
__exportStar(require("./readonly-optional/index"), exports);
__exportStar(require("./record/index"), exports);
__exportStar(require("./recursive/index"), exports);
__exportStar(require("./ref/index"), exports);
__exportStar(require("./regexp/index"), exports);
__exportStar(require("./registry/index"), exports);
__exportStar(require("./required/index"), exports);
__exportStar(require("./rest/index"), exports);
__exportStar(require("./return-type/index"), exports);
__exportStar(require("./schema/index"), exports);
__exportStar(require("./sets/index"), exports);
__exportStar(require("./static/index"), exports);
__exportStar(require("./string/index"), exports);
__exportStar(require("./symbol/index"), exports);
__exportStar(require("./symbols/index"), exports);
__exportStar(require("./template-literal/index"), exports);
__exportStar(require("./transform/index"), exports);
__exportStar(require("./tuple/index"), exports);
__exportStar(require("./type/index"), exports);
__exportStar(require("./uint8array/index"), exports);
__exportStar(require("./undefined/index"), exports);
__exportStar(require("./union/index"), exports);
__exportStar(require("./unknown/index"), exports);
__exportStar(require("./unsafe/index"), exports);
__exportStar(require("./void/index"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\index.d.ts

Code:
export * from './indexed-from-mapped-key';
export * from './indexed-from-mapped-result';
export * from './indexed-property-keys';
export * from './indexed';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./indexed-from-mapped-key"), exports);
__exportStar(require("./indexed-from-mapped-result"), exports);
__exportStar(require("./indexed-property-keys"), exports);
__exportStar(require("./indexed"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-from-mapped-key.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TIndex } from './indexed';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
type TMappedIndexPropertyKey<Type extends TSchema, Key extends PropertyKey> = {
    [_ in Key]: TIndex<Type, [Key]>;
};
type TMappedIndexPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[], Result extends TProperties = {}> = (PropertyKeys extends [infer Left extends PropertyKey, ...infer Right extends PropertyKey[]] ? TMappedIndexPropertyKeys<Type, Right, Result & TMappedIndexPropertyKey<Type, Left>> : Result);
type TMappedIndexProperties<Type extends TSchema, MappedKey extends TMappedKey> = Evaluate<TMappedIndexPropertyKeys<Type, MappedKey['keys']>>;
export type TIndexFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TMappedIndexProperties<Type, MappedKey>> = (Ensure<TMappedResult<Properties>>);
export declare function IndexFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TMappedIndexProperties<Type, MappedKey>>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-from-mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexFromMappedKey = IndexFromMappedKey;
const indexed_1 = require("./indexed");
const index_1 = require("../mapped/index");
const value_1 = require("../clone/value");
// prettier-ignore
function MappedIndexPropertyKey(type, key, options) {
    return { [key]: (0, indexed_1.Index)(type, [key], (0, value_1.Clone)(options)) };
}
// prettier-ignore
function MappedIndexPropertyKeys(type, propertyKeys, options) {
    return propertyKeys.reduce((result, left) => {
        return { ...result, ...MappedIndexPropertyKey(type, left, options) };
    }, {});
}
// prettier-ignore
function MappedIndexProperties(type, mappedKey, options) {
    return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
// prettier-ignore
function IndexFromMappedKey(type, mappedKey, options) {
    const properties = MappedIndexProperties(type, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-from-mapped-result.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TIndexPropertyKeys } from './indexed-property-keys';
import { type TIndex } from './index';
type TFromProperties<Type extends TSchema, Properties extends TProperties> = ({
    [K2 in keyof Properties]: TIndex<Type, TIndexPropertyKeys<Properties[K2]>>;
});
type TFromMappedResult<Type extends TSchema, MappedResult extends TMappedResult> = (TFromProperties<Type, MappedResult['properties']>);
export type TIndexFromMappedResult<Type extends TSchema, MappedResult extends TMappedResult, Properties extends TProperties = TFromMappedResult<Type, MappedResult>> = (TMappedResult<Properties>);
export declare function IndexFromMappedResult<Type extends TSchema, MappedResult extends TMappedResult, Properties extends TProperties = TFromMappedResult<Type, MappedResult>>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexFromMappedResult = IndexFromMappedResult;
const index_1 = require("../mapped/index");
const indexed_property_keys_1 = require("./indexed-property-keys");
const index_2 = require("./index");
// prettier-ignore
function FromProperties(type, properties, options) {
    const result = {};
    for (const K2 of Object.getOwnPropertyNames(properties)) {
        result[K2] = (0, index_2.Index)(type, (0, indexed_property_keys_1.IndexPropertyKeys)(properties[K2]), options);
    }
    return result;
}
// prettier-ignore
function FromMappedResult(type, mappedResult, options) {
    return FromProperties(type, mappedResult.properties, options);
}
// prettier-ignore
function IndexFromMappedResult(type, mappedResult, options) {
    const properties = FromMappedResult(type, mappedResult, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-property-keys.d.ts

Code:
import { type TTemplateLiteralGenerate, type TTemplateLiteral } from '../template-literal/index';
import type { TLiteral, TLiteralValue } from '../literal/index';
import type { TInteger } from '../integer/index';
import type { TNumber } from '../number/index';
import type { TSchema } from '../schema/index';
import type { TUnion } from '../union/index';
type TFromTemplateLiteral<TemplateLiteral extends TTemplateLiteral, Keys extends string[] = TTemplateLiteralGenerate<TemplateLiteral>> = (Keys);
type TFromUnion<Types extends TSchema[], Result extends string[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromUnion<Right, [...Result, ...TIndexPropertyKeys<Left>]> : Result);
type TFromLiteral<LiteralValue extends TLiteralValue> = (LiteralValue extends PropertyKey ? [`${LiteralValue}`] : []);
export type TIndexPropertyKeys<Type extends TSchema> = (Type extends TTemplateLiteral ? TFromTemplateLiteral<Type> : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<Types> : Type extends TLiteral<infer Value extends TLiteralValue> ? TFromLiteral<Value> : Type extends TNumber ? ['[number]'] : Type extends TInteger ? ['[number]'] : [
]);
/** Returns a tuple of PropertyKeys derived from the given TSchema */
export declare function IndexPropertyKeys<Type extends TSchema>(type: Type): TIndexPropertyKeys<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed-property-keys.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexPropertyKeys = IndexPropertyKeys;
const index_1 = require("../template-literal/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromTemplateLiteral(templateLiteral) {
    const keys = (0, index_1.TemplateLiteralGenerate)(templateLiteral);
    return keys.map(key => key.toString());
}
// prettier-ignore
function FromUnion(types) {
    const result = [];
    for (const type of types)
        result.push(...IndexPropertyKeys(type));
    return result;
}
// prettier-ignore
function FromLiteral(literalValue) {
    return ([literalValue.toString()] // TS 5.4 observes TLiteralValue as not having a toString()
    );
}
/** Returns a tuple of PropertyKeys derived from the given TSchema */
// prettier-ignore
function IndexPropertyKeys(type) {
    return [...new Set(((0, kind_1.IsTemplateLiteral)(type) ? FromTemplateLiteral(type) :
            (0, kind_1.IsUnion)(type) ? FromUnion(type.anyOf) :
                (0, kind_1.IsLiteral)(type) ? FromLiteral(type.const) :
                    (0, kind_1.IsNumber)(type) ? ['[number]'] :
                        (0, kind_1.IsInteger)(type) ? ['[number]'] :
                            []))];
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed.d.ts

Code:
import { type TSchema, SchemaOptions } from '../schema/index';
import { type Assert } from '../helpers/index';
import { type TComputed } from '../computed/index';
import { type TNever } from '../never/index';
import { type TArray } from '../array/index';
import { type TIntersect } from '../intersect/index';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
import { type TObject, type TProperties } from '../object/index';
import { type TUnion } from '../union/index';
import { type TRecursive } from '../recursive/index';
import { type TRef } from '../ref/index';
import { type TTuple } from '../tuple/index';
import { type TIntersectEvaluated } from '../intersect/index';
import { type TUnionEvaluated } from '../union/index';
import { type TIndexPropertyKeys } from './indexed-property-keys';
import { type TIndexFromMappedKey } from './indexed-from-mapped-key';
import { type TIndexFromMappedResult } from './indexed-from-mapped-result';
type TFromRest<Types extends TSchema[], Key extends PropertyKey, Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromRest<Right, Key, [...Result, Assert<TIndexFromPropertyKey<Left, Key>, TSchema>]> : Result);
type TFromIntersectRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TNever ? TFromIntersectRest<Right, [...Result]> : TFromIntersectRest<Right, [...Result, Left]> : Result);
type TFromIntersect<Types extends TSchema[], Key extends PropertyKey> = (TIntersectEvaluated<TFromIntersectRest<TFromRest<Types, Key>>>);
type TFromUnionRest<Types extends TSchema[], Result extends TSchema[] = []> = Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TNever ? [] : TFromUnionRest<Right, [Left, ...Result]> : Result;
type TFromUnion<Types extends TSchema[], Key extends PropertyKey> = (TUnionEvaluated<TFromUnionRest<TFromRest<Types, Key>>>);
type TFromTuple<Types extends TSchema[], Key extends PropertyKey> = (Key extends keyof Types ? Types[Key] : Key extends '[number]' ? TUnionEvaluated<Types> : TNever);
type TFromArray<Type extends TSchema, Key extends PropertyKey> = (Key extends '[number]' ? Type : TNever);
type AssertPropertyKey<T> = Assert<T, string | number>;
type TFromProperty<Properties extends TProperties, Key extends PropertyKey> = (Key extends keyof Properties ? Properties[Key] : `${AssertPropertyKey<Key>}` extends `${AssertPropertyKey<keyof Properties>}` ? Properties[AssertPropertyKey<Key>] : TNever);
export type TIndexFromPropertyKey<Type extends TSchema, Key extends PropertyKey> = (Type extends TRecursive<infer Type extends TSchema> ? TIndexFromPropertyKey<Type, Key> : Type extends TIntersect<infer Types extends TSchema[]> ? TFromIntersect<Types, Key> : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<Types, Key> : Type extends TTuple<infer Types extends TSchema[]> ? TFromTuple<Types, Key> : Type extends TArray<infer Type extends TSchema> ? TFromArray<Type, Key> : Type extends TObject<infer Properties extends TProperties> ? TFromProperty<Properties, Key> : TNever);
export declare function IndexFromPropertyKey<Type extends TSchema, Key extends PropertyKey>(type: Type, propertyKey: Key): TIndexFromPropertyKey<Type, Key>;
export type TIndexFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = (PropertyKeys extends [infer Left extends PropertyKey, ...infer Right extends PropertyKey[]] ? TIndexFromPropertyKeys<Type, Right, [...Result, Assert<TIndexFromPropertyKey<Type, Left>, TSchema>]> : Result);
export declare function IndexFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: [...PropertyKeys]): TIndexFromPropertyKeys<Type, PropertyKeys>;
type FromSchema<Type extends TSchema, PropertyKeys extends PropertyKey[]> = (TUnionEvaluated<TIndexFromPropertyKeys<Type, PropertyKeys>>);
declare function FromSchema<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: [...PropertyKeys]): FromSchema<Type, PropertyKeys>;
export type TIndexFromComputed<Type extends TSchema, Key extends TSchema> = (TComputed<'Index', [Type, Key]>);
export declare function IndexFromComputed<Type extends TSchema, Key extends TSchema>(type: Type, key: Key): TIndexFromComputed<Type, Key>;
export type TIndex<Type extends TSchema, PropertyKeys extends PropertyKey[]> = (FromSchema<Type, PropertyKeys>);
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TRef, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TRef, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedResult extends TMappedResult>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TIndexFromMappedResult<Type, MappedResult>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedResult extends TMappedResult>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TIndexFromMappedResult<Type, MappedResult>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedKey extends TMappedKey>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TIndexFromMappedKey<Type, MappedKey>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, Key extends TSchema, PropertyKeys extends PropertyKey[] = TIndexPropertyKeys<Key>>(T: Type, K: Key, options?: SchemaOptions): TIndex<Type, PropertyKeys>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: readonly [...PropertyKeys], options?: SchemaOptions): TIndex<Type, PropertyKeys>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\indexed\indexed.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexFromPropertyKey = IndexFromPropertyKey;
exports.IndexFromPropertyKeys = IndexFromPropertyKeys;
exports.IndexFromComputed = IndexFromComputed;
exports.Index = Index;
const type_1 = require("../create/type");
const index_1 = require("../error/index");
const index_2 = require("../computed/index");
const index_3 = require("../never/index");
const index_4 = require("../intersect/index");
const index_5 = require("../union/index");
const indexed_property_keys_1 = require("./indexed-property-keys");
const indexed_from_mapped_key_1 = require("./indexed-from-mapped-key");
const indexed_from_mapped_result_1 = require("./indexed-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromRest(types, key) {
    return types.map(type => IndexFromPropertyKey(type, key));
}
// prettier-ignore
function FromIntersectRest(types) {
    return types.filter(type => !(0, kind_1.IsNever)(type));
}
// prettier-ignore
function FromIntersect(types, key) {
    return ((0, index_4.IntersectEvaluated)(FromIntersectRest(FromRest(types, key))));
}
// prettier-ignore
function FromUnionRest(types) {
    return (types.some(L => (0, kind_1.IsNever)(L))
        ? []
        : types);
}
// prettier-ignore
function FromUnion(types, key) {
    return ((0, index_5.UnionEvaluated)(FromUnionRest(FromRest(types, key))));
}
// prettier-ignore
function FromTuple(types, key) {
    return (key in types ? types[key] :
        key === '[number]' ? (0, index_5.UnionEvaluated)(types) :
            (0, index_3.Never)());
}
// prettier-ignore
function FromArray(type, key) {
    return (key === '[number]'
        ? type
        : (0, index_3.Never)());
}
// prettier-ignore
function FromProperty(properties, propertyKey) {
    return (propertyKey in properties ? properties[propertyKey] : (0, index_3.Never)());
}
// prettier-ignore
function IndexFromPropertyKey(type, propertyKey) {
    return ((0, kind_1.IsIntersect)(type) ? FromIntersect(type.allOf, propertyKey) :
        (0, kind_1.IsUnion)(type) ? FromUnion(type.anyOf, propertyKey) :
            (0, kind_1.IsTuple)(type) ? FromTuple(type.items ?? [], propertyKey) :
                (0, kind_1.IsArray)(type) ? FromArray(type.items, propertyKey) :
                    (0, kind_1.IsObject)(type) ? FromProperty(type.properties, propertyKey) :
                        (0, index_3.Never)());
}
// prettier-ignore
function IndexFromPropertyKeys(type, propertyKeys) {
    return propertyKeys.map(propertyKey => IndexFromPropertyKey(type, propertyKey));
}
// prettier-ignore
function FromSchema(type, propertyKeys) {
    return ((0, index_5.UnionEvaluated)(IndexFromPropertyKeys(type, propertyKeys)));
}
// prettier-ignore
function IndexFromComputed(type, key) {
    return (0, index_2.Computed)('Index', [type, key]);
}
/** `[Json]` Returns an Indexed property type for the given keys */
function Index(type, key, options) {
    // computed-type
    if ((0, kind_1.IsRef)(type) || (0, kind_1.IsRef)(key)) {
        const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
        if (!(0, kind_1.IsSchema)(type) || !(0, kind_1.IsSchema)(key))
            throw new index_1.TypeBoxError(error);
        return (0, index_2.Computed)('Index', [type, key]);
    }
    // mapped-types
    if ((0, kind_1.IsMappedResult)(key))
        return (0, indexed_from_mapped_result_1.IndexFromMappedResult)(type, key, options);
    if ((0, kind_1.IsMappedKey)(key))
        return (0, indexed_from_mapped_key_1.IndexFromMappedKey)(type, key, options);
    // prettier-ignore
    return (0, type_1.CreateType)((0, kind_1.IsSchema)(key)
        ? FromSchema(type, (0, indexed_property_keys_1.IndexPropertyKeys)(key))
        : FromSchema(type, key), options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instance-type\index.d.ts

Code:
export * from './instance-type';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instance-type\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./instance-type"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instance-type\instance-type.d.ts

Code:
import { type TSchema, SchemaOptions } from '../schema/index';
import { type TConstructor } from '../constructor/index';
import { type TNever } from '../never/index';
export type TInstanceType<Type extends TSchema, Result extends TSchema = Type extends TConstructor<infer _Parameters extends TSchema[], infer InstanceType extends TSchema> ? InstanceType : TNever> = Result;
/** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
export declare function InstanceType<Type extends TSchema>(schema: Type, options?: SchemaOptions): TInstanceType<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instance-type\instance-type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceType = InstanceType;
const type_1 = require("../create/type");
const index_1 = require("../never/index");
const KindGuard = require("../guard/kind");
/** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
function InstanceType(schema, options) {
    return (KindGuard.IsConstructor(schema) ? (0, type_1.CreateType)(schema.returns, options) : (0, index_1.Never)(options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instantiate\index.d.ts

Code:
export * from './instantiate';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instantiate\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./instantiate"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instantiate\instantiate.d.ts

Code:
import { type TSchema } from '../schema/index';
import { type TArgument } from '../argument/index';
import { type TUnknown } from '../unknown/index';
import { type TReadonlyOptional } from '../readonly-optional/index';
import { type TReadonly } from '../readonly/index';
import { type TOptional } from '../optional/index';
import { type TConstructor } from '../constructor/index';
import { type TFunction } from '../function/index';
import { type TIntersect } from '../intersect/index';
import { type TUnion } from '../union/index';
import { type TTuple } from '../tuple/index';
import { type TArray } from '../array/index';
import { type TAsyncIterator } from '../async-iterator/index';
import { type TIterator } from '../iterator/index';
import { type TPromise } from '../promise/index';
import { type TObject, type TProperties } from '../object/index';
import { type TRecordOrObject, type TRecord } from '../record/index';
type TFromConstructor<Args extends TSchema[], Parameters extends TSchema[], InstanceType extends TSchema, Result extends TConstructor = TConstructor<TFromTypes<Args, Parameters>, TFromType<Args, InstanceType>>> = Result;
type TFromFunction<Args extends TSchema[], Parameters extends TSchema[], ReturnType extends TSchema, Result extends TFunction = TFunction<TFromTypes<Args, Parameters>, TFromType<Args, ReturnType>>> = Result;
type TFromIntersect<Args extends TSchema[], Types extends TSchema[], Result extends TIntersect = TIntersect<TFromTypes<Args, Types>>> = Result;
type TFromUnion<Args extends TSchema[], Types extends TSchema[], Result extends TUnion = TUnion<TFromTypes<Args, Types>>> = Result;
type TFromTuple<Args extends TSchema[], Types extends TSchema[], Result extends TTuple = TTuple<TFromTypes<Args, Types>>> = Result;
type TFromArray<Args extends TSchema[], Type extends TSchema, Result extends TArray = TArray<TFromType<Args, Type>>> = Result;
type TFromAsyncIterator<Args extends TSchema[], Type extends TSchema, Result extends TAsyncIterator = TAsyncIterator<TFromType<Args, Type>>> = Result;
type TFromIterator<Args extends TSchema[], Type extends TSchema, Result extends TIterator = TIterator<TFromType<Args, Type>>> = Result;
type TFromPromise<Args extends TSchema[], Type extends TSchema, Result extends TPromise = TPromise<TFromType<Args, Type>>> = Result;
type TFromObject<Args extends TSchema[], Properties extends TProperties, MappedProperties extends TProperties = TFromProperties<Args, Properties>, Result extends TObject = TObject<MappedProperties>> = Result;
type TFromRecord<Args extends TSchema[], Key extends TSchema, Value extends TSchema, MappedKey extends TSchema = TFromType<Args, Key>, MappedValue extends TSchema = TFromType<Args, Value>, Result extends TSchema = TRecordOrObject<MappedKey, MappedValue>> = Result;
type TFromArgument<Args extends TSchema[], Index extends number, Result extends TSchema = Index extends keyof Args[Index] ? Args[Index] : TUnknown> = Result;
type TFromProperty<Args extends TSchema[], Type extends TSchema, IsReadonly extends boolean = Type extends TReadonly<Type> ? true : false, IsOptional extends boolean = Type extends TOptional<Type> ? true : false, Mapped extends TSchema = TFromType<Args, Type>, Result extends TSchema = ([
    IsReadonly,
    IsOptional
] extends [true, true] ? TReadonlyOptional<Mapped> : [
    IsReadonly,
    IsOptional
] extends [true, false] ? TReadonly<Mapped> : [
    IsReadonly,
    IsOptional
] extends [false, true] ? TOptional<Mapped> : Mapped)> = Result;
type TFromProperties<Args extends TSchema[], Properties extends TProperties, Result extends TProperties = {
    [Key in keyof Properties]: TFromProperty<Args, Properties[Key]>;
}> = Result;
export type TFromTypes<Args extends TSchema[], Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromTypes<Args, Right, [...Result, TFromType<Args, Left>]> : Result);
export declare function FromTypes<Args extends TSchema[], Types extends TSchema[]>(args: [...Args], types: [...Types]): TFromTypes<Args, Types>;
export type TFromType<Args extends TSchema[], Type extends TSchema> = (Type extends TConstructor<infer Parameters extends TSchema[], infer InstanceType extends TSchema> ? TFromConstructor<Args, Parameters, InstanceType> : Type extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TFromFunction<Args, Parameters, ReturnType> : Type extends TIntersect<infer Types extends TSchema[]> ? TFromIntersect<Args, Types> : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<Args, Types> : Type extends TTuple<infer Types extends TSchema[]> ? TFromTuple<Args, Types> : Type extends TArray<infer Type extends TSchema> ? TFromArray<Args, Type> : Type extends TAsyncIterator<infer Type extends TSchema> ? TFromAsyncIterator<Args, Type> : Type extends TIterator<infer Type extends TSchema> ? TFromIterator<Args, Type> : Type extends TPromise<infer Type extends TSchema> ? TFromPromise<Args, Type> : Type extends TObject<infer Properties extends TProperties> ? TFromObject<Args, Properties> : Type extends TRecord<infer Key extends TSchema, infer Value extends TSchema> ? TFromRecord<Args, Key, Value> : Type extends TArgument<infer Index extends number> ? TFromArgument<Args, Index> : Type);
/** `[JavaScript]` Instantiates a type with the given parameters */
export type TInstantiate<Type extends TSchema, Args extends TSchema[], Result extends TSchema = TFromType<Args, Type>> = Result;
/** `[JavaScript]` Instantiates a type with the given parameters */
export declare function Instantiate<Type extends TSchema, Args extends TSchema[]>(type: Type, args: [...Args]): TInstantiate<Type, Args>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\instantiate\instantiate.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FromTypes = FromTypes;
exports.Instantiate = Instantiate;
const type_1 = require("../clone/type");
const index_1 = require("../unknown/index");
const index_2 = require("../readonly-optional/index");
const index_3 = require("../readonly/index");
const index_4 = require("../optional/index");
const index_5 = require("../object/index");
const index_6 = require("../record/index");
const ValueGuard = require("../guard/value");
const KindGuard = require("../guard/kind");
// prettier-ignore
function FromConstructor(args, type) {
    type.parameters = FromTypes(args, type.parameters);
    type.returns = FromType(args, type.returns);
    return type;
}
// prettier-ignore
function FromFunction(args, type) {
    type.parameters = FromTypes(args, type.parameters);
    type.returns = FromType(args, type.returns);
    return type;
}
// prettier-ignore
function FromIntersect(args, type) {
    type.allOf = FromTypes(args, type.allOf);
    return type;
}
// prettier-ignore
function FromUnion(args, type) {
    type.anyOf = FromTypes(args, type.anyOf);
    return type;
}
// prettier-ignore
function FromTuple(args, type) {
    if (ValueGuard.IsUndefined(type.items))
        return type;
    type.items = FromTypes(args, type.items);
    return type;
}
// prettier-ignore
function FromArray(args, type) {
    type.items = FromType(args, type.items);
    return type;
}
// prettier-ignore
function FromAsyncIterator(args, type) {
    type.items = FromType(args, type.items);
    return type;
}
// prettier-ignore
function FromIterator(args, type) {
    type.items = FromType(args, type.items);
    return type;
}
// prettier-ignore
function FromPromise(args, type) {
    type.item = FromType(args, type.item);
    return type;
}
// prettier-ignore
function FromObject(args, type) {
    const mappedProperties = FromProperties(args, type.properties);
    return { ...type, ...(0, index_5.Object)(mappedProperties) }; // retain options
}
// prettier-ignore
function FromRecord(args, type) {
    const mappedKey = FromType(args, (0, index_6.RecordKey)(type));
    const mappedValue = FromType(args, (0, index_6.RecordValue)(type));
    const result = (0, index_6.Record)(mappedKey, mappedValue);
    return { ...type, ...result }; // retain options
}
// prettier-ignore
function FromArgument(args, argument) {
    return argument.index in args ? args[argument.index] : (0, index_1.Unknown)();
}
// prettier-ignore
function FromProperty(args, type) {
    const isReadonly = KindGuard.IsReadonly(type);
    const isOptional = KindGuard.IsOptional(type);
    const mapped = FromType(args, type);
    return (isReadonly && isOptional ? (0, index_2.ReadonlyOptional)(mapped) :
        isReadonly && !isOptional ? (0, index_3.Readonly)(mapped) :
            !isReadonly && isOptional ? (0, index_4.Optional)(mapped) :
                mapped);
}
// prettier-ignore
function FromProperties(args, properties) {
    return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
        return { ...result, [key]: FromProperty(args, properties[key]) };
    }, {});
}
// prettier-ignore
function FromTypes(args, types) {
    return types.map(type => FromType(args, type));
}
// prettier-ignore
function FromType(args, type) {
    return (KindGuard.IsConstructor(type) ? FromConstructor(args, type) :
        KindGuard.IsFunction(type) ? FromFunction(args, type) :
            KindGuard.IsIntersect(type) ? FromIntersect(args, type) :
                KindGuard.IsUnion(type) ? FromUnion(args, type) :
                    KindGuard.IsTuple(type) ? FromTuple(args, type) :
                        KindGuard.IsArray(type) ? FromArray(args, type) :
                            KindGuard.IsAsyncIterator(type) ? FromAsyncIterator(args, type) :
                                KindGuard.IsIterator(type) ? FromIterator(args, type) :
                                    KindGuard.IsPromise(type) ? FromPromise(args, type) :
                                        KindGuard.IsObject(type) ? FromObject(args, type) :
                                            KindGuard.IsRecord(type) ? FromRecord(args, type) :
                                                KindGuard.IsArgument(type) ? FromArgument(args, type) :
                                                    type);
}
/** `[JavaScript]` Instantiates a type with the given parameters */
// prettier-ignore
function Instantiate(type, args) {
    return FromType(args, (0, type_1.CloneType)(type));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\integer\index.d.ts

Code:
export * from './integer';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\integer\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./integer"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\integer\integer.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface IntegerOptions extends SchemaOptions {
    exclusiveMaximum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    minimum?: number;
    multipleOf?: number;
}
export interface TInteger extends TSchema, IntegerOptions {
    [Kind]: 'Integer';
    static: number;
    type: 'integer';
}
/** `[Json]` Creates an Integer type */
export declare function Integer(options?: IntegerOptions): TInteger;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\integer\integer.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Integer = Integer;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates an Integer type */
function Integer(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Integer', type: 'integer' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\index.d.ts

Code:
export * from './intersect-evaluated';
export * from './intersect-type';
export * from './intersect';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./intersect-evaluated"), exports);
__exportStar(require("./intersect-type"), exports);
__exportStar(require("./intersect"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-create.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TIntersect, IntersectOptions } from './intersect-type';
export declare function IntersectCreate<T extends TSchema[]>(T: [...T], options?: IntersectOptions): TIntersect<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-create.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IntersectCreate = IntersectCreate;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// ------------------------------------------------------------------
// IntersectCreate
// ------------------------------------------------------------------
// prettier-ignore
function IntersectCreate(T, options = {}) {
    const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties)
        ? { unevaluatedProperties: options.unevaluatedProperties }
        : {};
    return (0, type_1.CreateType)((options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects
        ? { ...clonedUnevaluatedProperties, [index_1.Kind]: 'Intersect', type: 'object', allOf: T }
        : { ...clonedUnevaluatedProperties, [index_1.Kind]: 'Intersect', allOf: T }), options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-evaluated.d.ts

Code:
import type { TSchema } from '../schema/index';
import { type TNever } from '../never/index';
import { type TOptional } from '../optional/index';
import type { TReadonly } from '../readonly/index';
import { TIntersect, IntersectOptions } from './intersect-type';
type TIsIntersectOptional<Types extends TSchema[]> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<TSchema> ? TIsIntersectOptional<Right> : false : true);
type TRemoveOptionalFromType<Type extends TSchema> = (Type extends TReadonly<infer Type extends TSchema> ? TReadonly<TRemoveOptionalFromType<Type>> : Type extends TOptional<infer Type extends TSchema> ? TRemoveOptionalFromType<Type> : Type);
type TRemoveOptionalFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<infer Type extends TSchema> ? TRemoveOptionalFromRest<Right, [...Result, TRemoveOptionalFromType<Type>]> : TRemoveOptionalFromRest<Right, [...Result, Left]> : Result);
type TResolveIntersect<Types extends TSchema[]> = (TIsIntersectOptional<Types> extends true ? TOptional<TIntersect<TRemoveOptionalFromRest<Types>>> : TIntersect<TRemoveOptionalFromRest<Types>>);
export type TIntersectEvaluated<Types extends TSchema[]> = (Types extends [TSchema] ? Types[0] : Types extends [] ? TNever : TResolveIntersect<Types>);
/** `[Json]` Creates an evaluated Intersect type */
export declare function IntersectEvaluated<Types extends TSchema[], Result extends TSchema = TIntersectEvaluated<Types>>(types: [...Types], options?: IntersectOptions): Result;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-evaluated.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IntersectEvaluated = IntersectEvaluated;
const index_1 = require("../symbols/index");
const type_1 = require("../create/type");
const index_2 = require("../discard/index");
const index_3 = require("../never/index");
const index_4 = require("../optional/index");
const intersect_create_1 = require("./intersect-create");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function IsIntersectOptional(types) {
    return types.every(left => (0, kind_1.IsOptional)(left));
}
// prettier-ignore
function RemoveOptionalFromType(type) {
    return ((0, index_2.Discard)(type, [index_1.OptionalKind]));
}
// prettier-ignore
function RemoveOptionalFromRest(types) {
    return types.map(left => (0, kind_1.IsOptional)(left) ? RemoveOptionalFromType(left) : left);
}
// prettier-ignore
function ResolveIntersect(types, options) {
    return (IsIntersectOptional(types)
        ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(types), options))
        : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(types), options));
}
/** `[Json]` Creates an evaluated Intersect type */
function IntersectEvaluated(types, options = {}) {
    if (types.length === 1)
        return (0, type_1.CreateType)(types[0], options);
    if (types.length === 0)
        return (0, index_3.Never)(options);
    if (types.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error('Cannot intersect transform types');
    return ResolveIntersect(types, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-type.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
type TIntersectStatic<T extends TSchema[], P extends unknown[], Acc extends unknown = unknown> = T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TIntersectStatic<R, P, Acc & Static<L, P>> : Acc;
export type TUnevaluatedProperties = undefined | TSchema | boolean;
export interface IntersectOptions extends SchemaOptions {
    unevaluatedProperties?: TUnevaluatedProperties;
}
export interface TIntersect<T extends TSchema[] = TSchema[]> extends TSchema, IntersectOptions {
    [Kind]: 'Intersect';
    static: TIntersectStatic<T, this['params']>;
    type?: 'object';
    allOf: [...T];
}
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect-type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../symbols/index");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect.d.ts

Code:
import type { TSchema } from '../schema/index';
import { type TNever } from '../never/index';
import { TIntersect, IntersectOptions } from './intersect-type';
export type Intersect<Types extends TSchema[]> = (Types extends [TSchema] ? Types[0] : Types extends [] ? TNever : TIntersect<Types>);
/** `[Json]` Creates an evaluated Intersect type */
export declare function Intersect<Types extends TSchema[]>(types: [...Types], options?: IntersectOptions): Intersect<Types>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intersect\intersect.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Intersect = Intersect;
const type_1 = require("../create/type");
const index_1 = require("../never/index");
const intersect_create_1 = require("./intersect-create");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
/** `[Json]` Creates an evaluated Intersect type */
function Intersect(types, options) {
    if (types.length === 1)
        return (0, type_1.CreateType)(types[0], options);
    if (types.length === 0)
        return (0, index_1.Never)(options);
    if (types.some((schema) => (0, kind_1.IsTransform)(schema)))
        throw new Error('Cannot intersect transform types');
    return (0, intersect_create_1.IntersectCreate)(types, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\capitalize.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TIntrinsic } from './intrinsic';
export type TCapitalize<T extends TSchema> = TIntrinsic<T, 'Capitalize'>;
/** `[Json]` Intrinsic function to Capitalize LiteralString types */
export declare function Capitalize<T extends TSchema>(T: T, options?: SchemaOptions): TCapitalize<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\capitalize.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Capitalize = Capitalize;
const intrinsic_1 = require("./intrinsic");
/** `[Json]` Intrinsic function to Capitalize LiteralString types */
function Capitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, 'Capitalize', options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\index.d.ts

Code:
export * from './capitalize';
export * from './intrinsic-from-mapped-key';
export * from './intrinsic';
export * from './lowercase';
export * from './uncapitalize';
export * from './uppercase';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./capitalize"), exports);
__exportStar(require("./intrinsic-from-mapped-key"), exports);
__exportStar(require("./intrinsic"), exports);
__exportStar(require("./lowercase"), exports);
__exportStar(require("./uncapitalize"), exports);
__exportStar(require("./uppercase"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\intrinsic-from-mapped-key.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import { Assert } from '../helpers/index';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
import { type TIntrinsic, type IntrinsicMode } from './intrinsic';
import { type TLiteral, type TLiteralValue } from '../literal/index';
type TMappedIntrinsicPropertyKey<K extends PropertyKey, M extends IntrinsicMode> = {
    [_ in K]: TIntrinsic<TLiteral<Assert<K, TLiteralValue>>, M>;
};
type TMappedIntrinsicPropertyKeys<K extends PropertyKey[], M extends IntrinsicMode, Acc extends TProperties = {}> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedIntrinsicPropertyKeys<R, M, Acc & TMappedIntrinsicPropertyKey<L, M>> : Acc);
type TMappedIntrinsicProperties<K extends TMappedKey, M extends IntrinsicMode> = (TMappedIntrinsicPropertyKeys<K['keys'], M>);
export type TIntrinsicFromMappedKey<K extends TMappedKey, M extends IntrinsicMode, P extends TProperties = TMappedIntrinsicProperties<K, M>> = (TMappedResult<P>);
export declare function IntrinsicFromMappedKey<K extends TMappedKey, M extends IntrinsicMode, P extends TProperties = TMappedIntrinsicProperties<K, M>>(T: K, M: M, options: SchemaOptions): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\intrinsic-from-mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
const index_1 = require("../mapped/index");
const intrinsic_1 = require("./intrinsic");
const index_2 = require("../literal/index");
const value_1 = require("../clone/value");
// prettier-ignore
function MappedIntrinsicPropertyKey(K, M, options) {
    return {
        [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, (0, value_1.Clone)(options))
    };
}
// prettier-ignore
function MappedIntrinsicPropertyKeys(K, M, options) {
    const result = K.reduce((Acc, L) => {
        return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
    return result;
}
// prettier-ignore
function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T['keys'], M, options);
}
// prettier-ignore
function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\intrinsic.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TTemplateLiteral, type TTemplateLiteralKind } from '../template-literal/index';
import { type TIntrinsicFromMappedKey } from './intrinsic-from-mapped-key';
import { type TLiteral } from '../literal/index';
import { type TUnion } from '../union/index';
import { type TMappedKey } from '../mapped/index';
export type IntrinsicMode = 'Uppercase' | 'Lowercase' | 'Capitalize' | 'Uncapitalize';
type TFromTemplateLiteral<T extends TTemplateLiteralKind[], M extends IntrinsicMode> = M extends IntrinsicMode ? T extends [infer L extends TTemplateLiteralKind, ...infer R extends TTemplateLiteralKind[]] ? [TIntrinsic<L, M>, ...TFromTemplateLiteral<R, M>] : T : T;
type TFromLiteralValue<T, M extends IntrinsicMode> = (T extends string ? M extends 'Uncapitalize' ? Uncapitalize<T> : M extends 'Capitalize' ? Capitalize<T> : M extends 'Uppercase' ? Uppercase<T> : M extends 'Lowercase' ? Lowercase<T> : string : T);
type TFromRest<T extends TSchema[], M extends IntrinsicMode, Acc extends TSchema[] = []> = T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, M, [...Acc, TIntrinsic<L, M>]> : Acc;
export type TIntrinsic<T extends TSchema, M extends IntrinsicMode> = T extends TMappedKey ? TIntrinsicFromMappedKey<T, M> : T extends TTemplateLiteral<infer S> ? TTemplateLiteral<TFromTemplateLiteral<S, M>> : T extends TUnion<infer S> ? TUnion<TFromRest<S, M>> : T extends TLiteral<infer S> ? TLiteral<TFromLiteralValue<S, M>> : T;
/** Applies an intrinsic string manipulation to the given type. */
export declare function Intrinsic<T extends TMappedKey, M extends IntrinsicMode>(schema: T, mode: M, options?: SchemaOptions): TIntrinsicFromMappedKey<T, M>;
/** Applies an intrinsic string manipulation to the given type. */
export declare function Intrinsic<T extends TSchema, M extends IntrinsicMode>(schema: T, mode: M, options?: SchemaOptions): TIntrinsic<T, M>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\intrinsic.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Intrinsic = Intrinsic;
const type_1 = require("../create/type");
const index_1 = require("../template-literal/index");
const intrinsic_from_mapped_key_1 = require("./intrinsic-from-mapped-key");
const index_2 = require("../literal/index");
const index_3 = require("../union/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// ------------------------------------------------------------------
// Apply
// ------------------------------------------------------------------
function ApplyUncapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join('');
}
function ApplyCapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join('');
}
function ApplyUppercase(value) {
    return value.toUpperCase();
}
function ApplyLowercase(value) {
    return value.toLowerCase();
}
function FromTemplateLiteral(schema, mode, options) {
    // note: template literals require special runtime handling as they are encoded in string patterns.
    // This diverges from the mapped type which would otherwise map on the template literal kind.
    const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
    const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite)
        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value) => (0, index_2.Literal)(value));
    const mapped = FromRest(literals, mode);
    const union = (0, index_3.Union)(mapped);
    return (0, index_1.TemplateLiteral)([union], options);
}
// prettier-ignore
function FromLiteralValue(value, mode) {
    return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :
        mode === 'Capitalize' ? ApplyCapitalize(value) :
            mode === 'Uppercase' ? ApplyUppercase(value) :
                mode === 'Lowercase' ? ApplyLowercase(value) :
                    value) : value.toString());
}
// prettier-ignore
function FromRest(T, M) {
    return T.map(L => Intrinsic(L, M));
}
/** Applies an intrinsic string manipulation to the given type. */
function Intrinsic(schema, mode, options = {}) {
    // prettier-ignore
    return (
    // Intrinsic-Mapped-Inference
    (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) :
        // Standard-Inference
        (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, options) :
            (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) :
                (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) :
                    // Default Type
                    (0, type_1.CreateType)(schema, options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\lowercase.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TIntrinsic } from './intrinsic';
export type TLowercase<T extends TSchema> = TIntrinsic<T, 'Lowercase'>;
/** `[Json]` Intrinsic function to Lowercase LiteralString types */
export declare function Lowercase<T extends TSchema>(T: T, options?: SchemaOptions): TLowercase<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\lowercase.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Lowercase = Lowercase;
const intrinsic_1 = require("./intrinsic");
/** `[Json]` Intrinsic function to Lowercase LiteralString types */
function Lowercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, 'Lowercase', options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\uncapitalize.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TIntrinsic } from './intrinsic';
export type TUncapitalize<T extends TSchema> = TIntrinsic<T, 'Uncapitalize'>;
/** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
export declare function Uncapitalize<T extends TSchema>(T: T, options?: SchemaOptions): TUncapitalize<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\uncapitalize.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Uncapitalize = Uncapitalize;
const intrinsic_1 = require("./intrinsic");
/** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
function Uncapitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, 'Uncapitalize', options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\uppercase.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TIntrinsic } from './intrinsic';
export type TUppercase<T extends TSchema> = TIntrinsic<T, 'Uppercase'>;
/** `[Json]` Intrinsic function to Uppercase LiteralString types */
export declare function Uppercase<T extends TSchema>(T: T, options?: SchemaOptions): TUppercase<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\intrinsic\uppercase.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Uppercase = Uppercase;
const intrinsic_1 = require("./intrinsic");
/** `[Json]` Intrinsic function to Uppercase LiteralString types */
function Uppercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, 'Uppercase', options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\iterator\index.d.ts

Code:
export * from './iterator';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\iterator\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./iterator"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\iterator\iterator.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
export interface TIterator<T extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Iterator';
    static: IterableIterator<Static<T, this['params']>>;
    type: 'Iterator';
    items: T;
}
/** `[JavaScript]` Creates an Iterator type */
export declare function Iterator<T extends TSchema>(items: T, options?: SchemaOptions): TIterator<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\iterator\iterator.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Iterator = Iterator;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates an Iterator type */
function Iterator(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Iterator', type: 'Iterator', items }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\index.d.ts

Code:
export * from './keyof-from-mapped-result';
export * from './keyof-property-entries';
export * from './keyof-property-keys';
export * from './keyof';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./keyof-from-mapped-result"), exports);
__exportStar(require("./keyof-property-entries"), exports);
__exportStar(require("./keyof-property-keys"), exports);
__exportStar(require("./keyof"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-from-mapped-result.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TKeyOfFromType } from './keyof';
type TFromProperties<Properties extends TProperties> = ({
    [K2 in keyof Properties]: TKeyOfFromType<Properties[K2]>;
});
type TFromMappedResult<MappedResult extends TMappedResult> = (Evaluate<TFromProperties<MappedResult['properties']>>);
export type TKeyOfFromMappedResult<MappedResult extends TMappedResult, Properties extends TProperties = TFromMappedResult<MappedResult>> = (Ensure<TMappedResult<Properties>>);
export declare function KeyOfFromMappedResult<MappedResult extends TMappedResult, Properties extends TProperties = TFromMappedResult<MappedResult>>(mappedResult: MappedResult, options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyOfFromMappedResult = KeyOfFromMappedResult;
const index_1 = require("../mapped/index");
const keyof_1 = require("./keyof");
const value_1 = require("../clone/value");
// prettier-ignore
function FromProperties(properties, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = (0, keyof_1.KeyOf)(properties[K2], (0, value_1.Clone)(options));
    return result;
}
// prettier-ignore
function FromMappedResult(mappedResult, options) {
    return FromProperties(mappedResult.properties, options);
}
// prettier-ignore
function KeyOfFromMappedResult(mappedResult, options) {
    const properties = FromMappedResult(mappedResult, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-property-entries.d.ts

Code:
import { TSchema } from '../schema/index';
/**
 * `[Utility]` Resolves an array of keys and schemas from the given schema. This method is faster
 * than obtaining the keys and resolving each individually via indexing. This method was written
 * accellerate Intersect and Union encoding.
 */
export declare function KeyOfPropertyEntries(schema: TSchema): [key: string, schema: TSchema][];


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-property-entries.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyOfPropertyEntries = KeyOfPropertyEntries;
const indexed_1 = require("../indexed/indexed");
const keyof_property_keys_1 = require("./keyof-property-keys");
/**
 * `[Utility]` Resolves an array of keys and schemas from the given schema. This method is faster
 * than obtaining the keys and resolving each individually via indexing. This method was written
 * accellerate Intersect and Union encoding.
 */
function KeyOfPropertyEntries(schema) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
    return keys.map((_, index) => [keys[index], schemas[index]]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-property-keys.d.ts

Code:
import type { TSchema } from '../schema/index';
import { type ZeroString, type UnionToTuple, type TIncrement } from '../helpers/index';
import type { TRecursive } from '../recursive/index';
import type { TIntersect } from '../intersect/index';
import type { TUnion } from '../union/index';
import type { TTuple } from '../tuple/index';
import type { TArray } from '../array/index';
import type { TObject, TProperties } from '../object/index';
import { type TSetUnionMany, type TSetIntersectMany } from '../sets/index';
type TFromRest<Types extends TSchema[], Result extends PropertyKey[][] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, [...Result, TKeyOfPropertyKeys<L>]> : Result);
type TFromIntersect<Types extends TSchema[], PropertyKeysArray extends PropertyKey[][] = TFromRest<Types>, PropertyKeys extends PropertyKey[] = TSetUnionMany<PropertyKeysArray>> = PropertyKeys;
type TFromUnion<Types extends TSchema[], PropertyKeysArray extends PropertyKey[][] = TFromRest<Types>, PropertyKeys extends PropertyKey[] = TSetIntersectMany<PropertyKeysArray>> = PropertyKeys;
type TFromTuple<Types extends TSchema[], Indexer extends string = ZeroString, Acc extends PropertyKey[] = []> = Types extends [infer _ extends TSchema, ...infer R extends TSchema[]] ? TFromTuple<R, TIncrement<Indexer>, [...Acc, Indexer]> : Acc;
type TFromArray<_ extends TSchema> = ([
    '[number]'
]);
type TFromProperties<Properties extends TProperties> = (UnionToTuple<keyof Properties>);
export type TKeyOfPropertyKeys<Type extends TSchema> = (Type extends TRecursive<infer Type extends TSchema> ? TKeyOfPropertyKeys<Type> : Type extends TIntersect<infer Types extends TSchema[]> ? TFromIntersect<Types> : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<Types> : Type extends TTuple<infer Types extends TSchema[]> ? TFromTuple<Types> : Type extends TArray<infer Type extends TSchema> ? TFromArray<Type> : Type extends TObject<infer Properties extends TProperties> ? TFromProperties<Properties> : [
]);
/** Returns a tuple of PropertyKeys derived from the given TSchema. */
export declare function KeyOfPropertyKeys<Type extends TSchema>(type: Type): TKeyOfPropertyKeys<Type>;
/** Returns a regular expression pattern derived from the given TSchema */
export declare function KeyOfPattern(schema: TSchema): string;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof-property-keys.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyOfPropertyKeys = KeyOfPropertyKeys;
exports.KeyOfPattern = KeyOfPattern;
const index_1 = require("../sets/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromRest(types) {
    const result = [];
    for (const L of types)
        result.push(KeyOfPropertyKeys(L));
    return result;
}
// prettier-ignore
function FromIntersect(types) {
    const propertyKeysArray = FromRest(types);
    const propertyKeys = (0, index_1.SetUnionMany)(propertyKeysArray);
    return propertyKeys;
}
// prettier-ignore
function FromUnion(types) {
    const propertyKeysArray = FromRest(types);
    const propertyKeys = (0, index_1.SetIntersectMany)(propertyKeysArray);
    return propertyKeys;
}
// prettier-ignore
function FromTuple(types) {
    return types.map((_, indexer) => indexer.toString());
}
// prettier-ignore
function FromArray(_) {
    return (['[number]']);
}
// prettier-ignore
function FromProperties(T) {
    return (globalThis.Object.getOwnPropertyNames(T));
}
// ------------------------------------------------------------------
// FromPatternProperties
// ------------------------------------------------------------------
// prettier-ignore
function FromPatternProperties(patternProperties) {
    if (!includePatternProperties)
        return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map(key => {
        return (key[0] === '^' && key[key.length - 1] === '$')
            ? key.slice(1, key.length - 1)
            : key;
    });
}
/** Returns a tuple of PropertyKeys derived from the given TSchema. */
// prettier-ignore
function KeyOfPropertyKeys(type) {
    return ((0, kind_1.IsIntersect)(type) ? FromIntersect(type.allOf) :
        (0, kind_1.IsUnion)(type) ? FromUnion(type.anyOf) :
            (0, kind_1.IsTuple)(type) ? FromTuple(type.items ?? []) :
                (0, kind_1.IsArray)(type) ? FromArray(type.items) :
                    (0, kind_1.IsObject)(type) ? FromProperties(type.properties) :
                        (0, kind_1.IsRecord)(type) ? FromPatternProperties(type.patternProperties) :
                            []);
}
// ----------------------------------------------------------------
// KeyOfPattern
// ----------------------------------------------------------------
let includePatternProperties = false;
/** Returns a regular expression pattern derived from the given TSchema */
function KeyOfPattern(schema) {
    includePatternProperties = true;
    const keys = KeyOfPropertyKeys(schema);
    includePatternProperties = false;
    const pattern = keys.map((key) => `(${key})`);
    return `^(${pattern.join('|')})$`;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Assert, Ensure } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import type { SchemaOptions } from '../schema/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TNumber } from '../number/index';
import { TComputed } from '../computed/index';
import { type TRef } from '../ref/index';
import { type TKeyOfPropertyKeys } from './keyof-property-keys';
import { type TUnionEvaluated } from '../union/index';
import { type TKeyOfFromMappedResult } from './keyof-from-mapped-result';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<TComputed<'KeyOf', [TComputed<Target, Parameters>]>>;
type TFromRef<Ref extends string> = Ensure<TComputed<'KeyOf', [TRef<Ref>]>>;
/** `[Internal]` Used by KeyOfFromMappedResult */
export type TKeyOfFromType<Type extends TSchema, PropertyKeys extends PropertyKey[] = TKeyOfPropertyKeys<Type>, PropertyKeyTypes extends TSchema[] = TKeyOfPropertyKeysToRest<PropertyKeys>, Result = TUnionEvaluated<PropertyKeyTypes>> = Ensure<Result>;
export type TKeyOfPropertyKeysToRest<PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = (PropertyKeys extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? L extends '[number]' ? TKeyOfPropertyKeysToRest<R, [...Result, TNumber]> : TKeyOfPropertyKeysToRest<R, [...Result, TLiteral<Assert<L, TLiteralValue>>]> : Result);
export declare function KeyOfPropertyKeysToRest<PropertyKeys extends PropertyKey[]>(propertyKeys: [...PropertyKeys]): TKeyOfPropertyKeysToRest<PropertyKeys>;
export type TKeyOf<Type extends TSchema> = (Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TMappedResult ? TKeyOfFromMappedResult<Type> : TKeyOfFromType<Type>);
/** `[Json]` Creates a KeyOf type */
export declare function KeyOf<Type extends TSchema>(type: Type, options?: SchemaOptions): TKeyOf<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\keyof\keyof.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
exports.KeyOf = KeyOf;
const type_1 = require("../create/type");
const index_1 = require("../literal/index");
const index_2 = require("../number/index");
const index_3 = require("../computed/index");
const index_4 = require("../ref/index");
const keyof_property_keys_1 = require("./keyof-property-keys");
const index_5 = require("../union/index");
const keyof_from_mapped_result_1 = require("./keyof-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromComputed(target, parameters) {
    return (0, index_3.Computed)('KeyOf', [(0, index_3.Computed)(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return (0, index_3.Computed)('KeyOf', [(0, index_4.Ref)($ref)]);
}
// prettier-ignore
function KeyOfFromType(type, options) {
    const propertyKeys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(type);
    const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
    const result = (0, index_5.UnionEvaluated)(propertyKeyTypes);
    return (0, type_1.CreateType)(result, options);
}
// prettier-ignore
function KeyOfPropertyKeysToRest(propertyKeys) {
    return propertyKeys.map(L => L === '[number]' ? (0, index_2.Number)() : (0, index_1.Literal)(L));
}
/** `[Json]` Creates a KeyOf type */
function KeyOf(type, options) {
    return ((0, kind_1.IsComputed)(type) ? FromComputed(type.target, type.parameters) : (0, kind_1.IsRef)(type) ? FromRef(type.$ref) : (0, kind_1.IsMappedResult)(type) ? (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(type, options) : KeyOfFromType(type, options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\literal\index.d.ts

Code:
export * from './literal';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\literal\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./literal"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\literal\literal.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export type TLiteralValue = boolean | number | string;
export interface TLiteral<T extends TLiteralValue = TLiteralValue> extends TSchema {
    [Kind]: 'Literal';
    static: T;
    const: T;
}
/** `[Json]` Creates a Literal type */
export declare function Literal<T extends TLiteralValue>(value: T, options?: SchemaOptions): TLiteral<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\literal\literal.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Literal = Literal;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Literal type */
function Literal(value, options) {
    return (0, type_1.CreateType)({
        [index_1.Kind]: 'Literal',
        const: value,
        type: typeof value,
    }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\index.d.ts

Code:
export * from './mapped-key';
export * from './mapped-result';
export * from './mapped';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./mapped-key"), exports);
__exportStar(require("./mapped-result"), exports);
__exportStar(require("./mapped"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped-key.d.ts

Code:
import type { TSchema } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TMappedKey<T extends PropertyKey[] = PropertyKey[]> extends TSchema {
    [Kind]: 'MappedKey';
    static: T[number];
    keys: T;
}
export declare function MappedKey<T extends PropertyKey[]>(T: [...T]): TMappedKey<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedKey = MappedKey;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
// prettier-ignore
function MappedKey(T) {
    return (0, type_1.CreateType)({
        [index_1.Kind]: 'MappedKey',
        keys: T
    });
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped-result.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TProperties } from '../object/index';
import { Kind } from '../symbols/index';
export interface TMappedResult<T extends TProperties = TProperties> extends TSchema {
    [Kind]: 'MappedResult';
    properties: T;
    static: unknown;
}
export declare function MappedResult<T extends TProperties>(properties: T): TMappedResult<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedResult = MappedResult;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
// prettier-ignore
function MappedResult(properties) {
    return (0, type_1.CreateType)({
        [index_1.Kind]: 'MappedResult',
        properties
    });
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Ensure, Evaluate, Assert } from '../helpers/index';
import { type TArray } from '../array/index';
import { type TAsyncIterator } from '../async-iterator/index';
import { type TConstructor } from '../constructor/index';
import { type TEnum, type TEnumRecord } from '../enum/index';
import { type TFunction } from '../function/index';
import { type TIndexPropertyKeys } from '../indexed/index';
import { type TIntersect } from '../intersect/index';
import { type TIterator } from '../iterator/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TObject, type TProperties, type ObjectOptions } from '../object/index';
import { type TOptional } from '../optional/index';
import { type TPromise } from '../promise/index';
import { type TReadonly } from '../readonly/index';
import { type TTuple } from '../tuple/index';
import { type TUnion } from '../union/index';
import { type TSetIncludes } from '../sets/index';
import { type TMappedResult } from './mapped-result';
import type { TMappedKey } from './mapped-key';
type TFromMappedResult<K extends PropertyKey, P extends TProperties> = (K extends keyof P ? FromSchemaType<K, P[K]> : TMappedResult<P>);
type TMappedKeyToKnownMappedResultProperties<K extends PropertyKey> = {
    [_ in K]: TLiteral<Assert<K, TLiteralValue>>;
};
type TMappedKeyToUnknownMappedResultProperties<P extends PropertyKey[], Acc extends TProperties = {}> = (P extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedKeyToUnknownMappedResultProperties<R, Acc & {
    [_ in L]: TLiteral<Assert<L, TLiteralValue>>;
}> : Acc);
type TMappedKeyToMappedResultProperties<K extends PropertyKey, P extends PropertyKey[]> = (TSetIncludes<P, K> extends true ? TMappedKeyToKnownMappedResultProperties<K> : TMappedKeyToUnknownMappedResultProperties<P>);
type TFromMappedKey<K extends PropertyKey, P extends PropertyKey[], R extends TProperties = TMappedKeyToMappedResultProperties<K, P>> = (TFromMappedResult<K, R>);
type TFromRest<K extends PropertyKey, T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<K, R, [...Acc, FromSchemaType<K, L>]> : Acc);
type FromProperties<K extends PropertyKey, T extends TProperties, R extends TProperties = Evaluate<{
    [K2 in keyof T]: FromSchemaType<K, T[K2]>;
}>> = R;
declare function FromProperties<K extends PropertyKey, T extends TProperties>(K: K, T: T): FromProperties<K, T>;
type FromSchemaType<K extends PropertyKey, T extends TSchema> = (T extends TReadonly<infer S extends TSchema> ? TReadonly<FromSchemaType<K, S>> : T extends TOptional<infer S extends TSchema> ? TOptional<FromSchemaType<K, S>> : T extends TMappedResult<infer P extends TProperties> ? TFromMappedResult<K, P> : T extends TMappedKey<infer P extends PropertyKey[]> ? TFromMappedKey<K, P> : T extends TConstructor<infer S extends TSchema[], infer R extends TSchema> ? TConstructor<TFromRest<K, S>, FromSchemaType<K, R>> : T extends TFunction<infer S extends TSchema[], infer R extends TSchema> ? TFunction<TFromRest<K, S>, FromSchemaType<K, R>> : T extends TAsyncIterator<infer S extends TSchema> ? TAsyncIterator<FromSchemaType<K, S>> : T extends TIterator<infer S extends TSchema> ? TIterator<FromSchemaType<K, S>> : T extends TIntersect<infer S extends TSchema[]> ? TIntersect<TFromRest<K, S>> : T extends TEnum<infer S extends TEnumRecord> ? TEnum<S> : T extends TUnion<infer S extends TSchema[]> ? TUnion<TFromRest<K, S>> : T extends TTuple<infer S extends TSchema[]> ? TTuple<TFromRest<K, S>> : T extends TObject<infer S extends TProperties> ? TObject<FromProperties<K, S>> : T extends TArray<infer S extends TSchema> ? TArray<FromSchemaType<K, S>> : T extends TPromise<infer S extends TSchema> ? TPromise<FromSchemaType<K, S>> : T);
declare function FromSchemaType<K extends PropertyKey, T extends TSchema>(K: K, T: T): FromSchemaType<K, T>;
export type TMappedFunctionReturnType<K extends PropertyKey[], T extends TSchema, Acc extends TProperties = {}> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedFunctionReturnType<R, T, Acc & {
    [_ in L]: FromSchemaType<L, T>;
}> : Acc);
export declare function MappedFunctionReturnType<K extends PropertyKey[], T extends TSchema>(K: [...K], T: T): TMappedFunctionReturnType<K, T>;
export type TMappedFunction<K extends PropertyKey[], I = TMappedKey<K>> = (T: I) => TSchema;
export type TMapped<K extends PropertyKey[], F extends TMappedFunction<K>, R extends TProperties = Evaluate<TMappedFunctionReturnType<K, ReturnType<F>>>> = Ensure<TObject<R>>;
/** `[Json]` Creates a Mapped object type */
export declare function Mapped<K extends TSchema, I extends PropertyKey[] = TIndexPropertyKeys<K>, F extends TMappedFunction<I> = TMappedFunction<I>, R extends TMapped<I, F> = TMapped<I, F>>(key: K, map: F, options?: ObjectOptions): R;
/** `[Json]` Creates a Mapped object type */
export declare function Mapped<K extends PropertyKey[], F extends TMappedFunction<K> = TMappedFunction<K>, R extends TMapped<K, F> = TMapped<K, F>>(key: [...K], map: F, options?: ObjectOptions): R;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\mapped\mapped.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedFunctionReturnType = MappedFunctionReturnType;
exports.Mapped = Mapped;
const index_1 = require("../symbols/index");
const index_2 = require("../discard/index");
// evaluation types
const index_3 = require("../array/index");
const index_4 = require("../async-iterator/index");
const index_5 = require("../constructor/index");
const index_6 = require("../function/index");
const index_7 = require("../indexed/index");
const index_8 = require("../intersect/index");
const index_9 = require("../iterator/index");
const index_10 = require("../literal/index");
const index_11 = require("../object/index");
const index_12 = require("../optional/index");
const index_13 = require("../promise/index");
const index_14 = require("../readonly/index");
const index_15 = require("../tuple/index");
const index_16 = require("../union/index");
// operator
const index_17 = require("../sets/index");
// mapping types
const mapped_result_1 = require("./mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function FromMappedResult(K, P) {
    return (K in P
        ? FromSchemaType(K, P[K])
        : (0, mapped_result_1.MappedResult)(P));
}
// prettier-ignore
function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
}
// prettier-ignore
function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
        Acc[L] = (0, index_10.Literal)(L);
    return Acc;
}
// prettier-ignore
function MappedKeyToMappedResultProperties(K, P) {
    return ((0, index_17.SetIncludes)(P, K)
        ? MappedKeyToKnownMappedResultProperties(K)
        : MappedKeyToUnknownMappedResultProperties(P));
}
// prettier-ignore
function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
}
// prettier-ignore
function FromRest(K, T) {
    return T.map(L => FromSchemaType(K, L));
}
// prettier-ignore
function FromProperties(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
        Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
}
// prettier-ignore
function FromSchemaType(K, T) {
    // required to retain user defined options for mapped type
    const options = { ...T };
    return (
    // unevaluated modifier types
    (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) :
        (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) :
            // unevaluated mapped types
            (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) :
                (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) :
                    // unevaluated types
                    (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) :
                        (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) :
                            (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items), options) :
                                (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items), options) :
                                    (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf), options) :
                                        (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf), options) :
                                            (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? []), options) :
                                                (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties), options) :
                                                    (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items), options) :
                                                        (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item), options) :
                                                            T);
}
// prettier-ignore
function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
        Acc[L] = FromSchemaType(L, T);
    return Acc;
}
/** `[Json]` Creates a Mapped object type */
function Mapped(key, map, options) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: 'MappedKey', keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, index_11.Object)(R, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\compute.d.ts

Code:
import { Ensure, Evaluate } from '../helpers/index';
import { type TSchema } from '../schema/index';
import { type TArray } from '../array/index';
import { type TAwaited } from '../awaited/index';
import { type TAsyncIterator } from '../async-iterator/index';
import { TComputed } from '../computed/index';
import { type TConstructor } from '../constructor/index';
import { type TIndex, type TIndexPropertyKeys } from '../indexed/index';
import { TEnum, type TEnumRecord } from '../enum/index';
import { type TFunction } from '../function/index';
import { type TIntersect, type TIntersectEvaluated } from '../intersect/index';
import { type TIterator } from '../iterator/index';
import { type TKeyOf } from '../keyof/index';
import { type TObject, type TProperties } from '../object/index';
import { type TOmit } from '../omit/index';
import { type TOptional } from '../optional/index';
import { type TPick } from '../pick/index';
import { type TNever } from '../never/index';
import { TPartial } from '../partial/index';
import { type TReadonly } from '../readonly/index';
import { type TRecordOrObject, type TRecord } from '../record/index';
import { type TRef } from '../ref/index';
import { type TRequired } from '../required/index';
import { type TTransform } from '../transform/index';
import { type TTuple } from '../tuple/index';
import { type TUnion, type TUnionEvaluated } from '../union/index';
type TDereferenceParameters<ModuleProperties extends TProperties, Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TRef<infer Key extends string> ? TDereferenceParameters<ModuleProperties, Right, [...Result, TDereference<ModuleProperties, Key>]> : TDereferenceParameters<ModuleProperties, Right, [...Result, TFromType<ModuleProperties, Left>]> : Result);
type TDereference<ModuleProperties extends TProperties, Ref extends string, Result extends TSchema = (Ref extends keyof ModuleProperties ? ModuleProperties[Ref] extends TRef<infer Ref2 extends string> ? TDereference<ModuleProperties, Ref2> : TFromType<ModuleProperties, ModuleProperties[Ref]> : TNever)> = Result;
type TFromAwaited<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TAwaited<T0> : never);
type TFromIndex<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TIndex<T0, TIndexPropertyKeys<T1>> extends infer Result extends TSchema ? Result : never : never);
type TFromKeyOf<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TKeyOf<T0> : never);
type TFromPartial<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TPartial<T0> : never);
type TFromOmit<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TOmit<T0, T1> : never);
type TFromPick<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TPick<T0, T1> : never);
type TFromRequired<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TRequired<T0> : never);
type TFromComputed<ModuleProperties extends TProperties, Target extends string, Parameters extends TSchema[], Dereferenced extends TSchema[] = TDereferenceParameters<ModuleProperties, Parameters>> = (Target extends 'Awaited' ? TFromAwaited<Dereferenced> : Target extends 'Index' ? TFromIndex<Dereferenced> : Target extends 'KeyOf' ? TFromKeyOf<Dereferenced> : Target extends 'Partial' ? TFromPartial<Dereferenced> : Target extends 'Omit' ? TFromOmit<Dereferenced> : Target extends 'Pick' ? TFromPick<Dereferenced> : Target extends 'Required' ? TFromRequired<Dereferenced> : TNever);
type TFromArray<ModuleProperties extends TProperties, Type extends TSchema> = (Ensure<TArray<TFromType<ModuleProperties, Type>>>);
type TFromAsyncIterator<ModuleProperties extends TProperties, Type extends TSchema> = (TAsyncIterator<TFromType<ModuleProperties, Type>>);
type TFromConstructor<ModuleProperties extends TProperties, Parameters extends TSchema[], InstanceType extends TSchema> = (TConstructor<TFromTypes<ModuleProperties, Parameters>, TFromType<ModuleProperties, InstanceType>>);
type TFromFunction<ModuleProperties extends TProperties, Parameters extends TSchema[], ReturnType extends TSchema> = Ensure<Ensure<TFunction<TFromTypes<ModuleProperties, Parameters>, TFromType<ModuleProperties, ReturnType>>>>;
type TFromIntersect<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TIntersectEvaluated<TFromTypes<ModuleProperties, Types>>>);
type TFromIterator<ModuleProperties extends TProperties, Type extends TSchema> = (TIterator<TFromType<ModuleProperties, Type>>);
type TFromObject<ModuleProperties extends TProperties, Properties extends TProperties> = Ensure<TObject<Evaluate<{
    [Key in keyof Properties]: TFromType<ModuleProperties, Properties[Key]>;
}>>>;
type TFromRecord<ModuleProperties extends TProperties, Key extends TSchema, Value extends TSchema, Result extends TSchema = TRecordOrObject<Key, TFromType<ModuleProperties, Value>>> = Result;
type TFromTransform<ModuleProperties extends TProperties, Input extends TSchema, Output extends unknown, Result extends TSchema = Input extends TRef<infer Key extends string> ? TTransform<TDereference<ModuleProperties, Key>, Output> : TTransform<Input, Output>> = Result;
type TFromTuple<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TTuple<TFromTypes<ModuleProperties, Types>>>);
type TFromUnion<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TUnionEvaluated<TFromTypes<ModuleProperties, Types>>>);
type TFromTypes<ModuleProperties extends TProperties, Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromTypes<ModuleProperties, Right, [...Result, TFromType<ModuleProperties, Left>]> : Result);
export type TFromType<ModuleProperties extends TProperties, Type extends TSchema> = (Type extends TOptional<infer Type extends TSchema> ? TOptional<TFromType<ModuleProperties, Type>> : Type extends TReadonly<infer Type extends TSchema> ? TReadonly<TFromType<ModuleProperties, Type>> : Type extends TTransform<infer Input extends TSchema, infer Output extends unknown> ? TFromTransform<ModuleProperties, Input, Output> : Type extends TArray<infer Type extends TSchema> ? TFromArray<ModuleProperties, Type> : Type extends TAsyncIterator<infer Type extends TSchema> ? TFromAsyncIterator<ModuleProperties, Type> : Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<ModuleProperties, Target, Parameters> : Type extends TConstructor<infer Parameters extends TSchema[], infer InstanceType extends TSchema> ? TFromConstructor<ModuleProperties, Parameters, InstanceType> : Type extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TFromFunction<ModuleProperties, Parameters, ReturnType> : Type extends TIntersect<infer Types extends TSchema[]> ? TFromIntersect<ModuleProperties, Types> : Type extends TIterator<infer Type extends TSchema> ? TFromIterator<ModuleProperties, Type> : Type extends TObject<infer Properties extends TProperties> ? TFromObject<ModuleProperties, Properties> : Type extends TRecord<infer Key extends TSchema, infer Value extends TSchema> ? TFromRecord<ModuleProperties, Key, Value> : Type extends TTuple<infer Types extends TSchema[]> ? TFromTuple<ModuleProperties, Types> : Type extends TEnum<infer _ extends TEnumRecord> ? Type : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<ModuleProperties, Types> : Type);
export declare function FromType<ModuleProperties extends TProperties, Type extends TSchema>(moduleProperties: ModuleProperties, type: Type): TFromType<ModuleProperties, Type>;
export type TComputeType<ModuleProperties extends TProperties, Key extends PropertyKey> = (Key extends keyof ModuleProperties ? TFromType<ModuleProperties, ModuleProperties[Key]> : TNever);
export declare function ComputeType<ModuleProperties extends TProperties, Key extends PropertyKey>(moduleProperties: ModuleProperties, key: Key): TComputeType<ModuleProperties, Key>;
export type TComputeModuleProperties<ModuleProperties extends TProperties> = Evaluate<{
    [Key in keyof ModuleProperties]: TComputeType<ModuleProperties, Key>;
}>;
export declare function ComputeModuleProperties<ModuleProperties extends TProperties>(moduleProperties: ModuleProperties): TComputeModuleProperties<ModuleProperties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\compute.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FromType = FromType;
exports.ComputeType = ComputeType;
exports.ComputeModuleProperties = ComputeModuleProperties;
const index_1 = require("../create/index");
const index_2 = require("../clone/index");
const index_3 = require("../discard/index");
const index_4 = require("../array/index");
const index_5 = require("../awaited/index");
const index_6 = require("../async-iterator/index");
const index_7 = require("../constructor/index");
const index_8 = require("../indexed/index");
const index_9 = require("../function/index");
const index_10 = require("../intersect/index");
const index_11 = require("../iterator/index");
const index_12 = require("../keyof/index");
const index_13 = require("../object/index");
const index_14 = require("../omit/index");
const index_15 = require("../pick/index");
const index_16 = require("../never/index");
const index_17 = require("../partial/index");
const index_18 = require("../record/index");
const index_19 = require("../required/index");
const index_20 = require("../tuple/index");
const index_21 = require("../union/index");
// ------------------------------------------------------------------
// Symbols
// ------------------------------------------------------------------
const index_22 = require("../symbols/index");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const KindGuard = require("../guard/kind");
// prettier-ignore
function DereferenceParameters(moduleProperties, types) {
    return types.map((type) => {
        return KindGuard.IsRef(type)
            ? Dereference(moduleProperties, type.$ref)
            : FromType(moduleProperties, type);
    });
}
// prettier-ignore
function Dereference(moduleProperties, ref) {
    return (ref in moduleProperties
        ? KindGuard.IsRef(moduleProperties[ref])
            ? Dereference(moduleProperties, moduleProperties[ref].$ref)
            : FromType(moduleProperties, moduleProperties[ref])
        : (0, index_16.Never)());
}
// prettier-ignore
function FromAwaited(parameters) {
    return (0, index_5.Awaited)(parameters[0]);
}
// prettier-ignore
function FromIndex(parameters) {
    return (0, index_8.Index)(parameters[0], parameters[1]);
}
// prettier-ignore
function FromKeyOf(parameters) {
    return (0, index_12.KeyOf)(parameters[0]);
}
// prettier-ignore
function FromPartial(parameters) {
    return (0, index_17.Partial)(parameters[0]);
}
// prettier-ignore
function FromOmit(parameters) {
    return (0, index_14.Omit)(parameters[0], parameters[1]);
}
// prettier-ignore
function FromPick(parameters) {
    return (0, index_15.Pick)(parameters[0], parameters[1]);
}
// prettier-ignore
function FromRequired(parameters) {
    return (0, index_19.Required)(parameters[0]);
}
// prettier-ignore
function FromComputed(moduleProperties, target, parameters) {
    const dereferenced = DereferenceParameters(moduleProperties, parameters);
    return (target === 'Awaited' ? FromAwaited(dereferenced) :
        target === 'Index' ? FromIndex(dereferenced) :
            target === 'KeyOf' ? FromKeyOf(dereferenced) :
                target === 'Partial' ? FromPartial(dereferenced) :
                    target === 'Omit' ? FromOmit(dereferenced) :
                        target === 'Pick' ? FromPick(dereferenced) :
                            target === 'Required' ? FromRequired(dereferenced) :
                                (0, index_16.Never)());
}
function FromArray(moduleProperties, type) {
    return (0, index_4.Array)(FromType(moduleProperties, type));
}
function FromAsyncIterator(moduleProperties, type) {
    return (0, index_6.AsyncIterator)(FromType(moduleProperties, type));
}
// prettier-ignore
function FromConstructor(moduleProperties, parameters, instanceType) {
    return (0, index_7.Constructor)(FromTypes(moduleProperties, parameters), FromType(moduleProperties, instanceType));
}
// prettier-ignore
function FromFunction(moduleProperties, parameters, returnType) {
    return (0, index_9.Function)(FromTypes(moduleProperties, parameters), FromType(moduleProperties, returnType));
}
function FromIntersect(moduleProperties, types) {
    return (0, index_10.Intersect)(FromTypes(moduleProperties, types));
}
function FromIterator(moduleProperties, type) {
    return (0, index_11.Iterator)(FromType(moduleProperties, type));
}
function FromObject(moduleProperties, properties) {
    return (0, index_13.Object)(globalThis.Object.keys(properties).reduce((result, key) => {
        return { ...result, [key]: FromType(moduleProperties, properties[key]) };
    }, {}));
}
// prettier-ignore
function FromRecord(moduleProperties, type) {
    const [value, pattern] = [FromType(moduleProperties, (0, index_18.RecordValue)(type)), (0, index_18.RecordPattern)(type)];
    const result = (0, index_2.CloneType)(type);
    result.patternProperties[pattern] = value;
    return result;
}
// prettier-ignore
function FromTransform(moduleProperties, transform) {
    return (KindGuard.IsRef(transform))
        ? { ...Dereference(moduleProperties, transform.$ref), [index_22.TransformKind]: transform[index_22.TransformKind] }
        : transform;
}
function FromTuple(moduleProperties, types) {
    return (0, index_20.Tuple)(FromTypes(moduleProperties, types));
}
function FromUnion(moduleProperties, types) {
    return (0, index_21.Union)(FromTypes(moduleProperties, types));
}
function FromTypes(moduleProperties, types) {
    return types.map((type) => FromType(moduleProperties, type));
}
// prettier-ignore
function FromType(moduleProperties, type) {
    return (
    // Modifiers
    KindGuard.IsOptional(type) ? (0, index_1.CreateType)(FromType(moduleProperties, (0, index_3.Discard)(type, [index_22.OptionalKind])), type) :
        KindGuard.IsReadonly(type) ? (0, index_1.CreateType)(FromType(moduleProperties, (0, index_3.Discard)(type, [index_22.ReadonlyKind])), type) :
            // Transform
            KindGuard.IsTransform(type) ? (0, index_1.CreateType)(FromTransform(moduleProperties, type), type) :
                // Types
                KindGuard.IsArray(type) ? (0, index_1.CreateType)(FromArray(moduleProperties, type.items), type) :
                    KindGuard.IsAsyncIterator(type) ? (0, index_1.CreateType)(FromAsyncIterator(moduleProperties, type.items), type) :
                        KindGuard.IsComputed(type) ? (0, index_1.CreateType)(FromComputed(moduleProperties, type.target, type.parameters)) :
                            KindGuard.IsConstructor(type) ? (0, index_1.CreateType)(FromConstructor(moduleProperties, type.parameters, type.returns), type) :
                                KindGuard.IsFunction(type) ? (0, index_1.CreateType)(FromFunction(moduleProperties, type.parameters, type.returns), type) :
                                    KindGuard.IsIntersect(type) ? (0, index_1.CreateType)(FromIntersect(moduleProperties, type.allOf), type) :
                                        KindGuard.IsIterator(type) ? (0, index_1.CreateType)(FromIterator(moduleProperties, type.items), type) :
                                            KindGuard.IsObject(type) ? (0, index_1.CreateType)(FromObject(moduleProperties, type.properties), type) :
                                                KindGuard.IsRecord(type) ? (0, index_1.CreateType)(FromRecord(moduleProperties, type)) :
                                                    KindGuard.IsTuple(type) ? (0, index_1.CreateType)(FromTuple(moduleProperties, type.items || []), type) :
                                                        KindGuard.IsUnion(type) ? (0, index_1.CreateType)(FromUnion(moduleProperties, type.anyOf), type) :
                                                            type);
}
// prettier-ignore
function ComputeType(moduleProperties, key) {
    return (key in moduleProperties
        ? FromType(moduleProperties, moduleProperties[key])
        : (0, index_16.Never)());
}
// prettier-ignore
function ComputeModuleProperties(moduleProperties) {
    return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
        return { ...result, [key]: ComputeType(moduleProperties, key) };
    }, {});
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\index.d.ts

Code:
export * from './module';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./module"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\infer.d.ts

Code:
import { Ensure, Evaluate } from '../helpers/index';
import { TSchema } from '../schema/index';
import { TArray } from '../array/index';
import { TAsyncIterator } from '../async-iterator/index';
import { TConstructor } from '../constructor/index';
import { TEnum, TEnumRecord } from '../enum/index';
import { TFunction } from '../function/index';
import { TIntersect } from '../intersect/index';
import { TIterator } from '../iterator/index';
import { TObject, TProperties } from '../object/index';
import { TOptional } from '../optional/index';
import { TRecord } from '../record/index';
import { TReadonly } from '../readonly/index';
import { TRef } from '../ref/index';
import { TTuple } from '../tuple/index';
import { TUnion } from '../union/index';
import { Static } from '../static/index';
import { TRecursive } from '../recursive/index';
type TInferArray<ModuleProperties extends TProperties, Type extends TSchema> = (Ensure<Array<TInfer<ModuleProperties, Type>>>);
type TInferAsyncIterator<ModuleProperties extends TProperties, Type extends TSchema> = (Ensure<AsyncIterableIterator<TInfer<ModuleProperties, Type>>>);
type TInferConstructor<ModuleProperties extends TProperties, Parameters extends TSchema[], InstanceType extends TSchema> = Ensure<new (...args: TInferTuple<ModuleProperties, Parameters>) => TInfer<ModuleProperties, InstanceType>>;
type TInferFunction<ModuleProperties extends TProperties, Parameters extends TSchema[], ReturnType extends TSchema> = Ensure<(...args: TInferTuple<ModuleProperties, Parameters>) => TInfer<ModuleProperties, ReturnType>>;
type TInferIterator<ModuleProperties extends TProperties, Type extends TSchema> = (Ensure<IterableIterator<TInfer<ModuleProperties, Type>>>);
type TInferIntersect<ModuleProperties extends TProperties, Types extends TSchema[], Result extends unknown = unknown> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TInferIntersect<ModuleProperties, Right, Result & TInfer<ModuleProperties, Left>> : Result);
type ReadonlyOptionalPropertyKeys<Properties extends TProperties> = {
    [Key in keyof Properties]: Properties[Key] extends TReadonly<TSchema> ? (Properties[Key] extends TOptional<Properties[Key]> ? Key : never) : never;
}[keyof Properties];
type ReadonlyPropertyKeys<Source extends TProperties> = {
    [Key in keyof Source]: Source[Key] extends TReadonly<TSchema> ? (Source[Key] extends TOptional<Source[Key]> ? never : Key) : never;
}[keyof Source];
type OptionalPropertyKeys<Source extends TProperties> = {
    [Key in keyof Source]: Source[Key] extends TOptional<TSchema> ? (Source[Key] extends TReadonly<Source[Key]> ? never : Key) : never;
}[keyof Source];
type RequiredPropertyKeys<Source extends TProperties> = keyof Omit<Source, ReadonlyOptionalPropertyKeys<Source> | ReadonlyPropertyKeys<Source> | OptionalPropertyKeys<Source>>;
type InferPropertiesWithModifiers<Properties extends TProperties, Source extends Record<keyof any, unknown>> = Evaluate<(Readonly<Partial<Pick<Source, ReadonlyOptionalPropertyKeys<Properties>>>> & Readonly<Pick<Source, ReadonlyPropertyKeys<Properties>>> & Partial<Pick<Source, OptionalPropertyKeys<Properties>>> & Required<Pick<Source, RequiredPropertyKeys<Properties>>>)>;
type InferProperties<ModuleProperties extends TProperties, Properties extends TProperties> = InferPropertiesWithModifiers<Properties, {
    [K in keyof Properties]: TInfer<ModuleProperties, Properties[K]>;
}>;
type TInferObject<ModuleProperties extends TProperties, Properties extends TProperties> = (InferProperties<ModuleProperties, Properties>);
type TInferTuple<ModuleProperties extends TProperties, Types extends TSchema[], Result extends unknown[] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TInferTuple<ModuleProperties, R, [...Result, TInfer<ModuleProperties, L>]> : Result);
type TInferRecord<ModuleProperties extends TProperties, Key extends TSchema, Type extends TSchema, InferredKey extends PropertyKey = TInfer<ModuleProperties, Key> extends infer Key extends PropertyKey ? Key : never, InferedType extends unknown = TInfer<ModuleProperties, Type>> = Ensure<{
    [_ in InferredKey]: InferedType;
}>;
type TInferRef<ModuleProperties extends TProperties, Ref extends string> = (Ref extends keyof ModuleProperties ? TInfer<ModuleProperties, ModuleProperties[Ref]> : unknown);
type TInferUnion<ModuleProperties extends TProperties, Types extends TSchema[], Result extends unknown = never> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TInferUnion<ModuleProperties, R, Result | TInfer<ModuleProperties, L>> : Result);
type TInfer<ModuleProperties extends TProperties, Type extends TSchema> = (Type extends TArray<infer Type extends TSchema> ? TInferArray<ModuleProperties, Type> : Type extends TAsyncIterator<infer Type extends TSchema> ? TInferAsyncIterator<ModuleProperties, Type> : Type extends TConstructor<infer Parameters extends TSchema[], infer InstanceType extends TSchema> ? TInferConstructor<ModuleProperties, Parameters, InstanceType> : Type extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TInferFunction<ModuleProperties, Parameters, ReturnType> : Type extends TIntersect<infer Types extends TSchema[]> ? TInferIntersect<ModuleProperties, Types> : Type extends TIterator<infer Type extends TSchema> ? TInferIterator<ModuleProperties, Type> : Type extends TObject<infer Properties extends TProperties> ? TInferObject<ModuleProperties, Properties> : Type extends TRecord<infer Key extends TSchema, infer Type extends TSchema> ? TInferRecord<ModuleProperties, Key, Type> : Type extends TRef<infer Ref extends string> ? TInferRef<ModuleProperties, Ref> : Type extends TTuple<infer Types extends TSchema[]> ? TInferTuple<ModuleProperties, Types> : Type extends TEnum<infer _ extends TEnumRecord> ? Static<Type> : Type extends TUnion<infer Types extends TSchema[]> ? TInferUnion<ModuleProperties, Types> : Type extends TRecursive<infer Schema extends TSchema> ? TInfer<ModuleProperties, Schema> : Static<Type>);
/** Inference Path for Imports. This type is used to compute TImport `static` */
export type TInferFromModuleKey<ModuleProperties extends TProperties, Key extends PropertyKey> = (Key extends keyof ModuleProperties ? TInfer<ModuleProperties, ModuleProperties[Key]> : never);
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\infer.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\module.d.ts

Code:
import { Kind } from '../symbols/index';
import { SchemaOptions, TSchema } from '../schema/index';
import { TProperties } from '../object/index';
import { Static } from '../static/index';
import { TComputeModuleProperties } from './compute';
import { TInferFromModuleKey } from './infer';
export interface TDefinitions<ModuleProperties extends TProperties> extends TSchema {
    static: {
        [K in keyof ModuleProperties]: Static<ModuleProperties[K]>;
    };
    $defs: ModuleProperties;
}
export interface TImport<ModuleProperties extends TProperties = {}, Key extends keyof ModuleProperties = keyof ModuleProperties> extends TSchema {
    [Kind]: 'Import';
    static: TInferFromModuleKey<ModuleProperties, Key>;
    $defs: ModuleProperties;
    $ref: Key;
}
export declare class TModule<ModuleProperties extends TProperties, ComputedModuleProperties extends TProperties = TComputeModuleProperties<ModuleProperties>> {
    private readonly $defs;
    constructor($defs: ModuleProperties);
    /** `[Json]` Imports a Type by Key. */
    Import<Key extends keyof ComputedModuleProperties>(key: Key, options?: SchemaOptions): TImport<ComputedModuleProperties, Key>;
    private WithIdentifiers;
}
/** `[Json]` Creates a Type Definition Module. */
export declare function Module<Properties extends TProperties>(properties: Properties): TModule<Properties>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\module\module.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TModule = void 0;
exports.Module = Module;
const index_1 = require("../create/index");
const index_2 = require("../symbols/index");
// ------------------------------------------------------------------
// Module Infrastructure Types
// ------------------------------------------------------------------
const compute_1 = require("./compute");
// ------------------------------------------------------------------
// Module
// ------------------------------------------------------------------
// prettier-ignore
class TModule {
    constructor($defs) {
        const computed = (0, compute_1.ComputeModuleProperties)($defs);
        const identified = this.WithIdentifiers(computed);
        this.$defs = identified;
    }
    /** `[Json]` Imports a Type by Key. */
    Import(key, options) {
        const $defs = { ...this.$defs, [key]: (0, index_1.CreateType)(this.$defs[key], options) };
        return (0, index_1.CreateType)({ [index_2.Kind]: 'Import', $defs, $ref: key });
    }
    // prettier-ignore
    WithIdentifiers($defs) {
        return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
            return { ...result, [key]: { ...$defs[key], $id: key } };
        }, {});
    }
}
exports.TModule = TModule;
/** `[Json]` Creates a Type Definition Module. */
function Module(properties) {
    return new TModule(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\never\index.d.ts

Code:
export * from './never';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\never\index.js

Code:
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });

__exportStar(require("./never"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\never\never.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TNever extends TSchema {
    [Kind]: 'Never';
    static: never;
    not: {};
}
/** `[Json]` Creates a Never type */
export declare function Never(options?: SchemaOptions): TNever;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\never\never.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Never = Never;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Never type */
function Never(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Never', not: {} }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\not\index.d.ts

Code:
export * from './not';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\not\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./not"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\not\not.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
export interface TNot<T extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Not';
    static: T extends TNot<infer U> ? Static<U> : unknown;
    not: T;
}
/** `[Json]` Creates a Not type */
export declare function Not<Type extends TSchema>(type: Type, options?: SchemaOptions): TNot<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\not\not.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Not = Not;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Not type */
function Not(type, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Not', not: type }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\null\index.d.ts

Code:
export * from './null';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\null\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./null"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\null\null.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TNull extends TSchema {
    [Kind]: 'Null';
    static: null;
    type: 'null';
}
/** `[Json]` Creates a Null type */
export declare function Null(options?: SchemaOptions): TNull;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\null\null.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Null = Null;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Null type */
function Null(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Null', type: 'null' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\number\index.d.ts

Code:
export * from './number';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\number\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./number"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\number\number.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface NumberOptions extends SchemaOptions {
    exclusiveMaximum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    minimum?: number;
    multipleOf?: number;
}
export interface TNumber extends TSchema, NumberOptions {
    [Kind]: 'Number';
    static: number;
    type: 'number';
}
/** `[Json]` Creates a Number type */
export declare function Number(options?: NumberOptions): TNumber;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\number\number.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Number = Number;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Number type */
function Number(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Number', type: 'number' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\object\index.d.ts

Code:
export * from './object';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\object\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./object"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\object\object.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import type { Evaluate } from '../helpers/index';
import type { TReadonly } from '../readonly/index';
import type { TOptional } from '../optional/index';
import { Kind } from '../symbols/index';
type ReadonlyOptionalPropertyKeys<T extends TProperties> = {
    [K in keyof T]: T[K] extends TReadonly<TSchema> ? (T[K] extends TOptional<T[K]> ? K : never) : never;
}[keyof T];
type ReadonlyPropertyKeys<T extends TProperties> = {
    [K in keyof T]: T[K] extends TReadonly<TSchema> ? (T[K] extends TOptional<T[K]> ? never : K) : never;
}[keyof T];
type OptionalPropertyKeys<T extends TProperties> = {
    [K in keyof T]: T[K] extends TOptional<TSchema> ? (T[K] extends TReadonly<T[K]> ? never : K) : never;
}[keyof T];
type RequiredPropertyKeys<T extends TProperties> = keyof Omit<T, ReadonlyOptionalPropertyKeys<T> | ReadonlyPropertyKeys<T> | OptionalPropertyKeys<T>>;
type ObjectStaticProperties<T extends TProperties, R extends Record<keyof any, unknown>> = Evaluate<(Readonly<Partial<Pick<R, ReadonlyOptionalPropertyKeys<T>>>> & Readonly<Pick<R, ReadonlyPropertyKeys<T>>> & Partial<Pick<R, OptionalPropertyKeys<T>>> & Required<Pick<R, RequiredPropertyKeys<T>>>)>;
type ObjectStatic<T extends TProperties, P extends unknown[]> = ObjectStaticProperties<T, {
    [K in keyof T]: Static<T[K], P>;
}>;
export type TPropertyKey = string | number;
export type TProperties = Record<TPropertyKey, TSchema>;
export type TAdditionalProperties = undefined | TSchema | boolean;
export interface ObjectOptions extends SchemaOptions {
    /** Additional property constraints for this object */
    additionalProperties?: TAdditionalProperties;
    /** The minimum number of properties allowed on this object */
    minProperties?: number;
    /** The maximum number of properties allowed on this object */
    maxProperties?: number;
}
export interface TObject<T extends TProperties = TProperties> extends TSchema, ObjectOptions {
    [Kind]: 'Object';
    static: ObjectStatic<T, this['params']>;
    additionalProperties?: TAdditionalProperties;
    type: 'object';
    properties: T;
    required?: string[];
}
/** `[Json]` Creates an Object type */
declare function _Object<T extends TProperties>(properties: T, options?: ObjectOptions): TObject<T>;
/** `[Json]` Creates an Object type */
export declare var Object: typeof _Object;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\object\object.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Object = void 0;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
function RequiredKeys(properties) {
    const keys = [];
    for (let key in properties) {
        if (!(0, kind_1.IsOptional)(properties[key]))
            keys.push(key);
    }
    return keys;
}
/** `[Json]` Creates an Object type */
function _Object(properties, options) {
    const required = RequiredKeys(properties);
    const schematic = required.length > 0 ? { [index_1.Kind]: 'Object', type: 'object', properties, required } : { [index_1.Kind]: 'Object', type: 'object', properties };
    return (0, type_1.CreateType)(schematic, options);
}
/** `[Json]` Creates an Object type */
exports.Object = _Object;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\index.d.ts

Code:
export * from './omit-from-mapped-key';
export * from './omit-from-mapped-result';
export * from './omit';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./omit-from-mapped-key"), exports);
__exportStar(require("./omit-from-mapped-result"), exports);
__exportStar(require("./omit"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit-from-mapped-key.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
import { type TOmit } from './omit';
type TFromPropertyKey<Type extends TSchema, Key extends PropertyKey> = {
    [_ in Key]: TOmit<Type, [Key]>;
};
type TFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[], Result extends TProperties = {}> = (PropertyKeys extends [infer LK extends PropertyKey, ...infer RK extends PropertyKey[]] ? TFromPropertyKeys<Type, RK, Result & TFromPropertyKey<Type, LK>> : Result);
type TFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey> = (TFromPropertyKeys<Type, MappedKey['keys']>);
export type TOmitFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TFromMappedKey<Type, MappedKey>> = (TMappedResult<Properties>);
export declare function OmitFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TFromMappedKey<Type, MappedKey>>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit-from-mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OmitFromMappedKey = OmitFromMappedKey;
const index_1 = require("../mapped/index");
const omit_1 = require("./omit");
const value_1 = require("../clone/value");
// prettier-ignore
function FromPropertyKey(type, key, options) {
    return { [key]: (0, omit_1.Omit)(type, [key], (0, value_1.Clone)(options)) };
}
// prettier-ignore
function FromPropertyKeys(type, propertyKeys, options) {
    return propertyKeys.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey(type, LK, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey(type, mappedKey, options) {
    return FromPropertyKeys(type, mappedKey.keys, options);
}
// prettier-ignore
function OmitFromMappedKey(type, mappedKey, options) {
    const properties = FromMappedKey(type, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit-from-mapped-result.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TOmit } from './omit';
type TFromProperties<Properties extends TProperties, PropertyKeys extends PropertyKey[]> = ({
    [K2 in keyof Properties]: TOmit<Properties[K2], PropertyKeys>;
});
type TFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[]> = (Evaluate<TFromProperties<MappedResult['properties'], PropertyKeys>>);
export type TOmitFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[], Properties extends TProperties = TFromMappedResult<MappedResult, PropertyKeys>> = (Ensure<TMappedResult<Properties>>);
export declare function OmitFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[], Properties extends TProperties = TFromMappedResult<MappedResult, PropertyKeys>>(mappedResult: MappedResult, propertyKeys: [...PropertyKeys], options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OmitFromMappedResult = OmitFromMappedResult;
const index_1 = require("../mapped/index");
const omit_1 = require("./omit");
const value_1 = require("../clone/value");
// prettier-ignore
function FromProperties(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = (0, omit_1.Omit)(properties[K2], propertyKeys, (0, value_1.Clone)(options));
    return result;
}
// prettier-ignore
function FromMappedResult(mappedResult, propertyKeys, options) {
    return FromProperties(mappedResult.properties, propertyKeys, options);
}
// prettier-ignore
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult(mappedResult, propertyKeys, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit.d.ts

Code:
import type { SchemaOptions, TSchema } from '../schema/index';
import type { TupleToUnion, Evaluate, Ensure } from '../helpers/index';
import { type TRecursive } from '../recursive/index';
import type { TMappedKey, TMappedResult } from '../mapped/index';
import { TComputed } from '../computed/index';
import { TLiteral, TLiteralValue } from '../literal/index';
import { type TIndexPropertyKeys } from '../indexed/index';
import { type TIntersect } from '../intersect/index';
import { type TUnion } from '../union/index';
import { type TObject, type TProperties } from '../object/index';
import { type TRef } from '../ref/index';
import { type TOmitFromMappedKey } from './omit-from-mapped-key';
import { type TOmitFromMappedResult } from './omit-from-mapped-result';
type TFromIntersect<Types extends TSchema[], PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromIntersect<R, PropertyKeys, [...Result, TOmit<L, PropertyKeys>]> : Result);
type TFromUnion<T extends TSchema[], K extends PropertyKey[], Result extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromUnion<R, K, [...Result, TOmit<L, K>]> : Result);
type TFromProperties<Properties extends TProperties, PropertyKeys extends PropertyKey[], UnionKey extends PropertyKey = TupleToUnion<PropertyKeys>> = (Evaluate<Omit<Properties, UnionKey>>);
type TFromObject<Type extends TObject, PropertyKeys extends PropertyKey[], Properties extends TProperties = Type['properties']> = Ensure<TObject<(TFromProperties<Properties, PropertyKeys>)>>;
type TUnionFromPropertyKeys<PropertyKeys extends PropertyKey[], Result extends TLiteral[] = []> = (PropertyKeys extends [infer Key extends PropertyKey, ...infer Rest extends PropertyKey[]] ? Key extends TLiteralValue ? TUnionFromPropertyKeys<Rest, [...Result, TLiteral<Key>]> : TUnionFromPropertyKeys<Rest, [...Result]> : TUnion<Result>);
export type TOmitResolve<Properties extends TProperties, PropertyKeys extends PropertyKey[]> = (Properties extends TRecursive<infer Types extends TSchema> ? TRecursive<TOmitResolve<Types, PropertyKeys>> : Properties extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromIntersect<Types, PropertyKeys>> : Properties extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromUnion<Types, PropertyKeys>> : Properties extends TObject<infer Types extends TProperties> ? TFromObject<TObject<Types>, PropertyKeys> : TObject<{}>);
type TResolvePropertyKeys<Key extends TSchema | PropertyKey[]> = Key extends TSchema ? TIndexPropertyKeys<Key> : Key;
type TResolveTypeKey<Key extends TSchema | PropertyKey[]> = Key extends PropertyKey[] ? TUnionFromPropertyKeys<Key> : Key;
export type TOmit<Type extends TSchema, Key extends TSchema | PropertyKey[], IsTypeRef extends boolean = Type extends TRef ? true : false, IsKeyRef extends boolean = Key extends TRef ? true : false> = (Type extends TMappedResult ? TOmitFromMappedResult<Type, TResolvePropertyKeys<Key>> : Key extends TMappedKey ? TOmitFromMappedKey<Type, Key> : [
    IsTypeRef,
    IsKeyRef
] extends [true, true] ? TComputed<'Omit', [Type, TResolveTypeKey<Key>]> : [
    IsTypeRef,
    IsKeyRef
] extends [false, true] ? TComputed<'Omit', [Type, TResolveTypeKey<Key>]> : [
    IsTypeRef,
    IsKeyRef
] extends [true, false] ? TComputed<'Omit', [Type, TResolveTypeKey<Key>]> : TOmitResolve<Type, TResolvePropertyKeys<Key>>);
/** `[Json]` Constructs a type whose keys are picked from the given type */
export declare function Omit<Type extends TSchema, Key extends PropertyKey[]>(type: Type, key: readonly [...Key], options?: SchemaOptions): TOmit<Type, Key>;
/** `[Json]` Constructs a type whose keys are picked from the given type */
export declare function Omit<Type extends TSchema, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TOmit<Type, Key>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\omit\omit.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Omit = Omit;
const type_1 = require("../create/type");
const discard_1 = require("../discard/discard");
const symbols_1 = require("../symbols/symbols");
const index_1 = require("../computed/index");
const index_2 = require("../literal/index");
const index_3 = require("../indexed/index");
const index_4 = require("../intersect/index");
const index_5 = require("../union/index");
const index_6 = require("../object/index");
// ------------------------------------------------------------------
// Mapped
// ------------------------------------------------------------------
const omit_from_mapped_key_1 = require("./omit-from-mapped-key");
const omit_from_mapped_result_1 = require("./omit-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
const value_1 = require("../guard/value");
// prettier-ignore
function FromIntersect(types, propertyKeys) {
    return types.map((type) => OmitResolve(type, propertyKeys));
}
// prettier-ignore
function FromUnion(types, propertyKeys) {
    return types.map((type) => OmitResolve(type, propertyKeys));
}
// ------------------------------------------------------------------
// FromProperty
// ------------------------------------------------------------------
// prettier-ignore
function FromProperty(properties, key) {
    const { [key]: _, ...R } = properties;
    return R;
}
// prettier-ignore
function FromProperties(properties, propertyKeys) {
    return propertyKeys.reduce((T, K2) => FromProperty(T, K2), properties);
}
// prettier-ignore
function FromObject(properties, propertyKeys) {
    const options = (0, discard_1.Discard)(properties, [symbols_1.TransformKind, '$id', 'required', 'properties']);
    const omittedProperties = FromProperties(properties['properties'], propertyKeys);
    return (0, index_6.Object)(omittedProperties, options);
}
// prettier-ignore
function UnionFromPropertyKeys(propertyKeys) {
    const result = propertyKeys.reduce((result, key) => (0, kind_1.IsLiteralValue)(key) ? [...result, (0, index_2.Literal)(key)] : result, []);
    return (0, index_5.Union)(result);
}
// prettier-ignore
function OmitResolve(properties, propertyKeys) {
    return ((0, kind_1.IsIntersect)(properties) ? (0, index_4.Intersect)(FromIntersect(properties.allOf, propertyKeys)) :
        (0, kind_1.IsUnion)(properties) ? (0, index_5.Union)(FromUnion(properties.anyOf, propertyKeys)) :
            (0, kind_1.IsObject)(properties) ? FromObject(properties, propertyKeys) :
                (0, index_6.Object)({}));
}
/** `[Json]` Constructs a type whose keys are picked from the given type */
// prettier-ignore
function Omit(type, key, options) {
    const typeKey = (0, value_1.IsArray)(key) ? UnionFromPropertyKeys(key) : key;
    const propertyKeys = (0, kind_1.IsSchema)(key) ? (0, index_3.IndexPropertyKeys)(key) : key;
    const isTypeRef = (0, kind_1.IsRef)(type);
    const isKeyRef = (0, kind_1.IsRef)(key);
    return ((0, kind_1.IsMappedResult)(type) ? (0, omit_from_mapped_result_1.OmitFromMappedResult)(type, propertyKeys, options) :
        (0, kind_1.IsMappedKey)(key) ? (0, omit_from_mapped_key_1.OmitFromMappedKey)(type, key, options) :
            (isTypeRef && isKeyRef) ? (0, index_1.Computed)('Omit', [type, typeKey], options) :
                (!isTypeRef && isKeyRef) ? (0, index_1.Computed)('Omit', [type, typeKey], options) :
                    (isTypeRef && !isKeyRef) ? (0, index_1.Computed)('Omit', [type, typeKey], options) :
                        (0, type_1.CreateType)({ ...OmitResolve(type, propertyKeys), ...options }));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\index.d.ts

Code:
export * from './optional-from-mapped-result';
export * from './optional';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./optional-from-mapped-result"), exports);
__exportStar(require("./optional"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\optional-from-mapped-result.d.ts

Code:
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TOptionalWithFlag } from './optional';
type TFromProperties<P extends TProperties, F extends boolean> = ({
    [K2 in keyof P]: TOptionalWithFlag<P[K2], F>;
});
type TFromMappedResult<R extends TMappedResult, F extends boolean> = (TFromProperties<R['properties'], F>);
export type TOptionalFromMappedResult<R extends TMappedResult, F extends boolean, P extends TProperties = TFromMappedResult<R, F>> = (TMappedResult<P>);
export declare function OptionalFromMappedResult<R extends TMappedResult, F extends boolean, P extends TProperties = TFromMappedResult<R, F>>(R: R, F: F): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\optional-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionalFromMappedResult = OptionalFromMappedResult;
const index_1 = require("../mapped/index");
const optional_1 = require("./optional");
// prettier-ignore
function FromProperties(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
}
// prettier-ignore
function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\optional.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Ensure } from '../helpers/index';
import { OptionalKind } from '../symbols/index';
import type { TMappedResult } from '../mapped/index';
import { type TOptionalFromMappedResult } from './optional-from-mapped-result';
type TRemoveOptional<T extends TSchema> = T extends TOptional<infer S> ? S : T;
type TAddOptional<T extends TSchema> = T extends TOptional<infer S> ? TOptional<S> : Ensure<TOptional<T>>;
export type TOptionalWithFlag<T extends TSchema, F extends boolean> = F extends false ? TRemoveOptional<T> : TAddOptional<T>;
export type TOptional<T extends TSchema> = T & {
    [OptionalKind]: 'Optional';
};
/** `[Json]` Creates a Optional property */
export declare function Optional<T extends TMappedResult, F extends boolean>(schema: T, enable: F): TOptionalFromMappedResult<T, F>;
/** `[Json]` Creates a Optional property */
export declare function Optional<T extends TSchema, F extends boolean>(schema: T, enable: F): TOptionalWithFlag<T, F>;
/** `[Json]` Creates a Optional property */
export declare function Optional<T extends TMappedResult>(schema: T): TOptionalFromMappedResult<T, true>;
/** `[Json]` Creates a Optional property */
export declare function Optional<T extends TSchema>(schema: T): TOptionalWithFlag<T, true>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\optional\optional.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Optional = Optional;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
const index_2 = require("../discard/index");
const optional_from_mapped_result_1 = require("./optional-from-mapped-result");
const kind_1 = require("../guard/kind");
function RemoveOptional(schema) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.OptionalKind]));
}
function AddOptional(schema) {
    return (0, type_1.CreateType)({ ...schema, [index_1.OptionalKind]: 'Optional' });
}
// prettier-ignore
function OptionalWithFlag(schema, F) {
    return (F === false
        ? RemoveOptional(schema)
        : AddOptional(schema));
}
/** `[Json]` Creates a Optional property */
function Optional(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag(schema, F);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\parameters\index.d.ts

Code:
export * from './parameters';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\parameters\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./parameters"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\parameters\parameters.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TFunction } from '../function/index';
import { type TTuple } from '../tuple/index';
import { type TNever } from '../never/index';
export type TParameters<Type extends TSchema> = (Type extends TFunction<infer Parameters extends TSchema[], infer _ReturnType extends TSchema> ? TTuple<Parameters> : TNever);
/** `[JavaScript]` Extracts the Parameters from the given Function type */
export declare function Parameters<Type extends TSchema>(schema: Type, options?: SchemaOptions): TParameters<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\parameters\parameters.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Parameters = Parameters;
const index_1 = require("../tuple/index");
const index_2 = require("../never/index");
const KindGuard = require("../guard/kind");
/** `[JavaScript]` Extracts the Parameters from the given Function type */
function Parameters(schema, options) {
    return (KindGuard.IsFunction(schema) ? (0, index_1.Tuple)(schema.parameters, options) : (0, index_2.Never)());
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\index.d.ts

Code:
export * from './partial-from-mapped-result';
export * from './partial';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./partial-from-mapped-result"), exports);
__exportStar(require("./partial"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\partial-from-mapped-result.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TPartial } from './partial';
type TFromProperties<P extends TProperties> = ({
    [K2 in keyof P]: TPartial<P[K2]>;
});
type TFromMappedResult<R extends TMappedResult> = (Evaluate<TFromProperties<R['properties']>>);
export type TPartialFromMappedResult<R extends TMappedResult, P extends TProperties = TFromMappedResult<R>> = (Ensure<TMappedResult<P>>);
export declare function PartialFromMappedResult<R extends TMappedResult, P extends TProperties = TFromMappedResult<R>>(R: R, options?: SchemaOptions): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\partial-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PartialFromMappedResult = PartialFromMappedResult;
const index_1 = require("../mapped/index");
const partial_1 = require("./partial");
const value_1 = require("../clone/value");
// prettier-ignore
function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = (0, partial_1.Partial)(K[K2], (0, value_1.Clone)(options));
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
}
// prettier-ignore
function PartialFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\partial.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Evaluate, Ensure } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import { type TReadonlyOptional } from '../readonly-optional/index';
import { type TComputed } from '../computed/index';
import { type TOptional } from '../optional/index';
import { type TReadonly } from '../readonly/index';
import { type TRecursive } from '../recursive/index';
import { type TObject, type TProperties } from '../object/index';
import { type TIntersect } from '../intersect/index';
import { type TUnion } from '../union/index';
import { type TRef } from '../ref/index';
import { type TBigInt } from '../bigint/index';
import { type TBoolean } from '../boolean/index';
import { type TInteger } from '../integer/index';
import { type TLiteral } from '../literal/index';
import { type TNull } from '../null/index';
import { type TNumber } from '../number/index';
import { type TString } from '../string/index';
import { type TSymbol } from '../symbol/index';
import { type TUndefined } from '../undefined/index';
import { type TPartialFromMappedResult } from './partial-from-mapped-result';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<TComputed<'Partial', [TComputed<Target, Parameters>]>>;
type TFromRef<Ref extends string> = Ensure<TComputed<'Partial', [TRef<Ref>]>>;
type TFromProperties<Properties extends TProperties> = Evaluate<{
    [K in keyof Properties]: Properties[K] extends (TReadonlyOptional<infer S>) ? TReadonlyOptional<S> : Properties[K] extends (TReadonly<infer S>) ? TReadonlyOptional<S> : Properties[K] extends (TOptional<infer S>) ? TOptional<S> : TOptional<Properties[K]>;
}>;
type TFromObject<Type extends TObject, Properties extends TProperties = Type['properties']> = Ensure<TObject<(TFromProperties<Properties>)>>;
type TFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, [...Result, TPartial<L>]> : Result);
export type TPartial<Type extends TSchema> = (Type extends TRecursive<infer Type extends TSchema> ? TRecursive<TPartial<Type>> : Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromRest<Types>> : Type extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromRest<Types>> : Type extends TObject<infer Properties extends TProperties> ? TFromObject<TObject<Properties>> : Type extends TBigInt ? Type : Type extends TBoolean ? Type : Type extends TInteger ? Type : Type extends TLiteral ? Type : Type extends TNull ? Type : Type extends TNumber ? Type : Type extends TString ? Type : Type extends TSymbol ? Type : Type extends TUndefined ? Type : TObject<{}>);
/** `[Json]` Constructs a type where all properties are optional */
export declare function Partial<MappedResult extends TMappedResult>(type: MappedResult, options?: SchemaOptions): TPartialFromMappedResult<MappedResult>;
/** `[Json]` Constructs a type where all properties are optional */
export declare function Partial<Type extends TSchema>(type: Type, options?: SchemaOptions): TPartial<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\partial\partial.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Partial = Partial;
const type_1 = require("../create/type");
const index_1 = require("../computed/index");
const index_2 = require("../optional/index");
const index_3 = require("../object/index");
const index_4 = require("../intersect/index");
const index_5 = require("../union/index");
const index_6 = require("../ref/index");
const index_7 = require("../discard/index");
const index_8 = require("../symbols/index");
const partial_from_mapped_result_1 = require("./partial-from-mapped-result");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const KindGuard = require("../guard/kind");
// prettier-ignore
function FromComputed(target, parameters) {
    return (0, index_1.Computed)('Partial', [(0, index_1.Computed)(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return (0, index_1.Computed)('Partial', [(0, index_6.Ref)($ref)]);
}
// prettier-ignore
function FromProperties(properties) {
    const partialProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
        partialProperties[K] = (0, index_2.Optional)(properties[K]);
    return partialProperties;
}
// prettier-ignore
function FromObject(type) {
    const options = (0, index_7.Discard)(type, [index_8.TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties(type['properties']);
    return (0, index_3.Object)(properties, options);
}
// prettier-ignore
function FromRest(types) {
    return types.map(type => PartialResolve(type));
}
// ------------------------------------------------------------------
// PartialResolve
// ------------------------------------------------------------------
// prettier-ignore
function PartialResolve(type) {
    return (
    // Mappable
    KindGuard.IsComputed(type) ? FromComputed(type.target, type.parameters) :
        KindGuard.IsRef(type) ? FromRef(type.$ref) :
            KindGuard.IsIntersect(type) ? (0, index_4.Intersect)(FromRest(type.allOf)) :
                KindGuard.IsUnion(type) ? (0, index_5.Union)(FromRest(type.anyOf)) :
                    KindGuard.IsObject(type) ? FromObject(type) :
                        // Intrinsic
                        KindGuard.IsBigInt(type) ? type :
                            KindGuard.IsBoolean(type) ? type :
                                KindGuard.IsInteger(type) ? type :
                                    KindGuard.IsLiteral(type) ? type :
                                        KindGuard.IsNull(type) ? type :
                                            KindGuard.IsNumber(type) ? type :
                                                KindGuard.IsString(type) ? type :
                                                    KindGuard.IsSymbol(type) ? type :
                                                        KindGuard.IsUndefined(type) ? type :
                                                            // Passthrough
                                                            (0, index_3.Object)({}));
}
/** `[Json]` Constructs a type where all properties are optional */
function Partial(type, options) {
    if (KindGuard.IsMappedResult(type)) {
        return (0, partial_from_mapped_result_1.PartialFromMappedResult)(type, options);
    }
    else {
        // special: mapping types require overridable options
        return (0, type_1.CreateType)({ ...PartialResolve(type), ...options });
    }
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\patterns\index.d.ts

Code:
export * from './patterns';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\patterns\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./patterns"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\patterns\patterns.d.ts

Code:
export declare const PatternBoolean = "(true|false)";
export declare const PatternNumber = "(0|[1-9][0-9]*)";
export declare const PatternString = "(.*)";
export declare const PatternNever = "(?!.*)";
export declare const PatternBooleanExact = "^(true|false)$";
export declare const PatternNumberExact = "^(0|[1-9][0-9]*)$";
export declare const PatternStringExact = "^(.*)$";
export declare const PatternNeverExact = "^(?!.*)$";


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\patterns\patterns.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PatternNeverExact = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternNever = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = void 0;
exports.PatternBoolean = '(true|false)';
exports.PatternNumber = '(0|[1-9][0-9]*)';
exports.PatternString = '(.*)';
exports.PatternNever = '(?!.*)';
exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
exports.PatternNumberExact = `^${exports.PatternNumber}$`;
exports.PatternStringExact = `^${exports.PatternString}$`;
exports.PatternNeverExact = `^${exports.PatternNever}$`;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\index.d.ts

Code:
export * from './pick-from-mapped-key';
export * from './pick-from-mapped-result';
export * from './pick';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./pick-from-mapped-key"), exports);
__exportStar(require("./pick-from-mapped-result"), exports);
__exportStar(require("./pick"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick-from-mapped-key.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TProperties } from '../object/index';
import { type TMappedResult, type TMappedKey } from '../mapped/index';
import { type TPick } from './pick';
type TFromPropertyKey<Type extends TSchema, Key extends PropertyKey> = {
    [_ in Key]: TPick<Type, [Key]>;
};
type TFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[], Result extends TProperties = {}> = (PropertyKeys extends [infer LeftKey extends PropertyKey, ...infer RightKeys extends PropertyKey[]] ? TFromPropertyKeys<Type, RightKeys, Result & TFromPropertyKey<Type, LeftKey>> : Result);
type TFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey> = (TFromPropertyKeys<Type, MappedKey['keys']>);
export type TPickFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TFromMappedKey<Type, MappedKey>> = (TMappedResult<Properties>);
export declare function PickFromMappedKey<Type extends TSchema, MappedKey extends TMappedKey, Properties extends TProperties = TFromMappedKey<Type, MappedKey>>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick-from-mapped-key.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickFromMappedKey = PickFromMappedKey;
const index_1 = require("../mapped/index");
const pick_1 = require("./pick");
const value_1 = require("../clone/value");
// prettier-ignore
function FromPropertyKey(type, key, options) {
    return {
        [key]: (0, pick_1.Pick)(type, [key], (0, value_1.Clone)(options))
    };
}
// prettier-ignore
function FromPropertyKeys(type, propertyKeys, options) {
    return propertyKeys.reduce((result, leftKey) => {
        return { ...result, ...FromPropertyKey(type, leftKey, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey(type, mappedKey, options) {
    return FromPropertyKeys(type, mappedKey.keys, options);
}
// prettier-ignore
function PickFromMappedKey(type, mappedKey, options) {
    const properties = FromMappedKey(type, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick-from-mapped-result.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TPick } from './pick';
type TFromProperties<Properties extends TProperties, PropertyKeys extends PropertyKey[]> = ({
    [K2 in keyof Properties]: TPick<Properties[K2], PropertyKeys>;
});
type TFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[]> = (Evaluate<TFromProperties<MappedResult['properties'], PropertyKeys>>);
export type TPickFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[], Properties extends TProperties = TFromMappedResult<MappedResult, PropertyKeys>> = (Ensure<TMappedResult<Properties>>);
export declare function PickFromMappedResult<MappedResult extends TMappedResult, PropertyKeys extends PropertyKey[], Properties extends TProperties = TFromMappedResult<MappedResult, PropertyKeys>>(mappedResult: MappedResult, propertyKeys: [...PropertyKeys], options?: SchemaOptions): TMappedResult<Properties>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickFromMappedResult = PickFromMappedResult;
const index_1 = require("../mapped/index");
const pick_1 = require("./pick");
const value_1 = require("../clone/value");
// prettier-ignore
function FromProperties(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = (0, pick_1.Pick)(properties[K2], propertyKeys, (0, value_1.Clone)(options));
    return result;
}
// prettier-ignore
function FromMappedResult(mappedResult, propertyKeys, options) {
    return FromProperties(mappedResult.properties, propertyKeys, options);
}
// prettier-ignore
function PickFromMappedResult(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult(mappedResult, propertyKeys, options);
    return (0, index_1.MappedResult)(properties);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { TupleToUnion, Evaluate, Ensure } from '../helpers/index';
import { type TRecursive } from '../recursive/index';
import { type TComputed } from '../computed/index';
import { type TIntersect } from '../intersect/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TObject, type TProperties } from '../object/index';
import { type TUnion } from '../union/index';
import { type TMappedKey, type TMappedResult } from '../mapped/index';
import { type TRef } from '../ref/index';
import { type TIndexPropertyKeys } from '../indexed/index';
import { type TPickFromMappedKey } from './pick-from-mapped-key';
import { type TPickFromMappedResult } from './pick-from-mapped-result';
type TFromIntersect<Types extends TSchema[], PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromIntersect<R, PropertyKeys, [...Result, TPick<L, PropertyKeys>]> : Result;
type TFromUnion<Types extends TSchema[], PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromUnion<R, PropertyKeys, [...Result, TPick<L, PropertyKeys>]> : Result;
type TFromProperties<Properties extends TProperties, PropertyKeys extends PropertyKey[], UnionKeys extends PropertyKey = TupleToUnion<PropertyKeys>> = (Evaluate<Pick<Properties, UnionKeys & keyof Properties>>);
type TFromObject<Type extends TObject, Key extends PropertyKey[], Properties extends TProperties = Type['properties']> = Ensure<TObject<(TFromProperties<Properties, Key>)>>;
type TUnionFromPropertyKeys<PropertyKeys extends PropertyKey[], Result extends TLiteral[] = []> = (PropertyKeys extends [infer Key extends PropertyKey, ...infer Rest extends PropertyKey[]] ? Key extends TLiteralValue ? TUnionFromPropertyKeys<Rest, [...Result, TLiteral<Key>]> : TUnionFromPropertyKeys<Rest, [...Result]> : TUnion<Result>);
export type TPickResolve<Properties extends TProperties, PropertyKeys extends PropertyKey[]> = (Properties extends TRecursive<infer Types extends TSchema> ? TRecursive<TPickResolve<Types, PropertyKeys>> : Properties extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromIntersect<Types, PropertyKeys>> : Properties extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromUnion<Types, PropertyKeys>> : Properties extends TObject<infer Types extends TProperties> ? TFromObject<TObject<Types>, PropertyKeys> : TObject<{}>);
type TResolvePropertyKeys<Key extends TSchema | PropertyKey[]> = Key extends TSchema ? TIndexPropertyKeys<Key> : Key;
type TResolveTypeKey<Key extends TSchema | PropertyKey[]> = Key extends PropertyKey[] ? TUnionFromPropertyKeys<Key> : Key;
export type TPick<Type extends TSchema, Key extends TSchema | PropertyKey[], IsTypeRef extends boolean = Type extends TRef ? true : false, IsKeyRef extends boolean = Key extends TRef ? true : false> = (Type extends TMappedResult ? TPickFromMappedResult<Type, TResolvePropertyKeys<Key>> : Key extends TMappedKey ? TPickFromMappedKey<Type, Key> : [
    IsTypeRef,
    IsKeyRef
] extends [true, true] ? TComputed<'Pick', [Type, TResolveTypeKey<Key>]> : [
    IsTypeRef,
    IsKeyRef
] extends [false, true] ? TComputed<'Pick', [Type, TResolveTypeKey<Key>]> : [
    IsTypeRef,
    IsKeyRef
] extends [true, false] ? TComputed<'Pick', [Type, TResolveTypeKey<Key>]> : TPickResolve<Type, TResolvePropertyKeys<Key>>);
/** `[Json]` Constructs a type whose keys are picked from the given type */
export declare function Pick<Type extends TSchema, Key extends PropertyKey[]>(type: Type, key: readonly [...Key], options?: SchemaOptions): TPick<Type, Key>;
/** `[Json]` Constructs a type whose keys are picked from the given type */
export declare function Pick<Type extends TSchema, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TPick<Type, Key>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\pick\pick.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pick = Pick;
const type_1 = require("../create/type");
const discard_1 = require("../discard/discard");
const index_1 = require("../computed/index");
const index_2 = require("../intersect/index");
const index_3 = require("../literal/index");
const index_4 = require("../object/index");
const index_5 = require("../union/index");
const index_6 = require("../indexed/index");
const symbols_1 = require("../symbols/symbols");
// ------------------------------------------------------------------
// Guards
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
const value_1 = require("../guard/value");
// ------------------------------------------------------------------
// Infrastructure
// ------------------------------------------------------------------
const pick_from_mapped_key_1 = require("./pick-from-mapped-key");
const pick_from_mapped_result_1 = require("./pick-from-mapped-result");
function FromIntersect(types, propertyKeys) {
    return types.map((type) => PickResolve(type, propertyKeys));
}
// prettier-ignore
function FromUnion(types, propertyKeys) {
    return types.map((type) => PickResolve(type, propertyKeys));
}
// prettier-ignore
function FromProperties(properties, propertyKeys) {
    const result = {};
    for (const K2 of propertyKeys)
        if (K2 in properties)
            result[K2] = properties[K2];
    return result;
}
// prettier-ignore
function FromObject(T, K) {
    const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties(T['properties'], K);
    return (0, index_4.Object)(properties, options);
}
// prettier-ignore
function UnionFromPropertyKeys(propertyKeys) {
    const result = propertyKeys.reduce((result, key) => (0, kind_1.IsLiteralValue)(key) ? [...result, (0, index_3.Literal)(key)] : result, []);
    return (0, index_5.Union)(result);
}
// prettier-ignore
function PickResolve(properties, propertyKeys) {
    return ((0, kind_1.IsIntersect)(properties) ? (0, index_2.Intersect)(FromIntersect(properties.allOf, propertyKeys)) :
        (0, kind_1.IsUnion)(properties) ? (0, index_5.Union)(FromUnion(properties.anyOf, propertyKeys)) :
            (0, kind_1.IsObject)(properties) ? FromObject(properties, propertyKeys) :
                (0, index_4.Object)({}));
}
/** `[Json]` Constructs a type whose keys are picked from the given type */
// prettier-ignore
function Pick(type, key, options) {
    const typeKey = (0, value_1.IsArray)(key) ? UnionFromPropertyKeys(key) : key;
    const propertyKeys = (0, kind_1.IsSchema)(key) ? (0, index_6.IndexPropertyKeys)(key) : key;
    const isTypeRef = (0, kind_1.IsRef)(type);
    const isKeyRef = (0, kind_1.IsRef)(key);
    return ((0, kind_1.IsMappedResult)(type) ? (0, pick_from_mapped_result_1.PickFromMappedResult)(type, propertyKeys, options) :
        (0, kind_1.IsMappedKey)(key) ? (0, pick_from_mapped_key_1.PickFromMappedKey)(type, key, options) :
            (isTypeRef && isKeyRef) ? (0, index_1.Computed)('Pick', [type, typeKey], options) :
                (!isTypeRef && isKeyRef) ? (0, index_1.Computed)('Pick', [type, typeKey], options) :
                    (isTypeRef && !isKeyRef) ? (0, index_1.Computed)('Pick', [type, typeKey], options) :
                        (0, type_1.CreateType)({ ...PickResolve(type, propertyKeys), ...options }));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\promise\index.d.ts

Code:
export * from './promise';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\promise\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./promise"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\promise\promise.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
export interface TPromise<T extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Promise';
    static: Promise<Static<T, this['params']>>;
    type: 'Promise';
    item: TSchema;
}
/** `[JavaScript]` Creates a Promise type */
export declare function Promise<T extends TSchema>(item: T, options?: SchemaOptions): TPromise<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\promise\promise.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Promise = Promise;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Promise type */
function Promise(item, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Promise', type: 'Promise', item }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\index.d.ts

Code:
export * from './readonly-from-mapped-result';
export * from './readonly';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./readonly-from-mapped-result"), exports);
__exportStar(require("./readonly"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\readonly-from-mapped-result.d.ts

Code:
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TReadonlyWithFlag } from './readonly';
type TFromProperties<P extends TProperties, F extends boolean> = ({
    [K2 in keyof P]: TReadonlyWithFlag<P[K2], F>;
});
type TFromMappedResult<R extends TMappedResult, F extends boolean> = (TFromProperties<R['properties'], F>);
export type TReadonlyFromMappedResult<R extends TMappedResult, F extends boolean, P extends TProperties = TFromMappedResult<R, F>> = (TMappedResult<P>);
export declare function ReadonlyFromMappedResult<R extends TMappedResult, F extends boolean, P extends TProperties = TFromMappedResult<R, F>>(R: R, F: F): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\readonly-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
const index_1 = require("../mapped/index");
const readonly_1 = require("./readonly");
// prettier-ignore
function FromProperties(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
}
// prettier-ignore
function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\readonly.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Ensure } from '../helpers/index';
import { ReadonlyKind } from '../symbols/index';
import type { TMappedResult } from '../mapped/index';
import { type TReadonlyFromMappedResult } from './readonly-from-mapped-result';
type TRemoveReadonly<T extends TSchema> = T extends TReadonly<infer S> ? S : T;
type TAddReadonly<T extends TSchema> = T extends TReadonly<infer S> ? TReadonly<S> : Ensure<TReadonly<T>>;
export type TReadonlyWithFlag<T extends TSchema, F extends boolean> = F extends false ? TRemoveReadonly<T> : TAddReadonly<T>;
export type TReadonly<T extends TSchema> = T & {
    [ReadonlyKind]: 'Readonly';
};
/** `[Json]` Creates a Readonly property */
export declare function Readonly<T extends TMappedResult, F extends boolean>(schema: T, enable: F): TReadonlyFromMappedResult<T, F>;
/** `[Json]` Creates a Readonly property */
export declare function Readonly<T extends TSchema, F extends boolean>(schema: T, enable: F): TReadonlyWithFlag<T, F>;
/** `[Json]` Creates a Readonly property */
export declare function Readonly<T extends TMappedResult>(schema: T): TReadonlyFromMappedResult<T, true>;
/** `[Json]` Creates a Readonly property */
export declare function Readonly<T extends TSchema>(schema: T): TReadonlyWithFlag<T, true>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly\readonly.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Readonly = Readonly;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
const index_2 = require("../discard/index");
const readonly_from_mapped_result_1 = require("./readonly-from-mapped-result");
const kind_1 = require("../guard/kind");
function RemoveReadonly(schema) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.ReadonlyKind]));
}
function AddReadonly(schema) {
    return (0, type_1.CreateType)({ ...schema, [index_1.ReadonlyKind]: 'Readonly' });
}
// prettier-ignore
function ReadonlyWithFlag(schema, F) {
    return (F === false
        ? RemoveReadonly(schema)
        : AddReadonly(schema));
}
/** `[Json]` Creates a Readonly property */
function Readonly(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag(schema, F);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly-optional\index.d.ts

Code:
export * from './readonly-optional';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly-optional\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./readonly-optional"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly-optional\readonly-optional.d.ts

Code:
import type { TSchema } from '../schema/index';
import { type TReadonly } from '../readonly/index';
import { type TOptional } from '../optional/index';
export type TReadonlyOptional<T extends TSchema> = TOptional<T> & TReadonly<T>;
/** `[Json]` Creates a Readonly and Optional property */
export declare function ReadonlyOptional<T extends TSchema>(schema: T): TReadonly<TOptional<T>>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\readonly-optional\readonly-optional.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadonlyOptional = ReadonlyOptional;
const index_1 = require("../readonly/index");
const index_2 = require("../optional/index");
/** `[Json]` Creates a Readonly and Optional property */
function ReadonlyOptional(schema) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\record\index.d.ts

Code:
export * from './record';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\record\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./record"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\record\record.d.ts

Code:
import { Kind } from '../symbols/index';
import type { TSchema } from '../schema/index';
import type { Static } from '../static/index';
import type { Evaluate, Ensure, Assert } from '../helpers/index';
import { type TAny } from '../any/index';
import { type TBoolean } from '../boolean/index';
import { type TEnumRecord, type TEnum } from '../enum/index';
import { type TInteger } from '../integer/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TNever } from '../never/index';
import { type TNumber } from '../number/index';
import { type TObject, type TProperties, type TAdditionalProperties, type ObjectOptions } from '../object/index';
import { type TRegExp } from '../regexp/index';
import { type TString } from '../string/index';
import { type TUnion } from '../union/index';
import { TIsTemplateLiteralFinite, type TTemplateLiteral } from '../template-literal/index';
type TFromTemplateLiteralKeyInfinite<Key extends TTemplateLiteral, Type extends TSchema> = Ensure<TRecord<Key, Type>>;
type TFromTemplateLiteralKeyFinite<Key extends TTemplateLiteral, Type extends TSchema, I extends string = Static<Key>> = (Ensure<TObject<Evaluate<{
    [_ in I]: Type;
}>>>);
type TFromTemplateLiteralKey<Key extends TTemplateLiteral, Type extends TSchema> = TIsTemplateLiteralFinite<Key> extends false ? TFromTemplateLiteralKeyInfinite<Key, Type> : TFromTemplateLiteralKeyFinite<Key, Type>;
type TFromEnumKey<Key extends Record<string, string | number>, Type extends TSchema> = Ensure<TObject<{
    [_ in Key[keyof Key]]: Type;
}>>;
type TFromUnionKeyLiteralString<Key extends TLiteral<string>, Type extends TSchema> = {
    [_ in Key['const']]: Type;
};
type TFromUnionKeyLiteralNumber<Key extends TLiteral<number>, Type extends TSchema> = {
    [_ in Key['const']]: Type;
};
type TFromUnionKeyVariants<Keys extends TSchema[], Type extends TSchema, Result extends TProperties = {}> = Keys extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? (Left extends TUnion<infer Types extends TSchema[]> ? TFromUnionKeyVariants<Right, Type, Result & TFromUnionKeyVariants<Types, Type>> : Left extends TLiteral<string> ? TFromUnionKeyVariants<Right, Type, Result & TFromUnionKeyLiteralString<Left, Type>> : Left extends TLiteral<number> ? TFromUnionKeyVariants<Right, Type, Result & TFromUnionKeyLiteralNumber<Left, Type>> : {}) : Result;
type TFromUnionKey<Key extends TSchema[], Type extends TSchema, Properties extends TProperties = TFromUnionKeyVariants<Key, Type>> = (Ensure<TObject<Evaluate<Properties>>>);
type TFromLiteralKey<Key extends TLiteralValue, Type extends TSchema> = (Ensure<TObject<{
    [_ in Assert<Key, PropertyKey>]: Type;
}>>);
type TFromRegExpKey<_Key extends TRegExp, Type extends TSchema> = (Ensure<TRecord<TRegExp, Type>>);
type TFromStringKey<_Key extends TString, Type extends TSchema> = (Ensure<TRecord<TString, Type>>);
type TFromAnyKey<_Key extends TAny, Type extends TSchema> = (Ensure<TRecord<TAny, Type>>);
type TFromNeverKey<_Key extends TNever, Type extends TSchema> = (Ensure<TRecord<TNever, Type>>);
type TFromBooleanKey<_Key extends TBoolean, Type extends TSchema> = (Ensure<TObject<{
    true: Type;
    false: Type;
}>>);
type TFromIntegerKey<_Key extends TSchema, Type extends TSchema> = (Ensure<TRecord<TNumber, Type>>);
type TFromNumberKey<_Key extends TSchema, Type extends TSchema> = (Ensure<TRecord<TNumber, Type>>);
type RecordStatic<Key extends TSchema, Type extends TSchema, P extends unknown[]> = (Evaluate<{
    [_ in Assert<Static<Key>, PropertyKey>]: Static<Type, P>;
}>);
export interface TRecord<Key extends TSchema = TSchema, Type extends TSchema = TSchema> extends TSchema {
    [Kind]: 'Record';
    static: RecordStatic<Key, Type, this['params']>;
    type: 'object';
    patternProperties: {
        [pattern: string]: Type;
    };
    additionalProperties: TAdditionalProperties;
}
export type TRecordOrObject<Key extends TSchema, Type extends TSchema> = (Key extends TTemplateLiteral ? TFromTemplateLiteralKey<Key, Type> : Key extends TEnum<infer Enum extends TEnumRecord> ? TFromEnumKey<Enum, Type> : Key extends TUnion<infer Types extends TSchema[]> ? TFromUnionKey<Types, Type> : Key extends TLiteral<infer Value extends TLiteralValue> ? TFromLiteralKey<Value, Type> : Key extends TBoolean ? TFromBooleanKey<Key, Type> : Key extends TInteger ? TFromIntegerKey<Key, Type> : Key extends TNumber ? TFromNumberKey<Key, Type> : Key extends TRegExp ? TFromRegExpKey<Key, Type> : Key extends TString ? TFromStringKey<Key, Type> : Key extends TAny ? TFromAnyKey<Key, Type> : Key extends TNever ? TFromNeverKey<Key, Type> : TNever);
/** `[Json]` Creates a Record type */
export declare function Record<Key extends TSchema, Type extends TSchema>(key: Key, type: Type, options?: ObjectOptions): TRecordOrObject<Key, Type>;
/** Gets the Records Pattern */
export declare function RecordPattern(record: TRecord): string;
/** Gets the Records Key Type */
export type TRecordKey<Type extends TRecord, Result extends TSchema = Type extends TRecord<infer Key extends TSchema, TSchema> ? (Key extends TNumber ? TNumber : Key extends TString ? TString : TString) : TString> = Result;
/** Gets the Records Key Type */
export declare function RecordKey<Type extends TRecord>(type: Type): TRecordKey<Type>;
/** Gets a Record Value Type */
export type TRecordValue<Type extends TRecord, Result extends TSchema = (Type extends TRecord<TSchema, infer Value extends TSchema> ? Value : TNever)> = Result;
/** Gets a Record Value Type */
export declare function RecordValue<Type extends TRecord>(type: Type): TRecordValue<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\record\record.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Record = Record;
exports.RecordPattern = RecordPattern;
exports.RecordKey = RecordKey;
exports.RecordValue = RecordValue;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
const index_2 = require("../never/index");
const index_3 = require("../number/index");
const index_4 = require("../object/index");
const index_5 = require("../string/index");
const index_6 = require("../union/index");
const index_7 = require("../template-literal/index");
const index_8 = require("../patterns/index");
const index_9 = require("../indexed/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const value_1 = require("../guard/value");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// ------------------------------------------------------------------
// RecordCreateFromPattern
// ------------------------------------------------------------------
// prettier-ignore
function RecordCreateFromPattern(pattern, T, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: T } }, options);
}
// ------------------------------------------------------------------
// RecordCreateFromKeys
// ------------------------------------------------------------------
// prettier-ignore
function RecordCreateFromKeys(K, T, options) {
    const result = {};
    for (const K2 of K)
        result[K2] = T;
    return (0, index_4.Object)(result, { ...options, [index_1.Hint]: 'Record' });
}
// prettier-ignore
function FromTemplateLiteralKey(K, T, options) {
    return ((0, index_7.IsTemplateLiteralFinite)(K)
        ? RecordCreateFromKeys((0, index_9.IndexPropertyKeys)(K), T, options)
        : RecordCreateFromPattern(K.pattern, T, options));
}
// prettier-ignore
function FromUnionKey(key, type, options) {
    return RecordCreateFromKeys((0, index_9.IndexPropertyKeys)((0, index_6.Union)(key)), type, options);
}
// prettier-ignore
function FromLiteralKey(key, type, options) {
    return RecordCreateFromKeys([key.toString()], type, options);
}
// prettier-ignore
function FromRegExpKey(key, type, options) {
    return RecordCreateFromPattern(key.source, type, options);
}
// prettier-ignore
function FromStringKey(key, type, options) {
    const pattern = (0, value_1.IsUndefined)(key.pattern) ? index_8.PatternStringExact : key.pattern;
    return RecordCreateFromPattern(pattern, type, options);
}
// prettier-ignore
function FromAnyKey(_, type, options) {
    return RecordCreateFromPattern(index_8.PatternStringExact, type, options);
}
// prettier-ignore
function FromNeverKey(_key, type, options) {
    return RecordCreateFromPattern(index_8.PatternNeverExact, type, options);
}
// prettier-ignore
function FromBooleanKey(_key, type, options) {
    return (0, index_4.Object)({ true: type, false: type }, options);
}
// prettier-ignore
function FromIntegerKey(_key, type, options) {
    return RecordCreateFromPattern(index_8.PatternNumberExact, type, options);
}
// prettier-ignore
function FromNumberKey(_, type, options) {
    return RecordCreateFromPattern(index_8.PatternNumberExact, type, options);
}
// ------------------------------------------------------------------
// TRecordOrObject
// ------------------------------------------------------------------
/** `[Json]` Creates a Record type */
function Record(key, type, options = {}) {
    // prettier-ignore
    return ((0, kind_1.IsUnion)(key) ? FromUnionKey(key.anyOf, type, options) :
        (0, kind_1.IsTemplateLiteral)(key) ? FromTemplateLiteralKey(key, type, options) :
            (0, kind_1.IsLiteral)(key) ? FromLiteralKey(key.const, type, options) :
                (0, kind_1.IsBoolean)(key) ? FromBooleanKey(key, type, options) :
                    (0, kind_1.IsInteger)(key) ? FromIntegerKey(key, type, options) :
                        (0, kind_1.IsNumber)(key) ? FromNumberKey(key, type, options) :
                            (0, kind_1.IsRegExp)(key) ? FromRegExpKey(key, type, options) :
                                (0, kind_1.IsString)(key) ? FromStringKey(key, type, options) :
                                    (0, kind_1.IsAny)(key) ? FromAnyKey(key, type, options) :
                                        (0, kind_1.IsNever)(key) ? FromNeverKey(key, type, options) :
                                            (0, index_2.Never)(options));
}
// ------------------------------------------------------------------
// Record Utilities
// ------------------------------------------------------------------
/** Gets the Records Pattern */
function RecordPattern(record) {
    return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
/** Gets the Records Key Type */
// prettier-ignore
function RecordKey(type) {
    const pattern = RecordPattern(type);
    return (pattern === index_8.PatternStringExact ? (0, index_5.String)() :
        pattern === index_8.PatternNumberExact ? (0, index_3.Number)() :
            (0, index_5.String)({ pattern }));
}
/** Gets a Record Value Type */
// prettier-ignore
function RecordValue(type) {
    return type.patternProperties[RecordPattern(type)];
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\recursive\index.d.ts

Code:
export * from './recursive';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\recursive\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./recursive"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\recursive\recursive.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind, Hint } from '../symbols/index';
import { Static } from '../static/index';
export interface TThis extends TSchema {
    [Kind]: 'This';
    static: this['params'][0];
    $ref: string;
}
type RecursiveStatic<T extends TSchema> = Static<T, [RecursiveStatic<T>]>;
export interface TRecursive<T extends TSchema> extends TSchema {
    [Hint]: 'Recursive';
    static: RecursiveStatic<T>;
}
/** `[Json]` Creates a Recursive type */
export declare function Recursive<T extends TSchema>(callback: (thisType: TThis) => T, options?: SchemaOptions): TRecursive<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\recursive\recursive.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Recursive = Recursive;
const type_1 = require("../clone/type");
const type_2 = require("../create/type");
const value_1 = require("../guard/value");
const index_1 = require("../symbols/index");
// Auto Tracked For Recursive Types without ID's
let Ordinal = 0;
/** `[Json]` Creates a Recursive type */
function Recursive(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
        options.$id = `T${Ordinal++}`;
    const thisType = (0, type_1.CloneType)(callback({ [index_1.Kind]: 'This', $ref: `${options.$id}` }));
    thisType.$id = options.$id;
    // prettier-ignore
    return (0, type_2.CreateType)({ [index_1.Hint]: 'Recursive', ...thisType }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\ref\index.d.ts

Code:
export * from './ref';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\ref\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ref"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\ref\ref.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
import { TUnsafe } from '../unsafe/index';
import { Static } from '../static/index';
export interface TRef<Ref extends string = string> extends TSchema {
    [Kind]: 'Ref';
    static: unknown;
    $ref: Ref;
}
export type TRefUnsafe<Type extends TSchema> = TUnsafe<Static<Type>>;
/** `[Json]` Creates a Ref type.*/
export declare function Ref<Ref extends string>($ref: Ref, options?: SchemaOptions): TRef<Ref>;
/**
 * @deprecated `[Json]` Creates a Ref type. This signature was deprecated in 0.34.0 where Ref requires callers to pass
 * a `string` value for the reference (and not a schema).
 *
 * To adhere to the 0.34.0 signature, Ref implementations should be updated to the following.
 *
 * ```typescript
 * // pre-0.34.0
 *
 * const T = Type.String({ $id: 'T' })
 *
 * const R = Type.Ref(T)
 * ```
 * should be changed to the following
 *
 * ```typescript
 * // post-0.34.0
 *
 * const T = Type.String({ $id: 'T' })
 *
 * const R = Type.Unsafe<Static<typeof T>>(Type.Ref('T'))
 * ```
 * You can also create a generic function to replicate the pre-0.34.0 signature if required
 *
 * ```typescript
 * const LegacyRef = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T>>(Type.Ref(schema.$id!))
 * ```
 */
export declare function Ref<Type extends TSchema>(type: Type, options?: SchemaOptions): TRefUnsafe<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\ref\ref.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Ref = Ref;
const index_1 = require("../error/index");
const type_1 = require("../create/type");
const index_2 = require("../symbols/index");
/** `[Json]` Creates a Ref type. The referenced type must contain a $id */
function Ref(...args) {
    const [$ref, options] = typeof args[0] === 'string' ? [args[0], args[1]] : [args[0].$id, args[1]];
    if (typeof $ref !== 'string')
        throw new index_1.TypeBoxError('Ref: $ref must be a string');
    return (0, type_1.CreateType)({ [index_2.Kind]: 'Ref', $ref }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\regexp\index.d.ts

Code:
export * from './regexp';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\regexp\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./regexp"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\regexp\regexp.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { TSchema } from '../schema/index';
import { Kind } from '../symbols/index';
export interface RegExpOptions extends SchemaOptions {
    /** The maximum length of the string */
    maxLength?: number;
    /** The minimum length of the string */
    minLength?: number;
}
export interface TRegExp extends TSchema {
    [Kind]: 'RegExp';
    static: `${string}`;
    type: 'RegExp';
    source: string;
    flags: string;
}
/** `[JavaScript]` Creates a RegExp type */
export declare function RegExp(pattern: string, options?: RegExpOptions): TRegExp;
/** `[JavaScript]` Creates a RegExp type */
export declare function RegExp(regex: RegExp, options?: RegExpOptions): TRegExp;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\regexp\regexp.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RegExp = RegExp;
const type_1 = require("../create/type");
const value_1 = require("../guard/value");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a RegExp type */
function RegExp(unresolved, options) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return (0, type_1.CreateType)({ [index_1.Kind]: 'RegExp', type: 'RegExp', source: expr.source, flags: expr.flags }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\format.d.ts

Code:
export type FormatRegistryValidationFunction = (value: string) => boolean;
/** Returns the entries in this registry */
export declare function Entries(): Map<string, FormatRegistryValidationFunction>;
/** Clears all user defined string formats */
export declare function Clear(): void;
/** Deletes a registered format */
export declare function Delete(format: string): boolean;
/** Returns true if the user defined string format exists */
export declare function Has(format: string): boolean;
/** Sets a validation function for a user defined string format */
export declare function Set(format: string, func: FormatRegistryValidationFunction): void;
/** Gets a validation function for a user defined string format */
export declare function Get(format: string): FormatRegistryValidationFunction | undefined;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\format.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Entries = Entries;
exports.Clear = Clear;
exports.Delete = Delete;
exports.Has = Has;
exports.Set = Set;
exports.Get = Get;
/** A registry for user defined string formats */
const map = new Map();
/** Returns the entries in this registry */
function Entries() {
    return new Map(map);
}
/** Clears all user defined string formats */
function Clear() {
    return map.clear();
}
/** Deletes a registered format */
function Delete(format) {
    return map.delete(format);
}
/** Returns true if the user defined string format exists */
function Has(format) {
    return map.has(format);
}
/** Sets a validation function for a user defined string format */
function Set(format, func) {
    map.set(format, func);
}
/** Gets a validation function for a user defined string format */
function Get(format) {
    return map.get(format);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\index.d.ts

Code:
export * as FormatRegistry from './format';
export * as TypeRegistry from './type';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeRegistry = exports.FormatRegistry = void 0;
exports.FormatRegistry = require("./format");
exports.TypeRegistry = require("./type");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\type.d.ts

Code:
export type TypeRegistryValidationFunction<TSchema> = (schema: TSchema, value: unknown) => boolean;
/** Returns the entries in this registry */
export declare function Entries(): Map<string, TypeRegistryValidationFunction<any>>;
/** Clears all user defined types */
export declare function Clear(): void;
/** Deletes a registered type */
export declare function Delete(kind: string): boolean;
/** Returns true if this registry contains this kind */
export declare function Has(kind: string): boolean;
/** Sets a validation function for a user defined type */
export declare function Set<TSchema = unknown>(kind: string, func: TypeRegistryValidationFunction<TSchema>): void;
/** Gets a custom validation function for a user defined type */
export declare function Get(kind: string): TypeRegistryValidationFunction<any> | undefined;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\registry\type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Entries = Entries;
exports.Clear = Clear;
exports.Delete = Delete;
exports.Has = Has;
exports.Set = Set;
exports.Get = Get;
/** A registry for user defined types */
const map = new Map();
/** Returns the entries in this registry */
function Entries() {
    return new Map(map);
}
/** Clears all user defined types */
function Clear() {
    return map.clear();
}
/** Deletes a registered type */
function Delete(kind) {
    return map.delete(kind);
}
/** Returns true if this registry contains this kind */
function Has(kind) {
    return map.has(kind);
}
/** Sets a validation function for a user defined type */
function Set(kind, func) {
    map.set(kind, func);
}
/** Gets a custom validation function for a user defined type */
function Get(kind) {
    return map.get(kind);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\index.d.ts

Code:
export * from './required-from-mapped-result';
export * from './required';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./required-from-mapped-result"), exports);
__exportStar(require("./required"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\required-from-mapped-result.d.ts

Code:
import type { SchemaOptions } from '../schema/index';
import type { Ensure, Evaluate } from '../helpers/index';
import type { TProperties } from '../object/index';
import { type TMappedResult } from '../mapped/index';
import { type TRequired } from './required';
type TFromProperties<P extends TProperties> = ({
    [K2 in keyof P]: TRequired<P[K2]>;
});
type TFromMappedResult<R extends TMappedResult> = (Evaluate<TFromProperties<R['properties']>>);
export type TRequiredFromMappedResult<R extends TMappedResult, P extends TProperties = TFromMappedResult<R>> = (Ensure<TMappedResult<P>>);
export declare function RequiredFromMappedResult<R extends TMappedResult, P extends TProperties = TFromMappedResult<R>>(R: R, options?: SchemaOptions): TMappedResult<P>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\required-from-mapped-result.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RequiredFromMappedResult = RequiredFromMappedResult;
const index_1 = require("../mapped/index");
const required_1 = require("./required");
// prettier-ignore
function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
}
// prettier-ignore
function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\required.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Evaluate, Ensure } from '../helpers/index';
import type { TMappedResult } from '../mapped/index';
import { type TReadonlyOptional } from '../readonly-optional/index';
import { type TComputed } from '../computed/index';
import { type TOptional } from '../optional/index';
import { type TReadonly } from '../readonly/index';
import { type TRecursive } from '../recursive/index';
import { type TObject, type TProperties } from '../object/index';
import { type TIntersect } from '../intersect/index';
import { type TUnion } from '../union/index';
import { type TRef } from '../ref/index';
import { type TBigInt } from '../bigint/index';
import { type TBoolean } from '../boolean/index';
import { type TInteger } from '../integer/index';
import { type TLiteral } from '../literal/index';
import { type TNull } from '../null/index';
import { type TNumber } from '../number/index';
import { type TString } from '../string/index';
import { type TSymbol } from '../symbol/index';
import { type TUndefined } from '../undefined/index';
import { type TRequiredFromMappedResult } from './required-from-mapped-result';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<TComputed<'Required', [TComputed<Target, Parameters>]>>;
type TFromRef<Ref extends string> = Ensure<TComputed<'Required', [TRef<Ref>]>>;
type TFromProperties<Properties extends TProperties> = Evaluate<{
    [K in keyof Properties]: Properties[K] extends (TReadonlyOptional<infer S>) ? TReadonly<S> : Properties[K] extends (TReadonly<infer S>) ? TReadonly<S> : Properties[K] extends (TOptional<infer S>) ? S : Properties[K];
}>;
type TFromObject<Type extends TObject, Properties extends TProperties = Type['properties']> = Ensure<TObject<(TFromProperties<Properties>)>>;
type TFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, [...Result, TRequired<L>]> : Result);
export type TRequired<Type extends TSchema> = (Type extends TRecursive<infer Type extends TSchema> ? TRecursive<TRequired<Type>> : Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromRest<Types>> : Type extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromRest<Types>> : Type extends TObject<infer Properties extends TProperties> ? TFromObject<TObject<Properties>> : Type extends TBigInt ? Type : Type extends TBoolean ? Type : Type extends TInteger ? Type : Type extends TLiteral ? Type : Type extends TNull ? Type : Type extends TNumber ? Type : Type extends TString ? Type : Type extends TSymbol ? Type : Type extends TUndefined ? Type : TObject<{}>);
/** `[Json]` Constructs a type where all properties are required */
export declare function Required<MappedResult extends TMappedResult>(type: MappedResult, options?: SchemaOptions): TRequiredFromMappedResult<MappedResult>;
/** `[Json]` Constructs a type where all properties are required */
export declare function Required<Type extends TSchema>(type: Type, options?: SchemaOptions): TRequired<Type>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\required\required.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Required = Required;
const type_1 = require("../create/type");
const index_1 = require("../computed/index");
const index_2 = require("../object/index");
const index_3 = require("../intersect/index");
const index_4 = require("../union/index");
const index_5 = require("../ref/index");
const index_6 = require("../symbols/index");
const index_7 = require("../discard/index");
const required_from_mapped_result_1 = require("./required-from-mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const KindGuard = require("../guard/kind");
// prettier-ignore
function FromComputed(target, parameters) {
    return (0, index_1.Computed)('Required', [(0, index_1.Computed)(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return (0, index_1.Computed)('Required', [(0, index_5.Ref)($ref)]);
}
// prettier-ignore
function FromProperties(properties) {
    const requiredProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
        requiredProperties[K] = (0, index_7.Discard)(properties[K], [index_6.OptionalKind]);
    return requiredProperties;
}
// prettier-ignore
function FromObject(type) {
    const options = (0, index_7.Discard)(type, [index_6.TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties(type['properties']);
    return (0, index_2.Object)(properties, options);
}
// prettier-ignore
function FromRest(types) {
    return types.map(type => RequiredResolve(type));
}
// ------------------------------------------------------------------
// RequiredResolve
// ------------------------------------------------------------------
// prettier-ignore
function RequiredResolve(type) {
    return (
    // Mappable
    KindGuard.IsComputed(type) ? FromComputed(type.target, type.parameters) :
        KindGuard.IsRef(type) ? FromRef(type.$ref) :
            KindGuard.IsIntersect(type) ? (0, index_3.Intersect)(FromRest(type.allOf)) :
                KindGuard.IsUnion(type) ? (0, index_4.Union)(FromRest(type.anyOf)) :
                    KindGuard.IsObject(type) ? FromObject(type) :
                        // Intrinsic
                        KindGuard.IsBigInt(type) ? type :
                            KindGuard.IsBoolean(type) ? type :
                                KindGuard.IsInteger(type) ? type :
                                    KindGuard.IsLiteral(type) ? type :
                                        KindGuard.IsNull(type) ? type :
                                            KindGuard.IsNumber(type) ? type :
                                                KindGuard.IsString(type) ? type :
                                                    KindGuard.IsSymbol(type) ? type :
                                                        KindGuard.IsUndefined(type) ? type :
                                                            // Passthrough
                                                            (0, index_2.Object)({}));
}
/** `[Json]` Constructs a type where all properties are required */
function Required(type, options) {
    if (KindGuard.IsMappedResult(type)) {
        return (0, required_from_mapped_result_1.RequiredFromMappedResult)(type, options);
    }
    else {
        // special: mapping types require overridable options
        return (0, type_1.CreateType)({ ...RequiredResolve(type), ...options });
    }
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\rest\index.d.ts

Code:
export * from './rest';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\rest\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./rest"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\rest\rest.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { TIntersect } from '../intersect/index';
import type { TUnion } from '../union/index';
import type { TTuple } from '../tuple/index';
type TRestResolve<T extends TSchema> = T extends TIntersect<infer S extends TSchema[]> ? S : T extends TUnion<infer S extends TSchema[]> ? S : T extends TTuple<infer S extends TSchema[]> ? S : [
];
export type TRest<T extends TSchema> = TRestResolve<T>;
/** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
export declare function Rest<T extends TSchema>(T: T): TRest<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\rest\rest.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = Rest;
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function RestResolve(T) {
    return ((0, kind_1.IsIntersect)(T) ? T.allOf :
        (0, kind_1.IsUnion)(T) ? T.anyOf :
            (0, kind_1.IsTuple)(T) ? T.items ?? [] :
                []);
}
/** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
function Rest(T) {
    return RestResolve(T);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\return-type\index.d.ts

Code:
export * from './return-type';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\return-type\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./return-type"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\return-type\return-type.d.ts

Code:
import { type TSchema, type SchemaOptions } from '../schema/index';
import { type TFunction } from '../function/index';
import { type TNever } from '../never/index';
export type TReturnType<Type extends TSchema, Result extends TSchema = Type extends TFunction<infer _Parameters extends TSchema[], infer ReturnType extends TSchema> ? ReturnType : TNever> = Result;
/** `[JavaScript]` Extracts the ReturnType from the given Function type */
export declare function ReturnType<Type extends TSchema>(schema: Type, options?: SchemaOptions): TReturnType<Type>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\return-type\return-type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReturnType = ReturnType;
const type_1 = require("../create/type");
const index_1 = require("../never/index");
const KindGuard = require("../guard/kind");
/** `[JavaScript]` Extracts the ReturnType from the given Function type */
function ReturnType(schema, options) {
    return (KindGuard.IsFunction(schema) ? (0, type_1.CreateType)(schema.returns, options) : (0, index_1.Never)(options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\anyschema.d.ts

Code:
import type { TAny } from '../any/index';
import type { TArray } from '../array/index';
import type { TAsyncIterator } from '../async-iterator/index';
import type { TBigInt } from '../bigint/index';
import type { TBoolean } from '../boolean/index';
import type { TConstructor } from '../constructor/index';
import type { TDate } from '../date/index';
import type { TEnum } from '../enum/index';
import type { TFunction } from '../function/index';
import type { TInteger } from '../integer/index';
import type { TIntersect } from '../intersect/index';
import type { TIterator } from '../iterator/index';
import type { TLiteral } from '../literal/index';
import type { TNot } from '../not/index';
import type { TNull } from '../null/index';
import type { TNumber } from '../number/index';
import type { TObject } from '../object/index';
import type { TPromise } from '../promise/index';
import type { TRecord } from '../record/index';
import type { TThis } from '../recursive/index';
import type { TRef } from '../ref/index';
import type { TRegExp } from '../regexp/index';
import type { TString } from '../string/index';
import type { TSymbol } from '../symbol/index';
import type { TTemplateLiteral } from '../template-literal/index';
import type { TTuple } from '../tuple/index';
import type { TUint8Array } from '../uint8array/index';
import type { TUndefined } from '../undefined/index';
import type { TUnion } from '../union/index';
import type { TUnknown } from '../unknown/index';
import type { TVoid } from '../void/index';
import type { TSchema } from './schema';
export type TAnySchema = TSchema | TAny | TArray | TAsyncIterator | TBigInt | TBoolean | TConstructor | TDate | TEnum | TFunction | TInteger | TIntersect | TIterator | TLiteral | TNot | TNull | TNumber | TObject | TPromise | TRecord | TRef | TRegExp | TString | TSymbol | TTemplateLiteral | TThis | TTuple | TUndefined | TUnion | TUint8Array | TUnknown | TVoid;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\anyschema.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\index.d.ts

Code:
export * from './anyschema';
export * from './schema';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./anyschema"), exports);
__exportStar(require("./schema"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\schema.d.ts

Code:
import { Kind, Hint, ReadonlyKind, OptionalKind } from '../symbols/index';
export interface SchemaOptions {
    $schema?: string;
    /** Id for this schema */
    $id?: string;
    /** Title of this schema */
    title?: string;
    /** Description of this schema */
    description?: string;
    /** Default value for this schema */
    default?: any;
    /** Example values matching this schema */
    examples?: any;
    /** Optional annotation for readOnly */
    readOnly?: boolean;
    /** Optional annotation for writeOnly */
    writeOnly?: boolean;
    [prop: string]: any;
}
export interface TKind {
    [Kind]: string;
}
export interface TSchema extends TKind, SchemaOptions {
    [ReadonlyKind]?: string;
    [OptionalKind]?: string;
    [Hint]?: string;
    params: unknown[];
    static: unknown;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\schema\schema.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../symbols/index");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\sets\index.d.ts

Code:
export * from './set';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\sets\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./set"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\sets\set.d.ts

Code:
export type TSetIncludes<T extends PropertyKey[], S extends PropertyKey> = (T extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? S extends L ? true : TSetIncludes<R, S> : false);
/** Returns true if element right is in the set of left */
export declare function SetIncludes<T extends PropertyKey[], S extends PropertyKey>(T: [...T], S: S): TSetIncludes<T, S>;
export type TSetIsSubset<T extends PropertyKey[], S extends PropertyKey[]> = (T extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TSetIncludes<S, L> extends true ? TSetIsSubset<R, S> : false : true);
/** Returns true if left is a subset of right */
export declare function SetIsSubset<T extends PropertyKey[], S extends PropertyKey[]>(T: [...T], S: [...S]): TSetIsSubset<T, S>;
export type TSetDistinct<T extends PropertyKey[], Acc extends PropertyKey[] = []> = T extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TSetIncludes<Acc, L> extends false ? TSetDistinct<R, [...Acc, L]> : TSetDistinct<R, [...Acc]> : Acc;
/** Returns a distinct set of elements */
export declare function SetDistinct<T extends PropertyKey[]>(T: [...T]): TSetDistinct<T>;
export type TSetIntersect<T extends PropertyKey[], S extends PropertyKey[], Acc extends PropertyKey[] = []> = (T extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TSetIncludes<S, L> extends true ? TSetIntersect<R, S, [...Acc, L]> : TSetIntersect<R, S, [...Acc]> : Acc);
/** Returns the Intersect of the given sets */
export declare function SetIntersect<T extends PropertyKey[], S extends PropertyKey[]>(T: [...T], S: [...S]): TSetIntersect<T, S>;
export type TSetUnion<T extends PropertyKey[], S extends PropertyKey[]> = ([
    ...T,
    ...S
]);
/** Returns the Union of the given sets */
export declare function SetUnion<T extends PropertyKey[], S extends PropertyKey[]>(T: [...T], S: [...S]): TSetUnion<T, S>;
export type TSetComplement<T extends PropertyKey[], S extends PropertyKey[], Acc extends PropertyKey[] = []> = (T extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TSetIncludes<S, L> extends true ? TSetComplement<R, S, [...Acc]> : TSetComplement<R, S, [...Acc, L]> : Acc);
/** Returns the Complement by omitting elements in T that are in S */
export declare function SetComplement<T extends PropertyKey[], S extends PropertyKey[]>(T: [...T], S: [...S]): TSetComplement<T, S>;
type TSetIntersectManyResolve<T extends PropertyKey[][], Acc extends PropertyKey[]> = (T extends [infer L extends PropertyKey[], ...infer R extends PropertyKey[][]] ? TSetIntersectManyResolve<R, TSetIntersect<Acc, L>> : Acc);
export type TSetIntersectMany<T extends PropertyKey[][]> = (T extends [infer L extends PropertyKey[]] ? L : T extends [infer L extends PropertyKey[], ...infer R extends PropertyKey[][]] ? TSetIntersectManyResolve<R, L> : []);
export declare function SetIntersectMany<T extends PropertyKey[][]>(T: [...T]): TSetIntersectMany<T>;
export type TSetUnionMany<T extends PropertyKey[][], Acc extends PropertyKey[] = []> = (T extends [infer L extends PropertyKey[], ...infer R extends PropertyKey[][]] ? TSetUnionMany<R, TSetUnion<Acc, L>> : Acc);
/** Returns the Union of multiple sets */
export declare function SetUnionMany<T extends PropertyKey[][]>(T: [...T]): TSetUnionMany<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\sets\set.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SetIncludes = SetIncludes;
exports.SetIsSubset = SetIsSubset;
exports.SetDistinct = SetDistinct;
exports.SetIntersect = SetIntersect;
exports.SetUnion = SetUnion;
exports.SetComplement = SetComplement;
exports.SetIntersectMany = SetIntersectMany;
exports.SetUnionMany = SetUnionMany;
/** Returns true if element right is in the set of left */
// prettier-ignore
function SetIncludes(T, S) {
    return T.includes(S);
}
/** Returns true if left is a subset of right */
function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes(S, L));
}
/** Returns a distinct set of elements */
function SetDistinct(T) {
    return [...new Set(T)];
}
/** Returns the Intersect of the given sets */
function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
}
/** Returns the Union of the given sets */
function SetUnion(T, S) {
    return [...T, ...S];
}
/** Returns the Complement by omitting elements in T that are in S */
// prettier-ignore
function SetComplement(T, S) {
    return T.filter(L => !S.includes(L));
}
// prettier-ignore
function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
        return SetIntersect(Acc, L);
    }, Init);
}
// prettier-ignore
function SetIntersectMany(T) {
    return (T.length === 1
        ? T[0]
        // Use left to initialize the accumulator for resolve
        : T.length > 1
            ? SetIntersectManyResolve(T.slice(1), T[0])
            : []);
}
/** Returns the Union of multiple sets */
function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
        Acc.push(...L);
    return Acc;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\static\index.d.ts

Code:
export * from './static';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\static\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./static"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\static\static.d.ts

Code:
import type { Evaluate } from '../helpers/index';
import type { TOptional } from '../optional/index';
import type { TReadonly } from '../readonly/index';
import type { TArray } from '../array/index';
import type { TAsyncIterator } from '../async-iterator/index';
import type { TConstructor } from '../constructor/index';
import type { TEnum } from '../enum/index';
import type { TFunction } from '../function/index';
import type { TIntersect } from '../intersect/index';
import type { TImport } from '../module/index';
import type { TIterator } from '../iterator/index';
import type { TNot } from '../not/index';
import type { TObject, TProperties } from '../object/index';
import type { TPromise } from '../promise/index';
import type { TRecursive } from '../recursive/index';
import type { TRecord } from '../record/index';
import type { TRef } from '../ref/index';
import type { TTuple } from '../tuple/index';
import type { TUnion } from '../union/index';
import type { TUnsafe } from '../unsafe/index';
import type { TSchema } from '../schema/index';
import type { TTransform } from '../transform/index';
import type { TNever } from '../never/index';
type TDecodeImport<ModuleProperties extends TProperties, Key extends PropertyKey> = (Key extends keyof ModuleProperties ? TDecodeType<ModuleProperties[Key]> extends infer Type extends TSchema ? Type extends TRef<infer Ref extends string> ? TDecodeImport<ModuleProperties, Ref> : Type : TNever : TNever);
type TDecodeProperties<Properties extends TProperties> = {
    [Key in keyof Properties]: TDecodeType<Properties[Key]>;
};
type TDecodeTypes<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TDecodeTypes<Right, [...Result, TDecodeType<Left>]> : Result);
export type TDecodeType<Type extends TSchema> = (Type extends TOptional<infer Type extends TSchema> ? TOptional<TDecodeType<Type>> : Type extends TReadonly<infer Type extends TSchema> ? TReadonly<TDecodeType<Type>> : Type extends TTransform<infer _Input extends TSchema, infer Output> ? TUnsafe<Output> : Type extends TArray<infer Type extends TSchema> ? TArray<TDecodeType<Type>> : Type extends TAsyncIterator<infer Type extends TSchema> ? TAsyncIterator<TDecodeType<Type>> : Type extends TConstructor<infer Parameters extends TSchema[], infer InstanceType extends TSchema> ? TConstructor<TDecodeTypes<Parameters>, TDecodeType<InstanceType>> : Type extends TEnum<infer Values> ? TEnum<Values> : Type extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TFunction<TDecodeTypes<Parameters>, TDecodeType<ReturnType>> : Type extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TDecodeTypes<Types>> : Type extends TImport<infer ModuleProperties extends TProperties, infer Key> ? TDecodeImport<ModuleProperties, Key> : Type extends TIterator<infer Type extends TSchema> ? TIterator<TDecodeType<Type>> : Type extends TNot<infer Type extends TSchema> ? TNot<TDecodeType<Type>> : Type extends TObject<infer Properties extends TProperties> ? TObject<Evaluate<TDecodeProperties<Properties>>> : Type extends TPromise<infer Type extends TSchema> ? TPromise<TDecodeType<Type>> : Type extends TRecord<infer Key extends TSchema, infer Value extends TSchema> ? TRecord<Key, TDecodeType<Value>> : Type extends TRecursive<infer Type extends TSchema> ? TRecursive<TDecodeType<Type>> : Type extends TRef<infer Ref extends string> ? TRef<Ref> : Type extends TTuple<infer Types extends TSchema[]> ? TTuple<TDecodeTypes<Types>> : Type extends TUnion<infer Types extends TSchema[]> ? TUnion<TDecodeTypes<Types>> : Type);
export type StaticDecodeIsAny<Type> = boolean extends (Type extends TSchema ? true : false) ? true : false;
/** Creates an decoded static type from a TypeBox type */
export type StaticDecode<Type extends TSchema, Params extends unknown[] = [], Result = StaticDecodeIsAny<Type> extends true ? unknown : Static<TDecodeType<Type>, Params>> = Result;
/** Creates an encoded static type from a TypeBox type */
export type StaticEncode<Type extends TSchema, Params extends unknown[] = [], Result = Static<Type, Params>> = Result;
/** Creates a static type from a TypeBox type */
export type Static<Type extends TSchema, Params extends unknown[] = [], Result = (Type & {
    params: Params;
})['static']> = Result;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\static\static.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\string\index.d.ts

Code:
export * from './string';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\string\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./string"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\string\string.d.ts

Code:
import { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export type StringFormatOption = 'date-time' | 'time' | 'date' | 'email' | 'idn-email' | 'hostname' | 'idn-hostname' | 'ipv4' | 'ipv6' | 'uri' | 'uri-reference' | 'iri' | 'uuid' | 'iri-reference' | 'uri-template' | 'json-pointer' | 'relative-json-pointer' | 'regex' | ({} & string);
export type StringContentEncodingOption = '7bit' | '8bit' | 'binary' | 'quoted-printable' | 'base64' | ({} & string);
export interface StringOptions extends SchemaOptions {
    /** The maximum string length */
    maxLength?: number;
    /** The minimum string length */
    minLength?: number;
    /** A regular expression pattern this string should match */
    pattern?: string;
    /** A format this string should match */
    format?: StringFormatOption;
    /** The content encoding for this string */
    contentEncoding?: StringContentEncodingOption;
    /** The content media type for this string */
    contentMediaType?: string;
}
export interface TString extends TSchema, StringOptions {
    [Kind]: 'String';
    static: string;
    type: 'string';
}
/** `[Json]` Creates a String type */
export declare function String(options?: StringOptions): TString;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\string\string.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.String = String;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a String type */
function String(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'String', type: 'string' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbol\index.d.ts

Code:
export * from './symbol';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbol\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./symbol"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbol\symbol.d.ts

Code:
import { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export type TSymbolValue = string | number | undefined;
export interface TSymbol extends TSchema, SchemaOptions {
    [Kind]: 'Symbol';
    static: symbol;
    type: 'symbol';
}
/** `[JavaScript]` Creates a Symbol type */
export declare function Symbol(options?: SchemaOptions): TSymbol;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbol\symbol.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Symbol = Symbol;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Symbol type */
function Symbol(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Symbol', type: 'symbol' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbols\index.d.ts

Code:
export * from './symbols';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbols\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./symbols"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbols\symbols.d.ts

Code:
/** Symbol key applied to transform types */
export declare const TransformKind: unique symbol;
/** Symbol key applied to readonly types */
export declare const ReadonlyKind: unique symbol;
/** Symbol key applied to optional types */
export declare const OptionalKind: unique symbol;
/** Symbol key applied to types */
export declare const Hint: unique symbol;
/** Symbol key applied to types */
export declare const Kind: unique symbol;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\symbols\symbols.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = void 0;
/** Symbol key applied to transform types */
exports.TransformKind = Symbol.for('TypeBox.Transform');
/** Symbol key applied to readonly types */
exports.ReadonlyKind = Symbol.for('TypeBox.Readonly');
/** Symbol key applied to optional types */
exports.OptionalKind = Symbol.for('TypeBox.Optional');
/** Symbol key applied to types */
exports.Hint = Symbol.for('TypeBox.Hint');
/** Symbol key applied to types */
exports.Kind = Symbol.for('TypeBox.Kind');


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\finite.d.ts

Code:
import { TypeBoxError } from '../error/index';
import type { TTemplateLiteral, TTemplateLiteralKind } from './index';
import type { TUnion } from '../union/index';
import type { TString } from '../string/index';
import type { TBoolean } from '../boolean/index';
import type { TNumber } from '../number/index';
import type { TInteger } from '../integer/index';
import type { TBigInt } from '../bigint/index';
import type { TLiteral } from '../literal/index';
import type { Expression } from './parse';
export declare class TemplateLiteralFiniteError extends TypeBoxError {
}
type TFromTemplateLiteralKind<T> = T extends TTemplateLiteral<infer U extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<U> : T extends TUnion<infer U extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<U> : T extends TString ? false : T extends TNumber ? false : T extends TInteger ? false : T extends TBigInt ? false : T extends TBoolean ? true : T extends TLiteral ? true : false;
type TFromTemplateLiteralKinds<T extends TTemplateLiteralKind[]> = T extends [infer L extends TTemplateLiteralKind, ...infer R extends TTemplateLiteralKind[]] ? TFromTemplateLiteralKind<L> extends false ? false : TFromTemplateLiteralKinds<R> : true;
export declare function IsTemplateLiteralExpressionFinite(expression: Expression): boolean;
export type TIsTemplateLiteralFinite<T> = T extends TTemplateLiteral<infer U> ? TFromTemplateLiteralKinds<U> : false;
/** Returns true if this TemplateLiteral resolves to a finite set of values */
export declare function IsTemplateLiteralFinite<T extends TTemplateLiteral>(schema: T): boolean;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\finite.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralFiniteError = void 0;
exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
const parse_1 = require("./parse");
const index_1 = require("../error/index");
// ------------------------------------------------------------------
// TemplateLiteralFiniteError
// ------------------------------------------------------------------
class TemplateLiteralFiniteError extends index_1.TypeBoxError {
}
exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
// ------------------------------------------------------------------
// IsTemplateLiteralFiniteCheck
// ------------------------------------------------------------------
// prettier-ignore
function IsNumberExpression(expression) {
    return (expression.type === 'or' &&
        expression.expr.length === 2 &&
        expression.expr[0].type === 'const' &&
        expression.expr[0].const === '0' &&
        expression.expr[1].type === 'const' &&
        expression.expr[1].const === '[1-9][0-9]*');
}
// prettier-ignore
function IsBooleanExpression(expression) {
    return (expression.type === 'or' &&
        expression.expr.length === 2 &&
        expression.expr[0].type === 'const' &&
        expression.expr[0].const === 'true' &&
        expression.expr[1].type === 'const' &&
        expression.expr[1].const === 'false');
}
// prettier-ignore
function IsStringExpression(expression) {
    return expression.type === 'const' && expression.const === '.*';
}
// ------------------------------------------------------------------
// IsTemplateLiteralExpressionFinite
// ------------------------------------------------------------------
// prettier-ignore
function IsTemplateLiteralExpressionFinite(expression) {
    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :
        IsBooleanExpression(expression) ? true :
            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                    (expression.type === 'const') ? true :
                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());
}
/** Returns true if this TemplateLiteral resolves to a finite set of values */
function IsTemplateLiteralFinite(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\generate.d.ts

Code:
import { TIsTemplateLiteralFinite } from './finite';
import { TypeBoxError } from '../error/index';
import type { Assert } from '../helpers/index';
import type { TBoolean } from '../boolean/index';
import type { TTemplateLiteral, TTemplateLiteralKind } from './index';
import type { TLiteral, TLiteralValue } from '../literal/index';
import type { Expression } from './parse';
import type { TUnion } from '../union/index';
export declare class TemplateLiteralGenerateError extends TypeBoxError {
}
type TStringReduceUnary<L extends string, R extends string[], Acc extends string[] = []> = R extends [infer A extends string, ...infer B extends string[]] ? TStringReduceUnary<L, B, [...Acc, `${L}${A}`]> : Acc;
type TStringReduceBinary<L extends string[], R extends string[], Acc extends string[] = []> = L extends [infer A extends string, ...infer B extends string[]] ? TStringReduceBinary<B, R, [...Acc, ...TStringReduceUnary<A, R>]> : Acc;
type TStringReduceMany<T extends string[][]> = T extends [infer L extends string[], infer R extends string[], ...infer Rest extends string[][]] ? TStringReduceMany<[TStringReduceBinary<L, R>, ...Rest]> : T;
type TStringReduce<T extends string[][], O = TStringReduceMany<T>> = 0 extends keyof O ? Assert<O[0], string[]> : [];
type TFromTemplateLiteralUnionKinds<T extends TTemplateLiteralKind[]> = T extends [infer L extends TLiteral, ...infer R extends TLiteral[]] ? [`${L['const']}`, ...TFromTemplateLiteralUnionKinds<R>] : [];
type TFromTemplateLiteralKinds<T extends TTemplateLiteralKind[], Acc extends TLiteralValue[][] = []> = T extends [infer L extends TTemplateLiteralKind, ...infer R extends TTemplateLiteralKind[]] ? (L extends TTemplateLiteral<infer S extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<[...S, ...R], Acc> : L extends TLiteral<infer S extends TLiteralValue> ? TFromTemplateLiteralKinds<R, [...Acc, [S]]> : L extends TUnion<infer S extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<R, [...Acc, TFromTemplateLiteralUnionKinds<S>]> : L extends TBoolean ? TFromTemplateLiteralKinds<R, [...Acc, ['true', 'false']]> : Acc) : Acc;
export declare function TemplateLiteralExpressionGenerate(expression: Expression): IterableIterator<string>;
export type TTemplateLiteralGenerate<T extends TTemplateLiteral, F = TIsTemplateLiteralFinite<T>> = F extends true ? (T extends TTemplateLiteral<infer S extends TTemplateLiteralKind[]> ? TFromTemplateLiteralKinds<S> extends infer R extends string[][] ? TStringReduce<R> : [] : []) : [];
/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */
export declare function TemplateLiteralGenerate<T extends TTemplateLiteral>(schema: T): TTemplateLiteralGenerate<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\generate.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralGenerateError = void 0;
exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
exports.TemplateLiteralGenerate = TemplateLiteralGenerate;
const finite_1 = require("./finite");
const parse_1 = require("./parse");
const index_1 = require("../error/index");
// ------------------------------------------------------------------
// TemplateLiteralGenerateError
// ------------------------------------------------------------------
class TemplateLiteralGenerateError extends index_1.TypeBoxError {
}
exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
// ------------------------------------------------------------------
// TemplateLiteralExpressionGenerate
// ------------------------------------------------------------------
// prettier-ignore
function* GenerateReduce(buffer) {
    if (buffer.length === 1)
        return yield* buffer[0];
    for (const left of buffer[0]) {
        for (const right of GenerateReduce(buffer.slice(1))) {
            yield `${left}${right}`;
        }
    }
}
// prettier-ignore
function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
// prettier-ignore
function* GenerateOr(expression) {
    for (const expr of expression.expr)
        yield* TemplateLiteralExpressionGenerate(expr);
}
// prettier-ignore
function* GenerateConst(expression) {
    return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === 'and'
        ? yield* GenerateAnd(expression)
        : expression.type === 'or'
            ? yield* GenerateOr(expression)
            : expression.type === 'const'
                ? yield* GenerateConst(expression)
                : (() => {
                    throw new TemplateLiteralGenerateError('Unknown expression');
                })();
}
/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */
function TemplateLiteralGenerate(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    // prettier-ignore
    return ((0, finite_1.IsTemplateLiteralExpressionFinite)(expression)
        ? [...TemplateLiteralExpressionGenerate(expression)]
        : []);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\index.d.ts

Code:
export * from './finite';
export * from './generate';
export * from './syntax';
export * from './parse';
export * from './pattern';
export * from './union';
export * from './template-literal';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./finite"), exports);
__exportStar(require("./generate"), exports);
__exportStar(require("./syntax"), exports);
__exportStar(require("./parse"), exports);
__exportStar(require("./pattern"), exports);
__exportStar(require("./union"), exports);
__exportStar(require("./template-literal"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\parse.d.ts

Code:
import { TypeBoxError } from '../error/index';
export declare class TemplateLiteralParserError extends TypeBoxError {
}
export type Expression = ExpressionAnd | ExpressionOr | ExpressionConst;
export type ExpressionConst = {
    type: 'const';
    const: string;
};
export type ExpressionAnd = {
    type: 'and';
    expr: Expression[];
};
export type ExpressionOr = {
    type: 'or';
    expr: Expression[];
};
/** Parses a pattern and returns an expression tree */
export declare function TemplateLiteralParse(pattern: string): Expression;
/** Parses a pattern and strips forward and trailing ^ and $ */
export declare function TemplateLiteralParseExact(pattern: string): Expression;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\parse.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralParserError = void 0;
exports.TemplateLiteralParse = TemplateLiteralParse;
exports.TemplateLiteralParseExact = TemplateLiteralParseExact;
const index_1 = require("../error/index");
// ------------------------------------------------------------------
// TemplateLiteralParserError
// ------------------------------------------------------------------
class TemplateLiteralParserError extends index_1.TypeBoxError {
}
exports.TemplateLiteralParserError = TemplateLiteralParserError;
// -------------------------------------------------------------------
// Unescape
//
// Unescape for these control characters specifically. Note that this
// function is only called on non union group content, and where we
// still want to allow the user to embed control characters in that
// content. For review.
// -------------------------------------------------------------------
// prettier-ignore
function Unescape(pattern) {
    return pattern
        .replace(/\\\$/g, '$')
        .replace(/\\\*/g, '*')
        .replace(/\\\^/g, '^')
        .replace(/\\\|/g, '|')
        .replace(/\\\(/g, '(')
        .replace(/\\\)/g, ')');
}
// -------------------------------------------------------------------
// Control Characters
// -------------------------------------------------------------------
function IsNonEscaped(pattern, index, char) {
    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
    return IsNonEscaped(pattern, index, '(');
}
function IsCloseParen(pattern, index) {
    return IsNonEscaped(pattern, index, ')');
}
function IsSeparator(pattern, index) {
    return IsNonEscaped(pattern, index, '|');
}
// -------------------------------------------------------------------
// Control Groups
// -------------------------------------------------------------------
function IsGroup(pattern) {
    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
    let count = 0;
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (count === 0 && index !== pattern.length - 1)
            return false;
    }
    return true;
}
// prettier-ignore
function InGroup(pattern) {
    return pattern.slice(1, pattern.length - 1);
}
// prettier-ignore
function IsPrecedenceOr(pattern) {
    let count = 0;
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (IsSeparator(pattern, index) && count === 0)
            return true;
    }
    return false;
}
// prettier-ignore
function IsPrecedenceAnd(pattern) {
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            return true;
    }
    return false;
}
// prettier-ignore
function Or(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (IsSeparator(pattern, index) && count === 0) {
            const range = pattern.slice(start, index);
            if (range.length > 0)
                expressions.push(TemplateLiteralParse(range));
            start = index + 1;
        }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
        return { type: 'const', const: '' };
    if (expressions.length === 1)
        return expressions[0];
    return { type: 'or', expr: expressions };
}
// prettier-ignore
function And(pattern) {
    function Group(value, index) {
        if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
                count += 1;
            if (IsCloseParen(value, scan))
                count -= 1;
            if (count === 0)
                return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern, index) {
        for (let scan = index; scan < pattern.length; scan++) {
            if (IsOpenParen(pattern, scan))
                return [index, scan];
        }
        return [index, pattern.length];
    }
    const expressions = [];
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(TemplateLiteralParse(range));
            index = end;
        }
        else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
                expressions.push(TemplateLiteralParse(range));
            index = end - 1;
        }
    }
    return ((expressions.length === 0) ? { type: 'const', const: '' } :
        (expressions.length === 1) ? expressions[0] :
            { type: 'and', expr: expressions });
}
// ------------------------------------------------------------------
// TemplateLiteralParse
// ------------------------------------------------------------------
/** Parses a pattern and returns an expression tree */
function TemplateLiteralParse(pattern) {
    // prettier-ignore
    return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :
        IsPrecedenceOr(pattern) ? Or(pattern) :
            IsPrecedenceAnd(pattern) ? And(pattern) :
                { type: 'const', const: Unescape(pattern) });
}
// ------------------------------------------------------------------
// TemplateLiteralParseExact
// ------------------------------------------------------------------
/** Parses a pattern and strips forward and trailing ^ and $ */
function TemplateLiteralParseExact(pattern) {
    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\pattern.d.ts

Code:
import type { TTemplateLiteralKind } from './index';
import { TypeBoxError } from '../error/index';
export declare class TemplateLiteralPatternError extends TypeBoxError {
}
export declare function TemplateLiteralPattern(kinds: TTemplateLiteralKind[]): string;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\pattern.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralPatternError = void 0;
exports.TemplateLiteralPattern = TemplateLiteralPattern;
const index_1 = require("../patterns/index");
const index_2 = require("../symbols/index");
const index_3 = require("../error/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// ------------------------------------------------------------------
// TemplateLiteralPatternError
// ------------------------------------------------------------------
class TemplateLiteralPatternError extends index_3.TypeBoxError {
}
exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
// ------------------------------------------------------------------
// TemplateLiteralPattern
// ------------------------------------------------------------------
function Escape(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// prettier-ignore
function Visit(schema, acc) {
    return ((0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :
        (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :
            (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` :
                (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` :
                    (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` :
                        (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` :
                            (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape(schema.const.toString())}` :
                                (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` :
                                    (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[index_2.Kind]}'`); })());
}
function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema) => Visit(schema, '')).join('')}\$`;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\syntax.d.ts

Code:
import type { Assert, Trim } from '../helpers/index';
import type { TTemplateLiteral, TTemplateLiteralKind } from './index';
import { type TLiteral } from '../literal/index';
import { type TBoolean } from '../boolean/index';
import { type TBigInt } from '../bigint/index';
import { type TNumber } from '../number/index';
import { type TString } from '../string/index';
import { type TUnionEvaluated } from '../union/index';
declare function FromUnion(syntax: string): IterableIterator<TTemplateLiteralKind>;
declare function FromTerminal(syntax: string): IterableIterator<TTemplateLiteralKind>;
type FromUnionLiteral<T extends string> = T extends `${infer L}|${infer R}` ? [TLiteral<Trim<L>>, ...FromUnionLiteral<R>] : T extends `${infer L}` ? [TLiteral<Trim<L>>] : [
];
type FromUnion<T extends string> = TUnionEvaluated<FromUnionLiteral<T>>;
type FromTerminal<T extends string> = T extends 'boolean' ? TBoolean : T extends 'bigint' ? TBigInt : T extends 'number' ? TNumber : T extends 'string' ? TString : FromUnion<T>;
type FromString<T extends string> = T extends `{${infer L}}${infer R}` ? [FromTerminal<L>, ...FromString<R>] : T extends `${infer L}$\{${infer R1}\}${infer R2}` ? [TLiteral<L>, ...FromString<`{${R1}}`>, ...FromString<R2>] : T extends `${infer L}$\{${infer R1}\}` ? [TLiteral<L>, ...FromString<`{${R1}}`>] : T extends `${infer L}` ? [TLiteral<L>] : [
];
export type TTemplateLiteralSyntax<T extends string> = (TTemplateLiteral<Assert<FromString<T>, TTemplateLiteralKind[]>>);
/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */
export declare function TemplateLiteralSyntax(syntax: string): TTemplateLiteralKind[];
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\syntax.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralSyntax = TemplateLiteralSyntax;
const index_1 = require("../literal/index");
const index_2 = require("../boolean/index");
const index_3 = require("../bigint/index");
const index_4 = require("../number/index");
const index_5 = require("../string/index");
const index_6 = require("../union/index");
const index_7 = require("../never/index");
// ------------------------------------------------------------------
// SyntaxParsers
// ------------------------------------------------------------------
// prettier-ignore
function* FromUnion(syntax) {
    const trim = syntax.trim().replace(/"|'/g, '');
    return (trim === 'boolean' ? yield (0, index_2.Boolean)() :
        trim === 'number' ? yield (0, index_4.Number)() :
            trim === 'bigint' ? yield (0, index_3.BigInt)() :
                trim === 'string' ? yield (0, index_5.String)() :
                    yield (() => {
                        const literals = trim.split('|').map((literal) => (0, index_1.Literal)(literal.trim()));
                        return (literals.length === 0 ? (0, index_7.Never)() :
                            literals.length === 1 ? literals[0] :
                                (0, index_6.UnionEvaluated)(literals));
                    })());
}
// prettier-ignore
function* FromTerminal(syntax) {
    if (syntax[1] !== '{') {
        const L = (0, index_1.Literal)('$');
        const R = FromSyntax(syntax.slice(1));
        return yield* [L, ...R];
    }
    for (let i = 2; i < syntax.length; i++) {
        if (syntax[i] === '}') {
            const L = FromUnion(syntax.slice(2, i));
            const R = FromSyntax(syntax.slice(i + 1));
            return yield* [...L, ...R];
        }
    }
    yield (0, index_1.Literal)(syntax);
}
// prettier-ignore
function* FromSyntax(syntax) {
    for (let i = 0; i < syntax.length; i++) {
        if (syntax[i] === '$') {
            const L = (0, index_1.Literal)(syntax.slice(0, i));
            const R = FromTerminal(syntax.slice(i));
            return yield* [L, ...R];
        }
    }
    yield (0, index_1.Literal)(syntax);
}
/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */
function TemplateLiteralSyntax(syntax) {
    return [...FromSyntax(syntax)];
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\template-literal.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Assert } from '../helpers/index';
import type { TUnion } from '../union/index';
import type { TLiteral } from '../literal/index';
import type { TInteger } from '../integer/index';
import type { TNumber } from '../number/index';
import type { TBigInt } from '../bigint/index';
import type { TString } from '../string/index';
import type { TBoolean } from '../boolean/index';
import type { TNever } from '../never/index';
import type { Static } from '../static/index';
import { type TTemplateLiteralSyntax } from './syntax';
import { EmptyString } from '../helpers/index';
import { Kind } from '../symbols/index';
type TemplateLiteralStaticKind<T, Acc extends string> = T extends TUnion<infer U> ? {
    [K in keyof U]: TemplateLiteralStatic<Assert<[U[K]], TTemplateLiteralKind[]>, Acc>;
}[number] : T extends TTemplateLiteral ? `${Static<T>}` : T extends TLiteral<infer U> ? `${U}` : T extends TString ? `${string}` : T extends TNumber ? `${number}` : T extends TBigInt ? `${bigint}` : T extends TBoolean ? `${boolean}` : never;
type TemplateLiteralStatic<T extends TTemplateLiteralKind[], Acc extends string> = T extends [infer L, ...infer R] ? `${TemplateLiteralStaticKind<L, Acc>}${TemplateLiteralStatic<Assert<R, TTemplateLiteralKind[]>, Acc>}` : Acc;
export type TTemplateLiteralKind = TTemplateLiteral | TUnion | TLiteral | TInteger | TNumber | TBigInt | TString | TBoolean | TNever;
export interface TTemplateLiteral<T extends TTemplateLiteralKind[] = TTemplateLiteralKind[]> extends TSchema {
    [Kind]: 'TemplateLiteral';
    static: TemplateLiteralStatic<T, EmptyString>;
    type: 'string';
    pattern: string;
}
/** `[Json]` Creates a TemplateLiteral type from template dsl string */
export declare function TemplateLiteral<T extends string>(syntax: T, options?: SchemaOptions): TTemplateLiteralSyntax<T>;
/** `[Json]` Creates a TemplateLiteral type */
export declare function TemplateLiteral<T extends TTemplateLiteralKind[]>(kinds: [...T], options?: SchemaOptions): TTemplateLiteral<T>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\template-literal.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteral = TemplateLiteral;
const type_1 = require("../create/type");
const syntax_1 = require("./syntax");
const pattern_1 = require("./pattern");
const value_1 = require("../guard/value");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a TemplateLiteral type */
// prettier-ignore
function TemplateLiteral(unresolved, options) {
    const pattern = (0, value_1.IsString)(unresolved)
        ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved))
        : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return (0, type_1.CreateType)({ [index_1.Kind]: 'TemplateLiteral', type: 'string', pattern }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\union.d.ts

Code:
import type { Static } from '../static/index';
import type { TTemplateLiteral } from './template-literal';
import type { UnionToTuple } from '../helpers/index';
import { type TUnionEvaluated } from '../union/index';
import { type TLiteral } from '../literal/index';
export type TTemplateLiteralToUnionLiteralArray<T extends string[], Acc extends TLiteral[] = []> = (T extends [infer L extends string, ...infer R extends string[]] ? TTemplateLiteralToUnionLiteralArray<R, [...Acc, TLiteral<L>]> : Acc);
export type TTemplateLiteralToUnion<T extends TTemplateLiteral, U extends string[] = UnionToTuple<Static<T>>> = TUnionEvaluated<TTemplateLiteralToUnionLiteralArray<U>>;
/** Returns a Union from the given TemplateLiteral */
export declare function TemplateLiteralToUnion<T extends TTemplateLiteral>(schema: TTemplateLiteral): TTemplateLiteralToUnion<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\template-literal\union.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateLiteralToUnion = TemplateLiteralToUnion;
const index_1 = require("../union/index");
const index_2 = require("../literal/index");
const generate_1 = require("./generate");
/** Returns a Union from the given TemplateLiteral */
function TemplateLiteralToUnion(schema) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\transform\index.d.ts

Code:
export * from './transform';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\transform\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./transform"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\transform\transform.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Static, StaticDecode } from '../static/index';
import { TransformKind } from '../symbols/index';
export declare class TransformDecodeBuilder<T extends TSchema> {
    private readonly schema;
    constructor(schema: T);
    Decode<U extends unknown, D extends TransformFunction<StaticDecode<T>, U>>(decode: D): TransformEncodeBuilder<T, D>;
}
export declare class TransformEncodeBuilder<T extends TSchema, D extends TransformFunction> {
    private readonly schema;
    private readonly decode;
    constructor(schema: T, decode: D);
    private EncodeTransform;
    private EncodeSchema;
    Encode<E extends TransformFunction<ReturnType<D>, StaticDecode<T>>>(encode: E): TTransform<T, ReturnType<D>>;
}
type TransformStatic<T extends TSchema, P extends unknown[] = []> = T extends TTransform<infer _, infer S> ? S : Static<T, P>;
export type TransformFunction<T = any, U = any> = (value: T) => U;
export interface TransformOptions<I extends TSchema = TSchema, O extends unknown = unknown> {
    Decode: TransformFunction<StaticDecode<I>, O>;
    Encode: TransformFunction<O, StaticDecode<I>>;
}
export interface TTransform<I extends TSchema = TSchema, O extends unknown = unknown> extends TSchema {
    static: TransformStatic<I, this['params']>;
    [TransformKind]: TransformOptions<I, O>;
    [key: string]: any;
}
/** `[Json]` Creates a Transform type */
export declare function Transform<I extends TSchema>(schema: I): TransformDecodeBuilder<I>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\transform\transform.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = void 0;
exports.Transform = Transform;
const index_1 = require("../symbols/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// ------------------------------------------------------------------
// TransformBuilders
// ------------------------------------------------------------------
class TransformDecodeBuilder {
    constructor(schema) {
        this.schema = schema;
    }
    Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
    }
}
exports.TransformDecodeBuilder = TransformDecodeBuilder;
// prettier-ignore
class TransformEncodeBuilder {
    constructor(schema, decode) {
        this.schema = schema;
        this.decode = decode;
    }
    EncodeTransform(encode, schema) {
        const Encode = (value) => schema[index_1.TransformKind].Encode(encode(value));
        const Decode = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
        const Codec = { Encode: Encode, Decode: Decode };
        return { ...schema, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode, schema) {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [index_1.TransformKind]: Codec };
    }
    Encode(encode) {
        return ((0, kind_1.IsTransform)(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema));
    }
}
exports.TransformEncodeBuilder = TransformEncodeBuilder;
/** `[Json]` Creates a Transform type */
function Transform(schema) {
    return new TransformDecodeBuilder(schema);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\tuple\index.d.ts

Code:
export * from './tuple';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\tuple\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./tuple"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\tuple\tuple.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
type TupleStatic<T extends TSchema[], P extends unknown[], Acc extends unknown[] = []> = T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TupleStatic<R, P, [...Acc, Static<L, P>]> : Acc;
export interface TTuple<T extends TSchema[] = TSchema[]> extends TSchema {
    [Kind]: 'Tuple';
    static: TupleStatic<T, this['params']>;
    type: 'array';
    items?: T;
    additionalItems?: false;
    minItems: number;
    maxItems: number;
}
/** `[Json]` Creates a Tuple type */
export declare function Tuple<Types extends TSchema[]>(types: [...Types], options?: SchemaOptions): TTuple<Types>;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\tuple\tuple.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tuple = Tuple;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Tuple type */
function Tuple(types, options) {
    // prettier-ignore
    return (0, type_1.CreateType)(types.length > 0 ?
        { [index_1.Kind]: 'Tuple', type: 'array', items: types, additionalItems: false, minItems: types.length, maxItems: types.length } :
        { [index_1.Kind]: 'Tuple', type: 'array', minItems: types.length, maxItems: types.length }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\index.d.ts

Code:
export { JsonTypeBuilder } from './json';
import { JavaScriptTypeBuilder } from './javascript';
/** JavaScript Type Builder with Static Resolution for TypeScript */
declare const Type: InstanceType<typeof JavaScriptTypeBuilder>;
export { JavaScriptTypeBuilder };
export { Type };


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\index.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = void 0;
// ------------------------------------------------------------------
// JsonTypeBuilder
// ------------------------------------------------------------------
var json_1 = require("./json");
Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function () { return json_1.JsonTypeBuilder; } });
// ------------------------------------------------------------------
// JavaScriptTypeBuilder
// ------------------------------------------------------------------
const TypeBuilder = require("./type");
const javascript_1 = require("./javascript");
Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function () { return javascript_1.JavaScriptTypeBuilder; } });
/** JavaScript Type Builder with Static Resolution for TypeScript */
const Type = TypeBuilder;
exports.Type = Type;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\javascript.d.ts

Code:
import { JsonTypeBuilder } from './json';
import { type TArgument } from '../argument/index';
import { type TAsyncIterator } from '../async-iterator/index';
import { type TAwaited } from '../awaited/index';
import { type TBigInt, type BigIntOptions } from '../bigint/index';
import { type TConstructor } from '../constructor/index';
import { type TConstructorParameters } from '../constructor-parameters/index';
import { type TDate, type DateOptions } from '../date/index';
import { type TFunction } from '../function/index';
import { type TInstanceType } from '../instance-type/index';
import { type TInstantiate } from '../instantiate/index';
import { type TIterator } from '../iterator/index';
import { type TParameters } from '../parameters/index';
import { type TPromise } from '../promise/index';
import { type TRegExp, RegExpOptions } from '../regexp/index';
import { type TReturnType } from '../return-type/index';
import { type TSchema, type SchemaOptions } from '../schema/index';
import { type TSymbol } from '../symbol/index';
import { type TUint8Array, type Uint8ArrayOptions } from '../uint8array/index';
import { type TUndefined } from '../undefined/index';
import { type TVoid } from '../void/index';
/** JavaScript Type Builder with Static Resolution for TypeScript */
export declare class JavaScriptTypeBuilder extends JsonTypeBuilder {
    /** `[JavaScript]` Creates a Generic Argument Type */
    Argument<Index extends number>(index: Index): TArgument<Index>;
    /** `[JavaScript]` Creates a AsyncIterator type */
    AsyncIterator<Type extends TSchema>(items: Type, options?: SchemaOptions): TAsyncIterator<Type>;
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    Awaited<Type extends TSchema>(schema: Type, options?: SchemaOptions): TAwaited<Type>;
    /** `[JavaScript]` Creates a BigInt type */
    BigInt(options?: BigIntOptions): TBigInt;
    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters<Type extends TSchema>(schema: Type, options?: SchemaOptions): TConstructorParameters<Type>;
    /** `[JavaScript]` Creates a Constructor type */
    Constructor<Parameters extends TSchema[], InstanceType extends TSchema>(parameters: [...Parameters], instanceType: InstanceType, options?: SchemaOptions): TConstructor<Parameters, InstanceType>;
    /** `[JavaScript]` Creates a Date type */
    Date(options?: DateOptions): TDate;
    /** `[JavaScript]` Creates a Function type */
    Function<Parameters extends TSchema[], ReturnType extends TSchema>(parameters: [...Parameters], returnType: ReturnType, options?: SchemaOptions): TFunction<Parameters, ReturnType>;
    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    InstanceType<Type extends TSchema>(schema: Type, options?: SchemaOptions): TInstanceType<Type>;
    /** `[JavaScript]` Instantiates a type with the given parameters */
    Instantiate<Type extends TSchema, Parameters extends TSchema[]>(schema: Type, parameters: [...Parameters]): TInstantiate<Type, Parameters>;
    /** `[JavaScript]` Creates an Iterator type */
    Iterator<Type extends TSchema>(items: Type, options?: SchemaOptions): TIterator<Type>;
    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    Parameters<Type extends TSchema>(schema: Type, options?: SchemaOptions): TParameters<Type>;
    /** `[JavaScript]` Creates a Promise type */
    Promise<Type extends TSchema>(item: Type, options?: SchemaOptions): TPromise<Type>;
    /** `[JavaScript]` Creates a RegExp type */
    RegExp(pattern: string, options?: RegExpOptions): TRegExp;
    /** `[JavaScript]` Creates a RegExp type */
    RegExp(regex: RegExp, options?: RegExpOptions): TRegExp;
    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    ReturnType<Type extends TSchema>(type: Type, options?: SchemaOptions): TReturnType<Type>;
    /** `[JavaScript]` Creates a Symbol type */
    Symbol(options?: SchemaOptions): TSymbol;
    /** `[JavaScript]` Creates a Undefined type */
    Undefined(options?: SchemaOptions): TUndefined;
    /** `[JavaScript]` Creates a Uint8Array type */
    Uint8Array(options?: Uint8ArrayOptions): TUint8Array;
    /** `[JavaScript]` Creates a Void type */
    Void(options?: SchemaOptions): TVoid;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\javascript.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptTypeBuilder = void 0;
const json_1 = require("./json");
const index_1 = require("../argument/index");
const index_2 = require("../async-iterator/index");
const index_3 = require("../awaited/index");
const index_4 = require("../bigint/index");
const index_5 = require("../constructor/index");
const index_6 = require("../constructor-parameters/index");
const index_7 = require("../date/index");
const index_8 = require("../function/index");
const index_9 = require("../instance-type/index");
const index_10 = require("../instantiate/index");
const index_11 = require("../iterator/index");
const index_12 = require("../parameters/index");
const index_13 = require("../promise/index");
const index_14 = require("../regexp/index");
const index_15 = require("../return-type/index");
const index_16 = require("../symbol/index");
const index_17 = require("../uint8array/index");
const index_18 = require("../undefined/index");
const index_19 = require("../void/index");
/** JavaScript Type Builder with Static Resolution for TypeScript */
class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    /** `[JavaScript]` Creates a Generic Argument Type */
    Argument(index) {
        return (0, index_1.Argument)(index);
    }
    /** `[JavaScript]` Creates a AsyncIterator type */
    AsyncIterator(items, options) {
        return (0, index_2.AsyncIterator)(items, options);
    }
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    Awaited(schema, options) {
        return (0, index_3.Awaited)(schema, options);
    }
    /** `[JavaScript]` Creates a BigInt type */
    BigInt(options) {
        return (0, index_4.BigInt)(options);
    }
    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema, options) {
        return (0, index_6.ConstructorParameters)(schema, options);
    }
    /** `[JavaScript]` Creates a Constructor type */
    Constructor(parameters, instanceType, options) {
        return (0, index_5.Constructor)(parameters, instanceType, options);
    }
    /** `[JavaScript]` Creates a Date type */
    Date(options = {}) {
        return (0, index_7.Date)(options);
    }
    /** `[JavaScript]` Creates a Function type */
    Function(parameters, returnType, options) {
        return (0, index_8.Function)(parameters, returnType, options);
    }
    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    InstanceType(schema, options) {
        return (0, index_9.InstanceType)(schema, options);
    }
    /** `[JavaScript]` Instantiates a type with the given parameters */
    Instantiate(schema, parameters) {
        return (0, index_10.Instantiate)(schema, parameters);
    }
    /** `[JavaScript]` Creates an Iterator type */
    Iterator(items, options) {
        return (0, index_11.Iterator)(items, options);
    }
    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    Parameters(schema, options) {
        return (0, index_12.Parameters)(schema, options);
    }
    /** `[JavaScript]` Creates a Promise type */
    Promise(item, options) {
        return (0, index_13.Promise)(item, options);
    }
    /** `[JavaScript]` Creates a RegExp type */
    RegExp(unresolved, options) {
        return (0, index_14.RegExp)(unresolved, options);
    }
    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    ReturnType(type, options) {
        return (0, index_15.ReturnType)(type, options);
    }
    /** `[JavaScript]` Creates a Symbol type */
    Symbol(options) {
        return (0, index_16.Symbol)(options);
    }
    /** `[JavaScript]` Creates a Undefined type */
    Undefined(options) {
        return (0, index_18.Undefined)(options);
    }
    /** `[JavaScript]` Creates a Uint8Array type */
    Uint8Array(options) {
        return (0, index_17.Uint8Array)(options);
    }
    /** `[JavaScript]` Creates a Void type */
    Void(options) {
        return (0, index_19.Void)(options);
    }
}
exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\json.d.ts

Code:
import { type TAny } from '../any/index';
import { type TArray, type ArrayOptions } from '../array/index';
import { type TBoolean } from '../boolean/index';
import { type TComposite } from '../composite/index';
import { type TConst } from '../const/index';
import { type TEnum, type TEnumKey, type TEnumValue } from '../enum/index';
import { type TExclude, type TExcludeFromMappedResult, type TExcludeFromTemplateLiteral } from '../exclude/index';
import { type TExtends, type TExtendsFromMappedKey, type TExtendsFromMappedResult } from '../extends/index';
import { type TExtract, type TExtractFromMappedResult, type TExtractFromTemplateLiteral } from '../extract/index';
import { TIndex, type TIndexPropertyKeys, type TIndexFromMappedKey, type TIndexFromMappedResult, type TIndexFromComputed } from '../indexed/index';
import { type IntegerOptions, type TInteger } from '../integer/index';
import { Intersect, type IntersectOptions } from '../intersect/index';
import { type TCapitalize, type TUncapitalize, type TLowercase, type TUppercase } from '../intrinsic/index';
import { type TKeyOf } from '../keyof/index';
import { type TLiteral, type TLiteralValue } from '../literal/index';
import { type TMappedFunction, type TMapped, type TMappedResult } from '../mapped/index';
import { type TNever } from '../never/index';
import { type TNot } from '../not/index';
import { type TNull } from '../null/index';
import { type TMappedKey } from '../mapped/index';
import { TModule } from '../module/index';
import { type TNumber, type NumberOptions } from '../number/index';
import { type TObject, type TProperties, type ObjectOptions } from '../object/index';
import { type TOmit } from '../omit/index';
import { type TOptionalWithFlag, type TOptionalFromMappedResult } from '../optional/index';
import { type TPartial, type TPartialFromMappedResult } from '../partial/index';
import { type TPick } from '../pick/index';
import { type TReadonlyWithFlag, type TReadonlyFromMappedResult } from '../readonly/index';
import { type TReadonlyOptional } from '../readonly-optional/index';
import { type TRecordOrObject } from '../record/index';
import { type TRecursive, type TThis } from '../recursive/index';
import { type TRef, type TRefUnsafe } from '../ref/index';
import { type TRequired, type TRequiredFromMappedResult } from '../required/index';
import { type TRest } from '../rest/index';
import { type TSchema, type SchemaOptions } from '../schema/index';
import { type TString, type StringOptions } from '../string/index';
import { type TTemplateLiteral, type TTemplateLiteralKind, type TTemplateLiteralSyntax } from '../template-literal/index';
import { TransformDecodeBuilder } from '../transform/index';
import { type TTuple } from '../tuple/index';
import { Union } from '../union/index';
import { type TUnknown } from '../unknown/index';
import { type TUnsafe, type UnsafeOptions } from '../unsafe/index';
/** Json Type Builder with Static Resolution for TypeScript */
export declare class JsonTypeBuilder {
    /** `[Json]` Creates a Readonly and Optional property */
    ReadonlyOptional<Type extends TSchema>(type: Type): TReadonlyOptional<Type>;
    /** `[Json]` Creates a Readonly property */
    Readonly<Type extends TMappedResult, Flag extends boolean>(type: Type, enable: Flag): TReadonlyFromMappedResult<Type, Flag>;
    /** `[Json]` Creates a Readonly property */
    Readonly<Type extends TSchema, Flag extends boolean>(type: Type, enable: Flag): TReadonlyWithFlag<Type, Flag>;
    /** `[Json]` Creates a Optional property */
    Readonly<Type extends TMappedResult>(type: Type): TReadonlyFromMappedResult<Type, true>;
    /** `[Json]` Creates a Readonly property */
    Readonly<Type extends TSchema>(type: Type): TReadonlyWithFlag<Type, true>;
    /** `[Json]` Creates a Optional property */
    Optional<Type extends TMappedResult, Flag extends boolean>(type: Type, enable: Flag): TOptionalFromMappedResult<Type, Flag>;
    /** `[Json]` Creates a Optional property */
    Optional<Type extends TSchema, Flag extends boolean>(type: Type, enable: Flag): TOptionalWithFlag<Type, Flag>;
    /** `[Json]` Creates a Optional property */
    Optional<Type extends TMappedResult>(type: Type): TOptionalFromMappedResult<Type, true>;
    /** `[Json]` Creates a Optional property */
    Optional<Type extends TSchema>(type: Type): TOptionalWithFlag<Type, true>;
    /** `[Json]` Creates an Any type */
    Any(options?: SchemaOptions): TAny;
    /** `[Json]` Creates an Array type */
    Array<Type extends TSchema>(items: Type, options?: ArrayOptions): TArray<Type>;
    /** `[Json]` Creates a Boolean type */
    Boolean(options?: SchemaOptions): TBoolean;
    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    Capitalize<T extends TSchema>(schema: T, options?: SchemaOptions): TCapitalize<T>;
    /** `[Json]` Creates a Composite object type */
    Composite<T extends TSchema[]>(schemas: [...T], options?: ObjectOptions): TComposite<T>;
    /** `[JavaScript]` Creates a readonly const type from the given value. */
    Const</* const (not supported in 4.0) */ T>(value: T, options?: SchemaOptions): TConst<T>;
    /** `[Json]` Creates a Enum type */
    Enum<V extends TEnumValue, T extends Record<TEnumKey, V>>(item: T, options?: SchemaOptions): TEnum<T>;
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude<L extends TMappedResult, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExcludeFromMappedResult<L, R>;
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude<L extends TTemplateLiteral, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExcludeFromTemplateLiteral<L, R>;
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude<L extends TSchema, R extends TSchema>(unionType: L, excludedMembers: R, options?: SchemaOptions): TExclude<L, R>;
    /** `[Json]` Creates a Conditional type */
    Extends<L extends TMappedResult, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtendsFromMappedResult<L, R, T, F>;
    /** `[Json]` Creates a Conditional type */
    Extends<L extends TMappedKey, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtendsFromMappedKey<L, R, T, F>;
    /** `[Json]` Creates a Conditional type */
    Extends<L extends TSchema, R extends TSchema, T extends TSchema, F extends TSchema>(L: L, R: R, T: T, F: F, options?: SchemaOptions): TExtends<L, R, T, F>;
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract<L extends TMappedResult, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtractFromMappedResult<L, R>;
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract<L extends TTemplateLiteral, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtractFromTemplateLiteral<L, R>;
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract<L extends TSchema, R extends TSchema>(type: L, union: R, options?: SchemaOptions): TExtract<L, R>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TRef, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TSchema, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TRef, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TSchema, MappedResult extends TMappedResult>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TIndexFromMappedResult<Type, MappedResult>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TSchema, MappedKey extends TMappedKey>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TIndexFromMappedKey<Type, MappedKey>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TSchema, Key extends TSchema, PropertyKeys extends PropertyKey[] = TIndexPropertyKeys<Key>>(T: Type, K: Key, options?: SchemaOptions): TIndex<Type, PropertyKeys>;
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: readonly [...PropertyKeys], options?: SchemaOptions): TIndex<Type, PropertyKeys>;
    /** `[Json]` Creates an Integer type */
    Integer(options?: IntegerOptions): TInteger;
    /** `[Json]` Creates an Intersect type */
    Intersect<Types extends TSchema[]>(types: [...Types], options?: IntersectOptions): Intersect<Types>;
    /** `[Json]` Creates a KeyOf type */
    KeyOf<Type extends TSchema>(type: Type, options?: SchemaOptions): TKeyOf<Type>;
    /** `[Json]` Creates a Literal type */
    Literal<LiteralValue extends TLiteralValue>(literalValue: LiteralValue, options?: SchemaOptions): TLiteral<LiteralValue>;
    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    Lowercase<Type extends TSchema>(type: Type, options?: SchemaOptions): TLowercase<Type>;
    /** `[Json]` Creates a Mapped object type */
    Mapped<K extends TSchema, I extends PropertyKey[] = TIndexPropertyKeys<K>, F extends TMappedFunction<I> = TMappedFunction<I>, R extends TMapped<I, F> = TMapped<I, F>>(key: K, map: F, options?: ObjectOptions): R;
    /** `[Json]` Creates a Mapped object type */
    Mapped<K extends PropertyKey[], F extends TMappedFunction<K> = TMappedFunction<K>, R extends TMapped<K, F> = TMapped<K, F>>(key: [...K], map: F, options?: ObjectOptions): R;
    /** `[Json]` Creates a Type Definition Module. */
    Module<Properties extends TProperties>(properties: Properties): TModule<Properties>;
    /** `[Json]` Creates a Never type */
    Never(options?: SchemaOptions): TNever;
    /** `[Json]` Creates a Not type */
    Not<T extends TSchema>(type: T, options?: SchemaOptions): TNot<T>;
    /** `[Json]` Creates a Null type */
    Null(options?: SchemaOptions): TNull;
    /** `[Json]` Creates a Number type */
    Number(options?: NumberOptions): TNumber;
    /** `[Json]` Creates an Object type */
    Object<T extends TProperties>(properties: T, options?: ObjectOptions): TObject<T>;
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Omit<Type extends TSchema, Key extends PropertyKey[]>(type: Type, key: readonly [...Key], options?: SchemaOptions): TOmit<Type, Key>;
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Omit<Type extends TSchema, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TOmit<Type, Key>;
    /** `[Json]` Constructs a type where all properties are optional */
    Partial<MappedResult extends TMappedResult>(type: MappedResult, options?: SchemaOptions): TPartialFromMappedResult<MappedResult>;
    /** `[Json]` Constructs a type where all properties are optional */
    Partial<Type extends TSchema>(type: Type, options?: SchemaOptions): TPartial<Type>;
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick<Type extends TSchema, Key extends PropertyKey[]>(type: Type, key: readonly [...Key], options?: SchemaOptions): TPick<Type, Key>;
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick<Type extends TSchema, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TPick<Type, Key>;
    /** `[Json]` Creates a Record type */
    Record<Key extends TSchema, Value extends TSchema>(key: Key, value: Value, options?: ObjectOptions): TRecordOrObject<Key, Value>;
    /** `[Json]` Creates a Recursive type */
    Recursive<T extends TSchema>(callback: (thisType: TThis) => T, options?: SchemaOptions): TRecursive<T>;
    /** `[Json]` Creates a Ref type.*/
    Ref<Ref extends string>($ref: Ref, options?: SchemaOptions): TRef<Ref>;
    /**
     * @deprecated `[Json]` Creates a Ref type. This signature was deprecated in 0.34.0 where Ref requires callers to pass
     * a `string` value for the reference (and not a schema).
     *
     * To adhere to the 0.34.0 signature, Ref implementations should be updated to the following.
     *
     * ```typescript
     * // pre-0.34.0
     *
     * const T = Type.String({ $id: 'T' })
     *
     * const R = Type.Ref(T)
     * ```
     * should be changed to the following
     *
     * ```typescript
     * // post-0.34.0
     *
     * const T = Type.String({ $id: 'T' })
     *
     * const R = Type.Unsafe<Static<typeof T>>(Type.Ref('T'))
     * ```
     * You can also create a generic function to replicate the pre-0.34.0 signature if required
     *
     * ```typescript
     * const LegacyRef = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T>>(Type.Ref(schema.$id!))
     * ```
     */
    Ref<Type extends TSchema>(type: Type, options?: SchemaOptions): TRefUnsafe<Type>;
    /** `[Json]` Constructs a type where all properties are required */
    Required<MappedResult extends TMappedResult>(type: MappedResult, options?: SchemaOptions): TRequiredFromMappedResult<MappedResult>;
    /** `[Json]` Constructs a type where all properties are required */
    Required<Type extends TSchema>(type: Type, options?: SchemaOptions): TRequired<Type>;
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    Rest<Type extends TSchema>(type: Type): TRest<Type>;
    /** `[Json]` Creates a String type */
    String(options?: StringOptions): TString;
    /** `[Json]` Creates a TemplateLiteral type from template dsl string */
    TemplateLiteral<Syntax extends string>(syntax: Syntax, options?: SchemaOptions): TTemplateLiteralSyntax<Syntax>;
    /** `[Json]` Creates a TemplateLiteral type */
    TemplateLiteral<Kinds extends TTemplateLiteralKind[]>(kinds: [...Kinds], options?: SchemaOptions): TTemplateLiteral<Kinds>;
    /** `[Json]` Creates a Transform type */
    Transform<Type extends TSchema>(type: Type): TransformDecodeBuilder<Type>;
    /** `[Json]` Creates a Tuple type */
    Tuple<Types extends TSchema[]>(types: [...Types], options?: SchemaOptions): TTuple<Types>;
    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize<Type extends TSchema>(type: Type, options?: SchemaOptions): TUncapitalize<Type>;
    /** `[Json]` Creates a Union type */
    Union<Types extends TSchema[]>(types: [...Types], options?: SchemaOptions): Union<Types>;
    /** `[Json]` Creates an Unknown type */
    Unknown(options?: SchemaOptions): TUnknown;
    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe<T>(options?: UnsafeOptions): TUnsafe<T>;
    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    Uppercase<T extends TSchema>(schema: T, options?: SchemaOptions): TUppercase<T>;
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\json.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonTypeBuilder = void 0;
const index_1 = require("../any/index");
const index_2 = require("../array/index");
const index_3 = require("../boolean/index");
const index_4 = require("../composite/index");
const index_5 = require("../const/index");
const index_6 = require("../enum/index");
const index_7 = require("../exclude/index");
const index_8 = require("../extends/index");
const index_9 = require("../extract/index");
const index_10 = require("../indexed/index");
const index_11 = require("../integer/index");
const index_12 = require("../intersect/index");
const index_13 = require("../intrinsic/index");
const index_14 = require("../keyof/index");
const index_15 = require("../literal/index");
const index_16 = require("../mapped/index");
const index_17 = require("../never/index");
const index_18 = require("../not/index");
const index_19 = require("../null/index");
const index_20 = require("../module/index");
const index_21 = require("../number/index");
const index_22 = require("../object/index");
const index_23 = require("../omit/index");
const index_24 = require("../optional/index");
const index_25 = require("../partial/index");
const index_26 = require("../pick/index");
const index_27 = require("../readonly/index");
const index_28 = require("../readonly-optional/index");
const index_29 = require("../record/index");
const index_30 = require("../recursive/index");
const index_31 = require("../ref/index");
const index_32 = require("../required/index");
const index_33 = require("../rest/index");
const index_34 = require("../string/index");
const index_35 = require("../template-literal/index");
const index_36 = require("../transform/index");
const index_37 = require("../tuple/index");
const index_38 = require("../union/index");
const index_39 = require("../unknown/index");
const index_40 = require("../unsafe/index");
/** Json Type Builder with Static Resolution for TypeScript */
class JsonTypeBuilder {
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Json]` Creates a Readonly and Optional property */
    ReadonlyOptional(type) {
        return (0, index_28.ReadonlyOptional)(type);
    }
    /** `[Json]` Creates a Readonly property */
    Readonly(type, enable) {
        return (0, index_27.Readonly)(type, enable ?? true);
    }
    /** `[Json]` Creates a Optional property */
    Optional(type, enable) {
        return (0, index_24.Optional)(type, enable ?? true);
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Json]` Creates an Any type */
    Any(options) {
        return (0, index_1.Any)(options);
    }
    /** `[Json]` Creates an Array type */
    Array(items, options) {
        return (0, index_2.Array)(items, options);
    }
    /** `[Json]` Creates a Boolean type */
    Boolean(options) {
        return (0, index_3.Boolean)(options);
    }
    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    Capitalize(schema, options) {
        return (0, index_13.Capitalize)(schema, options);
    }
    /** `[Json]` Creates a Composite object type */
    Composite(schemas, options) {
        return (0, index_4.Composite)(schemas, options); // (error) TS 5.4.0-dev - review TComposite implementation
    }
    /** `[JavaScript]` Creates a readonly const type from the given value. */
    Const(value, options) {
        return (0, index_5.Const)(value, options);
    }
    /** `[Json]` Creates a Enum type */
    Enum(item, options) {
        return (0, index_6.Enum)(item, options);
    }
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude(unionType, excludedMembers, options) {
        return (0, index_7.Exclude)(unionType, excludedMembers, options);
    }
    /** `[Json]` Creates a Conditional type */
    Extends(L, R, T, F, options) {
        return (0, index_8.Extends)(L, R, T, F, options);
    }
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract(type, union, options) {
        return (0, index_9.Extract)(type, union, options);
    }
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index(type, key, options) {
        return (0, index_10.Index)(type, key, options);
    }
    /** `[Json]` Creates an Integer type */
    Integer(options) {
        return (0, index_11.Integer)(options);
    }
    /** `[Json]` Creates an Intersect type */
    Intersect(types, options) {
        return (0, index_12.Intersect)(types, options);
    }
    /** `[Json]` Creates a KeyOf type */
    KeyOf(type, options) {
        return (0, index_14.KeyOf)(type, options);
    }
    /** `[Json]` Creates a Literal type */
    Literal(literalValue, options) {
        return (0, index_15.Literal)(literalValue, options);
    }
    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    Lowercase(type, options) {
        return (0, index_13.Lowercase)(type, options);
    }
    /** `[Json]` Creates a Mapped object type */
    Mapped(key, map, options) {
        return (0, index_16.Mapped)(key, map, options);
    }
    /** `[Json]` Creates a Type Definition Module. */
    Module(properties) {
        return (0, index_20.Module)(properties);
    }
    /** `[Json]` Creates a Never type */
    Never(options) {
        return (0, index_17.Never)(options);
    }
    /** `[Json]` Creates a Not type */
    Not(type, options) {
        return (0, index_18.Not)(type, options);
    }
    /** `[Json]` Creates a Null type */
    Null(options) {
        return (0, index_19.Null)(options);
    }
    /** `[Json]` Creates a Number type */
    Number(options) {
        return (0, index_21.Number)(options);
    }
    /** `[Json]` Creates an Object type */
    Object(properties, options) {
        return (0, index_22.Object)(properties, options);
    }
    /** `[Json]` Constructs a type whose keys are omitted from the given type */
    Omit(schema, selector, options) {
        return (0, index_23.Omit)(schema, selector, options);
    }
    /** `[Json]` Constructs a type where all properties are optional */
    Partial(type, options) {
        return (0, index_25.Partial)(type, options);
    }
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick(type, key, options) {
        return (0, index_26.Pick)(type, key, options);
    }
    /** `[Json]` Creates a Record type */
    Record(key, value, options) {
        return (0, index_29.Record)(key, value, options);
    }
    /** `[Json]` Creates a Recursive type */
    Recursive(callback, options) {
        return (0, index_30.Recursive)(callback, options);
    }
    /** `[Json]` Creates a Ref type. The referenced type must contain a $id */
    Ref(...args) {
        return (0, index_31.Ref)(args[0], args[1]);
    }
    /** `[Json]` Constructs a type where all properties are required */
    Required(type, options) {
        return (0, index_32.Required)(type, options);
    }
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    Rest(type) {
        return (0, index_33.Rest)(type);
    }
    /** `[Json]` Creates a String type */
    String(options) {
        return (0, index_34.String)(options);
    }
    /** `[Json]` Creates a TemplateLiteral type */
    TemplateLiteral(unresolved, options) {
        return (0, index_35.TemplateLiteral)(unresolved, options);
    }
    /** `[Json]` Creates a Transform type */
    Transform(type) {
        return (0, index_36.Transform)(type);
    }
    /** `[Json]` Creates a Tuple type */
    Tuple(types, options) {
        return (0, index_37.Tuple)(types, options);
    }
    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize(type, options) {
        return (0, index_13.Uncapitalize)(type, options);
    }
    /** `[Json]` Creates a Union type */
    Union(types, options) {
        return (0, index_38.Union)(types, options);
    }
    /** `[Json]` Creates an Unknown type */
    Unknown(options) {
        return (0, index_39.Unknown)(options);
    }
    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe(options) {
        return (0, index_40.Unsafe)(options);
    }
    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    Uppercase(schema, options) {
        return (0, index_13.Uppercase)(schema, options);
    }
}
exports.JsonTypeBuilder = JsonTypeBuilder;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\type.d.ts

Code:
export { Any } from '../any/index';
export { Argument } from '../argument/index';
export { Array } from '../array/index';
export { AsyncIterator } from '../async-iterator/index';
export { Awaited } from '../awaited/index';
export { BigInt } from '../bigint/index';
export { Boolean } from '../boolean/index';
export { Composite } from '../composite/index';
export { Const } from '../const/index';
export { Constructor } from '../constructor/index';
export { ConstructorParameters } from '../constructor-parameters/index';
export { Date } from '../date/index';
export { Enum } from '../enum/index';
export { Exclude } from '../exclude/index';
export { Extends } from '../extends/index';
export { Extract } from '../extract/index';
export { Function } from '../function/index';
export { Index } from '../indexed/index';
export { InstanceType } from '../instance-type/index';
export { Instantiate } from '../instantiate/index';
export { Integer } from '../integer/index';
export { Intersect } from '../intersect/index';
export { Capitalize, Uncapitalize, Lowercase, Uppercase } from '../intrinsic/index';
export { Iterator } from '../iterator/index';
export { KeyOf } from '../keyof/index';
export { Literal } from '../literal/index';
export { Mapped } from '../mapped/index';
export { Module } from '../module/index';
export { Never } from '../never/index';
export { Not } from '../not/index';
export { Null } from '../null/index';
export { Number } from '../number/index';
export { Object } from '../object/index';
export { Omit } from '../omit/index';
export { Optional } from '../optional/index';
export { Parameters } from '../parameters/index';
export { Partial } from '../partial/index';
export { Pick } from '../pick/index';
export { Promise } from '../promise/index';
export { Readonly } from '../readonly/index';
export { ReadonlyOptional } from '../readonly-optional/index';
export { Record } from '../record/index';
export { Recursive } from '../recursive/index';
export { Ref } from '../ref/index';
export { RegExp } from '../regexp/index';
export { Required } from '../required/index';
export { Rest } from '../rest/index';
export { ReturnType } from '../return-type/index';
export { String } from '../string/index';
export { Symbol } from '../symbol/index';
export { TemplateLiteral } from '../template-literal/index';
export { Transform } from '../transform/index';
export { Tuple } from '../tuple/index';
export { Uint8Array } from '../uint8array/index';
export { Undefined } from '../undefined/index';
export { Union } from '../union/index';
export { Unknown } from '../unknown/index';
export { Unsafe } from '../unsafe/index';
export { Void } from '../void/index';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\type\type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Module = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.Instantiate = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Argument = exports.Any = void 0;
exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = exports.ReturnType = void 0;
// ------------------------------------------------------------------
// Type: Module
// ------------------------------------------------------------------
var index_1 = require("../any/index");
Object.defineProperty(exports, "Any", { enumerable: true, get: function () { return index_1.Any; } });
var index_2 = require("../argument/index");
Object.defineProperty(exports, "Argument", { enumerable: true, get: function () { return index_2.Argument; } });
var index_3 = require("../array/index");
Object.defineProperty(exports, "Array", { enumerable: true, get: function () { return index_3.Array; } });
var index_4 = require("../async-iterator/index");
Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function () { return index_4.AsyncIterator; } });
var index_5 = require("../awaited/index");
Object.defineProperty(exports, "Awaited", { enumerable: true, get: function () { return index_5.Awaited; } });
var index_6 = require("../bigint/index");
Object.defineProperty(exports, "BigInt", { enumerable: true, get: function () { return index_6.BigInt; } });
var index_7 = require("../boolean/index");
Object.defineProperty(exports, "Boolean", { enumerable: true, get: function () { return index_7.Boolean; } });
var index_8 = require("../composite/index");
Object.defineProperty(exports, "Composite", { enumerable: true, get: function () { return index_8.Composite; } });
var index_9 = require("../const/index");
Object.defineProperty(exports, "Const", { enumerable: true, get: function () { return index_9.Const; } });
var index_10 = require("../constructor/index");
Object.defineProperty(exports, "Constructor", { enumerable: true, get: function () { return index_10.Constructor; } });
var index_11 = require("../constructor-parameters/index");
Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function () { return index_11.ConstructorParameters; } });
var index_12 = require("../date/index");
Object.defineProperty(exports, "Date", { enumerable: true, get: function () { return index_12.Date; } });
var index_13 = require("../enum/index");
Object.defineProperty(exports, "Enum", { enumerable: true, get: function () { return index_13.Enum; } });
var index_14 = require("../exclude/index");
Object.defineProperty(exports, "Exclude", { enumerable: true, get: function () { return index_14.Exclude; } });
var index_15 = require("../extends/index");
Object.defineProperty(exports, "Extends", { enumerable: true, get: function () { return index_15.Extends; } });
var index_16 = require("../extract/index");
Object.defineProperty(exports, "Extract", { enumerable: true, get: function () { return index_16.Extract; } });
var index_17 = require("../function/index");
Object.defineProperty(exports, "Function", { enumerable: true, get: function () { return index_17.Function; } });
var index_18 = require("../indexed/index");
Object.defineProperty(exports, "Index", { enumerable: true, get: function () { return index_18.Index; } });
var index_19 = require("../instance-type/index");
Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function () { return index_19.InstanceType; } });
var index_20 = require("../instantiate/index");
Object.defineProperty(exports, "Instantiate", { enumerable: true, get: function () { return index_20.Instantiate; } });
var index_21 = require("../integer/index");
Object.defineProperty(exports, "Integer", { enumerable: true, get: function () { return index_21.Integer; } });
var index_22 = require("../intersect/index");
Object.defineProperty(exports, "Intersect", { enumerable: true, get: function () { return index_22.Intersect; } });
var index_23 = require("../intrinsic/index");
Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function () { return index_23.Capitalize; } });
Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function () { return index_23.Uncapitalize; } });
Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function () { return index_23.Lowercase; } });
Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function () { return index_23.Uppercase; } });
var index_24 = require("../iterator/index");
Object.defineProperty(exports, "Iterator", { enumerable: true, get: function () { return index_24.Iterator; } });
var index_25 = require("../keyof/index");
Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function () { return index_25.KeyOf; } });
var index_26 = require("../literal/index");
Object.defineProperty(exports, "Literal", { enumerable: true, get: function () { return index_26.Literal; } });
var index_27 = require("../mapped/index");
Object.defineProperty(exports, "Mapped", { enumerable: true, get: function () { return index_27.Mapped; } });
var index_28 = require("../module/index");
Object.defineProperty(exports, "Module", { enumerable: true, get: function () { return index_28.Module; } });
var index_29 = require("../never/index");
Object.defineProperty(exports, "Never", { enumerable: true, get: function () { return index_29.Never; } });
var index_30 = require("../not/index");
Object.defineProperty(exports, "Not", { enumerable: true, get: function () { return index_30.Not; } });
var index_31 = require("../null/index");
Object.defineProperty(exports, "Null", { enumerable: true, get: function () { return index_31.Null; } });
var index_32 = require("../number/index");
Object.defineProperty(exports, "Number", { enumerable: true, get: function () { return index_32.Number; } });
var index_33 = require("../object/index");
Object.defineProperty(exports, "Object", { enumerable: true, get: function () { return index_33.Object; } });
var index_34 = require("../omit/index");
Object.defineProperty(exports, "Omit", { enumerable: true, get: function () { return index_34.Omit; } });
var index_35 = require("../optional/index");
Object.defineProperty(exports, "Optional", { enumerable: true, get: function () { return index_35.Optional; } });
var index_36 = require("../parameters/index");
Object.defineProperty(exports, "Parameters", { enumerable: true, get: function () { return index_36.Parameters; } });
var index_37 = require("../partial/index");
Object.defineProperty(exports, "Partial", { enumerable: true, get: function () { return index_37.Partial; } });
var index_38 = require("../pick/index");
Object.defineProperty(exports, "Pick", { enumerable: true, get: function () { return index_38.Pick; } });
var index_39 = require("../promise/index");
Object.defineProperty(exports, "Promise", { enumerable: true, get: function () { return index_39.Promise; } });
var index_40 = require("../readonly/index");
Object.defineProperty(exports, "Readonly", { enumerable: true, get: function () { return index_40.Readonly; } });
var index_41 = require("../readonly-optional/index");
Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function () { return index_41.ReadonlyOptional; } });
var index_42 = require("../record/index");
Object.defineProperty(exports, "Record", { enumerable: true, get: function () { return index_42.Record; } });
var index_43 = require("../recursive/index");
Object.defineProperty(exports, "Recursive", { enumerable: true, get: function () { return index_43.Recursive; } });
var index_44 = require("../ref/index");
Object.defineProperty(exports, "Ref", { enumerable: true, get: function () { return index_44.Ref; } });
var index_45 = require("../regexp/index");
Object.defineProperty(exports, "RegExp", { enumerable: true, get: function () { return index_45.RegExp; } });
var index_46 = require("../required/index");
Object.defineProperty(exports, "Required", { enumerable: true, get: function () { return index_46.Required; } });
var index_47 = require("../rest/index");
Object.defineProperty(exports, "Rest", { enumerable: true, get: function () { return index_47.Rest; } });
var index_48 = require("../return-type/index");
Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function () { return index_48.ReturnType; } });
var index_49 = require("../string/index");
Object.defineProperty(exports, "String", { enumerable: true, get: function () { return index_49.String; } });
var index_50 = require("../symbol/index");
Object.defineProperty(exports, "Symbol", { enumerable: true, get: function () { return index_50.Symbol; } });
var index_51 = require("../template-literal/index");
Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function () { return index_51.TemplateLiteral; } });
var index_52 = require("../transform/index");
Object.defineProperty(exports, "Transform", { enumerable: true, get: function () { return index_52.Transform; } });
var index_53 = require("../tuple/index");
Object.defineProperty(exports, "Tuple", { enumerable: true, get: function () { return index_53.Tuple; } });
var index_54 = require("../uint8array/index");
Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function () { return index_54.Uint8Array; } });
var index_55 = require("../undefined/index");
Object.defineProperty(exports, "Undefined", { enumerable: true, get: function () { return index_55.Undefined; } });
var index_56 = require("../union/index");
Object.defineProperty(exports, "Union", { enumerable: true, get: function () { return index_56.Union; } });
var index_57 = require("../unknown/index");
Object.defineProperty(exports, "Unknown", { enumerable: true, get: function () { return index_57.Unknown; } });
var index_58 = require("../unsafe/index");
Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function () { return index_58.Unsafe; } });
var index_59 = require("../void/index");
Object.defineProperty(exports, "Void", { enumerable: true, get: function () { return index_59.Void; } });


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\uint8array\index.d.ts

Code:
export * from './uint8array';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\uint8array\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./uint8array"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\uint8array\uint8array.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface Uint8ArrayOptions extends SchemaOptions {
    maxByteLength?: number;
    minByteLength?: number;
}
export interface TUint8Array extends TSchema, Uint8ArrayOptions {
    [Kind]: 'Uint8Array';
    static: Uint8Array;
    type: 'uint8array';
}
/** `[JavaScript]` Creates a Uint8Array type */
export declare function Uint8Array(options?: Uint8ArrayOptions): TUint8Array;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\uint8array\uint8array.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Uint8Array = Uint8Array;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Uint8Array type */
function Uint8Array(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Uint8Array', type: 'Uint8Array' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\undefined\index.d.ts

Code:
export * from './undefined';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\undefined\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./undefined"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\undefined\undefined.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TUndefined extends TSchema {
    [Kind]: 'Undefined';
    static: undefined;
    type: 'undefined';
}
/** `[JavaScript]` Creates a Undefined type */
export declare function Undefined(options?: SchemaOptions): TUndefined;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\undefined\undefined.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Undefined = Undefined;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Undefined type */
function Undefined(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Undefined', type: 'undefined' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\index.d.ts

Code:
export * from './union-evaluated';
export * from './union-type';
export * from './union';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./union-evaluated"), exports);
__exportStar(require("./union-type"), exports);
__exportStar(require("./union"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-create.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { TUnion } from './union-type';
export declare function UnionCreate<T extends TSchema[]>(T: [...T], options?: SchemaOptions): TUnion<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-create.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionCreate = UnionCreate;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
function UnionCreate(T, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Union', anyOf: T }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-evaluated.d.ts

Code:
import type { SchemaOptions, TSchema } from '../schema/index';
import { type TNever } from '../never/index';
import { type TOptional } from '../optional/index';
import type { TReadonly } from '../readonly/index';
import type { TUnion } from './union-type';
type TIsUnionOptional<Types extends TSchema[]> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<TSchema> ? true : TIsUnionOptional<Right> : false);
type TRemoveOptionalFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<infer S extends TSchema> ? TRemoveOptionalFromRest<Right, [...Result, TRemoveOptionalFromType<S>]> : TRemoveOptionalFromRest<Right, [...Result, Left]> : Result);
type TRemoveOptionalFromType<Type extends TSchema> = (Type extends TReadonly<infer Type extends TSchema> ? TReadonly<TRemoveOptionalFromType<Type>> : Type extends TOptional<infer Type extends TSchema> ? TRemoveOptionalFromType<Type> : Type);
type TResolveUnion<Types extends TSchema[], Result extends TSchema[] = TRemoveOptionalFromRest<Types>, IsOptional extends boolean = TIsUnionOptional<Types>> = (IsOptional extends true ? TOptional<TUnion<Result>> : TUnion<Result>);
export type TUnionEvaluated<Types extends TSchema[]> = (Types extends [TSchema] ? Types[0] : Types extends [] ? TNever : TResolveUnion<Types>);
/** `[Json]` Creates an evaluated Union type */
export declare function UnionEvaluated<Types extends TSchema[], Result = TUnionEvaluated<Types>>(T: [...Types], options?: SchemaOptions): Result;
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-evaluated.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionEvaluated = UnionEvaluated;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
const index_2 = require("../discard/index");
const index_3 = require("../never/index");
const index_4 = require("../optional/index");
const union_create_1 = require("./union-create");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
const kind_1 = require("../guard/kind");
// prettier-ignore
function IsUnionOptional(types) {
    return types.some(type => (0, kind_1.IsOptional)(type));
}
// prettier-ignore
function RemoveOptionalFromRest(types) {
    return types.map(left => (0, kind_1.IsOptional)(left) ? RemoveOptionalFromType(left) : left);
}
// prettier-ignore
function RemoveOptionalFromType(T) {
    return ((0, index_2.Discard)(T, [index_1.OptionalKind]));
}
// prettier-ignore
function ResolveUnion(types, options) {
    const isOptional = IsUnionOptional(types);
    return (isOptional
        ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(types), options))
        : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(types), options));
}
/** `[Json]` Creates an evaluated Union type */
function UnionEvaluated(T, options) {
    // prettier-ignore
    return (T.length === 1 ? (0, type_1.CreateType)(T[0], options) :
        T.length === 0 ? (0, index_3.Never)(options) :
            ResolveUnion(T, options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-type.d.ts

Code:
import type { TSchema } from '../schema/index';
import type { Static } from '../static/index';
import { Kind } from '../symbols/index';
type UnionStatic<T extends TSchema[], P extends unknown[]> = {
    [K in keyof T]: T[K] extends TSchema ? Static<T[K], P> : never;
}[number];
export interface TUnion<T extends TSchema[] = TSchema[]> extends TSchema {
    [Kind]: 'Union';
    static: UnionStatic<T, this['params']>;
    anyOf: T;
}
export {};


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union-type.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../symbols/index");


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { type TNever } from '../never/index';
import type { TUnion } from './union-type';
export type Union<T extends TSchema[]> = (T extends [] ? TNever : T extends [TSchema] ? T[0] : TUnion<T>);
/** `[Json]` Creates a Union type */
export declare function Union<Types extends TSchema[]>(types: [...Types], options?: SchemaOptions): Union<Types>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\union\union.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Union = Union;
const index_1 = require("../never/index");
const type_1 = require("../create/type");
const union_create_1 = require("./union-create");
/** `[Json]` Creates a Union type */
function Union(types, options) {
    // prettier-ignore
    return (types.length === 0 ? (0, index_1.Never)(options) :
        types.length === 1 ? (0, type_1.CreateType)(types[0], options) :
            (0, union_create_1.UnionCreate)(types, options));
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unknown\index.d.ts

Code:
export * from './unknown';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unknown\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./unknown"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unknown\unknown.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TUnknown extends TSchema {
    [Kind]: 'Unknown';
    static: unknown;
}
/** `[Json]` Creates an Unknown type */
export declare function Unknown(options?: SchemaOptions): TUnknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unknown\unknown.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Unknown = Unknown;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates an Unknown type */
function Unknown(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Unknown' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unsafe\index.d.ts

Code:
export * from './unsafe';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unsafe\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./unsafe"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unsafe\unsafe.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface UnsafeOptions extends SchemaOptions {
    [Kind]?: string;
}
export interface TUnsafe<T> extends TSchema {
    [Kind]: string;
    static: T;
}
/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
export declare function Unsafe<T>(options?: UnsafeOptions): TUnsafe<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\unsafe\unsafe.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Unsafe = Unsafe;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
function Unsafe(options = {}) {
    return (0, type_1.CreateType)({ [index_1.Kind]: options[index_1.Kind] ?? 'Unsafe' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\void\index.d.ts

Code:
export * from './void';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\void\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./void"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\void\void.d.ts

Code:
import type { TSchema, SchemaOptions } from '../schema/index';
import { Kind } from '../symbols/index';
export interface TVoid extends TSchema {
    [Kind]: 'Void';
    static: void;
    type: 'void';
}
/** `[JavaScript]` Creates a Void type */
export declare function Void(options?: SchemaOptions): TVoid;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\type\void\void.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = Void;
const type_1 = require("../create/type");
const index_1 = require("../symbols/index");
/** `[JavaScript]` Creates a Void type */
function Void(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: 'Void', type: 'void' }, options);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\assert\assert.d.ts

Code:
import { ValueErrorIterator, ValueError } from '../../errors/index';
import { TypeBoxError } from '../../type/error/error';
import { TSchema } from '../../type/schema/index';
import { Static } from '../../type/static/index';
export declare class AssertError extends TypeBoxError {
    #private;
    error: ValueError | undefined;
    constructor(iterator: ValueErrorIterator);
    /** Returns an iterator for each error in this value. */
    Errors(): ValueErrorIterator;
}
/** Asserts a value matches the given type or throws an `AssertError` if invalid */
export declare function Assert<T extends TSchema>(schema: T, references: TSchema[], value: unknown): asserts value is Static<T>;
/** Asserts a value matches the given type or throws an `AssertError` if invalid */
export declare function Assert<T extends TSchema>(schema: T, value: unknown): asserts value is Static<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\assert\assert.js

Code:
"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances, _AssertError_iterator, _AssertError_Iterator;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertError = void 0;
exports.Assert = Assert;
const index_1 = require("../../errors/index");
const error_1 = require("../../type/error/error");
const check_1 = require("../check/check");
// ------------------------------------------------------------------
// AssertError
// ------------------------------------------------------------------
class AssertError extends error_1.TypeBoxError {
    constructor(iterator) {
        const error = iterator.First();
        super(error === undefined ? 'Invalid Value' : error.message);
        _AssertError_instances.add(this);
        _AssertError_iterator.set(this, void 0);
        __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
        this.error = error;
    }
    /** Returns an iterator for each error in this value. */
    Errors() {
        return new index_1.ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
    }
}
exports.AssertError = AssertError;
_AssertError_iterator = new WeakMap(), _AssertError_instances = new WeakSet(), _AssertError_Iterator = function* _AssertError_Iterator() {
    if (this.error)
        yield this.error;
    yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
// ------------------------------------------------------------------
// AssertValue
// ------------------------------------------------------------------
function AssertValue(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
        return;
    throw new AssertError((0, index_1.Errors)(schema, references, value));
}
/** Asserts a value matches the given type or throws an `AssertError` if invalid */
function Assert(...args) {
    return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\assert\index.d.ts

Code:
export * from './assert';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\assert\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\cast\cast.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import type { TSchema } from '../../type/schema/index';
import type { Static } from '../../type/static/index';
export declare class ValueCastError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema, message: string);
}
/** Casts a value into a given type and references. The return value will retain as much information of the original value as possible. */
export declare function Cast<T extends TSchema>(schema: T, references: TSchema[], value: unknown): Static<T>;
/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */
export declare function Cast<T extends TSchema>(schema: T, value: unknown): Static<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\cast\cast.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueCastError = void 0;
exports.Cast = Cast;
const index_1 = require("../guard/index");
const index_2 = require("../../type/error/index");
const index_3 = require("../../type/symbols/index");
const index_4 = require("../create/index");
const index_5 = require("../check/index");
const index_6 = require("../clone/index");
const index_7 = require("../deref/index");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueCastError extends index_2.TypeBoxError {
    constructor(schema, message) {
        super(message);
        this.schema = schema;
    }
}
exports.ValueCastError = ValueCastError;
// ------------------------------------------------------------------
// The following will score a schema against a value. For objects,
// the score is the tally of points awarded for each property of
// the value. Property points are (1.0 / propertyCount) to prevent
// large property counts biasing results. Properties that match
// literal values are maximally awarded as literals are typically
// used as union discriminator fields.
// ------------------------------------------------------------------
function ScoreUnion(schema, references, value) {
    if (schema[index_3.Kind] === 'Object' && typeof value === 'object' && !(0, index_1.IsNull)(value)) {
        const object = schema;
        const keys = Object.getOwnPropertyNames(value);
        const entries = Object.entries(object.properties);
        const [point, max] = [1 / entries.length, entries.length];
        return entries.reduce((acc, [key, schema]) => {
            const literal = schema[index_3.Kind] === 'Literal' && schema.const === value[key] ? max : 0;
            const checks = (0, index_5.Check)(schema, references, value[key]) ? point : 0;
            const exists = keys.includes(key) ? point : 0;
            return acc + (literal + checks + exists);
        }, 0);
    }
    else if (schema[index_3.Kind] === 'Union') {
        const schemas = schema.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
        const scores = schemas.map((schema) => ScoreUnion(schema, references, value));
        return Math.max(...scores);
    }
    else {
        return (0, index_5.Check)(schema, references, value) ? 1 : 0;
    }
}
function SelectUnion(union, references, value) {
    const schemas = union.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
    let [select, best] = [schemas[0], 0];
    for (const schema of schemas) {
        const score = ScoreUnion(schema, references, value);
        if (score > best) {
            select = schema;
            best = score;
        }
    }
    return select;
}
function CastUnion(union, references, value) {
    if ('default' in union) {
        return typeof value === 'function' ? union.default : (0, index_6.Clone)(union.default);
    }
    else {
        const schema = SelectUnion(union, references, value);
        return Cast(schema, references, value);
    }
}
// ------------------------------------------------------------------
// Default
// ------------------------------------------------------------------
function DefaultClone(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
}
function Default(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
}
// ------------------------------------------------------------------
// Cast
// ------------------------------------------------------------------
function FromArray(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
    const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value) => Visit(schema.items, references, value));
    if (schema.uniqueItems !== true)
        return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema, references, unique))
        throw new ValueCastError(schema, 'Array cast produced invalid data due to uniqueItems constraint');
    return unique;
}
function FromConstructor(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return (0, index_4.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function () { };
    for (const [key, property] of Object.entries(schema.returns.properties)) {
        if (!required.has(key) && value.prototype[key] === undefined)
            continue;
        result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
}
function FromImport(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions], value);
}
// ------------------------------------------------------------------
// Intersect
// ------------------------------------------------------------------
function IntersectAssign(correct, value) {
    // trust correct on mismatch | value on non-object
    if (((0, index_1.IsObject)(correct) && !(0, index_1.IsObject)(value)) || (!(0, index_1.IsObject)(correct) && (0, index_1.IsObject)(value)))
        return correct;
    if (!(0, index_1.IsObject)(correct) || !(0, index_1.IsObject)(value))
        return value;
    return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
        const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
        return { ...result, [key]: property };
    }, {});
}
function FromIntersect(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return value;
    const correct = (0, index_4.Create)(schema, references);
    const assigned = IntersectAssign(correct, value);
    return (0, index_5.Check)(schema, references, assigned) ? assigned : correct;
}
function FromNever(schema, references, value) {
    throw new ValueCastError(schema, 'Never types cannot be cast');
}
function FromObject(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return value;
    if (value === null || typeof value !== 'object')
        return (0, index_4.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
        if (!required.has(key) && value[key] === undefined)
            continue;
        result[key] = Visit(property, references, value[key]);
    }
    // additional schema properties
    if (typeof schema.additionalProperties === 'object') {
        const propertyNames = Object.getOwnPropertyNames(schema.properties);
        for (const propertyName of Object.getOwnPropertyNames(value)) {
            if (propertyNames.includes(propertyName))
                continue;
            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
        }
    }
    return result;
}
function FromRecord(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
    if (value === null || typeof value !== 'object' || Array.isArray(value) || value instanceof Date)
        return (0, index_4.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
}
function FromRef(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
}
function FromThis(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
}
function FromTuple(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
        return (0, index_6.Clone)(value);
    if (!(0, index_1.IsArray)(value))
        return (0, index_4.Create)(schema, references);
    if (schema.items === undefined)
        return [];
    return schema.items.map((schema, index) => Visit(schema, references, value[index]));
}
function FromUnion(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion(schema, references, value);
}
function Visit(schema, references, value) {
    const references_ = (0, index_1.IsString)(schema.$id) ? (0, index_7.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema[index_3.Kind]) {
        // --------------------------------------------------------------
        // Structural
        // --------------------------------------------------------------
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'Constructor':
            return FromConstructor(schema_, references_, value);
        case 'Import':
            return FromImport(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Never':
            return FromNever(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        // --------------------------------------------------------------
        // DefaultClone
        // --------------------------------------------------------------
        case 'Date':
        case 'Symbol':
        case 'Uint8Array':
            return DefaultClone(schema, references, value);
        // --------------------------------------------------------------
        // Default
        // --------------------------------------------------------------
        default:
            return Default(schema_, references_, value);
    }
}
/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */
function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\cast\index.d.ts

Code:
export * from './cast';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\cast\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./cast"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\check\check.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import type { TSchema } from '../../type/schema/index';
import type { Static } from '../../type/static/index';
export declare class ValueCheckUnknownTypeError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema);
}
/** Returns true if the value matches the given type. */
export declare function Check<T extends TSchema>(schema: T, references: TSchema[], value: unknown): value is Static<T>;
/** Returns true if the value matches the given type. */
export declare function Check<T extends TSchema>(schema: T, value: unknown): value is Static<T>;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\check\check.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueCheckUnknownTypeError = void 0;
exports.Check = Check;
const index_1 = require("../../system/index");
const index_2 = require("../deref/index");
const index_3 = require("../hash/index");
const index_4 = require("../../type/symbols/index");
const index_5 = require("../../type/keyof/index");
const index_6 = require("../../type/extends/index");
const index_7 = require("../../type/registry/index");
const index_8 = require("../../type/error/index");
const index_9 = require("../../type/never/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_10 = require("../guard/index");
// ------------------------------------------------------------------
// KindGuard
// ------------------------------------------------------------------
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// Errors
// ------------------------------------------------------------------
class ValueCheckUnknownTypeError extends index_8.TypeBoxError {
    constructor(schema) {
        super(`Unknown type`);
        this.schema = schema;
    }
}
exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
// ------------------------------------------------------------------
// TypeGuards
// ------------------------------------------------------------------
function IsAnyOrUnknown(schema) {
    return schema[index_4.Kind] === 'Any' || schema[index_4.Kind] === 'Unknown';
}
// ------------------------------------------------------------------
// Guards
// ------------------------------------------------------------------
function IsDefined(value) {
    return value !== undefined;
}
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
function FromAny(schema, references, value) {
    return true;
}
function FromArgument(schema, references, value) {
    return true;
}
function FromArray(schema, references, value) {
    if (!(0, index_10.IsArray)(value))
        return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
        return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
        return false;
    }
    if (!value.every((value) => Visit(schema.items, references, value))) {
        return false;
    }
    // prettier-ignore
    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {
        const hashed = (0, index_3.Hash)(element);
        if (set.has(hashed)) {
            return false;
        }
        else {
            set.add(hashed);
        }
    } return true; })())) {
        return false;
    }
    // contains
    if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
        return true; // exit
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);
    if (containsCount === 0) {
        return false;
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
        return false;
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
        return false;
    }
    return true;
}
function FromAsyncIterator(schema, references, value) {
    return (0, index_10.IsAsyncIterator)(value);
}
function FromBigInt(schema, references, value) {
    if (!(0, index_10.IsBigInt)(value))
        return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
        return false;
    }
    return true;
}
function FromBoolean(schema, references, value) {
    return (0, index_10.IsBoolean)(value);
}
function FromConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
}
function FromDate(schema, references, value) {
    if (!(0, index_10.IsDate)(value))
        return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
        return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
        return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
        return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
        return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
        return false;
    }
    return true;
}
function FromFunction(schema, references, value) {
    return (0, index_10.IsFunction)(value);
}
function FromImport(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions], value);
}
function FromInteger(schema, references, value) {
    if (!(0, index_10.IsInteger)(value)) {
        return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
    }
    return true;
}
function FromIntersect(schema, references, value) {
    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));
    if (schema.unevaluatedProperties === false) {
        const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
        return check1 && check2;
    }
    else if ((0, kind_1.IsSchema)(schema.unevaluatedProperties)) {
        const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
        return check1 && check2;
    }
    else {
        return check1;
    }
}
function FromIterator(schema, references, value) {
    return (0, index_10.IsIterator)(value);
}
function FromLiteral(schema, references, value) {
    return value === schema.const;
}
function FromNever(schema, references, value) {
    return false;
}
function FromNot(schema, references, value) {
    return !Visit(schema.not, references, value);
}
function FromNull(schema, references, value) {
    return (0, index_10.IsNull)(value);
}
function FromNumber(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
        return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
        return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
        return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
        return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
        return false;
    }
    return true;
}
function FromObject(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
            if (!Visit(property, references, value[knownKey])) {
                return false;
            }
            if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
                return false;
            }
        }
        else {
            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
                return false;
            }
        }
    }
    if (schema.additionalProperties === false) {
        const valueKeys = Object.getOwnPropertyNames(value);
        // optimization: value is valid if schemaKey length matches the valueKey length
        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
            return true;
        }
        else {
            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
        }
    }
    else if (typeof schema.additionalProperties === 'object') {
        const valueKeys = Object.getOwnPropertyNames(value);
        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    }
    else {
        return true;
    }
}
function FromPromise(schema, references, value) {
    return (0, index_10.IsPromise)(value);
}
function FromRecord(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
        return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
        return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
        return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    // prettier-ignore
    const check1 = Object.entries(value).every(([key, value]) => {
        return (regex.test(key)) ? Visit(patternSchema, references, value) : true;
    });
    // prettier-ignore
    const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {
        return (!regex.test(key)) ? Visit(schema.additionalProperties, references, value) : true;
    }) : true;
    const check3 = schema.additionalProperties === false
        ? Object.getOwnPropertyNames(value).every((key) => {
            return regex.test(key);
        })
        : true;
    return check1 && check2 && check3;
}
function FromRef(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
}
function FromRegExp(schema, references, value) {
    const regex = new RegExp(schema.source, schema.flags);
    if (IsDefined(schema.minLength)) {
        if (!(value.length >= schema.minLength))
            return false;
    }
    if (IsDefined(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
            return false;
    }
    return regex.test(value);
}
function FromString(schema, references, value) {
    if (!(0, index_10.IsString)(value)) {
        return false;
    }
    if (IsDefined(schema.minLength)) {
        if (!(value.length >= schema.minLength))
            return false;
    }
    if (IsDefined(schema.maxLength)) {
        if (!(value.length <= schema.maxLength))
            return false;
    }
    if (IsDefined(schema.pattern)) {
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value))
            return false;
    }
    if (IsDefined(schema.format)) {
        if (!index_7.FormatRegistry.Has(schema.format))
            return false;
        const func = index_7.FormatRegistry.Get(schema.format);
        return func(value);
    }
    return true;
}
function FromSymbol(schema, references, value) {
    return (0, index_10.IsSymbol)(value);
}
function FromTemplateLiteral(schema, references, value) {
    return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
}
function FromTuple(schema, references, value) {
    if (!(0, index_10.IsArray)(value)) {
        return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
        return false;
    }
    if (!(value.length === schema.maxItems)) {
        return false;
    }
    if (!schema.items) {
        return true;
    }
    for (let i = 0; i < schema.items.length; i++) {
        if (!Visit(schema.items[i], references, value[i]))
            return false;
    }
    return true;
}
function FromUndefined(schema, references, value) {
    return (0, index_10.IsUndefined)(value);
}
function FromUnion(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
}
function FromUint8Array(schema, references, value) {
    if (!(0, index_10.IsUint8Array)(value)) {
        return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
        return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
        return false;
    }
    return true;
}
function FromUnknown(schema, references, value) {
    return true;
}
function FromVoid(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
    if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
        return false;
    const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
    return func(schema, value);
}
function Visit(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? (0, index_2.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
        case 'Any':
            return FromAny(schema_, references_, value);
        case 'Argument':
            return FromArgument(schema_, references_, value);
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'AsyncIterator':
            return FromAsyncIterator(schema_, references_, value);
        case 'BigInt':
            return FromBigInt(schema_, references_, value);
        case 'Boolean':
            return FromBoolean(schema_, references_, value);
        case 'Constructor':
            return FromConstructor(schema_, references_, value);
        case 'Date':
            return FromDate(schema_, references_, value);
        case 'Function':
            return FromFunction(schema_, references_, value);
        case 'Import':
            return FromImport(schema_, references_, value);
        case 'Integer':
            return FromInteger(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Iterator':
            return FromIterator(schema_, references_, value);
        case 'Literal':
            return FromLiteral(schema_, references_, value);
        case 'Never':
            return FromNever(schema_, references_, value);
        case 'Not':
            return FromNot(schema_, references_, value);
        case 'Null':
            return FromNull(schema_, references_, value);
        case 'Number':
            return FromNumber(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Promise':
            return FromPromise(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'RegExp':
            return FromRegExp(schema_, references_, value);
        case 'String':
            return FromString(schema_, references_, value);
        case 'Symbol':
            return FromSymbol(schema_, references_, value);
        case 'TemplateLiteral':
            return FromTemplateLiteral(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Undefined':
            return FromUndefined(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        case 'Uint8Array':
            return FromUint8Array(schema_, references_, value);
        case 'Unknown':
            return FromUnknown(schema_, references_, value);
        case 'Void':
            return FromVoid(schema_, references_, value);
        default:
            if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
                throw new ValueCheckUnknownTypeError(schema_);
            return FromKind(schema_, references_, value);
    }
}
/** Returns true if the value matches the given type. */
function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\check\index.d.ts

Code:
export * from './check';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\check\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./check"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clean\clean.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */
export declare function Clean(schema: TSchema, references: TSchema[], value: unknown): unknown;
/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */
export declare function Clean(schema: TSchema, value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clean\clean.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Clean = Clean;
const index_1 = require("../../type/keyof/index");
const index_2 = require("../check/index");
const index_3 = require("../clone/index");
const index_4 = require("../deref/index");
const index_5 = require("../../type/symbols/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
// prettier-ignore
const index_6 = require("../guard/index");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
// prettier-ignore
const kind_1 = require("../../type/guard/kind");
// ------------------------------------------------------------------
// IsCheckable
// ------------------------------------------------------------------
function IsCheckable(schema) {
    return (0, kind_1.IsKind)(schema) && schema[index_5.Kind] !== 'Unsafe';
}
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
function FromArray(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
        return value;
    return value.map((value) => Visit(schema.items, references, value));
}
function FromImport(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions], value);
}
function FromIntersect(schema, references, value) {
    const unevaluatedProperties = schema.unevaluatedProperties;
    const intersections = schema.allOf.map((schema) => Visit(schema, references, (0, index_3.Clone)(value)));
    const composite = intersections.reduce((acc, value) => ((0, index_6.IsObject)(value) ? { ...acc, ...value } : value), {});
    if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, kind_1.IsKind)(unevaluatedProperties))
        return composite;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
    for (const key of Object.getOwnPropertyNames(value)) {
        if (knownkeys.includes(key))
            continue;
        if ((0, index_2.Check)(unevaluatedProperties, references, value[key])) {
            composite[key] = Visit(unevaluatedProperties, references, value[key]);
        }
    }
    return composite;
}
function FromObject(schema, references, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
        return value; // Check IsArray for AllowArrayObject configuration
    const additionalProperties = schema.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value)) {
        if ((0, index_6.HasPropertyKey)(schema.properties, key)) {
            value[key] = Visit(schema.properties[key], references, value[key]);
            continue;
        }
        if ((0, kind_1.IsKind)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
            value[key] = Visit(additionalProperties, references, value[key]);
            continue;
        }
        delete value[key];
    }
    return value;
}
function FromRecord(schema, references, value) {
    if (!(0, index_6.IsObject)(value))
        return value;
    const additionalProperties = schema.additionalProperties;
    const propertyKeys = Object.getOwnPropertyNames(value);
    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
        if (propertyKeyTest.test(key)) {
            value[key] = Visit(propertySchema, references, value[key]);
            continue;
        }
        if ((0, kind_1.IsKind)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
            value[key] = Visit(additionalProperties, references, value[key]);
            continue;
        }
        delete value[key];
    }
    return value;
}
function FromRef(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
}
function FromThis(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
}
function FromTuple(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
        return value;
    if ((0, index_6.IsUndefined)(schema.items))
        return [];
    const length = Math.min(value.length, schema.items.length);
    for (let i = 0; i < length; i++) {
        value[i] = Visit(schema.items[i], references, value[i]);
    }
    // prettier-ignore
    return value.length > length
        ? value.slice(0, length)
        : value;
}
function FromUnion(schema, references, value) {
    for (const inner of schema.anyOf) {
        if (IsCheckable(inner) && (0, index_2.Check)(inner, references, value)) {
            return Visit(inner, references, value);
        }
    }
    return value;
}
function Visit(schema, references, value) {
    const references_ = (0, index_6.IsString)(schema.$id) ? (0, index_4.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema_[index_5.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'Import':
            return FromImport(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        default:
            return value;
    }
}
/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */
function Clean(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clean\index.d.ts

Code:
export * from './clean';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clean\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./clean"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clone\clone.d.ts

Code:
/** Returns a clone of the given value */
export declare function Clone<T extends unknown>(value: T): T;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clone\clone.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Clone = Clone;
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_1 = require("../guard/index");
// ------------------------------------------------------------------
// Clonable
// ------------------------------------------------------------------
function FromObject(value) {
    const Acc = {};
    for (const key of Object.getOwnPropertyNames(value)) {
        Acc[key] = Clone(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
        Acc[key] = Clone(value[key]);
    }
    return Acc;
}
function FromArray(value) {
    return value.map((element) => Clone(element));
}
function FromTypedArray(value) {
    return value.slice();
}
function FromMap(value) {
    return new Map(Clone([...value.entries()]));
}
function FromSet(value) {
    return new Set(Clone([...value.entries()]));
}
function FromDate(value) {
    return new Date(value.toISOString());
}
function FromValue(value) {
    return value;
}
// ------------------------------------------------------------------
// Clone
// ------------------------------------------------------------------
/** Returns a clone of the given value */
function Clone(value) {
    if ((0, index_1.IsArray)(value))
        return FromArray(value);
    if ((0, index_1.IsDate)(value))
        return FromDate(value);
    if ((0, index_1.IsTypedArray)(value))
        return FromTypedArray(value);
    if ((0, index_1.IsMap)(value))
        return FromMap(value);
    if ((0, index_1.IsSet)(value))
        return FromSet(value);
    if ((0, index_1.IsObject)(value))
        return FromObject(value);
    if ((0, index_1.IsValueType)(value))
        return FromValue(value);
    throw new Error('ValueClone: Unable to clone value');
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clone\index.d.ts

Code:
export * from './clone';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\clone\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./clone"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\convert\convert.d.ts

Code:
import type { TSchema } from '../../type/schema/index';
/** `[Mutable]` Converts any type mismatched values to their target type if a reasonable conversion is possible. */
export declare function Convert(schema: TSchema, references: TSchema[], value: unknown): unknown;
/** `[Mutable]` Converts any type mismatched values to their target type if a reasonable conversion is possible. */
export declare function Convert(schema: TSchema, value: unknown): unknown;


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\convert\convert.js

Code:
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Convert = Convert;
const index_1 = require("../clone/index");
const index_2 = require("../check/index");
const index_3 = require("../deref/index");
const index_4 = require("../../type/symbols/index");
// ------------------------------------------------------------------
// ValueGuard
// ------------------------------------------------------------------
const index_5 = require("../guard/index");
// ------------------------------------------------------------------
// Conversions
// ------------------------------------------------------------------
function IsStringNumeric(value) {
    return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
    return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
}
function IsValueTrue(value) {
    return value === true || ((0, index_5.IsNumber)(value) && value === 1) || ((0, index_5.IsBigInt)(value) && value === BigInt('1')) || ((0, index_5.IsString)(value) && (value.toLowerCase() === 'true' || value === '1'));
}
function IsValueFalse(value) {
    return value === false || ((0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0))) || ((0, index_5.IsBigInt)(value) && value === BigInt('0')) || ((0, index_5.IsString)(value) && (value.toLowerCase() === 'false' || value === '0' || value === '-0'));
}
function IsTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
// ------------------------------------------------------------------
// Convert
// ------------------------------------------------------------------
function TryConvertLiteralString(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
}
// prettier-ignore
function TryConvertLiteral(schema, value) {
    return ((0, index_5.IsString)(schema.const) ? TryConvertLiteralString(value, schema.const) :
        (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber(value, schema.const) :
            (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean(value, schema.const) :
                value);
}
function TryConvertBoolean(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
    const truncateInteger = (value) => value.split('.')[0];
    return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : (0, index_5.IsNumber)(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
    return (0, index_5.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
    return (0, index_5.IsString)(value) && value.toLowerCase() === 'null' ? null : value;
}
function TryConvertUndefined(value) {
    return (0, index_5.IsString)(value) && value === 'undefined' ? undefined : value;
}
// ------------------------------------------------------------------
// note: this function may return an invalid dates for the regex
// tests above. Invalid dates will however be checked during the
// casting function and will return a epoch date if invalid.
// Consider better string parsing for the iso dates in future
// revisions.
// ------------------------------------------------------------------
// prettier-ignore
function TryConvertDate(value) {
    return ((0, index_5.IsDate)(value) ? value :
        (0, index_5.IsNumber)(value) ? new Date(value) :
            IsValueTrue(value) ? new Date(1) :
                IsValueFalse(value) ? new Date(0) :
                    IsStringNumeric(value) ? new Date(parseInt(value)) :
                        IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) :
                            IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) :
                                IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) :
                                    IsDateTimeStringWithTimeZone(value) ? new Date(value) :
                                        IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) :
                                            value);
}
// ------------------------------------------------------------------
// Default
// ------------------------------------------------------------------
function Default(value) {
    return value;
}
// ------------------------------------------------------------------
// Convert
// ------------------------------------------------------------------
function FromArray(schema, references, value) {
    const elements = (0, index_5.IsArray)(value) ? value : [value];
    return elements.map((element) => Visit(schema.items, references, element));
}
function FromBigInt(schema, references, value) {
    return TryConvertBigInt(value);
}
function FromBoolean(schema, references, value) {
    return TryConvertBoolean(value);
}
function FromDate(schema, references, value) {
    return TryConvertDate(value);
}
function FromImport(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit(target, [...references, ...definitions], value);
}
function FromInteger(schema, references, value) {
    return TryConvertInteger(value);
}
function FromIntersect(schema, references, value) {
    return schema.allOf.reduce((value, schema) => Visit(schema, references, value), value);
}
function FromLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
}
function FromNull(schema, references, value) {
    return TryConvertNull(value);
}
function FromNumber(schema, references, value) {
    return TryConvertNumber(value);
}
// prettier-ignore
function FromObject(schema, references, value) {
    if (!(0, index_5.IsObject)(value))
        return value;
    for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
        if (!(0, index_5.HasPropertyKey)(value, propertyKey))
            continue;
        value[propertyKey] = Visit(schema.properties[propertyKey], references, value[propertyKey]);
    }
    return value;
}
function FromRecord(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
        return value;
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    for (const [propKey, propValue] of Object.entries(value)) {
        value[propKey] = Visit(property, references, propValue);
    }
    return value;
}
function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
}
function FromString(schema, references, value) {
    return TryConvertString(value);
}
function FromSymbol(schema, references, value) {
    return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
}
function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
}
// prettier-ignore
function FromTuple(schema, references, value) {
    const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
    if (!isConvertable)
        return value;
    return value.map((value, index) => {
        return (index < schema.items.length)
            ? Visit(schema.items[index], references, value)
            : value;
    });
}
function FromUndefined(schema, references, value) {
    return TryConvertUndefined(value);
}
function FromUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
        const converted = Visit(subschema, references, (0, index_1.Clone)(value));
        if (!(0, index_2.Check)(subschema, references, converted))
            continue;
        return converted;
    }
    return value;
}
function Visit(schema, references, value) {
    const references_ = (0, index_3.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_4.Kind]) {
        case 'Array':
            return FromArray(schema_, references_, value);
        case 'BigInt':
            return FromBigInt(schema_, references_, value);
        case 'Boolean':
            return FromBoolean(schema_, references_, value);
        case 'Date':
            return FromDate(schema_, references_, value);
        case 'Import':
            return FromImport(schema_, references_, value);
        case 'Integer':
            return FromInteger(schema_, references_, value);
        case 'Intersect':
            return FromIntersect(schema_, references_, value);
        case 'Literal':
            return FromLiteral(schema_, references_, value);
        case 'Null':
            return FromNull(schema_, references_, value);
        case 'Number':
            return FromNumber(schema_, references_, value);
        case 'Object':
            return FromObject(schema_, references_, value);
        case 'Record':
            return FromRecord(schema_, references_, value);
        case 'Ref':
            return FromRef(schema_, references_, value);
        case 'String':
            return FromString(schema_, references_, value);
        case 'Symbol':
            return FromSymbol(schema_, references_, value);
        case 'This':
            return FromThis(schema_, references_, value);
        case 'Tuple':
            return FromTuple(schema_, references_, value);
        case 'Undefined':
            return FromUndefined(schema_, references_, value);
        case 'Union':
            return FromUnion(schema_, references_, value);
        default:
            return Default(value);
    }
}
/** `[Mutable]` Converts any type mismatched values to their target type if a reasonable conversion is possible. */
// prettier-ignore
function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\convert\index.d.ts

Code:
export * from './convert';


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\convert\index.js

Code:
"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./convert"), exports);


---

File name: node_modules\babel-jest\node_modules\@sinclair\typebox\build\cjs\value\create\create.d.ts

Code:
import { TypeBoxError } from '../../type/error/index';
import type { TSchema } from '../../type/schema/index';
import type { Static } from '../../type/static/index';
export declare class ValueCreateError extends TypeBoxError {
    readonly schema: TSchema;
    constructor(schema: TSchema, message: string);
}
/** Creates a value from the given schema and references */
export declare function Create<T extends TSchema>(schema: T, references: TSchema[]): Static<T>;
/** Creates a value from the given schema */
export declare function Create<T extends TSchema>(schema: T): Static<T>;


---

